import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as i,c as e,a as s}from"./app-m9pC5KT-.js";const n="/assets/f2c41f6947024c559acf45d19034adde-TqdAu4S4.png",t="/assets/987741f6f8c14f8a89903a5c1854df56-hBF_EWVj.png",c="/assets/3ac497b91652448f88b40f74b931f64b-KNJm45rf.png",l="/assets/ef961dd59c744b969d9cda3eee67fec0-XF8AUsQW.png",o="/assets/2ddc05b2ad284e609c4a38e38805e0d3-8EpsftRH.png",r="/assets/9058cd8ff4c244349e12ca23e980206d-MH3oD_zQ.png",d="/assets/d329b368bd5a4e01959e77cf16dcbb4f-0PWbkA2w.png",p="/assets/ca5d8ac00a4f4b7295f465eb17e887b2-KS4JMfMX.png",g="/assets/1d7de720cf264583a7690f5a73cf7096-nQel4Ib7.png",f="/assets/1bebaf81aad84a888a282b8da445ac98-120VxSXI.png",u="/assets/4fcf9cc1b9934315ba842ab0bb9b12bf-K0gfNFlA.png",b="/assets/78c1a57577af48cd91748d6bc31aab1e-lpCkYg2H.png",m="/assets/f4aa9f1b56634a3db848c65f714e08c1-hx2wxXR0.png",h="/assets/07356dc5a0d14a6796485cfefae54f26-K8AnGgLq.png",x="/assets/c6bb48dea48a4195998e6da63c223444-SNHp53JH.png",_="/assets/56e0f5ffbc0e46449faeeeef6d1d3254-SAGwh-3K.png",y="/assets/d83f89f264b34dc8bbe91a8664890494-FTLJ7aYY.png",k="/assets/f07c2011db18495f860ccdbf4569cfae-SVCv7hXN.png",v="/assets/cd1c7bc03baa45719cbcf390f2a56dbf--OXfMjAw.png",B="/assets/4da66a79b5a74726a9d69261b043e116-LNkT9tUz.png",z="/assets/97be4cf13e794f5ba701110c200c75b0-yOW-9zWZ.png",A={},q=s('<h1 id="事务和事务锁" tabindex="-1"><a class="header-anchor" href="#事务和事务锁" aria-hidden="true">#</a> 事务和事务锁</h1><h2 id="一、事务简介" tabindex="-1"><a class="header-anchor" href="#一、事务简介" aria-hidden="true">#</a> 一、事务简介</h2><p>Redis执行指令过程中，多条连续执行的指令被干扰，打断，插队，这多条连续指令执行的结果可能就会有问题</p><p>由于客户端2中断了客户端1两条连续的指令执行，导致客户端1获取到itcast</p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>redis事务就是一个命令执行的队列，将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或者干扰。</p><p>一个队列中，一次性、顺序性、排他性的执行一系列命令</p><h2 id="二、事务基本指令" tabindex="-1"><a class="header-anchor" href="#二、事务基本指令" aria-hidden="true">#</a> 二、事务基本指令</h2><ul><li><code>multi</code>：设定事务的开启位置，此指令执行后，后续的所有指令均加入到事务中</li><li><code>exec</code>：设定事务的结束位置，同时执行事务，与multi成对使用</li></ul><p><strong>注意：加入事务的命令暂时进入到任务队列中，并没有立即执行，只有执行exec命令才开始执行</strong></p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>discard：终止当前事务，发生在multi之后，exec之前；当我们把错误指令放入队列后，<strong>可以使用discard使multi失效，放弃当前任务队列，中止事务</strong></li></ul><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="三、事务的工作流程" tabindex="-1"><a class="header-anchor" href="#三、事务的工作流程" aria-hidden="true">#</a> 三、事务的工作流程</h2><p><strong>set执行流程：</strong> 正常执行，返回执行结果</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>multi执行流程：</strong> 创建事务队列后返回ok</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>创建事务后，set执行流程：</strong> 将set指令放入事务队列</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>创建事务后，del执行流程：</strong> 将del指令放入事务队列</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>创建事务后，exec执行流程：</strong> 顺序执行事务队列中的指令，并销毁队列</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>创建事务后，discard执行流程：</strong> 放弃执行队列中的指令，直接销毁队列，返回执行结果</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="四、事务中指令出错处理" tabindex="-1"><a class="header-anchor" href="#四、事务中指令出错处理" aria-hidden="true">#</a> 四、事务中指令出错处理</h2><ol><li>开启事务后，如果放入队列的指令存在语法错误，将会执行discard，当前事务队列会被销毁</li></ol><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol start="2"><li>开启事务后，如果放入队列的指令并没有语法错误，但无法执行，比如对string类型进行lpush。<strong>这种情况下，会顺序执行所有的指令，无法执行则会给出相应的提示信息，并跳过无法执行的指令，不会立即中断当前事务的执行</strong></li></ol><figure><img src="'+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>注意：已执行命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚</p><h2 id="五、事务锁" tabindex="-1"><a class="header-anchor" href="#五、事务锁" aria-hidden="true">#</a> 五、事务锁</h2><h3 id="_1-业务场景一-多个客户端想操作同一数据-保证数据不被重复操作" tabindex="-1"><a class="header-anchor" href="#_1-业务场景一-多个客户端想操作同一数据-保证数据不被重复操作" aria-hidden="true">#</a> 1. 业务场景一：多个客户端想操作同一数据，保证数据不被重复操作</h3><blockquote><p>视频中这个监视锁的作用好像有点局限，仅限于多个客户端想对同一数据进行相同的操作，保证数据不被重复操作。如果是想要对数据进行不同的操作呢？这个监视锁的功能好像也能用MySQL中的排它锁和共享锁实现</p></blockquote><p>天猫双11热卖过程中，对已经售罄的货物追加补货，4个业务员都有权限进行补货。补货的操作可能是一系列的操作，牵扯到多个连续操作，如何保障不会重复操作？</p><p>我们对需要操作的数据添加监视锁并开启事务，如果exec前监视的数据被修改了，那说明我放入事务队列的指令想要操作的数据被修改了，那这些指令操作的结果就不满足我的预期了。此时仍然输入exec，程序将不会执行exec指令，且放弃当前事务</p><ul><li><strong>对key添加监视锁，在事务执行exec前如果key发生了变化，终止事务执行</strong></li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">watch key1 </span><span style="color:#E06C75;">[key2…]</span><span style="color:#ABB2BF;">          # 必须在开启事务multi前执行</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>取消对所有key的监视</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">unwatch                     # 取消所有数据的监视锁 </span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>客户端A监视name和age，开启事务，准备执行一系列操作</p><figure><img src="`+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端B修改客户端A监视的age</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端A执行exec，执行失败，此时事务也不存在了</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>逻辑上，我们应该先监视数据，然后开启事务准备操作，所以不允许先multi开启事务后watch</p><figure><img src="'+x+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_2-业务场景二-setnx操作一个变量-然后再操作对应数据" tabindex="-1"><a class="header-anchor" href="#_2-业务场景二-setnx操作一个变量-然后再操作对应数据" aria-hidden="true">#</a> 2. 业务场景二：setnx操作一个变量，然后再操作对应数据</h3><p>很多客户同时抢购天猫超市的同一款商品，如何保证最后一件商品不被多人同时购买？【超卖问题】</p><p><strong>分析</strong>： 如果我们使用watch监视锁解决，此时一个客户端对商品进行监视，他购买时如果其他客户端购买了（修改了商品数量），他就不能购买（exec），这是不符合逻辑的，只要商品有库存，大家应该允许同时购买，只需要保证购买成功的数量和商品减少的数量相等就行。这种情况下，我们使用分布式锁解决（r<strong>edis并不提供这种特殊的锁，只是我们利用setnx的特性解决此业务场景，这并不像MySQL的排它锁，上了锁就不能操作指定数据，此处redis所谓的锁只是我们约好的先操作某个变量再操作对应数据，实际上setnx的结果并不影响直接操作对应数据</strong>）</p><p>利用setnx拥有的返回值特征，有值则返回设置失败，无值则返回设置成功</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">setnx lock-</span><span style="color:#C678DD;">key</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">value</span><span style="color:#ABB2BF;">   # 这个value不重要，其实这就是利用了setnx，lock-key也只是一个普通名字，这就是设置了一个普通的string变量</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>对于返回设置成功的，对数据拥有控制权，可以进行下一步操作，其他客户端得先操作这个使用setnx的lock-key，根据返回值判断是否可以进一步操作对应数据</li><li>对于返回设置失败的，不具有控制权，则等待</li></ul><p>操作完毕通过del释放锁</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">del lock-</span><span style="color:#C678DD;">key</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>客户端A获取对num的锁</p><figure><img src="`+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端B获取对lock-num，失败了，如果失败，我们不允许该客户端操作数据</p><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端A购买完商品释放锁</p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端B setnx lock-num成功，我们在逻辑上允许该客户端操作num</p><figure><img src="'+v+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-业务场景三-给上述setnx的变量设置有效时间" tabindex="-1"><a class="header-anchor" href="#_3-业务场景三-给上述setnx的变量设置有效时间" aria-hidden="true">#</a> 3. 业务场景三：给上述setnx的变量设置有效时间</h3><p>防止锁忘了释放，到达有效时间自动释放该锁变量</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">expire lock-</span><span style="color:#C678DD;">key</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">second</span></span>
<span class="line"><span style="color:#ABB2BF;">pexpire lock-kay millisenconds</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端A setnx一把锁，并设置有效时间</p><figure><img src="`+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>到达有效时间后，lock-name失效，其他客户端自动拿到锁</p><figure><img src="'+z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>由于操作通常都是微秒或者毫秒级，因此该锁设定时间不宜设置过大。具体时间需要业务测试后确认，例如：</strong></p><ul><li>持有锁的操作最长执行时间127ms,最短执行时间7ms</li><li>测试百万次最长执行时间对应命令的最大消耗时，测试百万次网络延迟平均耗时</li><li>锁时间设定推荐：最大耗时* 120%+平均网络延迟*110%</li><li>如果业务最大耗时&lt;&lt;网络平均延迟，通常为2个数量级，取其中单个耗时较长即可</li></ul>',74),F=[q];function D(S,w){return i(),e("div",null,F)}const N=a(A,[["render",D],["__file","事务和事务锁.html.vue"]]);export{N as default};
