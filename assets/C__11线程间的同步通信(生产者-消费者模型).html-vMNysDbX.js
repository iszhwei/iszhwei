const e=JSON.parse('{"key":"v-7cc2160e","path":"/ccpp/18%20C__11%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/C__11%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1(%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B).html","title":"C++11线程间的同步通信(生产者-消费者模型)","lang":"zh-CN","frontmatter":{"title":"C++11线程间的同步通信(生产者-消费者模型)","icon":"file","order":3,"headerDepth":4,"category":["c/c++"],"tag":["c++11线程"],"description":"C++11线程间的同步通信(生产者-消费者模型) 1、多线程编程两个问题 1.1、线程间的互斥 竞态条件： 多线程执行的结果出现不一致的情况，由于CPU对线程不同的调用顺序，而产生不同的运行结果。 发生竞态条件的代码段，称为临界区代码段（只有一个线程可以进来），保证临界区代码段原子操作， C++11的mutex底层实现： 使用strace ./a.out跟踪代码，使用C++11提供的mutex，Linux底层使用的也是自己的pthread_mutex互斥锁。","head":[["meta",{"property":"og:url","content":"https://iszhwei.gitee.io/ccpp/18%20C__11%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/C__11%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1(%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B).html"}],["meta",{"property":"og:site_name","content":"张威的编程学习笔记"}],["meta",{"property":"og:title","content":"C++11线程间的同步通信(生产者-消费者模型)"}],["meta",{"property":"og:description","content":"C++11线程间的同步通信(生产者-消费者模型) 1、多线程编程两个问题 1.1、线程间的互斥 竞态条件： 多线程执行的结果出现不一致的情况，由于CPU对线程不同的调用顺序，而产生不同的运行结果。 发生竞态条件的代码段，称为临界区代码段（只有一个线程可以进来），保证临界区代码段原子操作， C++11的mutex底层实现： 使用strace ./a.out跟踪代码，使用C++11提供的mutex，Linux底层使用的也是自己的pthread_mutex互斥锁。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"张威"}],["meta",{"property":"article:tag","content":"c++11线程"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"C++11线程间的同步通信(生产者-消费者模型)\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"张威\\",\\"url\\":\\"https://iszhwei.gitee.io\\"}]}"]]},"headers":[{"level":2,"title":"1、多线程编程两个问题","slug":"_1、多线程编程两个问题","link":"#_1、多线程编程两个问题","children":[{"level":3,"title":"1.1、线程间的互斥","slug":"_1-1、线程间的互斥","link":"#_1-1、线程间的互斥","children":[]},{"level":3,"title":"1.2、线程间的同步通信","slug":"_1-2、线程间的同步通信","link":"#_1-2、线程间的同步通信","children":[]}]},{"level":2,"title":"2、生产者-消费者线程模型","slug":"_2、生产者-消费者线程模型","link":"#_2、生产者-消费者线程模型","children":[]},{"level":2,"title":"3、lock_gard和unique_lock","slug":"_3、lock-gard和unique-lock","link":"#_3、lock-gard和unique-lock","children":[]},{"level":2,"title":"4、流程分析","slug":"_4、流程分析","link":"#_4、流程分析","children":[]}],"git":{},"readingTime":{"minutes":7.54,"words":2263},"filePathRelative":"ccpp/18 C++11知识汇总/C++11线程间的同步通信(生产者-消费者模型).md","excerpt":"<h1> C++11线程间的同步通信(生产者-消费者模型)</h1>\\n<h2> 1、多线程编程两个问题</h2>\\n<h3> 1.1、线程间的互斥</h3>\\n<p>竞态条件： 多线程执行的结果出现不一致的情况，由于CPU对线程不同的调用顺序，而产生不同的运行结果。</p>\\n<p>发生竞态条件的代码段，称为<strong>临界区代码段</strong>（只有一个线程可以进来），<strong>保证临界区代码段原子操作</strong>，</p>\\n<p>C++11的mutex底层实现：</p>\\n<p>使用<code>strace ./a.out</code>跟踪代码，使用C++11提供的mutex，Linux底层使用的也是自己的pthread_mutex互斥锁。</p>","autoDesc":true}');export{e as data};
