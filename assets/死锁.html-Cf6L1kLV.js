const e=JSON.parse('{"key":"v-1743001b","path":"/mysql/06%20MySQL%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/%E6%AD%BB%E9%94%81.html","title":"死锁","lang":"zh-CN","frontmatter":{"title":"死锁","icon":"file","order":3,"headerDepth":4,"category":["mysql"],"tag":["mysql锁机制"],"description":"死锁 数据库中的死锁 MyISAM 表锁是 deadlock free 的， 这是因为 MyISAM 不支持事务，只支持表锁，而且总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。 在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，即锁的粒度比较小（行锁），这就决定了在 InnoDB 中发生死锁是可能的 死锁问题一般都是我们自己的应用造成的，和多线程编程的死锁情况相似，大部分都是由于我们多个线程在获取多个锁资源的时候，获取的顺序不同而导致的死锁问题。因此我们应用在对数据库的多个表做更新的时候，不同的代码段，应对这些表按，以防止锁冲突导致死锁问题","head":[["meta",{"property":"og:url","content":"https://iszhwei.gitee.io/mysql/06%20MySQL%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/%E6%AD%BB%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"张威的编程学习笔记"}],["meta",{"property":"og:title","content":"死锁"}],["meta",{"property":"og:description","content":"死锁 数据库中的死锁 MyISAM 表锁是 deadlock free 的， 这是因为 MyISAM 不支持事务，只支持表锁，而且总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。 在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，即锁的粒度比较小（行锁），这就决定了在 InnoDB 中发生死锁是可能的 死锁问题一般都是我们自己的应用造成的，和多线程编程的死锁情况相似，大部分都是由于我们多个线程在获取多个锁资源的时候，获取的顺序不同而导致的死锁问题。因此我们应用在对数据库的多个表做更新的时候，不同的代码段，应对这些表按，以防止锁冲突导致死锁问题"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"张威"}],["meta",{"property":"article:tag","content":"mysql锁机制"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"死锁\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"张威\\",\\"url\\":\\"https://iszhwei.gitee.io\\"}]}"]]},"headers":[{"level":2,"title":"数据库中的死锁","slug":"数据库中的死锁","link":"#数据库中的死锁","children":[]},{"level":2,"title":"死锁场景以及解决办法","slug":"死锁场景以及解决办法","link":"#死锁场景以及解决办法","children":[]},{"level":2,"title":"操作","slug":"操作","link":"#操作","children":[]}],"git":{},"readingTime":{"minutes":2.64,"words":791},"filePathRelative":"mysql/06 MySQL的锁机制/死锁.md","excerpt":"<h1> 死锁</h1>\\n<h2> 数据库中的死锁</h2>\\n<p><strong>MyISAM 表锁是 deadlock free 的</strong>， 这是因为 MyISAM 不支持事务，<u>只支持表锁，而且总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁</u>。</p>\\n<figure><figcaption></figcaption></figure>\\n<p>在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，即锁的粒度比较小（行锁），这就决定了在 InnoDB 中发生死锁是可能的</p>\\n<p><strong>死锁问题一般都是我们自己的应用造成的，和多线程编程的死锁情况相似</strong>，大部分都是由于我们多个线程在获取多个锁资源的时候，<strong>获取的顺序不同而导致的死锁问题</strong>。因此我们应用在对数据库的多个表做更新的时候，不同的代码段，<strong>应对这些表按，以防止锁冲突导致死锁问题</strong></p>","autoDesc":true}');export{e as data};
