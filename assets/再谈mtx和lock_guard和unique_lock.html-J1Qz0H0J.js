import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as c,o as t,c as r,d as n,f as a,w as e,e as s,a as o}from"./app-9OmaxHRC.js";const p="/assets/80e0858ba5d949d885a70c6ea5a5f151-uDMwVh8L.png",d="/assets/bf21b46eda6a4742a5b885575a40e866-czbOiZC2.png",u="/assets/1257d93806cc4f029208dfb4e25b195e-Wwpp0ZEq.png",B="/assets/ff5dac79727c40f1add8ea3ee9476a8f-xWeDeesY.png",_="/assets/df76384fd4784b62ad4875a352c4444e-buoemmpv.png",y="/assets/a46daee03c57404bab2733ffee55616b-49o9DJ4t.png",m="/assets/efe6483c307b42c59f5693c0bd17a0d2-ha0tq64z.png",g={},f=o(`<h1 id="再谈mtx和lock-guard和unique-lock" tabindex="-1"><a class="header-anchor" href="#再谈mtx和lock-guard和unique-lock" aria-hidden="true">#</a> 再谈mtx和lock_guard和unique_lock</h1><h2 id="_1、mutex" tabindex="-1"><a class="header-anchor" href="#_1、mutex" aria-hidden="true">#</a> 1、mutex</h2><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">std::mutex mtx;</span></span>
<span class="line"><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span><span style="color:#E5C07B;">mtx</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">lock</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span><span style="color:#E5C07B;">mtx</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">unlock</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),v=n("u",null,"代码之间可能由于逻辑走掉了，代码发生异常了，造成锁没有释放掉",-1),b=n("h2",{id:"_2、lock-guard",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_2、lock-guard","aria-hidden":"true"},"#"),s(" 2、lock_guard")],-1),F=n("figure",null,[n("img",{src:p,alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),h=n("li",null,[s("利用的是"),n("strong",null,"智能指针"),s("的概念。")],-1),k=n("li",null,[s("在它的"),n("strong",null,"构造函数"),s("里面可以"),n("u",null,"主动的获取这把锁lock。")],-1),x=n("li",null,[s("当这个对象"),n("strong",null,"出作用域，自动调用析构函数"),s("，析构函数中有"),n("u",null,"释放锁的操作unlock。")],-1),A=o(`<div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">std::mutex mtx;</span></span>
<span class="line"><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">main</span><span style="color:#ABB2BF;">() {</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">    //只能用在简单的加锁解锁的临界区代码中；</span></span>
<span class="line"><span style="color:#ABB2BF;">    guard_lock</span><span style="color:#C678DD;">&lt;</span><span style="color:#ABB2BF;">std::mutex</span><span style="color:#C678DD;">&gt;</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">guard</span><span style="color:#ABB2BF;">(mtx);</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">	//mtx.lock();</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">	//mtx.unlock();</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_3、unique-lock" tabindex="-1"><a class="header-anchor" href="#_3、unique-lock" aria-hidden="true">#</a> 3、unique_lock</h2><ul><li>利用的是智能指针的概念。</li><li>在它的构造函数里面可以主动的获取这把锁lock。</li><li>当这个对象出作用域，自动调用析构函数，析构函数中有释放锁的操作unlock。</li></ul><figure><img src="`+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>它把左值引用的拷贝构造函数和赋值函数都删除掉了。</strong></p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',8),E=n("u",null,"右值引用的拷贝构造函数",-1),q=n("u",null,"赋值函数",-1),D=o('<figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>它还提供了一对lock和unlock方法。</strong></p><figure><img src="'+m+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">std::mutex mtx;</span><span style="color:#7F848E;font-style:italic;">//底层是pthread_mutex_t</span></span>
<span class="line"><span style="color:#ABB2BF;">std::condition_variable cv;</span><span style="color:#7F848E;font-style:italic;">//底层是pthread_condition_t</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E5C07B;">unique_lock</span><span style="color:#ABB2BF;">&lt;std::</span><span style="color:#E5C07B;">mutex</span><span style="color:#ABB2BF;">&gt; </span><span style="color:#61AFEF;">lck</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">mtx</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#E5C07B;">cv</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">wait</span><span style="color:#ABB2BF;">(lck); </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">//=&gt; #1.使当前线程进入等待状态 #2.lck.unlock可以把mtx给释放掉</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：</strong> 条件变量cv.wait里面传的是unique_lock，也只能传unique_lock，因为lock_gard将拷贝构造和赋值重载都delete了（实参到形参是一个拷贝构造的过程，传不进来）</p><h2 id="_4、lock-gard和unique-lock对比" tabindex="-1"><a class="header-anchor" href="#_4、lock-gard和unique-lock对比" aria-hidden="true">#</a> 4、lock_gard和unique_lock对比</h2>`,6),C=n("li",null,"lock_gard和unique_lock做的事情是一样的，都是在构造函数中国自动执行mutex的lock()函数，在析构函数中自动执行mutex的unlock()函数。",-1),w=o(`<h2 id="_5、notify-all" tabindex="-1"><a class="header-anchor" href="#_5、notify-all" aria-hidden="true">#</a> 5、notify_all</h2><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">	/*</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">	通知在cv上等待的线程，条件成立了，起来干活了！</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">	其它在cv上等待的线程，收到通知，</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">	从等待状态 =》到阻塞状态(不能直接运行) </span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">	=》只有当前线程释放锁了，其他线程才能获取互斥锁了 =》线程继续往下执行</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">	*/</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span><span style="color:#E5C07B;">cv</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">notify_all</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2);function z(V,N){const l=c("font");return t(),r("div",null,[f,n("ul",null,[n("li",null,[a(l,{color:"red"},{default:e(()=>[s("不安全")]),_:1}),s("，因为"),v,s("，成"),a(l,{color:"red"},{default:e(()=>[s("死锁")]),_:1})])]),b,F,n("ul",null,[h,k,x,n("li",null,[s("它把"),a(l,{color:"red"},{default:e(()=>[s("左值引用的拷贝构造函数和赋值函数都删除掉了")]),_:1}),s("。")])]),n("p",null,[n("strong",null,[a(l,{color:"red"},{default:e(()=>[s("不能用在")]),_:1}),a(l,{color:"cornflowerblue"},{default:e(()=>[s("函数参数传递")]),_:1}),s("或者"),a(l,{color:"cornflowerblue"},{default:e(()=>[s("返回过程")]),_:1}),s("中，因为要用到拷贝构造函数和赋值函数，"),a(l,{color:"green"},{default:e(()=>[s("只能用在简单的加锁解锁临界区代码段的互斥操作中")]),_:1}),s("。")])]),A,a(l,{color:"green"},{default:e(()=>[s("**但是它提供了"),E,s("和"),q,s("。所以可以用在函数参数传递或者返回过程中。**")]),_:1}),D,n("ul",null,[n("li",null,[s("lock_gard和unique_lock可以看成unique_ptr和scope_ptr之间的关系； "),n("ul",null,[n("li",null,[n("strong",null,[s("因为要用到拷贝构造函数和赋值函数，"),a(l,{color:"red"},{default:e(()=>[s("不能用在")]),_:1}),a(l,{color:"cornflowerblue"},{default:e(()=>[s("函数参数传递")]),_:1}),s("或者"),a(l,{color:"cornflowerblue"},{default:e(()=>[s("返回过程")]),_:1}),s("中，"),a(l,{color:"green"},{default:e(()=>[s("只能用在简单的加锁解锁临界区代码段的互斥操作中")]),_:1}),s("。")])])])]),C]),w,n("p",null,[n("strong",null,[a(l,{color:"red"},{default:e(()=>[s("从等待状态 =》到阻塞状态(不能直接运行) ")]),_:1})])])])}const J=i(g,[["render",z],["__file","再谈mtx和lock_guard和unique_lock.html.vue"]]);export{J as default};
