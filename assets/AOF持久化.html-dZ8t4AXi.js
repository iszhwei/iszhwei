import{_ as o}from"./plugin-vue_export-helper-x3n3nnut.js";import{r,o as t,c,d as s,e as a,f as n,w as i,a as l}from"./app-2pke9_a8.js";const d="/assets/70a072d83bc841e594fbd38bef0ed904-TIhZTdIK.png",p="/assets/2b9d3fb9d1b94598a2eb831873eb3b56-TAAdwd2A.png",g="/assets/4f5a9e32849744a992b4917f1a0562ab-dsHhWznP.png",f="/assets/79ee4e64dd0e4d52a287cff544fe8d5d-mqQSqn1A.png",u="/assets/0f8b9d74b7754120a23799971e0d96b6-VMe25dlv.png",b="/assets/61c7509bbfef4a9fbbbd869c14831ecc-lB-D1clm.png",_="/assets/7b81e0d0c0b143e9bd34863a3a0479ce-D83UDWtH.png",h="/assets/5fb34c26a742456f960e136391072216-6Xd1i98q.png",m="/assets/3764ba064afa4726a544c0e9d91c0c3c-fCNgyN-Q.png",y="/assets/cfe5c2163ae44e97b29507ba2da26eb4-Kc1v5FZO.png",A="/assets/image-20240504215212879-P1Um0xTg.png",B="/assets/7c2e52bf0d76439e91117b7bba5e6e36-WlzxbQcN.png",v="/assets/5893cec65b1e4fe3b8c5a8c5b0b214db-p-cInE4D.png",F="/assets/71907ee0c116450fa5c6b73f1234ea48-XRTfZxIz.png",x="/assets/ae0c58f480c1444e8e8e5d3d43d1e7e9-25hAnEgf.png",O="/assets/605275b1f572439e8fd3110fb81d389f-MYczGQgE.png",D="/assets/68ab9fcfc3154f1db8b88998ddd90d4d-kzrjl3jV.png",z="/assets/e7fbc46e27b442f990d42ebf1ac6de4a-Nanliokq.png",k="/assets/5e6deb584cf146d2b07aa32f3c225b40-pbxYRZkA.png",w="/assets/3f58f3cd48254a94b0d2644c28caa477-iK5YlPlg.png",R="/assets/4cb3a1425e544bc29b7c08ecbef7de27-AzlhmsAS.png",q="/assets/a0e414bb98584dd19b4aaadb46cc42a9-0AW1a3iT.png",C="/assets/c49a9b27e05642c5a5d5305d0847678d-U6wwcNrY.png",N="/assets/cfa929870734498284ee8d8efd71ac67-fAwrD3yx.png",T="/assets/image-20230704163821497-zobVcpfr.png",V={},I=l('<h1 id="aof持久化" tabindex="-1"><a class="header-anchor" href="#aof持久化" aria-hidden="true">#</a> AOF持久化</h1><h2 id="一、aof概念" tabindex="-1"><a class="header-anchor" href="#一、aof概念" aria-hidden="true">#</a> 一、AOF概念</h2><p>RDB存储的弊端</p><ul><li>存储数据量较大，效率较低——<strong>基于快照思想，每次读写都是全部数据，当数据量巨大时，效率非常低</strong></li><li>大数据量下的IO性能较低</li><li>基于fork创建子进程，内存产生额外消耗</li><li>宕机会带来数据丢失</li></ul><p>AOF解决思路</p>',5),P=s("li",null,"不记录数据，记录操作过程",-1),E=s("p",null,[a("AOF（append only file）持久化："),s("strong",null,"不记录数据，只是以独立日志的方式记录每次写命令"),a("，重启时再重新执行AOF文件中命令达到恢复数据的目的 AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的"),s("strong",null,"主流方式"),a("（优先用AOF，再使用RDB）")],-1),M=s("figure",null,[s("img",{src:d,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),Q=s("h2",{id:"二、aof写数据三种策略",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#二、aof写数据三种策略","aria-hidden":"true"},"#"),a(" 二、AOF写数据三种策略")],-1),W=s("code",null,"always",-1),Y=s("strong",null,"每次",-1),Z=s("code",null,"everysec",-1),K=s("strong",null,"每秒",-1),S=s("code",null,"no",-1),U=l(`<h2 id="三、aof功能配置" tabindex="-1"><a class="header-anchor" href="#三、aof功能配置" aria-hidden="true">#</a> 三、AOF功能配置</h2><p>配置文件.conf中配置</p><p>是否开启APF持久化功能，默认为不开启</p><div class="language-ini line-numbers-mode" data-ext="ini"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#98C379;">appendonly yes|no</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>配置AOF写策略</p><div class="language-ini line-numbers-mode" data-ext="ini"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#98C379;">appendfsync always|everysec|no</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>修改AOF持久化文件名，默认文件名为<code>appendonly.aof</code>，建议配置为<code>appendonly-端口号.aof</code></p><div class="language-ini line-numbers-mode" data-ext="ini"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#98C379;">appendfilename filename</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>AOF持久化文件保存路径，<u>与RDB持久化文件保持一致即可</u></p><div class="language-ini line-numbers-mode" data-ext="ini"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#98C379;">dir</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>测试always写策略</strong></p><figure><img src="`+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>后台启动后，配置的数据目录下出现<code>appendonly.aof</code>文件，此时文件大小还是0字节</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由于我们配置的AOF存储方式是always，每次写指令AOF文件都会记录</p><p>我们启动客户端，执行2个写指令</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>然后我们查看AOF文件中的内容</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>测试everysec写策略</strong></p><p>修改配置文件中的写策略</p><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>杀掉进程后重启redis服务器</p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>启动客户端插入一些数据</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查看<code>appendonly.aof</code>文件</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="四、aof重写机制" tabindex="-1"><a class="header-anchor" href="#四、aof重写机制" aria-hidden="true">#</a> 四、AOF重写机制</h2><p>如果连续执行以下指令，会造成<strong>AOF文件冗余，连续三次set同一个变量是没必要的，记住最后一次set即可</strong>；同理，<strong>连续三次incr也是没有必要的，直接求和set即可</strong></p><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',31),j=s("strong",null,"将对同一个数据的若干个条命令执行结果转化成最终结果数据对应的指令进行记录",-1),H=l('<h3 id="aof重写作用" tabindex="-1"><a class="header-anchor" href="#aof重写作用" aria-hidden="true">#</a> AOF重写作用</h3><ul><li><u>降低磁盘占用量</u>，提高磁盘利用率</li><li>提高持久化效率，<u>降低持久化写时间</u>，提高IO性能</li><li><u>降低数据恢复所需时长</u>，提高数据恢复效率</li></ul><h3 id="aof重写规则" tabindex="-1"><a class="header-anchor" href="#aof重写规则" aria-hidden="true">#</a> AOF重写规则</h3>',3),X=s("li",null,[a("进程内"),s("strong",null,"已超时"),a("的数据不再写入文件，即"),s("strong",null,"不写无效数据")],-1),G=s("li",null,[a("忽略无效指令，重写时使用进程内数据直接生成，这样"),s("strong",null,"新的AOF文件只保留最终数据的写入命令")],-1),J=s("li",null,[a("如del key1、 hdel key2、srem key3、set key4 111、set key4 222等 "),s("strong",null,"对同一数据的多条写命令合并为一条命令"),a("：如lpush list1 a、lpush list1 b、 lpush list1 c 可以转化为：lpush list1 a b c")],-1),L=l(`<h3 id="aof重写方式" tabindex="-1"><a class="header-anchor" href="#aof重写方式" aria-hidden="true">#</a> AOF重写方式</h3><h4 id="指令方式-手动重写" tabindex="-1"><a class="header-anchor" href="#指令方式-手动重写" aria-hidden="true">#</a> 指令方式：手动重写</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">bgrewriteaof</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>验证手动重写指令 bgrewriteaof</strong></p><p>修改配置文件后，重启服务</p><figure><img src="`+A+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端连接后，连续set三次</p><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查看一下<code>appendonly-6379.aof</code></p><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>手动执行<code>bgrewriteaof</code>指令，重写aof文件</p><figure><img src="'+F+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查看aof文件，文件重写后占用空间变小了</p><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端给list1中插入三个数据，并删除变量name</p><figure><img src="'+O+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查看<code>appendonly-6379.aof</code></p><figure><img src="'+D+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端输入<code>bgrewriteaof</code>指令，重写aof文件</p><figure><img src="'+z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查看<code>appendonly-6379.aof</code></p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>bgrewriteaof指令工作原理</strong></p><figure><img src="'+w+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="配置文件方式-自动重写" tabindex="-1"><a class="header-anchor" href="#配置文件方式-自动重写" aria-hidden="true">#</a> 配置文件方式：自动重写</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">auto</span><span style="color:#ABB2BF;">-aof-rewrite-min-</span><span style="color:#C678DD;">size</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">size</span><span style="color:#ABB2BF;">            # size的默认大小比较大，32M或64M，超过size触发重写</span></span>
<span class="line"><span style="color:#C678DD;">auto</span><span style="color:#ABB2BF;">-aof-rewrite-</span><span style="color:#C678DD;">percentage</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">percentage</span><span style="color:#ABB2BF;">    # 超过百分比，触发AOF重写</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>自动重写触发对比参数（运行指令<code>info Persistence</code>获取具体信息）</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">aof_current_size</span></span>
<span class="line"><span style="color:#ABB2BF;">aof_base_size</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>自动重写触发条件</p><figure><img src="`+R+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>输入info指令可以获得以下信息</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;"># Persistence</span></span>
<span class="line"><span style="color:#ABB2BF;">loading:</span><span style="color:#D19A66;">0</span></span>
<span class="line"><span style="color:#ABB2BF;">rdb_changes_since_last_save:</span><span style="color:#D19A66;">0</span></span>
<span class="line"><span style="color:#ABB2BF;">rdb_bgsave_in_progress:</span><span style="color:#D19A66;">0</span></span>
<span class="line"><span style="color:#ABB2BF;">rdb_last_save_time:</span><span style="color:#D19A66;">1655626139</span></span>
<span class="line"><span style="color:#ABB2BF;">rdb_last_bgsave_status:ok</span></span>
<span class="line"><span style="color:#ABB2BF;">rdb_last_bgsave_time_sec:-</span><span style="color:#D19A66;">1</span></span>
<span class="line"><span style="color:#ABB2BF;">rdb_current_bgsave_time_sec:-</span><span style="color:#D19A66;">1</span></span>
<span class="line"><span style="color:#ABB2BF;">rdb_last_cow_size:</span><span style="color:#D19A66;">0</span></span>
<span class="line"><span style="color:#ABB2BF;">aof_enabled:</span><span style="color:#D19A66;">0</span></span>
<span class="line"><span style="color:#ABB2BF;">aof_rewrite_in_progress:</span><span style="color:#D19A66;">0</span></span>
<span class="line"><span style="color:#ABB2BF;">aof_rewrite_scheduled:</span><span style="color:#D19A66;">0</span></span>
<span class="line"><span style="color:#ABB2BF;">aof_last_rewrite_time_sec:-</span><span style="color:#D19A66;">1</span></span>
<span class="line"><span style="color:#ABB2BF;">aof_current_rewrite_time_sec:-</span><span style="color:#D19A66;">1</span></span>
<span class="line"><span style="color:#ABB2BF;">aof_last_bgrewrite_status:ok</span></span>
<span class="line"><span style="color:#ABB2BF;">aof_last_write_status:ok</span></span>
<span class="line"><span style="color:#ABB2BF;">aof_last_cow_size:</span><span style="color:#D19A66;">0</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="五、aof工作流程" tabindex="-1"><a class="header-anchor" href="#五、aof工作流程" aria-hidden="true">#</a> 五、AOF工作流程</h2><figure><img src="`+q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>always：主进程执行set，<u>子进程写AOF文件中相关信息</u> everysec：主进程执行set，<u>子进程先把相关信息写入AOF缓存区（突然停电，这里面的数据就丢了），时间到1s后，写入AOF文件</u></p><figure><img src="'+C+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>配置everysec重写方式：<u>根据配置文件，后台进程执行bgrewriteaof</u>，先给用户返回提示信息。然后<u>用左边子进程写入<strong>aof缓存区</strong>的数据重写临时aof文件，最终会讲临时aof文件的内容<strong>更新到真正的aof文件</strong>，然后<strong>临时的aof文件就被删除</strong>了</u></p><h2 id="六、aof和rdb的区别" tabindex="-1"><a class="header-anchor" href="#六、aof和rdb的区别" aria-hidden="true">#</a> 六、AOF和RDB的区别</h2><figure><img src="'+N+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',39),$=l("<li>占用空间： 由于很多指令可能只是对某几个数据进行操作，所以对于<u>同样的数据量，AOF存指令会占用更多的空间</u></li><li>存储速度： 由于<u>RDB每次都会<strong>存储所有的数据</strong>，而AOF只是<strong>追加</strong>当前的写操作，所以RDB存储较慢</u>，AOF存储较快</li><li>恢复速度： RDB恢复的时候<u>直接导入数据</u>即可，AOF需要<u>执行很多指令</u>，恢复速度较慢</li>",3),aa=s("li",null,[a("启动优先级："),s("strong",null,"如果同时启用了AOF和RDB两种持久化方式，那么AOF的启动优先级是高于RDB的"),s("ul",null,[s("li",null,[a("因为AOF持久化方式可以记录每一个写命令，并且可以在服务重启时重新执行这些写命令来恢复数据，从而保证了"),s("strong",null,"数据的完整性"),a("。而RDB持久化方式则是通过定期生成快照来保存数据的，因此在两次快照之间的数据变更如果Redis服务器宕机，则这部分数据将会丢失")])])],-1),sa=s("h3",{id:"基于需求选择rdb和aof",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#基于需求选择rdb和aof","aria-hidden":"true"},"#"),a(" 基于需求选择RDB和AOF")],-1),ea=s("u",null,"AOF持久化策略使用everysecond，每秒钟持久化一次。该策略redis仍可以保持很好的处理性能，当出现问题时，最多丢失0-1秒内的数据",-1),na=l('<p>综合比对</p><ul><li>RDB与AOF的选择实际上是在做一种权衡，每种都有利有弊</li><li>如不能承受数分钟以内的数据丢失，对业务数据非常敏感，选用AOF，因为AOF可以用always保存所有写操作</li><li>如能承受数分钟以内的数据丢失，且追求大数据集的恢复速度，选用RDB，RDB恢复数据快</li><li>灾难恢复选用RDB，因为RDB保存的是全数据</li><li><strong>双保险策略，同时开启 RDB 和 AOF，重启后，Redis优先使用 AOF 来恢复数据，降低丢失数据的量</strong></li></ul><blockquote><p>1、如果对数据的完整性与一致性要求比较高，可以选择aof持久化；如果想让数据恢复快一些，可以使用rdb，默认情况使用的是rdb持久化方式</p><p>2、两种持久化的方式是可以一起使用的，可以起到互补的作用。</p><p>3、如果只有aof持久化方式，是可以启动redis服务器的。如果aof是唯一的持久化方式，但是aof文件被损坏了，那么redis服务器是启动不成功的。</p><p>4、如果aof持久化是唯一的方式，那么aof文件损坏之后，服务器不能正常启动，但是可以通过命令修复aof文件。</p><figure><img src="'+T+'" alt="image-20230704163821497" tabindex="0" loading="lazy"><figcaption>image-20230704163821497</figcaption></figure></blockquote>',3);function ia(la,oa){const e=r("font");return t(),c("div",null,[I,s("ul",null,[P,s("li",null,[s("strong",null,[a("对"),n(e,{color:"red"},{default:i(()=>[a("所有写操作")]),_:1}),a("均进行记录，排除丢失数据的风险")])])]),E,M,Q,s("p",null,[W,a("："),Y,a("写入操作均同步到AOF文件中，数据零误差，"),n(e,{color:"red"},{default:i(()=>[a("性能较低，一般不建议使用")]),_:1})]),s("p",null,[Z,a("："),K,a("将缓冲区中的指令同步到AOF文件中，"),n(e,{color:"red"},{default:i(()=>[a("数据准确性高，性能较高，再系统突然当即的情况下最多丢失1秒内的数据")]),_:1}),a("，"),s("strong",null,[n(e,{color:"green"},{default:i(()=>[a("一般建议使用，同时也是默认配置")]),_:1})])]),s("p",null,[S,a("：由操作系统每次同步到AOF文件的周期，整体过程"),n(e,{color:"red"},{default:i(()=>[a("不可控")]),_:1})]),U,s("p",null,[a("随着命令不断写入AOF，文件会越来越大，为了解决这个问题，"),s("strong",null,[a("Redis引入了"),n(e,{color:"green"},{default:i(()=>[a("AOF重写机制")]),_:1}),a("压缩文件体积")]),a("。AOF文件重写是将Redis进程内的数据转化为写命令同步到新AOF文件的过程，简单说就是"),n(e,{color:"green"},{default:i(()=>[j]),_:1})]),H,s("ul",null,[X,G,J,s("li",null,[a("为"),n(e,{color:"red"},{default:i(()=>[a("防止数据量过大造成客户端缓冲区溢出")]),_:1}),a("，对"),s("u",null,[a("list、set、hash、zset等类型，每条指令"),n(e,{color:"red"},{default:i(()=>[a("最多写入64个元素")]),_:1})])])]),L,s("ul",null,[$,s("li",null,[a("数据安全性： "),n(e,{color:"red"},{default:i(()=>[a("RDB快照频率高则丢失数据少，快照频率低则丢失数据多；AOF设置always记录所有指令，不丢数据，everysec可能丢1s数据")]),_:1})]),aa]),sa,s("ul",null,[s("li",null,[n(e,{color:"green"},{default:i(()=>[a("对数据非常敏感，建议使用默认的AOF持久化方案，丢数据更少")]),_:1}),a("："),ea,a(" 。注意：由于"),n(e,{color:"red"},{default:i(()=>[a("AOF文件存储体积较大，恢复速度较慢")]),_:1})]),s("li",null,[n(e,{color:"green"},{default:i(()=>[a("数据呈现阶段有效性，建议使用RDB")]),_:1}),a("持久化方案：数据可以良好的做到阶段内无丢失（**该阶段是开发者或运维人员手工维护的**），且"),n(e,{color:"green"},{default:i(()=>[a("恢复速度较快，阶段点数据恢复通常采用RDB方案")]),_:1}),a("。注意："),n(e,{color:"green"},{default:i(()=>[a("利用RDB实现紧凑的数据持久化会使Redis降的很低")]),_:1})])]),na])}const ca=o(V,[["render",ia],["__file","AOF持久化.html.vue"]]);export{ca as default};
