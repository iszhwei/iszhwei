import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as e,o as p,c,d as s,e as n,f as o,w as a,b as r,a as i}from"./app-rY1SOIco.js";const B="/assets/1683811336407-445d996e-c0a0-48da-bbaa-8d222c07299d-j1XF_IxT.png",d={},y=s("u",null,"类可以实例无数的对象，每个对象都有自己的成员变量，但是共享一套成员方法代码（存储在.text）",-1),u=s("strong",null,"编译",-1),_=s("strong",null,"非静态成员函数",-1),h=s("strong",null,"this指针的作用就是区分不同对象的",-1),g=s("strong",null,"接收调用该方法的对象的地址",-1),F=i('<figure><img src="'+B+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li>this指针<strong>指向本身</strong></li><li>this指针隐藏在**（非静态）成员函数<strong>的</strong>第一个参数的位置**</li><li>被const修饰<code>类类型 * const this</code> ，即<strong>指针常量</strong></li></ol><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">void</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Point</span><span style="color:#ABB2BF;">::</span><span style="color:#61AFEF;">print</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">Point</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">    cout </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;(&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">-&gt;</span><span style="color:#E06C75;">_ix</span></span>
<span class="line"><span style="color:#ABB2BF;">         </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;,&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">this</span><span style="color:#ABB2BF;">-&gt;</span><span style="color:#E06C75;">_iy</span></span>
<span class="line"><span style="color:#ABB2BF;">         </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;)&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#ABB2BF;"> endl;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),m=s("u",null,"编译之后，此成员函数地址即已确定。而成员函数之所以能把属于此类的各个对象的数据区别开, 就是靠这个this指针。函数体内所有对类数据成员的访问， 都会被转化为this->数据成员的方式",-1),A=s("blockquote",null,[s("p",null,"这就是一套方法能知道处理哪个对象的原因：因为当用对象调用这些方法的时候，他就把对象的地址当作实参传给这些函数了，这些函数在编译过程中会产生this指针来接收所传入函数的地址。")],-1);function C(v,f){const l=e("font");return p(),c("div",null,[s("p",null,[y,n("。类的成员方法一经"),s("u",null,[o(l,{color:"green"},{default:a(()=>[u]),_:1}),n("，会给的"),_,n("都加一个this指针，接收调用该方法的对象的地址（即"),h,n("("),g,n(")")])]),r("more"),F,s("p",null,[n("对于类成员函数而言，并不是一个对象对应一个单独的成员函数体，而是此"),s("strong",null,[n("类的所有对象"),o(l,{color:"green"},{default:a(()=>[n("共用")]),_:1}),n("这个成员函数体")]),n("。 当程序被"),m,n("。")]),A])}const x=t(d,[["render",C],["__file","this.html.vue"]]);export{x as default};
