import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as t,c as _,a as e}from"./app-rY1SOIco.js";const r="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAQnVnTWFrZXItc2hlbg___size_20_color_FFFFFF_t_70_g_se_x_16-azOzok3r.png",i="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAQnVnTWFrZXItc2hlbg___size_20_color_FFFFFF_t_70_g_se_x_16-17137030197623-qz0klwz4.png",s="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAQnVnTWFrZXItc2hlbg___size_20_color_FFFFFF_t_70_g_se_x_16-17137030413386-LSOhxWRO.png",n="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAQnVnTWFrZXItc2hlbg___size_20_color_FFFFFF_t_70_g_se_x_16-17137030673199-x-mglG_Z.png",p={},o=e('<h1 id="读写分离原理" tabindex="-1"><a class="header-anchor" href="#读写分离原理" aria-hidden="true">#</a> 读写分离原理</h1><h2 id="读写分离概念" tabindex="-1"><a class="header-anchor" href="#读写分离概念" aria-hidden="true">#</a> 读写分离概念</h2><p>基于主从复制的读写分离，是我们在单机环境下，数据库的性能到瓶颈了，可以通过读写分离，提高后台服务性能。存储这一块的增删改查的并发的处理能力，<strong>主库专门负责相对少的写操作，从库专门负责相对多的读操作，主库的数据更改通过主从复制同步到从库</strong></p><p>读写分离就是在主服务器上修改，数据会同步到从服务器，从服务器只能提供读取数据，不能写入，实现备份的同时也实现了数据库性能的优化，以及提升了服务器安全</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>MySQL client通过mysql 提供的API，用mysql自定义的基于TCP的数据协议（简称mysql协议）与MySQL Server通信，访问MySQL Server数据库</p><p>最初，我们只有一台MySQL服务器，所有数据的增删改查都是在一台机器上进行，随着服务越来越多的人使用，流量越来越大，需要并发能力的不断提升，如果数据库的性能到瓶颈了，我们就要进行读写分离的操作</p><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>图中的MySQL主服务器专门做写操作，下面连着2个MySQL从服务器专门做读操作，读请求转发到B、C，写请求转发到A</p><p>如果我们在客户端上直接用代码写死，insert、update等写操作，在A上做，show、select等读操作在B、C上做，相当于代码和主从环境就是强绑定的。</p><p>这就导致代码的稳定性不太好，因为和环境强相关了，我们写代码得时候必须得知道哪个机器是负责写操作的主库，哪个机器是负责读操作的从库。而这时如果有某个机器挂掉了，代码也不会知道，还是按照原来的方式转发请求，通信就会出现问题，所以把读写分离用代码实现肯定不合适</p><h2 id="引入中间件mycat" tabindex="-1"><a class="header-anchor" href="#引入中间件mycat" aria-hidden="true">#</a> 引入中间件MyCat</h2><p>这时候就需要引入数据库中间件了，实际上，读写分离，分库分表都是需要依赖数据库中间件（mycat），mycat就是反向代理服务器</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端实际上区分不出来连的是MyCat还是MySQL，因为通信都是遵守的是MySQL通信协议，之前怎么和MySQL通信，现在就怎么和MyCat通信，所以不用进行区分</p><p><strong>在MyCat上配置读写分离</strong>，我们在客户端上的代码不用做任何变更，代码上不需要区分哪个请求是读，哪个请求是写，代码直接访问的是MyCat，由MyCat解析请求，根据SQL的读写性质转发到负责相应操作的服务器，实现读写分离</p><p>在MyCat上就是要配置主服务器和从服务器的信息，有3种情况：一主一从、一主多从、多主多从</p><p>一主多从场景：当写库（master）挂了，MyCat还可以马上把一个从库（slave）直接变成一个写库（master），然后变成写库的从库还要和其他从库之间配置一下主从复制</p><p>多主多从场景：</p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到图中，MyCat服务器挂了两套环境，如果其中1套的主库宕机了（它对应的从库也就不能用了），此时MyCat会自动切到另一套环境，因为M1和M2之间也是配置成互为主从的，所以M2可以同步M1的数据，提供与M1环境完全相同的服务</p><h2 id="mycat服务端口和管理端口" tabindex="-1"><a class="header-anchor" href="#mycat服务端口和管理端口" aria-hidden="true">#</a> MyCat服务端口和管理端口</h2><p>MySQL的服务端口是3306，MyCat服务端口是8066（这个端口也是可以改的），也就是MySQL Client连接的是8066端口，登录8066端口看到的界面就和登录MySQL Server的3306端口一样</p><p>MyCat还有一个管理端口9066，登录这个管理端口可以查看MyCat正在工作的所有状态以及和后端服务器的连接，以及连接数据源的状态等</p>',24),c=[o];function l(d,h){return t(),_("div",null,c)}const m=a(p,[["render",l],["__file","读写分离原理.html.vue"]]);export{m as default};
