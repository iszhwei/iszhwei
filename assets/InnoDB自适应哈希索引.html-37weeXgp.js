import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as p,o as r,c,d as s,e as n,f as a,w as e,a as o}from"./app-2pke9_a8.js";const i="/assets/image-20240418205543848-1e3btuLJ.png",d="/assets/image-20240418210328778-XHpD4Osq.png",B="/assets/402f6b3b819a407dbeda7289c5221259-_njx8xrL.png",u={},_=s("h1",{id:"innodb自适应哈希索引",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#innodb自适应哈希索引","aria-hidden":"true"},"#"),n(" InnoDB自适应哈希索引")],-1),y=s("strong",null,"自适应哈希索引作用",-1),g=s("u",null,"避免频繁回表",-1),h=s("strong",null,"频繁访问的二级索引项",-1),m=o(`<ul><li>自动创建的</li><li>也是只能等值查询</li><li>是InnoDB对B+树二级索引的一个优化措施</li></ul><p>假如name是有索引的，我们不断使用如下的方式查询，那就得先访问name的二级索引树，从二级索引树上取出主键uid，然后<strong>回表</strong>，用这个uid去主键索引树上取得对应的数据</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">select</span><span style="color:#ABB2BF;"> * </span><span style="color:#C678DD;">from</span><span style="color:#ABB2BF;"> student </span><span style="color:#C678DD;">where</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">name</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;zhangsan&quot;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">select</span><span style="color:#ABB2BF;"> * </span><span style="color:#C678DD;">from</span><span style="color:#ABB2BF;"> student </span><span style="color:#C678DD;">where</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">name</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;gaoyang&quot;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#C678DD;">select</span><span style="color:#ABB2BF;"> * </span><span style="color:#C678DD;">from</span><span style="color:#ABB2BF;"> student </span><span style="color:#C678DD;">where</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">name</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;linfeng&quot;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">...</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3),b=s("strong",null,"某个二级索引不断被使用，二级索引成为热数据",-1),v=s("figure",null,[s("img",{src:i,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),D=s("ul",null,[s("li",null,[s("p",null,"蓝色的箭头表搜索二级索引树然后回表的过程")]),s("li",null,[s("p",null,"黄色箭头就是直接等值查询搜索哈希表，直接拿到数据地址的过程。**使用哈希索引O(1)的时间复杂度就访问到哈希索引name，然后取出data即可（**对于InnoDB来说应该是直接取得数据，而不是拿到数据地址后再访问）")])],-1),f=o(`<p>自适应哈希索引是默认开启的：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">show variables </span><span style="color:#C678DD;">like</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&#39;innodb_adaptive_hash_index&#39;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在MySQL5.7以前，操作哈希表是只有一把锁的，锁的粒度太大，效率很低。<u>在MySQL5.7以后，每个分区都会有自己的锁，锁的粒度减小，要是各个线程在同一个分区（一个分区可以包含一个或多个桶）进行并发操作，就需要加锁</u>。要是<strong>在不同的分区操作，就不用加锁</strong>。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">show variables </span><span style="color:#C678DD;">like</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&#39;innodb_adaptive_hash_index_parts&#39;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',5),A=o(`<p>我们通过以下命令查看两个关键信息：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">show engine innodb </span><span style="color:#C678DD;">status</span><span style="color:#ABB2BF;">\\G</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,2),F=s("strong",null,"RW-latch阻塞/等待线程的数量",-1),C=s("strong",null,"等待的线程数量过多",-1),x=s("figure",null,[s("img",{src:B,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),k=s("p",null,[n("项目中如果遇到并发量很大，服务器处理请求慢时，可以使用"),s("code",null,"show engine innodb status\\G"),n("查看是否需要关闭AHI，也是提高数据库性能的一种方式")],-1);function q(w,I){const l=p("font");return r(),c("div",null,[_,s("p",null,[y,n("：MySQL Server为"),g,n("，"),a(l,{color:"green"},{default:e(()=>[n("对"),h,n("创建哈希索引")]),_:1})]),m,s("p",null,[n("InnoDB存储引擎会做如下优化：如果检测到"),b,n("，那么InnoDB会根据在二级索引树上的索引值在构建一个哈希索引来加速搜索（"),a(l,{color:"red"},{default:e(()=>[n("只适用于等值查询")]),_:1}),n("）")]),v,D,s("p",null,[n("注意："),s("strong",null,[a(l,{color:"red"},{default:e(()=>[n("hash索引的生成和维护也是耗费性能的，并不能绝对的在任何场景下提高对二级索引的搜索效率")]),_:1})]),n("，我们可以查看相关参数指标，如果自适应哈希索引可以提高效率，那我们使用它，否则我们就关闭它")]),f,a(l,{color:"red"},{default:e(()=>[n("在并发环境中，如果同一个分区等待的线程过多，这个时候需要考虑关闭自适应哈希索引")]),_:1}),A,s("ul",null,[s("li",null,[F,n("，自适应哈希索引默认分配了8个分区，"),a(l,{color:"red"},{default:e(()=>[n("若某个分区"),C]),_:1}),n("，则需要考虑关闭自适应哈希索引")]),s("li",null,[a(l,{color:"red"},{default:e(()=>[n("使用自适应哈希索引搜索的**频率低于**不使用自适应哈希索引搜索的频率")]),_:1}),n("，也需要考虑关闭自适应哈希索引")])]),x,k])}const z=t(u,[["render",q],["__file","InnoDB自适应哈希索引.html.vue"]]);export{z as default};
