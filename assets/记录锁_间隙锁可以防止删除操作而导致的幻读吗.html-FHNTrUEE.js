import{_ as r}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as s,o as c,c as d,d as e,e as t,f as n,w as o,a as i}from"./app-9OmaxHRC.js";const _="/assets/ed18d83815c94912b89ad340a51f3f6f-17136310221253-iYh6qnk7.png",l="/assets/960d8d327b074989bb53de4d17307f3b-537bmZry.png",g="/assets/815c4cd81ffa476fa7283ee4ebaed5d4-22Ri68rl.png",f="/assets/d62d381b8c9646a18c67a9f6906fffeb-XnCtWw_a.png",p="/assets/c7b95eca5a274c64b91bd3876d137cb5-rHVROLMN.png",h={},u=i('<h1 id="记录锁-间隙锁可以防止删除操作而导致的幻读吗" tabindex="-1"><a class="header-anchor" href="#记录锁-间隙锁可以防止删除操作而导致的幻读吗" aria-hidden="true">#</a> 记录锁+间隙锁可以防止删除操作而导致的幻读吗？</h1><h2 id="mysql-是怎么解决幻读的" tabindex="-1"><a class="header-anchor" href="#mysql-是怎么解决幻读的" aria-hidden="true">#</a> MySQL 是怎么解决幻读的？</h2><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，<u>因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</u></li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，<u>如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题</u>。</li></ul><h2 id="加锁分析" tabindex="-1"><a class="header-anchor" href="#加锁分析" aria-hidden="true">#</a> 加锁分析</h2><p>问题来了，A 事务在执行 select … for update 语句时，具体加了什么锁呢？</p><h3 id="如果对-age-没有索引-事务-a-这条查询会加什么锁呢" tabindex="-1"><a class="header-anchor" href="#如果对-age-没有索引-事务-a-这条查询会加什么锁呢" aria-hidden="true">#</a> 如果对 age 没有索引，事务 A 这条查询会加什么锁呢？</h3><p>我们可以通过 <code>select * from performance_schema.data_locks\\G; </code>这条语句，查看事务执行 SQL 过程中加了什么锁。</p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从上面输出的信息可以看到，共加了两种不同粒度的锁，分别是：</p><p><strong>表锁（LOCK_TYPE: TABLE）</strong>：X 类型的意向锁； <strong>行锁（LOCK_TYPE: RECORD）</strong>：X 类型的 next-key 锁； 这里我们重点关注「行锁」，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思：</p><p>如果 LOCK_MODE 为 <code>X</code>，说明是 <strong>next-key 锁</strong>； 如果 LOCK_MODE 为 <code>X, REC_NOT_GAP</code>，说明是<strong>记录锁</strong>； 如果 LOCK_MODE 为 <code>X, GAP</code>，说明是<strong>间隙锁</strong>；</p><p>因此，此时事务 A 在主键索引（INDEX_NAME : PRIMARY）上加了 10 个 next-key 锁，如下：</p><p>X 型的 next-key 锁，范围：(-∞, 1] X 型的 next-key 锁，范围：(1, 2] X 型的 next-key 锁，范围：(2, 3] X 型的 next-key 锁，范围：(3, 4] X 型的 next-key 锁，范围：(4, 5] X 型的 next-key 锁，范围：(5, 6] X 型的 next-key 锁，范围：(6, 7] X 型的 next-key 锁，范围：(7, 8] X 型的 next-key 锁，范围：(8, 9] X 型的 next-key 锁，范围：(9, +∞]</p><p><strong>这相当于把<u>整个表给锁住了</u>，其他事务在对该表进行增、删、改操作的时候都会被阻塞。</strong></p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="如果对-age-建立索引-事务-a-这条查询会加什么锁呢" tabindex="-1"><a class="header-anchor" href="#如果对-age-建立索引-事务-a-这条查询会加什么锁呢" aria-hidden="true">#</a> 如果对 age 建立索引，事务 A 这条查询会加什么锁呢？</h3><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>继续通过 <code>select * from performance_schema.data_locks\\G; </code>这条语句，查看事务执行 SQL 过程中加了什么锁。</p>',19),x=e("figure",null,[e("img",{src:f,alt:"",tabindex:"0",loading:"lazy"}),e("figcaption")],-1),m=e("figure",null,[e("img",{src:p,alt:"",tabindex:"0",loading:"lazy"}),e("figcaption")],-1),y=e("h2",{id:"总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#总结","aria-hidden":"true"},"#"),t(" 总结")],-1),k=e("p",null,"在 MySQL 的可重复读隔离级别下，针对当前读的语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。",-1);function b(X,C){const a=s("font");return c(),d("div",null,[u,e("p",null,[e("strong",null,[t("因为表中有两个索引，分别是主键索引和 age 索引，所以会分别对这两个索引加锁。"),n(a,{color:"red"},{default:o(()=>[t("二级索引树加next-key lock，主键索引树加record lock")]),_:1})])]),x,m,y,k,n(a,{color:"red"},{default:o(()=>[t("有一点要注意的是，在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了，这是挺严重的问题。")]),_:1})])}const O=r(h,[["render",b],["__file","记录锁_间隙锁可以防止删除操作而导致的幻读吗.html.vue"]]);export{O as default};
