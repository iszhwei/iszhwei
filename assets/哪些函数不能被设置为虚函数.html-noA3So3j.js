import{_ as s}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as _,o as r,c as a,d as l,e as t,f as e,w as n,a as u}from"./app-rY1SOIco.js";const d={},c=u('<h2 id="成为虚函数的条件" tabindex="-1"><a class="header-anchor" href="#成为虚函数的条件" aria-hidden="true">#</a> 成为虚函数的条件</h2><p><strong>1.要成为虚函数，函数地址就要记录在虚函数表中，即<u>虚函数能产生函数地址，存储在vftable中</u>。</strong><strong>2.<u>vfptr指针需要依赖对象，对象必须存在</u>。</strong>（vfptr-&gt;vftable-&gt;虚函数地址 ）</p><h2 id="哪些函数不能被设置为虚函数" tabindex="-1"><a class="header-anchor" href="#哪些函数不能被设置为虚函数" aria-hidden="true">#</a> 哪些函数不能被设置为虚函数？</h2>',3),i=l("strong",null,"普通函数（非成员函数）",-1),h=l("u",null,"虚函数的主要目的是为了重写达到多态",-1),f=l("strong",null,"静态成员函数",-1),g=l("strong",null,"，所以它也没有动态绑定的必要。(静态函数发生在",-1),p=l("ul",null,[l("li",null,[t("不可能出现 "),l("code",null,"static + virtual"),t(" 或 "),l("code",null,"virtual + static")])],-1),m=l("strong",null,"内联成员函数",-1),v=l("u",null,[t("是为了"),l("strong",null,"减少函数调用的代价"),t("，所以在代码中直接展开")],-1),x=l("u",null,[t("但虚函数"),l("strong",null,"一定要创建虚函数表"),t("，这两者不可能统一")],-1),b=l("u",null,"运行时才动态绑定",-1),N=l("strong",null,"构造函数",-1),V=l("strong",null,"友元函数",-1),B=l("u",null,[t("当我们把一个函数声明为一个类的友元函数时，它只是一个可以访问类内成员的"),l("strong",null,"普通函数"),t("，并不是这个类的成员函数")],-1),k=l("u",null,"成员函数",-1),w=l("u",null,"可以设置为虚函数的",-1),C=l("h2",{id:"为什么析构函数可以成为虚函数",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#为什么析构函数可以成为虚函数","aria-hidden":"true"},"#"),t(" 为什么析构函数可以成为虚函数")],-1),E=l("p",null,"因为析构函数调用的时候，对象是存在的！",-1);function S(T,j){const o=_("font");return r(),a("div",null,[c,l("ol",null,[l("li",null,[i,t("：定义"),h,t("，所以普通函数声明为虚函数没有意义，因此编译器在**"),e(o,{color:"red"},{default:n(()=>[t("编译时")]),_:1}),t("**就绑定了它。")]),l("li",null,[f,t("：静态成员函数对于每个类都只有一份代码，所有对象都可以共享这份代码，他**"),e(o,{color:"red"},{default:n(()=>[t("不归某一个对象所有")]),_:1}),g,e(o,{color:"red"},{default:n(()=>[t("编译时")]),_:1}),t("**，虚函数体现多态发生在运行时) "),p]),l("li",null,[m,t("：内联函数本就"),v,t("。"),x,t("。另外，内联函数在**"),e(o,{color:"red"},{default:n(()=>[t("编译时被展开")]),_:1}),t("**，而虚函数在"),b,t("。")]),l("li",null,[N,t("：这个原因很简单，主要从语义上考虑。因为构造函数本来是为了初始化对象成员才产生的，然而虚函数的目的是为了在完全不了解细节的情况下也能正确处理对象，两者根本不能“ 好好相处 ”。因为**"),e(o,{color:"red"},{default:n(()=>[t("虚函数要对不同类型的对象产生不同的动作，如果将构造函数定义成虚函数，那么对象都没有产生，怎么完成想要的动作呢")]),_:1}),t("**")]),l("li",null,[V,t("："),B,t("，自然也不能在自己的类内将它声明为虚函数。("),l("strong",null,[e(o,{color:"green"},{default:n(()=>[t("当友元函数是"),k,t("的时候是"),w]),_:1})]),t("，比如在自己类里面设置为虚函数，但是作为另一个类的友元)")])]),C,E])}const z=s(d,[["render",S],["__file","哪些函数不能被设置为虚函数.html.vue"]]);export{z as default};
