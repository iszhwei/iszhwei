import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as t,o as c,c as r,b as p,d as s,f as l,w as e,e as a,a as o}from"./app-m9pC5KT-.js";const d="/assets/image-20231230103243664-Ykrg3kfx.png",u="/assets/a0faa85bb14444b8b9636925b867ee51-PmpPeoac.png",g="/assets/image-20240130222426316-y1iqsbJg.png",B="/assets/dd0090dd967d4ac5be3039c5ffe49cc7-PE8bKEAB.png",m="/assets/image-20240131004256680-uuy5OnYC.png",y="/assets/3efd42aafd1a444d9a8c860f6bbe4eb9-63G4E6hF.png",h="/assets/image-20240131011722928-vxG0s0On.png",b="/assets/b793d1397df944f6b04ed7d1527a57fd-zLwOmTVi.png",f="/assets/966cc3e1fc9b4366a718135dcf71d756-zsWMyx9q.png",_="/assets/616264ffaf724268b028b05c305b078c-IeqOvilF.png",F="/assets/d5fdc35df9e54958bde15cdbef48ff17-d5hhmVtK.png",v="/assets/image-20240310133845350-YClOngIa.png",A="/assets/693e6eec33134fa488aff85e9a3c7500-yNtBRyrU.png",x="/assets/0a542f82a1dd4b8cbe4bd68104acf0d1-HcVLBmRG.png",D={},k=o('<h1 id="编译器角度理解c-代码的编译和链接" tabindex="-1"><a class="header-anchor" href="#编译器角度理解c-代码的编译和链接" aria-hidden="true">#</a> 编译器角度理解c++代码的编译和链接</h1><p>c/c++这种<strong>本地编译型语言</strong>的编译过程</p><figure><img src="'+d+'" alt="image-20231230103243664" tabindex="0" loading="lazy"><figcaption>image-20231230103243664</figcaption></figure><h2 id="重点" tabindex="-1"><a class="header-anchor" href="#重点" aria-hidden="true">#</a> <strong>重点</strong>：</h2><ol><li><strong><code>*.o</code>文件的组成格式是什么样的？</strong></li><li><strong>可执行文件的组成格式是什么样的？</strong></li><li><strong>链接的两个步骤做的是什么事情？</strong></li><li><strong>符号表中的符号怎么理解？</strong></li><li><strong>符号何时分配虚拟地址？</strong><img src="'+u+'" alt="在这里插入图片描述" loading="lazy"></li></ol>',5),C=s("li",null,[s("code",null,"#pragma lib"),a("表示程序执行时需要连接的库，所以必须在链接阶段生效")],-1),E=s("li",null,[a("假如有个函数start，想让程序执行的时候从start开始执行而不是main，需要"),s("code",null,"#pragma link"),a("修改程序的入口地址，所以也必须持续到链接阶段。")],-1),z=s("code",null,"#include",-1),N=s("code",null,"#define",-1),V=s("code",null,"#ifdef",-1),j=s("code",null,"#ifndef",-1),O=s("code",null,"#endif",-1),S=o("<li><strong>编译阶段</strong>可以gcc，也可以g++, <code>g++ -O 0 1 2 3 ...</code>表示优化级别</li><li>编译完成后会生成相应平台的汇编代码，<strong>汇编阶段</strong>有两种架构的汇编代码<code>x86</code>和<code>AT&amp;T</code><ul><li>在gdb下使用<code>set disassembly-flavor intel</code> 转换为intel格式的汇编</li><li><code>set disassembly-flavor att </code>转换为att格式的汇编</li></ul></li><li><strong>汇编</strong>就是把汇编代码转成特定平台的二进制码</li>",3),q=s("h2",{id:"链接主要工作🍔",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#链接主要工作🍔","aria-hidden":"true"},"#"),a(" 链接主要工作🍔")],-1),P=s("p",null,"⭐在编译过程中，源文件经过预编译、编译和汇编的过程，生成了二进制的可重定位的目标文件；",-1),T=s("strong",null,"段",-1),w=s("strong",null,"合并",-1),G=o(`<ul><li>⭐对<strong>符号</strong>进行<strong>解析</strong>：所有对符号的引用，都要找到其定义的地方</li></ul><p>⭐<u>对符号进行解析完成后，就会给所有的符号分配虚拟地址</u>；</p><ul><li>⭐<strong>符号重定位</strong>：就是将给符号分配后的地址写回代码段；</li></ul><h2 id="示例" tabindex="-1"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> 示例</h2><p>根据如下两段代码分析</p><p>其中注释表示<u>符号</u>和存放<u>在进程虚拟地址空间的位置</u></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">//main.cpp</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// 引用sum.cpp里定义得全局变量及函数</span></span>
<span class="line"><span style="color:#C678DD;">extern</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> gdata;</span><span style="color:#7F848E;font-style:italic;">  // gdata *UND*</span></span>
<span class="line"><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">sum</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;">, </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;">);</span><span style="color:#7F848E;font-style:italic;"> // _Z3sumii *UND*</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> data </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">20</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // data .data</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">main</span><span style="color:#ABB2BF;">()</span><span style="color:#7F848E;font-style:italic;"> // main .text</span></span>
<span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> a </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> gdata;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> b </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> data;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> ret </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">sum</span><span style="color:#ABB2BF;">(a, b);</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">// sum.cpp</span></span>
<span class="line"><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> gdata </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">20</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;"> // gdata .data</span></span>
<span class="line"><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">sum</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;font-style:italic;">a</span><span style="color:#ABB2BF;">, </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;font-style:italic;">b</span><span style="color:#ABB2BF;">)</span><span style="color:#7F848E;font-style:italic;"> // _Z3sumii .text</span></span>
<span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> a </span><span style="color:#56B6C2;">+</span><span style="color:#ABB2BF;"> b;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="编译阶段" tabindex="-1"><a class="header-anchor" href="#编译阶段" aria-hidden="true">#</a> 编译阶段：</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">g++</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-c</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">main.cpp</span><span style="color:#ABB2BF;"> </span><span style="color:#7F848E;font-style:italic;">#编译成main.o</span></span>
<span class="line"><span style="color:#61AFEF;">g++</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-c</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">sum.cpp</span><span style="color:#ABB2BF;">	</span><span style="color:#7F848E;font-style:italic;">#编译成sum.o</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="查看符号表" tabindex="-1"><a class="header-anchor" href="#查看符号表" aria-hidden="true">#</a> 查看符号表：</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">objdump</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-t</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">main.o</span><span style="color:#ABB2BF;">	</span><span style="color:#7F848E;font-style:italic;">#不仅显示符号表，还显示了段的信息</span></span>
<span class="line"><span style="color:#61AFEF;">nm</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">main.o</span><span style="color:#ABB2BF;">	</span><span style="color:#7F848E;font-style:italic;">#简洁，符号表（符号名称、类型和地址等基本信息）</span></span>
<span class="line"><span style="color:#61AFEF;">readelf</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-s</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">main.o</span><span style="color:#ABB2BF;"> </span><span style="color:#7F848E;font-style:italic;">#也可以查看符号表信息</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="查看main-o符号表" tabindex="-1"><a class="header-anchor" href="#查看main-o符号表" aria-hidden="true">#</a> 查看main.o符号表</h4><figure><img src="`+g+'" alt="image-20240130222426316" tabindex="0" loading="lazy"><figcaption>image-20240130222426316</figcaption></figure>',13),L=s("li",null,"l = local",-1),U=s("li",null,"g = global",-1),Y=s("ul",null,[s("li",null,"因为引用的符号都不知道在哪里定义的，肯定无法分配虚拟地址"),s("li",null,[s("u",null,[a("符号的虚拟地址是在"),s("strong",null,"链接时"),a("分配的")])])],-1),I=o('<h4 id="查看sum-o符号表" tabindex="-1"><a class="header-anchor" href="#查看sum-o符号表" aria-hidden="true">#</a> 查看sum.o符号表</h4><figure><img src="'+B+'" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><h3 id="分析main-o文件头" tabindex="-1"><a class="header-anchor" href="#分析main-o文件头" aria-hidden="true">#</a> 分析main.o文件头</h3><p>汇编器把汇编代码转成可重定向的文件时不仅生成了符号表，还生成了各种各样的段</p><figure><img src="'+m+`" alt="image-20240131004256680" tabindex="0" loading="lazy"><figcaption>image-20240131004256680</figcaption></figure><p><strong><code>*.o</code>文件的组成，需要关注的：</strong></p><ul><li><p><strong>ELF文件头</strong></p></li><li><p><strong>.text</strong></p></li><li><p><strong>.data</strong></p></li><li><p><strong>.bss</strong></p></li><li><p><strong>.symbal （符号段）</strong></p></li><li><p><strong>.section table(段表/节头部表)</strong></p></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">readelf</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-h</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">main.o</span><span style="color:#ABB2BF;"> </span><span style="color:#7F848E;font-style:italic;">#查看文件头 （elf头）</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+y+`" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><ul><li>这是 <u>可重定义的文件</u> 不是 <u>可执行文件</u>，所以入口地址 <code>Enter point address = 0x0</code>, 0x0不可以访问</li></ul><h3 id="打印目标文件各个段" tabindex="-1"><a class="header-anchor" href="#打印目标文件各个段" aria-hidden="true">#</a> 打印目标文件各个段：</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">readelf</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-S</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">main.o</span><span style="color:#ABB2BF;"> </span><span style="color:#7F848E;font-style:italic;">#查看有哪些段以及各个段的信息</span></span>
<span class="line"><span style="color:#61AFEF;">readelf</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-s</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">main.o</span><span style="color:#ABB2BF;"> </span><span style="color:#7F848E;font-style:italic;">#查看符号表信息</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+h+`" alt="image-20240131011722928" tabindex="0" loading="lazy"><figcaption>image-20240131011722928</figcaption></figure><ul><li>flag标志 <ul><li>A 分配空间的</li><li>W 可写的</li><li>X 可执行的</li></ul></li></ul><h3 id="分析main-o的-text段" tabindex="-1"><a class="header-anchor" href="#分析main-o的-text段" aria-hidden="true">#</a> 分析main.o的.text段</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">$</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">g++</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-c</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">main.cpp</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-g</span></span>
<span class="line"><span style="color:#61AFEF;">$</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">objdump</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-S</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">main.o</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+b+'" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>',17),K=s("strong",null,"符号是不分配虚拟地址的里面看汇编代码发现变量的值都为全0，说明符号值还没加载进来，这也是.o无法执行的原因之一",-1),M=s("h2",{id:"链接阶段",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#链接阶段","aria-hidden":"true"},"#"),a(" 链接阶段")],-1),R=s("h3",{id:"链接的过程🍔🍔🍔",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#链接的过程🍔🍔🍔","aria-hidden":"true"},"#"),a(" 链接的过程🍔🍔🍔")],-1),W=s("p",null,[a("所有"),s("code",null,".o文件段"),a("的"),s("u",null,"合并"),a("，"),s("u",null,"符号表"),a("合并后，进行"),s("u",null,"符号解析")],-1),Z=s("li",null,[s("p",null,[s("code",null,"main.o"),a("和"),s("code",null,"sum.o"),a("中各个段进行"),s("strong",null,"合并")]),s("ul",null,[s("li",null,".text <=>.text, .data<=>.data, .bss<=>.bss ..."),s("li",null,"符号表属于文件段之一（.symbal）")])],-1),$=s("p",null,[a("符号表合并后，进行"),s("strong",null,"符号解析")],-1),H=s("li",null,[a("符号解析：所有对符号的"),s("strong",null,"引用"),a("，都要找到该符号"),s("strong",null,"定义的地方")],-1),J=s("code",null,".text",-1),X=s("code",null,".data",-1),Q=s("ul",null,[s("li",null,"若一次都无，则符号未定义（报错）；"),s("li",null,"若出现多次，符号重定义(报错)")],-1),ss=s("strong",null,"是否",-1),as=s("code",null,".text",-1),ns=s("code",null,".data",-1),ls=s("strong",null,"链接的核心",-1),es=s("ul",null,[s("li",null,"符号重定向：符号解析成功后，给所有的符号分配了虚拟地址，前面符号的指令值都是全0，所以需要把符号的具体地址写到符号的指令上")],-1),os=o('<p><mark>符号什么时候分配虚拟地址：<strong>链接过程，第一步符号解析完成后</strong></mark></p><p><strong>手动链接</strong>：<code>ld -e main *.o</code></p><ul><li><code>-e</code> 参数用于指定链接后生成的可执行文件的入口点（entry point） <ul><li><code>ld -e main *.o</code> 意味着将所有的 <code>*.o</code> 目标文件链接在一起，并指定 <code>main</code> 函数作为程序的入口点</li></ul></li></ul><h2 id="可执行文件" tabindex="-1"><a class="header-anchor" href="#可执行文件" aria-hidden="true">#</a> 可执行文件</h2><h3 id="查看可执行文件a-out的符号表" tabindex="-1"><a class="header-anchor" href="#查看可执行文件a-out的符号表" aria-hidden="true">#</a> 查看可执行文件<code>a.out</code>的符号表</h3><figure><img src="'+f+'" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><ul><li>可以看出<u>每个符号都有其对应的<strong>虚拟地址</strong>以及<strong>所在的区域</strong>，<strong>运行时</strong>就可以将其加载到指定段中（如.data .text）</u></li></ul><h3 id="分析可执行文件的elf头" tabindex="-1"><a class="header-anchor" href="#分析可执行文件的elf头" aria-hidden="true">#</a> 分析可执行文件的elf头</h3><figure><img src="'+_+'" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><h3 id="再看一下a-out的汇编代码" tabindex="-1"><a class="header-anchor" href="#再看一下a-out的汇编代码" aria-hidden="true">#</a> 再看一下<code>a.out</code>的汇编代码</h3><h4 id="objdump-s查看汇编" tabindex="-1"><a class="header-anchor" href="#objdump-s查看汇编" aria-hidden="true">#</a> objdump -S查看汇编</h4><p><code>g++ -g -c main main.cc</code> #前提编译时 加<code>-g</code></p><p><code>objdump -M intel -S main.o</code> #反汇编、与相关联的源代码交替并且以英特尔的框架显示🍗🍗🍗</p><figure><img src="'+F+'" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><ul><li>可以发现<code>main</code>函数内第一条指令地址就是前面的入口地址(<code>entry</code>)</li></ul><h4 id="gdb查看汇编" tabindex="-1"><a class="header-anchor" href="#gdb查看汇编" aria-hidden="true">#</a> gdb查看汇编</h4><p>使用 <code>disassemble</code> 命令，或者简写为 <code>disas</code></p>',17),is=o(`<ol><li><p>在 <code>gdb</code> 提示符下，设置断点或让程序运行到你想要查看汇编代码的位置</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#abb2bf;">break main</span></span>
<span class="line"><span style="color:#abb2bf;">b main</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>在gdb下使用<code>set disassembly-flavor intel</code> 转换为intel格式的汇编</p></li><li><p>使用 <code>run</code> 命令运行程序</p></li><li><p>一旦程序停止在断点或你指定的位置，可以使用 <code>disassemble</code> 命令查看汇编代码。如果你没有指定任何参数，<code>gdb</code> 会显示当前函数的汇编代码</p></li></ol><figure><img src="`+v+`" alt="image-20240310133845350" tabindex="0" loading="lazy"><figcaption>image-20240310133845350</figcaption></figure><ol start="5"><li><p>如果你想要查看特定函数或地址的汇编代码，你可以将函数名或地址作为参数传递给 <code>disassemble</code> 命令。例如：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#abb2bf;">disas main</span></span>
<span class="line"><span style="color:#abb2bf;">disas 0x00000000004008ee </span></span>
<span class="line"><span style="color:#abb2bf;"></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>如果你想在每一步执行时都看到对应的汇编指令，你可以使用 <code>layout asm</code> 命令。这将打开一个新的窗口，显示当前执行点的汇编代码。然后，你可以使用 <code>stepi</code> 或 <code>nexti</code> 命令逐步执行汇编指令，并查看每步的汇编代码变化。</p></li><li><p>退出<code>q</code>或<code>quit</code></p></li></ol><h3 id="查看可执行程序的program-headers段" tabindex="-1"><a class="header-anchor" href="#查看可执行程序的program-headers段" aria-hidden="true">#</a> 查看可执行程序的program headers段</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#abb2bf;">readelf -l a.out #从查看可执行程序的program headers</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><mark><code>a.out </code>比<code>*.o</code>多了<code>program headers</code>段，<strong>有两个<code>load</code>(加载段),告知系统，运行时把哪些内容加载到内存中（.text, .data）</strong></mark></p><figure><img src="`+A+'" alt="693e6eec33134fa488aff85e9a3c7500" tabindex="0" loading="lazy"><figcaption>693e6eec33134fa488aff85e9a3c7500</figcaption></figure><h2 id="物理内存和虚拟内存映射🍗🍗🍗" tabindex="-1"><a class="header-anchor" href="#物理内存和虚拟内存映射🍗🍗🍗" aria-hidden="true">#</a> 物理内存和虚拟内存映射🍗🍗🍗</h2><p>运行程序时的工作大概如下图，数据加载到指定段，将进程的虚拟地址映射到物理地址空间：</p><figure><img src="'+x+'" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><ul><li><p><mark>a.out位于磁盘中，a.out包含很多段</mark></p><ul><li><mark>elf header , 告诉程序入口地址在哪里</mark></li><li><mark>program headers, 告诉系统加载文件中.text .data段到内存中</mark></li></ul></li><li><p><mark>并没有直接加载到物理内存，而是做一个地址映射，把.text .data .bss映射到cpu虚拟地址（进程的虚拟地址空间）中</mark></p><ul><li><p><mark>如果发现访问的地址还没有做映射，则会产生页面异常</mark></p></li><li><p><mark>页面异常=》执行地址映射页面异常处理程序，分配物理内存</mark></p></li></ul></li></ul><h2 id="进阶阅读" tabindex="-1"><a class="header-anchor" href="#进阶阅读" aria-hidden="true">#</a> 进阶阅读</h2><ol><li>《CSAPP》第七章</li><li>《程序员的自我修养》第2、3、4、6章</li></ol>',13);function ts(cs,rs){const n=t("font");return c(),r("div",null,[k,p("more"),s("ul",null,[C,E,s("li",null,[l(n,{color:"red"},{default:e(()=>[a("除了`#pragma lib`和`#pragma link`之外以`#`开头的都在预编译阶段处理")]),_:1}),a("("),z,a("、"),N,a("、"),V,a("、"),j,a("、"),O,a(" 等)")]),S]),q,P,s("p",null,[a("⭐此后，"),s("u",null,[a("在链接过程，所有.o文件对应的"),T,a("进行"),w,a("，其中"),l(n,{color:"red"},{default:e(()=>[a("symtab就是符号表段")]),_:1}),a("，符号表进行合并后，需要对符号进行解析")])]),G,s("ul",null,[L,U,s("li",null,[a("符号表都为0，"),l(n,{color:"red"},{default:e(()=>[a("编译过程中是不分配虚拟地址的")]),_:1}),Y])]),I,s("p",null,[a("由上图可知编译过程中，"),l(n,{color:"red"},{default:e(()=>[K]),_:1})]),M,R,s("ol",null,[s("li",null,[W,s("ol",null,[Z,s("li",null,[$,s("ul",null,[H,s("li",null,[a("在符号表中找对应的符号是否只出现于"),J,a("或"),X,a("段"),l(n,{color:"red"},{default:e(()=>[a("一次")]),_:1}),Q])]),s("p",null,[s("u",null,[a("链接时就是在符号表中找对应的符号"),ss,a("只出现于"),as,a("或"),ns,a("段"),l(n,{color:"red"},{default:e(()=>[a("一次")]),_:1}),a("；若一次都无，则符号未定义（报错）；若出现多次，符号重定义(报错)")])])])])]),s("li",null,[l(n,{color:"red"},{default:e(()=>[a("符号重定位（重定向）")]),_:1}),a("("),ls,a("),给所有符号分配虚拟地址，前面都是全0"),es])]),os,l(n,{color:"red"},{default:e(()=>[a("多用tab键")]),_:1}),is])}const us=i(D,[["render",ts],["__file","编译器角度理解c__代码的编译和链接.html.vue"]]);export{us as default};
