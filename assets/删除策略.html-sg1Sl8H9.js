import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as n,o as l,c as d,d as t,e,f as o,w as i,a as r}from"./app-2pke9_a8.js";const c="/assets/0273434c752c47728775a7f3b645967c-YXTi2qme.png",g="/assets/b3ab140e6de546c1bbaf3db3dcb04612-IQgOwUvo.png",p="/assets/c8820a59629c456da20cff77f750f5de-ux2SVCwS.png",u="/assets/d901aaee471544b8bceb012670f9bc97-j6-W2GMM.png",_="/assets/2eb5f42526f54c30b38baf3eeab0ca9d-mO1gb4CA.png",f="/assets/8ad90db824614517b96a5573c0be19d2-MC717iq1.png",h="/assets/c1baccfe1bcf460bb8aed85cbc3379f4-3az48wue.png",b="/assets/6123dfb15e5b4a7ca5e72069d720e7eb-ZE1NmbqD.png",m="/assets/8ee2f5be75274a4b9f453e12970254ed-o71Tjo0D.png",x={},y=r('<h1 id="删除策略" tabindex="-1"><a class="header-anchor" href="#删除策略" aria-hidden="true">#</a> 删除策略</h1><h2 id="一、过期数据" tabindex="-1"><a class="header-anchor" href="#一、过期数据" aria-hidden="true">#</a> 一、过期数据</h2><p><strong>Redis中的数据特征：</strong> Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过<code>TTL</code>指令获取其状态</p><ul><li><code>XX</code> : 具有时效性的数据</li><li><code>-1</code> : 永久有效的数据</li><li><code>-2</code> : 已经过期的数据 或 被删除的数据 或 未定义的数据</li></ul><p><strong>过期的数据真的被删了吗？</strong></p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>redis服务器有很多操作需要执行时，CPU的压力会很大，于是redis中的策略是，在内存还够的前提下，先不急着释放已删除的数据的内存空间，先执行客户端的指令</p><h2 id="二、数据删除策略" tabindex="-1"><a class="header-anchor" href="#二、数据删除策略" aria-hidden="true">#</a> 二、数据删除策略</h2><p>redis中的数据删除策略包括<strong>定时删除、惰性删除、定期删除</strong></p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',10),C=t("strong",null,"删除策略就是基于这块hash数据结构",-1),v=r('<h3 id="_1-定时删除-时间换空间" tabindex="-1"><a class="header-anchor" href="#_1-定时删除-时间换空间" aria-hidden="true">#</a> 1. 定时删除（时间换空间）</h3><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>创建一个定时器，当key设置有过期时间，且过期时间到达时，<strong>立即执行key的删除操作</strong></p><ul><li>优点：<strong>节约内存</strong>，到时就删除，立即释放不必要的内存占用</li><li>缺点：<strong>CPU压力较大</strong>，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li><li>总结：用处理器性能换取存储空间（时间换空间），<strong>适用于小内存，强CPU场景</strong></li></ul><h3 id="_2-惰性删除-空间换时间" tabindex="-1"><a class="header-anchor" href="#_2-惰性删除-空间换时间" aria-hidden="true">#</a> 2. 惰性删除 （空间换时间）</h3><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',6),U=t("strong",null,"发现数据已过期，删除，给客户端返回不存在",-1),P=t("code",null,"expireIfNeeded()",-1),z=t("ul",null,[t("li",null,"优点：节约CPU性能，发现不得不删除的时候才删除"),t("li",null,"缺点：内存空间压力很大，出现长期占用内存的数据"),t("li",null,[e("总结：用存储空间换取处理器性能 （空间换时间），适用于"),t("strong",null,"大内存，弱CPU"),e("场景")])],-1),k={id:"_3-定期删除-中和以上两种方案",tabindex:"-1"},B=t("a",{class:"header-anchor",href:"#_3-定期删除-中和以上两种方案","aria-hidden":"true"},"#",-1),N=r('<p>每个库都有独自维护的过期库expires</p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>定期删除算法过程如下：</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>每秒钟执行server.hz次serverCron，serverCron会轮询所有的库，使用databasesCron方法对每个库进行检测，databasesCron会调用activeExpireCycle会对每个expire[]检测，一个expire[]检测250ms/server.hz</p><p>周期性轮询redis库中的时效性数据，采用随机抽取的策略，<strong>利用过期数据占比的方式控制删除频度</strong></p><ul><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</li></ul><p>总结：周期性抽查存储空间（查询某个库的expires时，如果这轮删除过多，则再抽取删除一轮，如果这轮删除的很少，则去检查下一个库的expires）</p><h3 id="_4-三种删除方案对比" tabindex="-1"><a class="header-anchor" href="#_4-三种删除方案对比" aria-hidden="true">#</a> 4. 三种删除方案对比</h3><table><thead><tr><th></th><th>内存占用</th><th>CPU占用</th><th>特征</th></tr></thead><tbody><tr><td><strong>定时删除</strong></td><td>节约内存，无占用</td><td>不分时段占用CPU资源，频度高</td><td>时间换空间</td></tr><tr><td><strong>惰性删除</strong></td><td>内存占用严重</td><td>延时执行，CPU利用率高</td><td>空间换时间</td></tr><tr><td><strong>定期删除</strong></td><td>内存定期随机清理</td><td>每秒花费固定的CPU资源维护内存</td><td>随机抽查，重点抽查</td></tr></tbody></table><p>在redis里，会使用惰性删除和定期删除两种方式</p><h2 id="三、逐出算法" tabindex="-1"><a class="header-anchor" href="#三、逐出算法" aria-hidden="true">#</a> 三、逐出算法</h2><p><strong>当内存被永久数据占满（删除策略只能清除过期数据），新数据进入redis时，如果内存不足怎么办？</strong></p><p>Redis使用内存存储数据，<u>在执行每一个命令前，会调用<code>freeMemoryIfNeeded()</code>检测内存是否充足</u>。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法</p>',14),O=r('<figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>影响数据逐出的相关配置</strong></p><ul><li><p><strong>maxmemory</strong>：redis可使用内存占物理内存的最大比例，<strong>默认为0，表示不限制redis使用内存</strong>。生产环境中根据需求设定，<strong>通常设置在50%以上</strong></p></li><li><p><strong>maxmemory-samples</strong>：每次选取<strong>待删除数据的个数</strong>，选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此<u>采用<strong>随机获取数据的方式</strong>作为待检测删除数据</u></p></li><li><p><strong>maxmemory-policy</strong>：达到最大内存后的，对被挑选出来的数据进行<strong>删除的算法</strong></p></li></ul><p>删除算法有如下几种：</p><p><strong>检查可能会过期的数据集server.db[i].expires内的数据</strong></p>',5),M=t("code",null,"volatile-lru",-1),q=t("strong",null,"时间",-1),w=t("code",null,"volatile-lfu",-1),T=t("strong",null,"次数",-1),V=t("li",null,[t("code",null,"volatile-ttl"),e(" ：挑选将要过期的数据淘汰")],-1),D=t("li",null,[t("code",null,"volatile-random"),e("：任意选择数据淘汰，一般用的少")],-1),I=r('<figure><img src="'+b+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>检测全库数据（所有数据集server.db[i].dict）</strong></p><ul><li><code>allkeys-lru</code>：挑选最近最少使用的数据淘汰</li><li><code>allkeys-lfu</code>：挑选最近使用次数最少的数据淘汰</li><li><code>allkeys-random</code>：任意选择数据淘汰</li></ul><p><strong>放弃数据驱逐</strong></p><ul><li><code>no-enviction</code>（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）</li></ul><p>以上的逐出算法都可在<strong>配置文件中配置</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">maxmemory-</span><span style="color:#C678DD;">policy</span><span style="color:#ABB2BF;"> volatile-lru</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们可以使用INFO命令输出监控信息，查询缓存int和miss的次数，根据业务需求调优Redis配置</p><figure><img src="`+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',9);function R(A,E){const s=n("font");return l(),d("div",null,[y,t("p",null,[e("redis中用一个**"),o(s,{color:"green"},{default:i(()=>[e("hash结构")]),_:1}),e("数据存放地址和过期时间**，而"),C]),t("p",null,[e("我们需要在"),o(s,{color:"red"},{default:i(()=>[e("内存占用")]),_:1}),e("与"),o(s,{color:"red"},{default:i(()=>[e("CPU占用")]),_:1}),e("之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄漏。CPU忙时暂且不维护内存，闲时再来进行内存释放")]),v,t("p",null,[e("数据到达过期时间，先不做处理。"),o(s,{color:"red"},{default:i(()=>[e("等下次访问该数据时")]),_:1}),e("，"),U,e("。只要是调用操作数据的指令，都会先执行"),P]),z,t("h3",k,[B,e(" 3. 定期删除（"),o(s,{color:"green"},{default:i(()=>[e("中和以上两种方案")]),_:1}),e("）")]),N,t("p",null,[e("注意："),o(s,{color:"red"},{default:i(()=>[e("逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行")]),_:1}),e("。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现如下错误信息：")]),O,t("ul",null,[t("li",null,[M,e("：挑选最近最少使用（"),o(s,{color:"red"},{default:i(()=>[e("最长"),q,e("不使用的")]),_:1}),e("）的数据淘汰，"),o(s,{color:"red"},{default:i(()=>[e("使用较多")]),_:1})]),t("li",null,[w,e("：挑选最近"),o(s,{color:"red"},{default:i(()=>[e("使用"),T,e("最少")]),_:1}),e("的数据淘汰")]),V,D]),I])}const X=a(x,[["render",R],["__file","删除策略.html.vue"]]);export{X as default};
