import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as c,o as t,c as r,f as l,w as p,e as n,d as s,a as o}from"./app-m9pC5KT-.js";const B="/assets/20200316162336130-E4Q75WvX.png",i="/assets/20200316163136186-1rqaGutc.png",d="/assets/20200316163905518-YY-aBH_g.png",y="/assets/watermark_type_ZmFuZ3poZW5naGVpdGk_shadow_10_text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQxNjkz_size_16_color_FFFFFF_t_70-YBRrMbWN.png",u={},F=s("h1",{id:"容器适配器-栈、队列、优先级队列",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#容器适配器-栈、队列、优先级队列","aria-hidden":"true"},"#"),n(" 容器适配器：栈、队列、优先级队列")],-1),A=s("h2",{id:"一、容器适配器",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#一、容器适配器","aria-hidden":"true"},"#"),n(" 一、容器适配器")],-1),v=s("p",null,[s("strong",null,"什么是容器适配器？")],-1),D=o(`<strong>适配器底层没有自己的数据结构，它是另外一个容器的封装，它的方法全部由底层依赖的容器进行实现的；它没有实现自己的迭代器，不能使用迭代器遍历。</strong><p><strong>来看这个例子：我们使用容器适配器来实现一个栈。</strong></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">template</span><span style="color:#ABB2BF;">&lt;</span><span style="color:#C678DD;">typename</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">T</span><span style="color:#ABB2BF;">, </span><span style="color:#C678DD;">typename</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Container</span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;">deque&lt;</span><span style="color:#E5C07B;">T</span><span style="color:#ABB2BF;">&gt;&gt;</span></span>
<span class="line"><span style="color:#C678DD;">class</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Stack</span></span>
<span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#C678DD;">public:</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span><span style="color:#C678DD;">void</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">push</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">const</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">T</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">&amp;</span><span style="color:#E06C75;font-style:italic;">val</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">	{</span></span>
<span class="line"><span style="color:#ABB2BF;">		</span><span style="color:#E5C07B;">con</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">push_back</span><span style="color:#ABB2BF;">(val);</span></span>
<span class="line"><span style="color:#ABB2BF;">	}</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span><span style="color:#C678DD;">void</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">pop</span><span style="color:#ABB2BF;">()</span></span>
<span class="line"><span style="color:#ABB2BF;">	{</span></span>
<span class="line"><span style="color:#ABB2BF;">		</span><span style="color:#E5C07B;">con</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">pop_back</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">	}</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span><span style="color:#E5C07B;">T</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">top</span><span style="color:#ABB2BF;">()</span><span style="color:#C678DD;">const</span></span>
<span class="line"><span style="color:#ABB2BF;">	{</span></span>
<span class="line"><span style="color:#ABB2BF;">		</span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">con</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">back</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">	}</span></span>
<span class="line"><span style="color:#C678DD;">private:</span></span>
<span class="line"><span style="color:#ABB2BF;">	Container con;</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现成功，相当于栈将deque代理了一下，也成为代理模式。push将底层容器的push_back代理了，pop将底层pop_back代理了，栈的top将容器底层的back代理了。</p><h2 id="二、栈" tabindex="-1"><a class="header-anchor" href="#二、栈" aria-hidden="true">#</a> 二、栈</h2><p>我们使用库中的栈，需要加上头文件<code>&lt;stack&gt;</code></p><p><strong>stack常用方法：</strong> 1.<code>push()</code>;//入栈 2.<code>pop()</code>;//出栈 3.<code>top()</code>;//查看栈顶元素 4.<code>empty()</code>;//判断栈空 5.<code>size()</code>;//返回元素个数</p><p><strong>简单使用一下：</strong></p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">stack</span><span style="color:#C678DD;">&lt;int&gt;</span><span style="color:#ABB2BF;"> s1;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">for</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> i</span><span style="color:#C678DD;">=</span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">; i</span><span style="color:#C678DD;">&lt;</span><span style="color:#D19A66;">20</span><span style="color:#ABB2BF;">; </span><span style="color:#C678DD;">++</span><span style="color:#ABB2BF;">i)</span></span>
<span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span><span style="color:#E5C07B;">s1</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">push</span><span style="color:#ABB2BF;">(</span><span style="color:#61AFEF;">rand</span><span style="color:#ABB2BF;">() </span><span style="color:#56B6C2;">%</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">100</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">cout </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;栈中元素个数:&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#E5C07B;">s1</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">size</span><span style="color:#ABB2BF;">() </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#ABB2BF;"> endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">while</span><span style="color:#ABB2BF;"> (</span><span style="color:#56B6C2;">!</span><span style="color:#E5C07B;">s1</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">empty</span><span style="color:#ABB2BF;">())</span></span>
<span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">	cout </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">s1</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">top</span><span style="color:#ABB2BF;">() </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot; &quot;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span><span style="color:#E5C07B;">s1</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">pop</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+B+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="三、队列" tabindex="-1"><a class="header-anchor" href="#三、队列" aria-hidden="true">#</a> 三、队列</h2><p>我们使用库中的队列，需要加上头文件<code>&lt;queue&gt;</code></p><p><strong>stack常用方法：</strong> 1.push();//入队 2.pop();//出队 3.front();//查看队头元素 4.back();//产看队尾元素 5.empty();//判空 6.size();//返回队列元素个数</p><p><strong>简单使用一下：</strong></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">queue</span><span style="color:#56B6C2;">&lt;</span><span style="color:#C678DD;">int</span><span style="color:#56B6C2;">&gt;</span><span style="color:#ABB2BF;"> que;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">for</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> i</span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">; i</span><span style="color:#56B6C2;">&lt;</span><span style="color:#D19A66;">20</span><span style="color:#ABB2BF;">; ++i)</span></span>
<span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span><span style="color:#D19A66;">que</span><span style="color:#ABB2BF;">.</span><span style="color:#D19A66;">push</span><span style="color:#ABB2BF;">(</span><span style="color:#56B6C2;">rand</span><span style="color:#ABB2BF;">() % </span><span style="color:#D19A66;">100</span><span style="color:#ABB2BF;"> + </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">cout </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;队列中元素个数:&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#D19A66;">que</span><span style="color:#ABB2BF;">.</span><span style="color:#D19A66;">size</span><span style="color:#ABB2BF;">() </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#ABB2BF;"> endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">while</span><span style="color:#ABB2BF;"> (!</span><span style="color:#D19A66;">que</span><span style="color:#ABB2BF;">.</span><span style="color:#D19A66;">empty</span><span style="color:#ABB2BF;">())</span></span>
<span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">	cout </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">que</span><span style="color:#ABB2BF;">.</span><span style="color:#D19A66;">front</span><span style="color:#ABB2BF;">() </span><span style="color:#56B6C2;">&lt;&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot; &quot;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span><span style="color:#D19A66;">que</span><span style="color:#ABB2BF;">.</span><span style="color:#D19A66;">pop</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="四、优先级队列" tabindex="-1"><a class="header-anchor" href="#四、优先级队列" aria-hidden="true">#</a> 四、优先级队列</h2>',17),m=s("strong",null,"大根堆",-1),b=s("code",null,"<queue>",-1),C=s("strong",null,"优先级队列，谁优先级大谁先出队，谁优先级小，谁后出队。",-1),_=o(`<p>stack常用方法： 1.<code>push()</code>;//入优先级队列 2.<code>pop()</code>;//出优先级队列 3.<code>top()</code>;//查看队顶元素 4.<code>empty()</code>;//判断队空 5.<code>size()</code>;//返回元素个数</p><p>简单使用一下：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">priority_queue</span><span style="color:#C678DD;">&lt;int&gt;</span><span style="color:#ABB2BF;"> pque;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">for</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> i</span><span style="color:#C678DD;">=</span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">; i</span><span style="color:#C678DD;">&lt;</span><span style="color:#D19A66;">20</span><span style="color:#ABB2BF;">; </span><span style="color:#C678DD;">++</span><span style="color:#ABB2BF;">i)</span></span>
<span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span><span style="color:#E5C07B;">pque</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">push</span><span style="color:#ABB2BF;">(</span><span style="color:#61AFEF;">rand</span><span style="color:#ABB2BF;">() </span><span style="color:#56B6C2;">%</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">100</span><span style="color:#ABB2BF;"> </span><span style="color:#56B6C2;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">cout </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot;优先级队列中元素个数:&quot;</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#E5C07B;">pque</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">size</span><span style="color:#ABB2BF;">() </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#ABB2BF;"> endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">while</span><span style="color:#ABB2BF;"> (</span><span style="color:#56B6C2;">!</span><span style="color:#E5C07B;">pque</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">empty</span><span style="color:#ABB2BF;">())</span></span>
<span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">	cout </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">pque</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">top</span><span style="color:#ABB2BF;">() </span><span style="color:#C678DD;">&lt;&lt;</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">&quot; &quot;</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">	</span><span style="color:#E5C07B;">pque</span><span style="color:#ABB2BF;">.</span><span style="color:#61AFEF;">pop</span><span style="color:#ABB2BF;">();</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行成功：数据从大到小依次出队，数据越大优先级越高。</p><figure><img src="`+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="问题一-stack与queue第二个模板类型参数依赖deque-为什么不依赖vector-而优先级队列为什么底层依赖vector" tabindex="-1"><a class="header-anchor" href="#问题一-stack与queue第二个模板类型参数依赖deque-为什么不依赖vector-而优先级队列为什么底层依赖vector" aria-hidden="true">#</a> 问题一：stack与queue第二个模板类型参数依赖deque，为什么不依赖vector？而优先级队列为什么底层依赖vector？</h2>',6),h=s("h2",{id:"问题二-优先级队列为什么底层依赖vector",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#问题二-优先级队列为什么底层依赖vector","aria-hidden":"true"},"#"),n(" 问题二：优先级队列为什么底层依赖vector？")],-1),g=s("figure",null,[s("img",{src:y,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1);function q(f,E){const a=c("font");return t(),r("div",null,[F,A,v,l(a,{color:"red"},{default:p(()=>[n("**容器适配器**")]),_:1}),n("："),D,s("p",null,[n("优先级队列：底层数据结构为"),l(a,{color:"red"},{default:p(()=>[m]),_:1}),n("。 我们使用库中的优先级队列，需要加上头文件"),b,n("；"),C]),_,s("ol",null,[s("li",null,[s("p",null,[s("strong",null,[n("vector的"),l(a,{color:"red"},{default:p(()=>[n("初始内存使用效率太低")]),_:1}),n("，没有deque好。")]),n("(需要从0开始2倍扩容)")])]),s("li",null,[s("p",null,[s("strong",null,[n("对于queue来说，需要支持"),l(a,{color:"red"},{default:p(()=>[n("尾部插入，头部删除")]),_:1}),n("，时间复杂度需要为O(1)，deque恰好符合条件，若用vector其底层效率太低。")])])]),s("li",null,[s("p",null,[s("strong",null,[n("vector需要大片的连续内存，而deque只需要分段的内存，当存储大量数据时，显然deuqe对于"),l(a,{color:"red"},{default:p(()=>[n("内存的利用率更高")]),_:1}),n("更好一些。")])])])]),h,s("p",null,[s("strong",null,[n("优先级队列底层默认把数据组成一个大根堆结构，将大根堆结构看作一棵树，如果将大根堆结构所有元素放入数组中，使用下标计算其结点。若根节点为i，左孩子为2i+1，右孩子为2i+2；大根堆为堆顶，其元素最大，"),l(a,{color:"red"},{default:p(()=>[n("结点与左右孩子关系使用下标计算，就需要每一个元素内存必须是连续的")]),_:1}),n("，因此底层依赖vector；而deque的第二维不是连续的，不能使用。")])]),g])}const z=e(u,[["render",q],["__file","容器适配器：栈、队列、优先级队列.html.vue"]]);export{z as default};
