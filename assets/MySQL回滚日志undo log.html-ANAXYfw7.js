import{_ as s}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as d,o as r,c as u,d as o,e as l,f as e,w as t,a as _}from"./app-mYdPlPhZ.js";const a={},i=_('<h1 id="mysql回滚日志undo-log" tabindex="-1"><a class="header-anchor" href="#mysql回滚日志undo-log" aria-hidden="true">#</a> MySQL回滚日志undo log</h1><h2 id="一、引入-undo-log" tabindex="-1"><a class="header-anchor" href="#一、引入-undo-log" aria-hidden="true">#</a> 一、引入 undo log</h2><p>![](MySQL回滚日志undo log.assets/image-20240420132938427.png)</p><p>一般数据库引擎默认工作在事务的中间两个隔离级别：</p><ol><li>TRANSACTION_READ_COMMITTED，已提交读，oracle默认工作级别。不允许读取未commit的数据，这个级别仍然允许不可重复读和幻读产生。</li><li>TRANSACTION_REPEATABLE_READ，可重复读，MySQL默认工作级别。保证事务再次读取是依然得到相同的数据，部分解决了幻读，但幻读是仍然会出现的</li></ol><p>![img](MySQL回滚日志undo log.assets/image-20240419150312478-pI4JWCa2.png)</p><p>注：</p><ul><li>事务隔离级别越高，为避免冲突所花费的性能也就越多</li><li>在可重复读级别，实际上可以解决部分的幻读问题，但是不能防止update更新产生的虚读问题，要禁止虚读产生，还是需要设置串行化隔离级别</li></ul>',8),g=o("strong",null,"已提交读和可重复读",-1),h=o("strong",null,"MVCC",-1),c=o("strong",null,"并发的读取方式，即快照读 ，同一份数据会有多个版本",-1),p=o("p",null,"InnoDB提供了2种读取操作：锁定读和非锁定读",-1),F=o("li",null,[o("strong",null,"锁定读"),l("就是读取的时候"),o("strong",null,"加锁****（S或X）")],-1),m=o("strong",null,"非锁定读",-1),Q=o("strong",null,"MVCC提供的快照读",-1),L=o("strong",null,"undo log回滚日志",-1),D=o("p",null,[o("u",null,"ACD特性用事务日志实现，I 特性用锁+MVCC 实现"),l("。事务日志分为undo log（回滚日志） 和 redo log（重做日志）")],-1),I=o("h2",{id:"二、undo-log",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#二、undo-log","aria-hidden":"true"},"#"),l(" 二、undo log")],-1),b=o("h3",{id:"_1-undo-log的概念",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_1-undo-log的概念","aria-hidden":"true"},"#"),l(" 1.undo log的概念")],-1),M=o("p",null,[o("u",null,[l("undo log和redo log统称事务日志，不同于binlog是MySQL Server层的日志，这两个属于"),o("strong",null,"存储引擎层的日志")])],-1),T=o("strong",null,"记录",-1),B=o("strong",null,"持久性",-1),C=o("strong",null,"保存",-1),f=o("strong",null,"发生之前",-1),x=o("strong",null,"版本",-1),y=o("u",null,"事务的回滚操作",-1),S=o("u",null,"快照读",-1),V=o("h3",{id:"_2-undo-log的作用",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_2-undo-log的作用","aria-hidden":"true"},"#"),l(" 2.undo log的作用")],-1),R=o("p",null,"undo log回滚日志的主要作用：",-1),k=o("li",null,"提供了MVCC的非锁定读（快照读），依赖undo log实现",-1),X=o("h3",{id:"_3-undo-log的数据结构",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#_3-undo-log的数据结构","aria-hidden":"true"},"#"),l(" 3.undo log的数据结构")],-1),A=o("p",null,"![](MySQL回滚日志undo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16.png)",-1),N=o("p",null,[l("在MVCC下，针对表的所有记录，除了我们自行设定的字段"),o("strong",null,"book_id、book_name、auther"),l("，还会添加几个字段")],-1),w=o("li",null,[o("strong",null,"DB_ROW_ID"),l("：和MVCC的关系不大，这个是我们创建表的时候，如果没有加PRIMARY KEY，那么InnoDB就"),o("strong",null,"自动生成主键列id（DB_ROW_ID）"),l("，"),o("u",null,"通过这个id作为主键创建索引树，在B+树的叶子节点上存放数据。由于InnoDB的数据和索引是存放在一起的，如果我们没有设置主键，InnoDB会自动生成主键")],-1),E=o("strong",null,"DB_TRX_ID",-1),W=o("strong",null,"事务ID",-1),O=o("strong",null,"同一个事务无论怎么更改数据，这个事务ID都不会改变",-1),z=o("li",null,[o("strong",null,"DB_ROLL_PTR"),l("："),o("strong",null,"回滚指针"),l("，我们看到，存放的是地址，这个地址表示的是一个数据的内存的位置，看起来是一个链表，上图中的这个橙色表是最后的成品，那么这个表是怎么变来的呢？")],-1),Z=_('<p>最初的时候表是这样的：</p><p>![](MySQL回滚日志undo log.assets/89f6ddfd541041c6a8b684c31db1262a.png)</p><p>现在<u>有一个ID为1001的事务</u>来更改这条数据，这个事务把book_name改成了“笑傲江湖（吕颂贤）”</p><p>此时数据涉及到修改了，修改的数据存放在当前这个表中，那<u>修改之前的数据怎么办？防止事务回滚恢复修改前的状态，需要将最初的数据存放在undo log中！</u></p><p>现在undo log的数据结构如下：</p><p>![](MySQL回滚日志undo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-17135959581577.png)</p><p>现在<u>有一个ID为1002的事务</u>来更改这条数据，这个事务把book_name改成了“笑傲江湖（李亚鹏）”</p><p>现在undo log的数据结构如下：</p><p>![](MySQL回滚日志undo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171359600478510.png)</p><p><mark>MVCC会给我们创建的表增加2个列，一个是事务ID，一个是指向修改前的数据的指针，修改之前的数据都是放在undo log回滚日志当中。对于每个版本的数据，是哪个事务改的DB_TRX_ID就写哪个事务ID，DB_ROLL_PTR指针把当前数据和旧数据串成1个链表。从当前行的DB_ROLL_PTR可以访问到旧数据，进行回滚就很简单了</mark></p><h2 id="三、undo-log举例" tabindex="-1"><a class="header-anchor" href="#三、undo-log举例" aria-hidden="true">#</a> 三、undo log举例</h2><p>原始的user表如下：</p><p>![](MySQL回滚日志undo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_7,color_FFFFFF,t_70,g_se,x_16.png)</p><p>MVCC机制会对这张表增加2列，修改当前数据的事务ID（DB_TRX_ID）和指向undo log的指针（DB_ROLL_PTR）</p><p>我们<u>把id=7的age改为16</u>，如下图所示：</p><p>![](MySQL回滚日志undo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171359616071615.png)</p><ul><li>原来(id=7,age=15)这个版本的数据放到了undo log中</li></ul><p>这时我们再<u>增加了1行新数据</u>，由于新增的数据没有对应的老版本，所以undo log中对应为NULL，如下图所示：</p><p>![在这里插入图片描述](MySQL回滚日志undo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171359623530518.png)</p><ul><li><mark>回滚的时候发现是NULL，就知道是insert增加的数据，直接执行insert的反操作delete就可以了</mark></li></ul><p>同样的，如果我们这时要<u>修改</u>刚刚insert的数据，将id=23的age改成23</p><p>![](MySQL回滚日志undo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171359635630221.png)</p><p><mark>在已提交读和可重复读隔离级别下，当我们去读数据的时候，可不是像串行化一样通过SX锁或间隙锁实现，而是纯粹通过MVCC的快照读实现的</mark></p>',23);function v(P,q){const n=d("font");return r(),u("div",null,[i,o("p",null,[o("u",null,[l("InnoDB的"),g,l("的"),e(n,{color:"red"},{default:t(()=>[l("底层实现原理")]),_:1}),l("："),h,l("（多版本并发控制），MVCC提供了一种"),c])]),p,o("ul",null,[F,o("li",null,[m,l("就是读取的时候没有加锁，指的就是"),Q,l("—>"),o("u",null,[l("快照读依赖的是"),e(n,{color:"red"},{default:t(()=>[l("底层")]),_:1}),l("的"),L])])]),D,I,b,M,o("p",null,[l("redo log：重做日志，"),T,l("事务**"),e(n,{color:"red"},{default:t(()=>[l("操作")]),_:1}),l("的变化**，确保事务的"),B,l("。"),e(n,{color:"green"},{default:t(()=>[l("redo log在事务开始时就开始记录，不管事务是否commit都会记录。出现异常时（如数据持久化过程断电），重启后InnoDB会使用redo log恢复到断电前的状态，保证数据的完整性")]),_:1}),l(" undo log：回滚日志，"),C,l("了事务"),f,l("的"),e(n,{color:"red"},{default:t(()=>[l("数据的一个"),x]),_:1}),l("，用于"),y,l("，同时也是实现多版本并发控制（MVCC）下读操作（"),S,l("）的关键技术")]),V,R,o("ul",null,[o("li",null,[l("事务发生错误时回滚rollback，"),e(n,{color:"green"},{default:t(()=>[l("数据更新之前，会把原始数据保存在回滚日志中")]),_:1}),l("，保证事务出错回滚或者我们手动"),e(n,{color:"green"},{default:t(()=>[l("回滚的时候，能够在回滚日志中找到最初的数据")]),_:1})]),k]),X,A,N,o("ul",null,[w,o("li",null,[E,l("："),W,l("，我们每打开一个客户端session，输入begin，向服务器请求开启一个事务。"),e(n,{color:"green"},{default:t(()=>[l("事务开启请求发到MySQL server上，MySQL server为每个事务都会分配一个全局的，不冲突的事务ID（InnoDB存储引擎分配的，因为只有innodb才支持事务）")]),_:1}),l("。当某个事务修改数据时，DB_TRX_ID放的就是该事务的ID，"),O]),z]),Z])}const J=s(a,[["render",v],["__file","MySQL回滚日志undo log.html.vue"]]);export{J as default};
