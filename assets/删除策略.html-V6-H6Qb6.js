import{_ as i}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as e,c as a,a as t}from"./app-m9pC5KT-.js";const r="/assets/0273434c752c47728775a7f3b645967c-YXTi2qme.png",s="/assets/b3ab140e6de546c1bbaf3db3dcb04612-IQgOwUvo.png",l="/assets/c8820a59629c456da20cff77f750f5de-ux2SVCwS.png",n="/assets/d901aaee471544b8bceb012670f9bc97-j6-W2GMM.png",d="/assets/2eb5f42526f54c30b38baf3eeab0ca9d-mO1gb4CA.png",o="/assets/8ad90db824614517b96a5573c0be19d2-MC717iq1.png",p="/assets/c1baccfe1bcf460bb8aed85cbc3379f4-3az48wue.png",c="/assets/6123dfb15e5b4a7ca5e72069d720e7eb-ZE1NmbqD.png",g="/assets/8ee2f5be75274a4b9f453e12970254ed-o71Tjo0D.png",f={},h=t('<h1 id="删除策略" tabindex="-1"><a class="header-anchor" href="#删除策略" aria-hidden="true">#</a> 删除策略</h1><h2 id="一、过期数据" tabindex="-1"><a class="header-anchor" href="#一、过期数据" aria-hidden="true">#</a> 一、过期数据</h2><p><strong>Redis中的数据特征：</strong> Redis是一种内存级数据库，所有数据均存放在内存中，内存中的数据可以通过TTL指令获取其状态</p><ul><li>XX : 具有时效性的数据</li><li>-1 : 永久有效的数据</li><li>-2 : 已经过期的数据 或 被删除的数据 或 未定义的数据</li></ul><p><strong>过期的数据真的被删了吗？</strong></p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>redis服务器有很多操作需要执行时，CPU的压力会很大，于是redis中的策略是，在内存还够的前提下，先不急着释放已删除的数据的内存空间，先执行客户端的指令</p><h2 id="二、数据删除策略" tabindex="-1"><a class="header-anchor" href="#二、数据删除策略" aria-hidden="true">#</a> 二、数据删除策略</h2><p>redis中的数据删除策略包括定时删除、惰性删除、定期删除</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>redis中用一个hash结构数据存放地址和过期时间，而删除策略就是基于这块hash数据结构</p><p>我们需要在内存占用与CPU占用之间寻找一种平衡，顾此失彼都会造成整体redis性能的下降，甚至引发服务器宕机或内存泄漏。CPU忙时暂且不维护内存，闲时再来进行内存释放</p><h3 id="_1-定时删除-时间换空间" tabindex="-1"><a class="header-anchor" href="#_1-定时删除-时间换空间" aria-hidden="true">#</a> 1. 定时删除（时间换空间）</h3><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>创建一个定时器，当key设置有过期时间，且过期时间到达时，<strong>立即执行key的删除操作</strong></p><ul><li>优点：节约内存，到时就删除，立即释放不必要的内存占用</li><li>缺点：CPU压力较大，无论CPU此时负载量多高，均占用CPU，会影响redis服务器响应时间和指令吞吐量</li><li>总结：用处理器性能换取存储空间（时间换空间），适用于小内存，强CPU场景</li></ul><h3 id="_2-惰性删除-空间换时间" tabindex="-1"><a class="header-anchor" href="#_2-惰性删除-空间换时间" aria-hidden="true">#</a> 2. 惰性删除 （空间换时间）</h3><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>数据到达过期时间，先不做处理。等下次访问该数据时，发现数据已过期，删除，给客户端返回不存在。只要是调用操作数据的指令，都会先执行<code>expireIfNeeded()</code></p><ul><li>优点：节约CPU性能，发现不得不删除的时候才删除</li><li>缺点：内存空间压力很大，出现长期占用内存的数据</li><li>总结：用存储空间换取处理器性能 （空间换时间），适用于大内存，弱CPU场景</li></ul><h3 id="_3-定期删除-中和以上两种方案" tabindex="-1"><a class="header-anchor" href="#_3-定期删除-中和以上两种方案" aria-hidden="true">#</a> 3. 定期删除（中和以上两种方案）</h3><p>每个库都有独自维护的过期库expires</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>定期删除算法过程如下：</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>每秒钟执行server.hz次serverCron，serverCron会轮询所有的库，使用databasesCron方法对每个库进行检测，databasesCron会调用activeExpireCycle会对每个expire[]检测，一个expire[]检测250ms/server.hz</p><p>周期性轮询redis库中的时效性数据，采用随机抽取的策略，利用过期数据占比的方式控制删除频度</p><ul><li>特点1：CPU性能占用设置有峰值，检测频度可自定义设置</li><li>特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理</li></ul><p>总结：周期性抽查存储空间（查询某个库的expires时，如果这轮删除过多，则再抽取删除一轮，如果这轮删除的很少，则去检查下一个库的expires）</p><h3 id="_4-三种删除方案对比" tabindex="-1"><a class="header-anchor" href="#_4-三种删除方案对比" aria-hidden="true">#</a> 4. 三种删除方案对比</h3><table><thead><tr><th></th><th>内存占用</th><th>CPU占用</th><th>特征</th></tr></thead><tbody><tr><td><strong>定时删除</strong></td><td>节约内存，无占用</td><td>不分时段占用CPU资源，频度高</td><td>时间换空间</td></tr><tr><td><strong>惰性删除</strong></td><td>内存占用严重</td><td>延时执行，CPU利用率高</td><td>空间换时间</td></tr><tr><td><strong>定期删除</strong></td><td>内存定期随机清理</td><td>每秒花费固定的CPU资源维护内存</td><td>随机抽查，重点抽查</td></tr></tbody></table><p>在redis里，会使用惰性删除和定期删除两种方式</p><h2 id="三、逐出算法" tabindex="-1"><a class="header-anchor" href="#三、逐出算法" aria-hidden="true">#</a> 三、逐出算法</h2><p><strong>当内存被永久数据占满（删除策略只能清除过期数据），新数据进入redis时，如果内存不足怎么办？</strong></p><p>Redis使用内存存储数据，在执行每一个命令前，会调用freeMemoryIfNeeded()检测内存是否充足。如果内存不满足新加入数据的最低存储要求，redis要临时删除一些数据为当前指令清理存储空间。清理数据的策略称为逐出算法</p><p>注意：逐出数据的过程不是100%能够清理出足够的可使用的内存空间，如果不成功则反复执行。当对所有数据尝试完毕后，如果不能达到内存清理的要求，将出现如下错误信息：</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>影响数据逐出的相关配置</strong></p><ul><li><p><strong>maxmemory</strong>：redis可使用内存占物理内存的最大比例，默认为0，表示不限制redis使用内存。生产环境中根据需求设定，通常设置在50%以上</p></li><li><p><strong>maxmemory-samples</strong>：每次选取待删除数据的个数，选取数据时并不会全库扫描，导致严重的性能消耗，降低读写性能。因此采用随机获取数据的方式作为待检测删除数据</p></li><li><p><strong>maxmemory-policy</strong>：达到最大内存后的，对被挑选出来的数据进行删除的算法</p></li></ul><p>删除算法有如下几种：</p><p><strong>检查可能会过期的数据集server.db[i].expires内的数据</strong></p><ul><li>volatile-lru：挑选最近最少使用（最长时间不使用的）的数据淘汰，使用较多</li><li>volatile-lfu：挑选最近使用次数最少的数据淘汰</li><li>volatile-ttl ：挑选将要过期的数据淘汰</li><li>volatile-random：任意选择数据淘汰，一般用的少</li></ul><figure><img src="'+c+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>检测全库数据（所有数据集server.db[i].dict）</strong></p><ul><li>allkeys-lru：挑选最近最少使用的数据淘汰</li><li>allkeys-lfu：挑选最近使用次数最少的数据淘汰</li><li>allkeys-random：任意选择数据淘汰</li></ul><p><strong>放弃数据驱逐</strong></p><ul><li>no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out Of Memory）</li></ul><p>以上的逐出算法都可在配置文件中配置</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">maxmemory-</span><span style="color:#C678DD;">policy</span><span style="color:#ABB2BF;"> volatile-lru</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们可以使用INFO命令输出监控信息，查询缓存int和miss的次数，根据业务需求调优Redis配置</p><figure><img src="`+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',51),u=[h];function b(m,_){return e(),a("div",null,u)}const C=i(f,[["render",b],["__file","删除策略.html.vue"]]);export{C as default};
