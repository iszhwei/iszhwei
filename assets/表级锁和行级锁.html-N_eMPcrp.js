import{_ as s}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as _,o as r,c as a,d as t,e as o,f as e,w as l,a as d}from"./app-2pke9_a8.js";const i="/assets/image-20240419183553280-m04mbtzT.png",c="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAQnVnTWFrZXItc2hlbg___size_11_color_FFFFFF_t_70_g_se_x_16-ZsQ7Zp9O.png",u={},h=d('<h1 id="表级锁和行级锁" tabindex="-1"><a class="header-anchor" href="#表级锁和行级锁" aria-hidden="true">#</a> 表级锁和行级锁</h1><p><strong>事务隔离级别的实现原理</strong>：简单来说就是<u>各种锁机制和MVCC</u>多版本并发控制</p><p>我们学习知识的时候，需要了解知识点出现的原因，什么情况下能用到这个知识</p><p>我们说到事务，就得说到事务的ACID特性，<u>为什么需要隔离性呢？因为事务要能够允许并发执行，并发执行为了同时保证数据的<strong>安全性，一致性</strong>和<strong>并发的效率</strong>，就需要设置事务的隔离级别</u></p><h2 id="一、事务隔离机制的选择" tabindex="-1"><a class="header-anchor" href="#一、事务隔离机制的选择" aria-hidden="true">#</a> 一、事务隔离机制的选择</h2><figure><img src="'+i+'" alt="image-20240419183553280" tabindex="0" loading="lazy"><figcaption>image-20240419183553280</figcaption></figure>',6),g=t("strong",null,"未提交读",-1),f=t("u",null,"会出现脏读（读取了未commit的数据）、不可重复读（两次查询值不同）、幻读（两次查询数据量不同）等问题",-1),p=t("strong",null,"串行化",-1),m=t("strong",null,"已提交读、可重复读",-1),x=t("h2",{id:"二、表级锁-行级锁",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#二、表级锁-行级锁","aria-hidden":"true"},"#"),o(" 二、表级锁&行级锁")],-1),B=t("p",null,"表级锁：对整张表加锁。开销小（因为不用去找表的某一行的记录进行加锁，要修改这张表，直接申请加这张表的锁），加锁快，不会出现死锁；锁粒度大，发生锁冲突的概率高，并发度低",-1),C=t("figure",null,[t("img",{src:c,alt:"",tabindex:"0",loading:"lazy"}),t("figcaption")],-1),b=t("p",null,"InnoDB存储引擎支持事务处理，表支持行级锁定，并发能力更好",-1),F=t("s",null,"而不是给表的行记录加锁实现的",-1),I=t("strong",null,"索引条件检索",-1),V=t("strong",null,"行级锁",-1),D=t("li",null,[o("由于InnoDB的行锁实现是针对"),t("strong",null,"索引字段"),o("添加的锁，不是针对行记录加的锁，因此虽然访问的是InnoDB引擎下表的不同行，但如果使用"),t("u",null,"相同的索引字段作为过滤条件，依然会发生锁冲突，只能串行进行，不能并发进行")],-1),Q=t("li",null,[o("即使SQL中使用了索引，但是经过"),t("strong",null,"MySQL5.7"),o("的优化器后，"),t("strong",null,"如果认为全表扫描比使用索引效率高，此时会放弃使用索引，因此也不会使用行锁"),o("，而是使用表锁，比如对一些很小的表，MySQL就不会去使用索引")],-1);function y(M,N){const n=_("font");return r(),a("div",null,[h,t("p",null,[o("如果我们"),e(n,{color:"red"},{default:l(()=>[o("完全不管")]),_:1}),o("，使用"),g,o("的事务隔离机制，任由这些线程并发操作数据库，那就"),f,o("，数据的安全性最低，优点是并发效率非常高，"),e(n,{color:"red"},{default:l(()=>[o("一般不会使用")]),_:1})]),t("p",null,[o("如果我们"),p,o("（"),e(n,{color:"red"},{default:l(()=>[o("靠锁实现")]),_:1}),o("），"),e(n,{color:"red"},{default:l(()=>[o("通过锁给所有的事务都排个序")]),_:1}),o("，虽然数据的安全性提高了，并发的效率就太低了，"),e(n,{color:"red"},{default:l(()=>[o("一般也不会使用")]),_:1})]),t("p",null,[o("所以我们一般用的是"),m,o("这两个隔离级别，平衡了数据的安全性，一致性以及并发的效率 ，是由"),e(n,{color:"red"},{default:l(()=>[o("MVCC多版本")]),_:1}),o("并发控制实现的（MVCC是已提交读和可重复读的原理，锁是串行化的原理）")]),x,B,t("p",null,[o("行级锁：对某行记录加锁。开销大（需要找到表中相应的记录，有"),e(n,{color:"red"},{default:l(()=>[o("搜表搜索引")]),_:1}),o("的过程），加锁慢，会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度高")]),C,b,t("ol",null,[t("li",null,[t("strong",null,[o("InnoDB行锁是通过给索引上的"),e(n,{color:"red"},{default:l(()=>[o("索引项加锁")]),_:1}),o("来实现的，"),F]),o("，这就意味着"),e(n,{color:"red"},{default:l(()=>[o("只有通过"),I,o("数据，InnoDB才使用"),V,o("，否则InnoDB将使用表锁")]),_:1})]),D,Q])])}const L=s(u,[["render",y],["__file","表级锁和行级锁.html.vue"]]);export{L as default};
