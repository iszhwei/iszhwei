import{_ as p}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as c,o as t,c as i,d as n,e as s,f as a,w as o,a as e}from"./app-rY1SOIco.js";const r="/assets/Center-vfJlIF-R.jpeg",B="/assets/Center-17143762806113-13YKQ9dz.jpeg",d="/assets/format_png-thF2kiz8.png",y="data:image/png;base64,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",u="/assets/format_png-171437670443611-bPrUj5Kz.png",m="/assets/20160115103314694-U3VOTHaP.jpeg",A="/assets/20160115105727465-5nhPvkbN.jpeg",b={},F=n("h1",{id:"malloc、free的底层实现",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#malloc、free的底层实现","aria-hidden":"true"},"#"),s(" malloc、free的底层实现")],-1),v=n("h2",{id:"前言",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#前言","aria-hidden":"true"},"#"),s(" 前言")],-1),g=n("p",null,[s("从"),n("strong",null,"操作系统角度"),s("来看，进程分配内存有2种方式，分别由2个系统调用完成："),n("code",null,"brk"),s("和"),n("code",null,"mmap"),s("（不考虑共享内存）。")],-1),D=n("code",null,"brk",-1),_=n("strong",null,[s("数据段(.data)"),n("strong",null,"的"),s("最高地址指针_edata")],-1),C=n("li",null,[n("code",null,"mmap"),s("是在进程的虚拟地址空间中（堆和栈中间，称为"),n("strong",null,"文件映射区域"),s("的地方）"),n("strong",null,"找一块空闲的虚拟内存"),s("。")],-1),h=n("strong",null,"分配的都是虚拟内存，没有分配物理内存",-1),f=n("strong",null,"第一次访问",-1),E=n("u",null,"已分配的虚拟地址空间",-1),x=n("h2",{id:"malloc概述",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#malloc概述","aria-hidden":"true"},"#"),s(" malloc概述")],-1),z=n("p",null,[s("在C语言中只能通过malloc()和其派生的函数进行动态的申请内存，而实现的根本是通过系统调用实现的（在"),n("strong",null,[s("linux下是通过"),n("code",null,"sbrk()"),s("系统调用实现")]),s("）。")],-1),k=n("u",null,"函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表",-1),Q=n("strong",null,"操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序",-1),U=n("u",null,[s("malloc()在分配用户传入的大小的时候，还分配的一个相关的"),n("strong",null,"用于管理的额外内存"),s("，不过，用户是看不到的")],-1),K=e(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#abb2bf;">实际的大小 = 管理空间 + 用户空间</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="小于128k的内存分配" tabindex="-1"><a class="header-anchor" href="#小于128k的内存分配" aria-hidden="true">#</a> 小于128K的内存分配</h3>`,2),Z=n("figure",null,[n("img",{src:r,alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),w=n("li",null,[n("p",null,[s("进程启动的时候，其（虚拟）内存空间的"),n("strong",null,"初始布局"),s("如图1所示")]),n("p",null,[s("其中，"),n("u",null,"mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so"),s("，其它数据文件等），为了简单起见，省略了内存映射文件。")]),n("p",null,"_edata指针（glibc里面定义）指向数据段的最高地址。")],-1),I=n("p",null,[s("进程**调用"),n("code",null,"A=malloc(30K)"),s("**以后，内存空间如图2")],-1),P=n("strong",null,"虚拟内存分配",-1),W=n("p",null,[n("strong",null,"你可能会问：只要把_edata+30K就完成内存分配了？")],-1),V=n("h3",{id:"大于128k的内存分配",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#大于128k的内存分配","aria-hidden":"true"},"#"),s(" 大于128K的内存分配")],-1),T=n("code",null,"mmap",-1),S=n("figure",null,[n("img",{src:B,alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),O=n("li",null,[n("p",null,[s("进程**调用"),n("code",null,"C=malloc(200K)"),s("**以后，内存空间如图4：")])],-1),j=n("code",null,"M_MMAP_THRESHOLD",-1),M=e(`<h2 id="分配虚拟内存的细节" tabindex="-1"><a class="header-anchor" href="#分配虚拟内存的细节" aria-hidden="true">#</a> 分配虚拟内存的细节</h2><p>malloc()在运行期动态分配分配内存，free()释放由其分配的内存。malloc()在分配用户传入的大小的时候，还分配的一个相关的用于管理的额外内存，不过，用户是看不到的。所以</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#abb2bf;">实际的大小 = 管理空间 + 用户空间</span></span>
<span class="line"><span style="color:#abb2bf;"></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><u>在64位系统中，malloc(0)的有效内存大小为24，32位中为12，准确的说是至少是这么多</u>，并且这些内存是可以用的</p><figure><img src="`+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',6),N=n("figure",null,[n("img",{src:u,alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),X=n("u",null,[s("linux系统下面一个程序的"),n("strong",null,"堆的管理"),s("是通过"),n("strong",null,"内存块"),s("进行管理的，也就是将堆分成了很多大小不一的内存块。"),n("strong",null,"这些块怎么管理呢，比如怎么查询块的大小，怎么查询块是否正在被程序使用，怎么知道这个块的地址"),s("。")],-1),L=n("figure",null,[n("img",{src:m,alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),J=n("figure",null,[n("img",{src:A,alt:"",tabindex:"0",loading:"lazy"}),n("figcaption")],-1),H=n("strong",null,"free()函数的实现思路，只要将内存管理块设置为可用就可以了",-1),Y=e(`<p>最后，贴上malloc()和free()实现的代码：</p><h3 id="malloc-实现" tabindex="-1"><a class="header-anchor" href="#malloc-实现" aria-hidden="true">#</a> malloc()实现：</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">/**内存控制块数据结构，用于管理所有的内存块</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">* is_available: 标志着该块是否可用。1表示可用，0表示不可用</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">* size: 该块的大小</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">**/</span></span>
<span class="line"><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> mem_control_block {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> is_available;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">int</span><span style="color:#ABB2BF;"> size;</span></span>
<span class="line"><span style="color:#ABB2BF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">/**在实现malloc时要用到linux下的全局变量</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">*managed_memory_start：该指针指向进程的堆底，也就是堆中的第一个内存块</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">*last_valid_address：该指针指向进程的堆顶，也就是堆中最后一个内存块的末地址</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">**/</span></span>
<span class="line"><span style="color:#C678DD;">void</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">managed_memory_start;</span></span>
<span class="line"><span style="color:#C678DD;">void</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">last_valid_address;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">/**malloc()功能是动态的分配一块满足参数要求的内存块</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">*numbytes：该参数表明要申请多大的内存空间</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">*返回值：函数执行结束后将返回满足参数要求的内存块首地址，要是没有分配成功则返回NULL</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">**/</span></span>
<span class="line"><span style="color:#C678DD;">void</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#61AFEF;">malloc</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">size_t</span><span style="color:#E06C75;"> </span><span style="color:#E06C75;font-style:italic;">numbytes</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">//游标，指向当前的内存块</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">void</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">current_location;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">//保存当前内存块的内存控制结构</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> mem_control_block </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">current_location_mcb;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">//保存满足条件的内存块的地址用于函数返回</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">void</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">memory_location;</span></span>
<span class="line"><span style="color:#ABB2BF;">    memory_location </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">NULL</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">//计算内存块的实际大小，也就是函数参数指定的大小+内存控制块的大小</span></span>
<span class="line"><span style="color:#ABB2BF;">    numbytes </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> numbytes </span><span style="color:#C678DD;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">sizeof</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> mem_control_block);</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">//利用全局变量得到堆中的第一个内存块的地址</span></span>
<span class="line"><span style="color:#ABB2BF;">    current_location </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> managed_memory_start;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">//对堆中的内存块进行遍历，找合适的内存块</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">while</span><span style="color:#ABB2BF;"> (current_location </span><span style="color:#C678DD;">!=</span><span style="color:#ABB2BF;"> last_valid_address)</span><span style="color:#7F848E;font-style:italic;"> //检查是否遍历到堆顶了</span></span>
<span class="line"><span style="color:#ABB2BF;">    {</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#7F848E;font-style:italic;">//取得当前内存块的内存控制结构</span></span>
<span class="line"><span style="color:#ABB2BF;">        current_location_mcb </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> mem_control_block</span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">)current_location;</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#7F848E;font-style:italic;">//判断该块是否可用</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#E5C07B;">current_location_mcb</span><span style="color:#ABB2BF;">-&gt;</span><span style="color:#E06C75;">is_available</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">            </span><span style="color:#7F848E;font-style:italic;">//检查该块大小是否满足</span></span>
<span class="line"><span style="color:#ABB2BF;">            </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#E5C07B;">current_location_mcb</span><span style="color:#ABB2BF;">-&gt;</span><span style="color:#E06C75;">size</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">&gt;=</span><span style="color:#ABB2BF;"> numbytes)</span></span>
<span class="line"><span style="color:#ABB2BF;">            {</span></span>
<span class="line"><span style="color:#ABB2BF;">                </span><span style="color:#7F848E;font-style:italic;">//满足的块将其标志为不可用</span></span>
<span class="line"><span style="color:#ABB2BF;">                </span><span style="color:#E5C07B;">current_location_mcb</span><span style="color:#ABB2BF;">-&gt;</span><span style="color:#E06C75;">is_available</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">                </span><span style="color:#7F848E;font-style:italic;">//得到该块的地址，结束遍历</span></span>
<span class="line"><span style="color:#ABB2BF;">                memory_location </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> current_location;</span></span>
<span class="line"><span style="color:#ABB2BF;">                </span><span style="color:#C678DD;">break</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">            }</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#7F848E;font-style:italic;">//取得下一个内存块</span></span>
<span class="line"><span style="color:#ABB2BF;">        current_location </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> current_location </span><span style="color:#C678DD;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">current_location_mcb</span><span style="color:#ABB2BF;">-&gt;</span><span style="color:#E06C75;">size</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">//在堆中已有的内存块中没有找到满足条件的内存块时执行下面的函数</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#56B6C2;">!</span><span style="color:#ABB2BF;">memory_location)</span></span>
<span class="line"><span style="color:#ABB2BF;">    {</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#7F848E;font-style:italic;">//向操作系统申请新的内存块</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (</span><span style="color:#61AFEF;">sbrk</span><span style="color:#ABB2BF;">(numbytes) </span><span style="color:#C678DD;">==</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">-</span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">            </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">NULL</span><span style="color:#ABB2BF;">;</span><span style="color:#7F848E;font-style:italic;">//申请失败，说明系统没有可用内存</span></span>
<span class="line"><span style="color:#ABB2BF;">        memory_location </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> last_valid_address;</span></span>
<span class="line"><span style="color:#ABB2BF;">        last_valid_address </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> last_valid_address </span><span style="color:#C678DD;">+</span><span style="color:#ABB2BF;"> numbytes;</span></span>
<span class="line"><span style="color:#ABB2BF;">        current_location_mcb </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> (</span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> mem_control_block)memory_location;</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">current_location_mcb</span><span style="color:#ABB2BF;">-&gt;</span><span style="color:#E06C75;">is_available</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">0</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">        </span><span style="color:#E5C07B;">current_location_mcb</span><span style="color:#ABB2BF;">-&gt;</span><span style="color:#E06C75;">size</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> numbytes;</span></span>
<span class="line"><span style="color:#ABB2BF;">    }</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">//到此已经得到所要的内存块，现在要做的是越过内存控制块返回内存块的首地址</span></span>
<span class="line"><span style="color:#ABB2BF;">    memory_location </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> memory_location </span><span style="color:#C678DD;">+</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">sizeof</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> mem_control_block);</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;"> memory_location;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="free实现" tabindex="-1"><a class="header-anchor" href="#free实现" aria-hidden="true">#</a> free实现：</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#7F848E;font-style:italic;">/**free()功能是将参数指向的内存块进行释放</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">*firstbyte：要释放的内存块首地址</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">*返回值：空</span></span>
<span class="line"><span style="color:#7F848E;font-style:italic;">**/</span></span>
<span class="line"><span style="color:#C678DD;">void</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">free</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">void</span><span style="color:#E06C75;"> </span><span style="color:#C678DD;">*</span><span style="color:#E06C75;font-style:italic;">firstbyte</span><span style="color:#ABB2BF;">)</span></span>
<span class="line"><span style="color:#ABB2BF;">{</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> mem_control_block </span><span style="color:#C678DD;">*</span><span style="color:#ABB2BF;">mcb;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">//取得该块的内存控制块的首地址</span></span>
<span class="line"><span style="color:#ABB2BF;">    mcb </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> firstbyte </span><span style="color:#C678DD;">-</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">sizeof</span><span style="color:#ABB2BF;">(</span><span style="color:#C678DD;">struct</span><span style="color:#ABB2BF;"> mem_control_block);</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#7F848E;font-style:italic;">//将该块标志设为可用</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#E5C07B;">mcb</span><span style="color:#ABB2BF;">-&gt;</span><span style="color:#E06C75;">is_available</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#C678DD;">return</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="缺页中断" tabindex="-1"><a class="header-anchor" href="#缺页中断" aria-hidden="true">#</a> 缺页中断</h3><h4 id="查看缺页中断的次数" tabindex="-1"><a class="header-anchor" href="#查看缺页中断的次数" aria-hidden="true">#</a> 查看缺页中断的次数</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">ps</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-o</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">majflt,minflt</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-C</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">program</span><span style="color:#ABB2BF;"> </span><span style="color:#7F848E;font-style:italic;">#查看缺页中断的次数</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><code>majflt</code>代表majorfault，中文名叫大错误</li><li><code>minflt</code>代表minor fault，中文名叫小错误。</li></ul><p>这2个数值表示一个进程自启动以来所发生的缺页中断的次数。</p><h4 id="发生缺页中断后-执行了哪些操作" tabindex="-1"><a class="header-anchor" href="#发生缺页中断后-执行了哪些操作" aria-hidden="true">#</a> 发生缺页中断后，执行了哪些操作？</h4>`,11),q=e("<ol><li><p><strong>检查要访问的虚拟地址是否合法</strong></p></li><li><p><strong>查找/分配一个物理页</strong></p></li><li><p><strong>填充物理页内容（读取磁盘，或者直接置0，或者啥也不干）</strong></p></li><li><p><strong>建立映射关系（虚拟地址到物理地址）</strong></p></li><li><p><strong>重新执行发生缺页中断的那条指令</strong></p></li></ol><p>如果<u>第3步，需要读取磁盘，那么这次缺页中断就是majflt，否则就是minflt。</u></p>",2);function G(R,$){const l=c("font");return t(),i("div",null,[F,v,g,n("ul",null,[n("li",null,[D,s("是将"),_,a(l,{color:"red"},{default:o(()=>[s("往高地址推")]),_:1})]),C]),n("p",null,[s("这两种方式"),h,s("。在"),a(l,{color:"red"},{default:o(()=>[f,E,s("的时候，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。")]),_:1})]),x,z,n("p",null,[s("malloc()到底从哪里得到了内存空间？答案是从堆里面获得空间。也就是说"),k,s("。当"),a(l,{color:"green"},{default:o(()=>[Q]),_:1}),s("。")]),n("p",null,[s("malloc()在"),a(l,{color:"red"},{default:o(()=>[s("运行期")]),_:1}),s("动态分配分配内存，free()释放由其分配的内存。"),U,s("。所以，")]),K,a(l,{color:"red"},{default:o(()=>[s("malloc小于128k的内存，**使用`brk`分配内存**，将_edata往高地址推(只分配虚拟空间，不对应物理内存(因此没有初始化)，第一次读/写数据时，引起内核缺页中断，内核才分配对应的物理内存，然后虚拟地址空间建立映射关系)")]),_:1}),s("，如下图(32位系统)："),Z,n("ol",null,[w,n("li",null,[I,n("p",null,[s("malloc函数会"),a(l,{color:"red"},{default:o(()=>[s("调用brk系统调用，将_edata指针往高地址推30K")]),_:1}),s("，就完成"),P,s("。")])])]),W,n("p",null,[s("事实是这样的，_edata+30K只是完成虚拟地址的分配，"),a(l,{color:"red"},{default:o(()=>[s("A这块内存现在还是没有物理页与之对应的")]),_:1}),s("，等到进程"),a(l,{color:"red"},{default:o(()=>[s("第一次读写A这块内存的时候，发生缺页中断，这个时候，内核才分配A这块内存对应的物理页")]),_:1}),s("。也就是说，"),a(l,{color:"red"},{default:o(()=>[s("如果用malloc分配了A这块内容，然后从来不访问它，那么，A对应的物理页是不会被分配的")]),_:1}),s("。")]),V,n("p",null,[s("malloc大于128k的内存，"),a(l,{color:"red"},{default:o(()=>[s("使用"),T,s("分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)")]),_:1}),s("，如下图：")]),S,n("ol",null,[O,n("li",null,[n("p",null,[s("默认情况下，malloc函数分配内存，如果请求内存大于128K（"),a(l,{color:"green"},{default:o(()=>[s("可由"),j,s("选项调节")]),_:1}),s("），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。这样子做主要是因为："),a(l,{color:"red"},{default:o(()=>[s("brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。")]),_:1})])])]),M,n("p",null,[s("此外，"),n("strong",null,[a(l,{color:"red"},{default:o(()=>[s("堆中的内存块总是成块分配的")]),_:1}),s("，并不是申请多少字节，就拿出多少个字节的内存来提供使用。"),a(l,{color:"red"},{default:o(()=>[s("堆中内存块的大小通常与内存对齐有关")]),_:1}),s("（8Byte(for 32bit system)或16Byte(for 64bit system)")]),s("。")]),n("p",null,[s("因此，"),a(l,{color:"red"},{default:o(()=>[s("在64位系统下，当(申请内存大小+sizeof(struct mem_control_block) )% 16 == 0的时候，刚好可以完成一次满额的分配，但是当其!=0的时候，就会多分配内存块")]),_:1}),s("。")]),N,n("p",null,[s("在"),X,s("为了解决内存块的管理所以要设计一个管理内存块的"),a(l,{color:"green"},{default:o(()=>[s("数据结构")]),_:1}),s("，详细的数据结构如下：")]),L,n("p",null,[s("综合上面的知识，可以很容易想到malloc()实现的大体思路。"),n("strong",null,[a(l,{color:"green"},{default:o(()=>[s("首先挨个检查堆中的内存是否可用，如果可用那么大小是否能满足需求，要是都满足的话就直接用。当遍历了堆中的所有内存块时，要是没有能满足需求的块时就只能通过系统调用向操作系统申请新的内存，然后将新的内存添加到堆中")]),_:1})]),s("。思路很简单，malloc()实现流程图如下所示：")]),J,n("p",null,[s("看完上面的思路，也会很容易的想到"),a(l,{color:"green"},{default:o(()=>[H]),_:1}),s("。这样下次调用malloc()函数的时候就可以将该内存块作为可分配块再次进行分配了。")]),Y,n("p",null,[s("当一个"),a(l,{color:"red"},{default:o(()=>[s("进程发生缺页中断的时候，进程会陷入内核态")]),_:1}),s("，执行以下操作：")]),q])}const ls=p(b,[["render",G],["__file","malloc、free的底层实现.html.vue"]]);export{ls as default};
