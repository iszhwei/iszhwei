const e=JSON.parse('{"key":"v-ef005662","path":"/ccpp/10%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html","title":"单例模式","lang":"zh-CN","frontmatter":{"title":"单例模式","icon":"file","order":2,"headerDepth":4,"category":["c/c++"],"tag":["设计模式"],"description":"单例模式 什么是单例模式 单例模式是指在整个系统生命周期内，保证一个类只能产生一个实例，确保该类的唯一性。 为什么需要单例模式 节省资源。一个类只有一个实例，不存在多份实例，节省资源。 方便控制。在一些操作公共资源的场景时，避免了多个对象引起的复杂操作。 线程安全 什么是线程安全？ 在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。","head":[["meta",{"property":"og:url","content":"https://iszhwei.gitee.io/ccpp/10%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"张威的编程学习笔记"}],["meta",{"property":"og:title","content":"单例模式"}],["meta",{"property":"og:description","content":"单例模式 什么是单例模式 单例模式是指在整个系统生命周期内，保证一个类只能产生一个实例，确保该类的唯一性。 为什么需要单例模式 节省资源。一个类只有一个实例，不存在多份实例，节省资源。 方便控制。在一些操作公共资源的场景时，避免了多个对象引起的复杂操作。 线程安全 什么是线程安全？ 在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"张威"}],["meta",{"property":"article:tag","content":"设计模式"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"单例模式\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"张威\\",\\"url\\":\\"https://iszhwei.gitee.io\\"}]}"]]},"headers":[{"level":2,"title":"什么是单例模式","slug":"什么是单例模式","link":"#什么是单例模式","children":[]},{"level":2,"title":"为什么需要单例模式","slug":"为什么需要单例模式","link":"#为什么需要单例模式","children":[]},{"level":2,"title":"线程安全","slug":"线程安全","link":"#线程安全","children":[{"level":3,"title":"什么是线程安全？","slug":"什么是线程安全","link":"#什么是线程安全","children":[]},{"level":3,"title":"如何保证线程安全？","slug":"如何保证线程安全","link":"#如何保证线程安全","children":[]}]},{"level":2,"title":"单例类的特点","slug":"单例类的特点","link":"#单例类的特点","children":[]},{"level":2,"title":"单例模式分类","slug":"单例模式分类","link":"#单例模式分类","children":[{"level":3,"title":"懒汉式","slug":"懒汉式","link":"#懒汉式","children":[]},{"level":3,"title":"饿汉式","slug":"饿汉式","link":"#饿汉式","children":[]}]},{"level":2,"title":"单例模式实现","slug":"单例模式实现","link":"#单例模式实现","children":[{"level":3,"title":"普通懒汉式单例（线程不安全）","slug":"普通懒汉式单例-线程不安全","link":"#普通懒汉式单例-线程不安全","children":[]},{"level":3,"title":"加锁的懒汉式单例（线程安全）","slug":"加锁的懒汉式单例-线程安全","link":"#加锁的懒汉式单例-线程安全","children":[]},{"level":3,"title":"静态局部变量的懒汉单例（C++11线程安全）","slug":"静态局部变量的懒汉单例-c-11线程安全","link":"#静态局部变量的懒汉单例-c-11线程安全","children":[]},{"level":3,"title":"饿汉式单例（线程安全）","slug":"饿汉式单例-线程安全","link":"#饿汉式单例-线程安全","children":[]},{"level":3,"title":"使用 C++11 std::call_once 实现单例（C++11线程安全）","slug":"使用-c-11-std-call-once-实现单例-c-11线程安全","link":"#使用-c-11-std-call-once-实现单例-c-11线程安全","children":[]}]},{"level":2,"title":"单例模式的自动释放","slug":"单例模式的自动释放","link":"#单例模式的自动释放","children":[{"level":3,"title":"可以使用友元形式进行设计","slug":"可以使用友元形式进行设计","link":"#可以使用友元形式进行设计","children":[]},{"level":3,"title":"内部类加静态数据成员形式","slug":"内部类加静态数据成员形式","link":"#内部类加静态数据成员形式","children":[]},{"level":3,"title":"atexit方式进行","slug":"atexit方式进行","link":"#atexit方式进行","children":[]},{"level":3,"title":"pthread_once形式","slug":"pthread-once形式","link":"#pthread-once形式","children":[]}]}],"git":{},"readingTime":{"minutes":7.23,"words":2169},"filePathRelative":"ccpp/10 设计模式/单例模式.md","excerpt":"<h1> 单例模式</h1>\\n<h2> 什么是单例模式</h2>\\n<p>单例模式是指在整个系统生命周期内，保<u>证一个类只能产生一个实例</u>，确保该<strong>类的唯一性</strong>。</p>\\n<h2> 为什么需要单例模式</h2>\\n<ol>\\n<li>节省资源。一个类<u>只有一个实例，不存在多份实例</u>，节省资源。</li>\\n<li>方便控制。在一些操作<strong>公共资源</strong>的场景时，避免了多个对象引起的复杂操作。</li>\\n</ol>\\n<h2> 线程安全</h2>\\n<h3> 什么是线程安全？</h3>\\n<p>在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会<u>通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况</u>。</p>","autoDesc":true}');export{e as data};
