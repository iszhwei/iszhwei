import{_ as o}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as i,o as c,c as d,d as s,e,f as a,w as l,a as t}from"./app-2pke9_a8.js";const r="/assets/f2c41f6947024c559acf45d19034adde-TqdAu4S4.png",g="/assets/987741f6f8c14f8a89903a5c1854df56-hBF_EWVj.png",p="/assets/3ac497b91652448f88b40f74b931f64b-KNJm45rf.png",u="/assets/ef961dd59c744b969d9cda3eee67fec0-XF8AUsQW.png",_="/assets/2ddc05b2ad284e609c4a38e38805e0d3-8EpsftRH.png",f="/assets/9058cd8ff4c244349e12ca23e980206d-MH3oD_zQ.png",h="/assets/d329b368bd5a4e01959e77cf16dcbb4f-0PWbkA2w.png",b="/assets/ca5d8ac00a4f4b7295f465eb17e887b2-KS4JMfMX.png",m="/assets/1d7de720cf264583a7690f5a73cf7096-nQel4Ib7.png",x="/assets/1bebaf81aad84a888a282b8da445ac98-120VxSXI.png",y="/assets/4fcf9cc1b9934315ba842ab0bb9b12bf-K0gfNFlA.png",k="/assets/78c1a57577af48cd91748d6bc31aab1e-lpCkYg2H.png",v="/assets/f4aa9f1b56634a3db848c65f714e08c1-hx2wxXR0.png",B="/assets/07356dc5a0d14a6796485cfefae54f26-K8AnGgLq.png",z="/assets/c6bb48dea48a4195998e6da63c223444-SNHp53JH.png",A="/assets/56e0f5ffbc0e46449faeeeef6d1d3254-SAGwh-3K.png",F="/assets/d83f89f264b34dc8bbe91a8664890494-FTLJ7aYY.png",q="/assets/f07c2011db18495f860ccdbf4569cfae-SVCv7hXN.png",D="/assets/cd1c7bc03baa45719cbcf390f2a56dbf--OXfMjAw.png",w="/assets/4da66a79b5a74726a9d69261b043e116-LNkT9tUz.png",C="/assets/97be4cf13e794f5ba701110c200c75b0-yOW-9zWZ.png",N={},S=s("h1",{id:"事务和事务锁",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#事务和事务锁","aria-hidden":"true"},"#"),e(" 事务和事务锁")],-1),V=s("h2",{id:"一、事务简介",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#一、事务简介","aria-hidden":"true"},"#"),e(" 一、事务简介")],-1),M=s("p",null,"由于客户端2中断了客户端1两条连续的指令执行，导致客户端1获取到itcast",-1),X=s("figure",null,[s("img",{src:r,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),H=s("strong",null,"redis事务",-1),K=s("u",null,"将一系列预定义命令包装成一个整体（一个队列）。当执行时，一次性按照添加顺序依次执行，中间不会被打断或者干扰。",-1),L=s("h2",{id:"二、事务基本指令",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#二、事务基本指令","aria-hidden":"true"},"#"),e(" 二、事务基本指令")],-1),Q=s("ul",null,[s("li",null,[s("code",null,"multi"),e("：设定事务的"),s("strong",null,"开启位置"),e("，此指令执行后，后续的所有指令均加入到事务中")]),s("li",null,[s("code",null,"exec"),e("：设定事务的"),s("strong",null,"结束位置"),e("，同时执行事务，与multi成对使用")])],-1),W=s("figure",null,[s("img",{src:g,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),E=s("code",null,"discard",-1),J=s("strong",null,"可以使用discard使multi失效，放弃当前任务队列，中止事务",-1),T=t('<figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="三、事务的工作流程" tabindex="-1"><a class="header-anchor" href="#三、事务的工作流程" aria-hidden="true">#</a> 三、事务的工作流程</h2><p><strong>set执行流程：</strong> 正常执行，返回执行结果</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>multi执行流程：</strong> 创建事务队列后返回ok</p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>创建事务后，set执行流程：</strong> 将set指令放入事务队列</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>创建事务后，del执行流程：</strong> 将del指令放入事务队列</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',10),R=s("strong",null,"创建事务后，exec执行流程：",-1),Y=s("figure",null,[s("img",{src:b,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),j=s("strong",null,"创建事务后，discard执行流程：",-1),G=s("figure",null,[s("img",{src:m,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),I=s("h2",{id:"四、事务中指令出错处理",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#四、事务中指令出错处理","aria-hidden":"true"},"#"),e(" 四、事务中指令出错处理")],-1),O=s("figure",null,[s("img",{src:x,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),U={start:"2"},P=s("u",null,"比如对string类型进行lpush",-1),Z=s("figure",null,[s("img",{src:y,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),$=s("h2",{id:"五、事务锁",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#五、事务锁","aria-hidden":"true"},"#"),e(" 五、事务锁")],-1),ss=s("h3",{id:"_1-业务场景一-多个客户端想操作同一数据-保证数据不被重复操作",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_1-业务场景一-多个客户端想操作同一数据-保证数据不被重复操作","aria-hidden":"true"},"#"),e(" 1. 业务场景一：多个客户端想操作同一数据，保证数据不被重复操作")],-1),es=s("blockquote",null,[s("p",null,"视频中这个监视锁的作用好像有点局限，仅限于多个客户端想对同一数据进行相同的操作，保证数据不被重复操作。如果是想要对数据进行不同的操作呢？这个监视锁的功能好像也能用MySQL中的排它锁和共享锁实现")],-1),ns=s("p",null,[e("天猫双11热卖过程中，对已经售罄的货物追加补货，"),s("u",null,"4个业务员"),e("都有权限进行补货。补货的"),s("u",null,"操作可能是一系列的操作，牵扯到多个连续操作"),e("，如何保障不会重复操作？")],-1),as=s("strong",null,"监视锁并开启事务",-1),ls=t(`<ul><li><strong>对key添加监视锁，在事务执行exec前如果key发生了变化，终止事务执行</strong></li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">watch key1 </span><span style="color:#E06C75;">[key2…]</span><span style="color:#ABB2BF;">          # 必须在开启事务multi前执行</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><strong>取消对所有key的监视</strong></li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">unwatch                     # 取消所有数据的监视锁 </span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>客户端<strong>A监视name和age，开启事务</strong>，准备执行一系列操作</p><figure><img src="`+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端<strong>B修改</strong>客户端A监视的age</p><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端<strong>A执行exec，执行失败，此时事务也不存在了</strong></p><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',10),ts=s("figure",null,[s("img",{src:z,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),os=s("h3",{id:"_2-业务场景二-setnx操作一个变量-然后再操作对应数据",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#_2-业务场景二-setnx操作一个变量-然后再操作对应数据","aria-hidden":"true"},"#"),e(" 2. 业务场景二：setnx操作一个变量，然后再操作对应数据")],-1),is=s("strong",null,"分析",-1),cs=s("strong",null,"watch监视锁",-1),ds=s("strong",null,"修改了商品数量），他就不能购买（exec",-1),rs=s("strong",null,"购买成功的数量",-1),gs=s("strong",null,"商品减少的数量相等",-1),ps=s("strong",null,"分布式锁解决",-1),us=s("strong",null,"redis并不提供这种特殊的锁，只是我们利用setnx的特性解决此业务场景，这并不像MySQL的排它锁，上了锁就不能操作指定数据，此处redis所谓的锁只是我们约好的先操作某个变量再操作对应数据，实际上setnx的结果并不影响直接操作对应数据",-1),_s=t(`<div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">setnx lock-</span><span style="color:#C678DD;">key</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">value</span><span style="color:#ABB2BF;">   # 这个value不重要，其实这就是利用了setnx，lock-key也只是一个普通名字，这就是设置了一个普通的string变量</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,1),fs=s("li",null,"对于返回设置失败的，不具有控制权，则等待",-1),hs=t(`<p>操作完毕通过del释放锁</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">del lock-</span><span style="color:#C678DD;">key</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>客户端<strong>A获取对num的锁</strong></p><figure><img src="`+A+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端B获取对lock-num，失败了，如果<strong>失败，我们不允许该客户端操作数据</strong></p><figure><img src="'+F+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端<strong>A购买完商品释放锁</strong></p><figure><img src="'+q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端B setnx lock-num成功，我们在逻辑上允许该客户端操作num</p><figure><img src="'+D+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-业务场景三-给上述setnx的变量设置有效时间" tabindex="-1"><a class="header-anchor" href="#_3-业务场景三-给上述setnx的变量设置有效时间" aria-hidden="true">#</a> 3. 业务场景三：给上述setnx的变量设置有效时间</h3>',11),bs=t(`<div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">expire lock-</span><span style="color:#C678DD;">key</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">second</span></span>
<span class="line"><span style="color:#ABB2BF;">pexpire lock-kay millisenconds</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端A setnx一把锁，并设置有效时间</p><figure><img src="`+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>到达有效时间后，lock-name失效，其他客户端自动拿到锁</p><figure><img src="'+C+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',5),ms=s("ul",null,[s("li",null,"持有锁的操作最长执行时间127ms，最短执行时间7ms"),s("li",null,"测试百万次最长执行时间对应命令的最大消耗时，测试百万次网络延迟平均耗时"),s("li",null,[e("锁时间设定推荐："),s("code",null,"最大耗时* 120%+平均网络延迟*110%")]),s("li",null,[e("如果业务最大耗时<<网络平均延迟，通常为"),s("strong",null,"2个数量级"),e("，取其中单个耗时较长即可")])],-1);function xs(ys,ks){const n=i("font");return c(),d("div",null,[S,V,s("p",null,[e("Redis执行指令过程中，多条连续执行的指令被干扰，打断，插队，这"),a(n,{color:"red"},{default:l(()=>[e("多条连续指令执行的结果可能就会有问题")]),_:1}),e("font>")]),M,X,s("p",null,[H,e("就是一个命令执行的**"),a(n,{color:"green"},{default:l(()=>[e("队列")]),_:1}),e("**，"),K]),s("p",null,[e("一个队列中，"),a(n,{color:"green"},{default:l(()=>[e("一次性、顺序性、排他性")]),_:1}),e("的执行一系列命令")]),L,Q,s("p",null,[s("strong",null,[e("注意：加入事务的命令暂时进入到任务队列中，"),a(n,{color:"red"},{default:l(()=>[e("并没有立即执行，只有执行exec命令才开始执行")]),_:1})])]),W,s("ul",null,[s("li",null,[E,e("："),a(n,{color:"red"},{default:l(()=>[e("终止当前事务")]),_:1}),e("，发生在multi之后，exec之前；当我们把"),a(n,{color:"red"},{default:l(()=>[e("错误指令放入队列")]),_:1}),e("后，"),J])]),T,s("p",null,[R,e(),a(n,{color:"red"},{default:l(()=>[e("顺序执行事务队列中的指令")]),_:1}),e("，并"),a(n,{color:"red"},{default:l(()=>[e("销毁队列")]),_:1})]),Y,s("p",null,[j,e(" 放弃执行队列中的指令，"),a(n,{color:"red"},{default:l(()=>[e("直接销毁队列")]),_:1}),e("，返回执行结果")]),G,I,s("ol",null,[s("li",null,[e("开启事务后，如果放入队列的指令"),a(n,{color:"red"},{default:l(()=>[e("存在语法错误，将会执行discard，当前事务队列会被销毁")]),_:1})])]),O,s("ol",U,[s("li",null,[e("开启事务后，"),a(n,{color:"red"},{default:l(()=>[e("如果放入队列的指令并没有语法错误，但无法执行")]),_:1}),e("，"),P,e("。"),s("strong",null,[e("这种情况下，会顺序执行所有的指令，无法执行则"),a(n,{color:"green"},{default:l(()=>[e("会给出相应的提示信息，并跳过无法执行的指令，不会立即中断当前事务")]),_:1}),e("的执行")])])]),Z,s("p",null,[e("注意："),s("mark",null,[a(n,{color:"red"},{default:l(()=>[e("已执行命令对应的数据不会自动回滚，需要程序员自己在代码中实现回滚")]),_:1})])]),$,ss,es,ns,s("p",null,[e("我们"),s("u",null,[e("对需要操作的数据添加"),as,e("，如果exec前"),a(n,{color:"red"},{default:l(()=>[e("监视的数据被修改")]),_:1}),e("了，那说明我放入事务队列的指令想要操作的数据被修改了，那这些指令操作的结果就不满足我的预期了。此时仍然输入exec，"),a(n,{color:"red"},{default:l(()=>[e("程序将不会执行exec指令，且放弃当前事务")]),_:1})])]),ls,a(n,{color:"red"},{default:l(()=>[e("逻辑上，我们应该先监视数据，然后开启事务准备操作，所以不允许先multi开启事务后watch")]),_:1}),ts,os,s("p",null,[e("很多客户同时抢购天猫超市的同一款商品，"),s("strong",null,[e("如何保证"),a(n,{color:"red"},{default:l(()=>[e("最后一件")]),_:1}),e("商品不被多人同时购买")]),e("？【超卖问题】")]),s("p",null,[is,e("： 如果我们使用"),a(n,{color:"red"},{default:l(()=>[cs,e("解决，此时一个客户端对商品进行监视，他购买时如果其他客户端购买了（"),ds,e("），这是不符合逻辑的，只要商品有库存，大家应该允许同时购买")]),_:1}),e("，"),a(n,{color:"green"},{default:l(()=>[e("只需要保证"),rs,e("和"),gs,e("就行。这种情况下，我们使用"),ps]),_:1}),e("（"),us,e("）")]),a(n,{color:"green"},{default:l(()=>[e("利用setnx拥有的返回值特征，有值则返回设置失败，无值则返回设置成功")]),_:1}),_s,s("ul",null,[s("li",null,[e("对于返回设置成功的，对数据拥有"),a(n,{color:"red"},{default:l(()=>[e("控制权")]),_:1}),e("，可以进行下一步操作，其他客户端得先操作这个使用setnx的lock-key，根据返回值判断是否可以进一步操作对应数据")]),fs]),hs,a(n,{color:"red"},{default:l(()=>[e("防止锁忘了释放")]),_:1}),e("，到达有效时间自动释放该锁变量"),bs,s("p",null,[s("strong",null,[e("由于操作"),a(n,{color:"red"},{default:l(()=>[e("通常都是微秒或者毫秒级")]),_:1}),e("，因此该锁设定时间不宜设置过大。具体时间需要业务测试后确认，例如：")])]),ms])}const zs=o(N,[["render",xs],["__file","事务和事务锁.html.vue"]]);export{zs as default};
