import{_ as l}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as i,o as r,c as d,d as s,e,f as a,w as t,a as o}from"./app-9OmaxHRC.js";const _="/assets/image-20240421111518559-QWwcI1eI.png",c="/assets/9bb8ddb3288a4f77b6382ddde9a21dbc-l-ceC-qg.png",p="/assets/dd9440ca479b4597a8ff46926887df1d-ifAUPk2P.png",u="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAQnVnTWFrZXItc2hlbg___size_20_color_FFFFFF_t_70_g_se_x_16-cZc2jM4J.png",h="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAQnVnTWFrZXItc2hlbg___size_20_color_FFFFFF_t_70_g_se_x_16-17136329288027-NZiovXP7.png",g="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAQnVnTWFrZXItc2hlbg___size_17_color_FFFFFF_t_70_g_se_x_16-QZmPQI1W.png",f="/assets/6dae79534d564e9bab6622899d1eb74b-QvTKcn5x.png",m="/assets/image-20240421093317470-cFJeP65Z.png",y="/assets/2a4f919c23804f8b80b289bf85b1626b-2CQEHqU1.png",b="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAQnVnTWFrZXItc2hlbg___size_16_color_FFFFFF_t_70_g_se_x_16-UUzuqdqY.png",Q="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAQnVnTWFrZXItc2hlbg___size_15_color_FFFFFF_t_70_g_se_x_16-MWl8DFVC.png",S={},F=o('<h1 id="sql和索引优化总结" tabindex="-1"><a class="header-anchor" href="#sql和索引优化总结" aria-hidden="true">#</a> SQL和索引优化总结</h1><p>首先我们需要知道MySQL主要是从以下3个方面进行优化：</p><ul><li>SQL语句和索引</li><li>应用优化（引入缓存、连接池）</li><li>配置参数优化</li></ul><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="一、sql语句和索引的优化" tabindex="-1"><a class="header-anchor" href="#一、sql语句和索引的优化" aria-hidden="true">#</a> 一、SQL语句和索引的优化</h2><p>当数据量比较大，若SQL语句写的不合适，会导致SQL的执行效率低，我们需要等待很长时间才能拿到结果</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',7),x=s("p",null,"explain分析的时候可能出现以下问题：",-1),L=s("h2",{id:"二、应用优化",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#二、应用优化","aria-hidden":"true"},"#"),e(" 二、应用优化")],-1),M=s("p",null,[e("除了优化SQL和索引，在实际生产环境中，"),s("u",null,"由于数据库服务器本身的性能局限，就必须要对上层的应用来进行一些优化，使得上层应用访问数据库的压力能够减到最小")],-1),v=s("strong",null,"引入数据库连接池",-1),B=s("strong",null,"引入缓存",-1),q=o(`<h2 id="三、mysql-server优化" tabindex="-1"><a class="header-anchor" href="#三、mysql-server优化" aria-hidden="true">#</a> 三、MySQL Server优化</h2><p>对于MySQL Server端的优化，主要指的是MySQL Server启动时加载的配置文件（my.ini或my.cnf）中配置项的优化</p><h3 id="自适应哈希索引" tabindex="-1"><a class="header-anchor" href="#自适应哈希索引" aria-hidden="true">#</a> 自适应哈希索引</h3><p>[InnoDB自适应哈希索引 | 张威的编程学习笔记 (gitee.io)](https://iszhwei.gitee.io/mysql/04 MYSQL索引/InnoDB自适应哈希索引.html)</p><p>由于hash索引的生成和维护也是耗费性能的，通过以下命令查看自适应哈希索引搜索的频率低于使用二级索引树搜索的频率：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">show engine innodb </span><span style="color:#C678DD;">status</span><span style="color:#ABB2BF;">\\G</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',7),z=s("code",null,"innodb_adaptive_hash_index",-1),w=s("h3",{id:"redo-log",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#redo-log","aria-hidden":"true"},"#"),e(" redo log")],-1),I=s("code",null,"Innodb_buffer_pool_size",-1),k=s("u",null,"来减少磁盘I/O次数，因为缓存区大了，在缓冲区工作的时间就长了，redo log的效率就高了",-1),A=s("p",null,"my.cnf配置参数如下：",-1),T=s("figure",null,[s("img",{src:u,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),X=s("h3",{id:"mysql查询缓存",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#mysql查询缓存","aria-hidden":"true"},"#"),e(" MySQL查询缓存")],-1),D=s("p",null,"MySQL的查询缓存是把上一次select的查询结果记录下来放在缓存当中，下一次再查询相同内容的时候，直接从缓存中取出来就可以了，不用再进行一遍真正的SQL查询（在内存中划分一块空间用做缓存的地方）",-1),N=s("strong",null,"查询缓存适用于更新不频繁的表，查询频繁的表",-1),V=o('<h4 id="mysql5-7-支持查询缓存" tabindex="-1"><a class="header-anchor" href="#mysql5-7-支持查询缓存" aria-hidden="true">#</a> MySQL5.7 支持查询缓存</h4><p>可以通过以下命令，来查看查询缓存的设置：</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果某个表的<u>查询多而更改少，可以考虑开启查询缓存</u></p><p>通过show status命令，可以查看MySQL查询缓存的使用状况，如下：</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以通过set命令设置上面的缓存参数开启MySQL查询缓存功能，也可以找到MySQL的配置文件（windows是my.ini，linux是my.cnf），修改query_cache_type参数为1就可以了，然后重启MySQL Server就可以使用了，如下：</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',8),Z=o('<strong>redis提供的API精确控制要缓存的数据，以及不缓存的数据</strong><h4 id="mysql8-0-不支持查询缓存" tabindex="-1"><a class="header-anchor" href="#mysql8-0-不支持查询缓存" aria-hidden="true">#</a> MySQL8.0 不支持查询缓存</h4><figure><img src="'+m+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="索引和数据缓存" tabindex="-1"><a class="header-anchor" href="#索引和数据缓存" aria-hidden="true">#</a> 索引和数据缓存</h3><p>主要指的就是innodb_buffer_pool_size配置项，从名字上就能看到，该配置项是针对InnoDB存储引擎起作用的，<u>这个参数定义了InnoDB存储引擎的表数据和索引数据的最大内存缓冲区大小。innodb_buffer_pool_size是同时为数据块和索引块做缓存，这个值设的越高，访问表中数据需要的磁盘I/O就越少</u></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">innodb_buffer_pool_size </span><span style="color:#56B6C2;">=</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">402653184</span><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">-- 384M</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="mysql线程缓存" tabindex="-1"><a class="header-anchor" href="#mysql线程缓存" aria-hidden="true">#</a> MySQL线程缓存</h3><p>主要指<strong>配置文件中thread_cache_size配置项</strong></p>`,8),E=s("u",null,"引入线程池，主要就是为了在业务执行的过程中，不会因为临时创建和销毁线程，造成系统性能降低，因为线程的创建和销毁是很耗费性能的",-1),W=s("figure",null,[s("img",{src:y,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),C=s("h3",{id:"并发连接数量和超时时间",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#并发连接数量和超时时间","aria-hidden":"true"},"#"),e(" 并发连接数量和超时时间")],-1),P=s("strong",null,"如果数据库连接统计数量比较大，这两个参数的值需要设置大一些",-1),U=s("figure",null,[s("img",{src:b,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),O=s("strong",null,"配置文件",-1),j=o('<figure><img src="'+Q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>&gt; <strong>wait_timeout</strong>：服务器在关闭非交互式连接之前等待活动的秒数（空闲连接存活时间）</p><p>&gt; <strong>connect_timeout</strong>：mysqld服务器在响应错误握手之前等待连接数据包的秒数（连接超时时间）</p><p>例子</p><p>&gt;如果<strong>wait_timeout</strong>为1800(30分钟),如果连接空闲,则DB连接将在30分钟内关闭(由进程列表的命令列中的Sleep指示). &gt;如果<strong>connect_timeout</strong>是10,那么如果您在10秒内无法登录(验证),mysqld将拒绝您.</p></blockquote>',2);function J(Y,G){const n=i("font");return r(),d("div",null,[F,s("p",null,[e("针对性优化的时候，"),a(n,{color:"red"},{default:t(()=>[e("若数据量太大，可通过limit分页")]),_:1})]),x,s("ul",null,[s("li",null,[a(n,{color:"red"},{default:t(()=>[e("没有用索引")]),_:1})]),s("li",null,[s("p",null,[e("用"),a(n,{color:"red"},{default:t(()=>[e("多列索引没有用到第一列")]),_:1}),e("，导致没用到索引")])]),s("li",null,[a(n,{color:"red"},{default:t(()=>[e("联合查询")]),_:1}),e("的大小表设置不合理，导致索引没用上（小表是整表查询，"),a(n,{color:"red"},{default:t(()=>[e("大表才用索引")]),_:1}),e("）")]),s("li",null,[s("p",null,[e("多表查询不用in（产生中间表），用"),a(n,{color:"red"},{default:t(()=>[e("外连接（join）替代带in子查询")]),_:1}),e("的过程，合理使用索引")])])]),L,M,s("ol",null,[s("li",null,[v,e("；防止客户端不断"),a(n,{color:"red"},{default:t(()=>[e("三次握手建立连接，四次挥手关闭连接")]),_:1}),e("，耗费网络以及服务器资源，我们可以引入数据库连接池，这是高并发场景下常用的一种优化手段（需要设置初始连接量，最大连接量以及最大空闲时间等参数）")]),s("li",null,[B,e("；用于"),a(n,{color:"red"},{default:t(()=>[e("存储热点数据")]),_:1}),e("，如果客户端的请求来了，先在redis上查一下（redis是基于内存的数据库），如果redis上直接查到就不经过MySQL数据库，如果没有查到就去访问MySQL数据库，访问MySQL完成后，先把当前访问的数据往redis上缓存一下，再把结果返回给用户")])]),s("p",null,[e("引入redis缓存的话，也会有一些附带的问题："),a(n,{color:"red"},{default:t(()=>[e("缓存数据一致性问题，缓存穿透和缓存雪崩")]),_:1}),e("等等")]),q,s("p",null,[e("如果使用"),a(n,{color:"red"},{default:t(()=>[e("自适应哈希索引搜索的频率较低")]),_:1}),e("，可以通过变量"),z,e("关闭自适应哈希索引")]),w,s("p",null,[e("可以根据物理机的条件，"),a(n,{color:"red"},{default:t(()=>[e("合理设置InnoDB log buffer大小（redo log缓存的大小）")]),_:1}),e("，"),I,e("（缓存的大小），"),k]),A,T,X,D,s("p",null,[N,e("，因为"),a(n,{color:"red"},{default:t(()=>[e("当两个select查询中间出现insert，update，delete语句的时候，查询缓存就会被清空，过多的查询缓存的数据添加和删除，就会影响MySQL的执行效率，可能还不如每次都从磁盘上查询")]),_:1})]),V,a(n,{color:"red"},{default:t(()=>[e("MySQL查询缓存还是不如使用redis，这是MySQL的查询缓存，我们作为MySQL服务的使用者来说，控制不了MySQL的缓存方式")]),_:1}),e("，如果我们引入redis的话，可以通过"),Z,s("p",null,[e("MySQL Server网络模块采用经典的"),a(n,{color:"red"},{default:t(()=>[e("select I/O复用+线程池模型")]),_:1}),e("，之所以"),E]),a(n,{color:"green"},{default:t(()=>[e("线程池就是在业务使用之前，先创建一组固定数量的线程，等待事件发生，当有SQL请求到达MySQL Server的时候，在线程池中取一个线程来执行该SQL请求就可以了，执行完成后，不销毁线程，而是把线程再归还到线程池中，等待下一次任务的处理（线程池的线程数量随着请求越来越多，是可以动态增加的）")]),_:1}),W,s("p",null,[e("配置完thread_cache_size，"),a(n,{color:"red"},{default:t(()=>[e("重启MySQL Server服务后即可生效")]),_:1})]),C,s("p",null,[e("MySQL Server作为一个服务器，可以设置客户端的**"),a(n,{color:"red"},{default:t(()=>[e("最大连接量")]),_:1}),e("和"),a(n,{color:"red"},{default:t(()=>[e("连接超时时间")]),_:1}),e("**，"),P]),U,s("p",null,[e("在"),O,e("（my.cnf或my.ini）最下面，添加配置：max_connections=1000，然后"),a(n,{color:"red"},{default:t(()=>[e("重启MySQLServer，配置生效")]),_:1})]),s("p",null,[e("MySQL Server对于长时间未通信的连接，会主动关闭连接。设置超时时间，超过"),s("strong",null,[e("设置时间"),a(n,{color:"red"},{default:t(()=>[e("没有请求就主动断开")]),_:1}),e("，单位是秒，在配置文件中添加配置：wait_timeout = 600")])]),j])}const R=l(S,[["render",J],["__file","SQL和索引优化总结.html.vue"]]);export{R as default};
