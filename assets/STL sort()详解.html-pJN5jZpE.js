import{_ as s}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as n,c as a,a as l}from"./app-2pke9_a8.js";const o={},e=l(`<h2 id="函数原型-stl-algo-h" tabindex="-1"><a class="header-anchor" href="#函数原型-stl-algo-h" aria-hidden="true">#</a> 函数原型（stl_algo.h）</h2><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">template</span><span style="color:#ABB2BF;"> &lt;</span><span style="color:#C678DD;">class</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">RandomAccessIterator</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#C678DD;">inline</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">void</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">sort</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">RandomAccessIterator</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;font-style:italic;">first</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">RandomAccessIterator</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;font-style:italic;">last</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (first </span><span style="color:#C678DD;">!=</span><span style="color:#ABB2BF;"> last) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#61AFEF;">__introsort_loop</span><span style="color:#ABB2BF;">(first, last, </span><span style="color:#61AFEF;">value_type</span><span style="color:#ABB2BF;">(first), </span><span style="color:#61AFEF;">__lg</span><span style="color:#ABB2BF;">(last </span><span style="color:#56B6C2;">-</span><span style="color:#ABB2BF;"> first) </span><span style="color:#56B6C2;">*</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">);</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#61AFEF;">__final_insertion_sort</span><span style="color:#ABB2BF;">(first, last);</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">template</span><span style="color:#ABB2BF;"> &lt;</span><span style="color:#C678DD;">class</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">RandomAccessIterator</span><span style="color:#ABB2BF;">, </span><span style="color:#C678DD;">class</span><span style="color:#ABB2BF;"> </span><span style="color:#E5C07B;">Compare</span><span style="color:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="color:#C678DD;">inline</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">void</span><span style="color:#ABB2BF;"> </span><span style="color:#61AFEF;">sort</span><span style="color:#ABB2BF;">(</span><span style="color:#E5C07B;">RandomAccessIterator</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;font-style:italic;">first</span><span style="color:#ABB2BF;">, </span><span style="color:#E5C07B;">RandomAccessIterator</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;font-style:italic;">last</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">                 </span><span style="color:#E5C07B;">Compare</span><span style="color:#ABB2BF;"> </span><span style="color:#E06C75;font-style:italic;">comp</span><span style="color:#ABB2BF;">) {</span></span>
<span class="line"><span style="color:#ABB2BF;">  </span><span style="color:#C678DD;">if</span><span style="color:#ABB2BF;"> (first </span><span style="color:#C678DD;">!=</span><span style="color:#ABB2BF;"> last) {</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#61AFEF;">__introsort_loop</span><span style="color:#ABB2BF;">(first, last, </span><span style="color:#61AFEF;">value_type</span><span style="color:#ABB2BF;">(first), </span><span style="color:#61AFEF;">__lg</span><span style="color:#ABB2BF;">(last </span><span style="color:#56B6C2;">-</span><span style="color:#ABB2BF;"> first) </span><span style="color:#56B6C2;">*</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">2</span><span style="color:#ABB2BF;">,</span></span>
<span class="line"><span style="color:#ABB2BF;">                     comp);</span></span>
<span class="line"><span style="color:#ABB2BF;">    </span><span style="color:#61AFEF;">__final_insertion_sort</span><span style="color:#ABB2BF;">(first, last, comp);</span></span>
<span class="line"><span style="color:#ABB2BF;">  }</span></span>
<span class="line"><span style="color:#ABB2BF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>序列式容器只有<strong>vector、array（C++11起）、deque和string</strong>(因为<code>string</code>本质上是一个字符的<code>vector</code>)的迭代器类型是RandomAccessIterator，用到这个<code>sort()</code>；</p></li><li><p>对于像<code>list</code>这样的双向链表容器，由于其只提供双向迭代器，所以不能直接使用<code>sort()</code>算法。但是，你可以<strong>先将<code>list</code>的内容复制到<code>vector</code>或<code>deque</code>中，然后排序，最后再（如果需要的话）将结果复制回<code>list</code></strong>。</p></li><li><p>对于<strong>关联容器（如<code>set</code>、<code>multiset</code>、<code>map</code>、<code>multimap</code>），它们内部已经是有序的</strong>，所以不需要（也不能）使用<code>sort()</code>进行排序。但是，你可以通过提供自定义的比较函数或函数对象来改变它们的排序顺序</p></li></ul><h2 id="策略" tabindex="-1"><a class="header-anchor" href="#策略" aria-hidden="true">#</a> 策略</h2><p>一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用<strong>插入排序</strong>。</p><p>当数据量较大时采用<strong>快速排序</strong>，分段递归。</p><p>而如果递归层次过深，有出现最坏情况的倾向，还会改用<strong>堆排序</strong>。</p>`,7),p=[e];function t(c,r){return n(),a("div",null,p)}const y=s(o,[["render",t],["__file","STL sort()详解.html.vue"]]);export{y as default};
