import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as t,o,c as s,b as r,d as i,e,f as c,w as d,a as g}from"./app-m9pC5KT-.js";const l="/assets/0537ffbf95294648ab57522e67e8ce68-3zBg4GC0.png",u="/assets/10e21b5eb94d493b9e6cc58d233791d6-zmAz-LL-.png",p="/assets/image-20231230115745742-cRtKLlUz.png",h="/assets/image-20231230120138838-nAP2kzjm.png",f="/assets/image-20231230103243664-Ykrg3kfx.png",m="/assets/image-20231230111457047-m6b_1uVH.png",_="/assets/image-20231230111622514-Elx4oWsi.png",b="/assets/image-20231230104904001-sR3Yi6nB.png",x={},C=i("h1",{id:"前言",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#前言","aria-hidden":"true"},"#"),e(" 前言")],-1),B=g('<h2 id="为什么叫c语言" tabindex="-1"><a class="header-anchor" href="#为什么叫c语言" aria-hidden="true">#</a> 为什么叫c语言</h2><blockquote><p>详细请看wd_C语言</p></blockquote><p>其实是因为先有高级语言ALGOL 60，简称 A 语言，后来经过简化，变为 BCPL 语言，简称 B 语言，而 <u>C 语言是在 B 语言的基础之上发展而来的</u>，所以就称为 C 语言。所以<u>世界上第一个 C 语言的编译器是用 B语言编写的。</u></p><h2 id="unix和c语言的发展史" tabindex="-1"><a class="header-anchor" href="#unix和c语言的发展史" aria-hidden="true">#</a> UNIX和c语言的发展史</h2><ul><li><p>1965年为了<u>解决大型机连接终端数量不够用的问题</u>(当时大型主机至多能提供 30 台终端（30 个键盘、显示器)，连接一台电脑)，<strong>贝尔实验室</strong> 加入了 <strong>麻省理工学院</strong> 以及 <strong>通用电气</strong> 合作的计划</p></li><li><p>1969 年前后这个项目进度缓慢，资金短缺，贝尔实验室退出了研究</p></li><li><p>1969 年从这个项目中退出的 <strong>Ken Thompson</strong> 当时在实验室无聊时，为了让一台空闲的电脑上能够运行 “星际旅行（Space Travel）” 游行，在 8 月份左右趁着其妻子探亲的时间，用了 <strong>1 个月的时间</strong>，使用<u>汇编</u>写出了 <strong>Unix 操作系统的原型</strong></p></li><li><p>1970 年，美国贝尔实验室的 <strong>Ken Thompson</strong> ，以 BCPL 语言为基础，设计出很简单且很接近硬件的 B 语言（取 BCPL 的首字母），并且他用 <strong><u>B 语言</u> 写了第一个 UNIX 操作系统</strong></p></li><li><p>1971 年，同样酷爱 “星际旅行（Space Travel）” 的 <strong>Dennis M.Ritchie</strong> 为了能早点儿玩上游戏，加入了 <strong>Thompson</strong> 的开发项目，合作开发 UNIX，<strong>他的主要工作是改造 B语言，因为 B 语言 的跨平台性较差</strong></p></li><li><p>1972 年， <strong><u>Dennis M.Ritchie（丹尼斯·里奇）</u> 在 B 语言 的基础上最终设计出了</strong>一种新的语言，他取了 CPL 的第二个字母作为这种语言的名字，这就是 <strong>C 语言</strong></p></li><li><p>1973 年初， C 语言的主体完成， <strong>Thompson 和 Ritchie</strong> 迫不及待地开始用它完全重写了现在大名鼎鼎的 <strong>Unix 操作系统</strong></p></li></ul><h2 id="为什么说c语言移植性强" tabindex="-1"><a class="header-anchor" href="#为什么说c语言移植性强" aria-hidden="true">#</a> 为什么说c语言移植性强</h2><ul><li><strong>机器语言和汇编语言都不具有移植性</strong>，为 x86 开发的程序，不可能在Alpha，SPARC 和 ARM 等机器上运行</li><li>而 C 语言程序则可以使用在任意架构的处理器上，<strong>只要那种架构的处理器具有对应 的 <u>C 语言编译器和库</u></strong>，然后<u>将 C 源代码编译、链接成目标二进制文件</u>之后即可运 行</li></ul><h2 id="为什么c语言不能叫跨平台" tabindex="-1"><a class="header-anchor" href="#为什么c语言不能叫跨平台" aria-hidden="true">#</a> 为什么c语言不能叫跨平台</h2><p>Java编写的任何代码，<strong>无序修改即可在任何一个平台上运行</strong>，所以称之为跨平台语言</p><p>我们所讲的 C 标准，<u>当然可以通过不同的编译器编译后在任何一台平台上运行</u>，但是 C 标准除了文件操作之外，是没有涉及到<strong>操作系统硬件资源的接口的，比如进程调度，网络通信等</strong> ，这些接口均<u>为每一个操作系统独有的，windows与 Linux 这些接口有差异，一旦你的 C 程序中使用了这些接口，代码放到另外一个平台就无法编译通过了</u></p><h2 id="c语言的优势" tabindex="-1"><a class="header-anchor" href="#c语言的优势" aria-hidden="true">#</a> C语言的优势</h2><p>C 语言的**<u>执行效率</u>**一直是高级语言中的第一！另外 <strong>Java 及其他脚本语言中没有<u>指针</u>，无法<u>访问物理地址</u></strong>，所以系统中的驱动都需要用 C或 C++进行编写。</p><h2 id="学习c语言的目标" tabindex="-1"><a class="header-anchor" href="#学习c语言的目标" aria-hidden="true">#</a> 学习c语言的目标</h2><ol><li>理解<u>运行的逻辑</u></li><li><u>内存</u>变化</li><li>程序的<u>调试能力</u></li></ol><h2 id="vs-studio-调试方法" tabindex="-1"><a class="header-anchor" href="#vs-studio-调试方法" aria-hidden="true">#</a> vs studio 调试方法</h2><p><code>打断点</code>-&gt;<code>F5·</code>（启动程序）-&gt;打开<code>监视、调用堆栈、输出、内存</code>窗口</p><figure><img src="'+l+'" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><p><code>按钮 1</code> 是<strong>单步执行按钮</strong><code>F10</code>，点击该按钮一次，程序会向下执行一步；<code>按钮 2 </code>是<strong>继续执行按钮</strong>，点击后，程序会<u>执行到最后，或者执行到下一个断点</u>，<code>按钮3</code> 是停止执行按钮<code>shift F5</code>，点击后程序直接停止运行。（左键点击断点就可以取消断点）</p><p>在断点调试状态下，我们点击菜单栏的<strong>调试</strong>，选择<strong>窗口</strong>，然后依次点击<strong>监视，调用堆栈，内存</strong>，三个调试窗口，调用堆栈，监视，内存窗口对于后面我们<strong>调试程序及理解程序执行原理都至关重要</strong>，这次调出以后，后面每次调试程序都会自动弹出</p><p>程序调试方法：</p><ol><li>断点单步调试</li><li>判断打印调试</li><li>等等</li></ol><h3 id="内存地址及内存空间" tabindex="-1"><a class="header-anchor" href="#内存地址及内存空间" aria-hidden="true">#</a> 内存地址及内存空间</h3><figure><img src="'+u+'" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><p>i 的值是 0x00000001，为什么显示效果为 01 00 00 00 呢，这个是因为英特尔的 CPU 为<strong>小端存储</strong>，所以低位在前，高位在后</p><h4 id="内存地址只是一个编号-代表一个内存空间-容易产生误区" tabindex="-1"><a class="header-anchor" href="#内存地址只是一个编号-代表一个内存空间-容易产生误区" aria-hidden="true">#</a> 内存地址只是一个编号，代表一个内存空间（！容易产生误区）</h4><p><u>内存地址只是一个编号，代表一个内存空间，这个空间大小不会随编号的位数改变而改变（变成2个字节，4个字节），<strong>一个内存地址所代表的永远是1个字节</strong></u>。<mark>内存的每一个字节都有一个编号，16位操作系统、32位操作系统只是改变这个编号的长短，不会影响内存的最小单元大小</mark>，仅仅是个编号。唯一影响的是所能表示的个数（寻址能力）。</p><figure><img src="'+p+'" alt="image-20231230115745742" tabindex="0" loading="lazy"><figcaption>image-20231230115745742</figcaption></figure><p><mark>所以这个16位的cpu，所有表示的地址个数是2^20 = 1048576个，一个地址所指大小1个字节 ，也就是1M；32位的cpu，所有表示的地址个数是2^32 = 4294967296个，一个地址所指大小1个字节 ，也就是4G；</mark></p><figure><img src="'+h+'" alt="image-20231230120138838" tabindex="0" loading="lazy"><figcaption>image-20231230120138838</figcaption></figure><h3 id="显示代码行号" tabindex="-1"><a class="header-anchor" href="#显示代码行号" aria-hidden="true">#</a> 显示代码行号</h3><p>工具 --&gt; 选项 --&gt;勾选行号</p><h2 id="程序生成过程" tabindex="-1"><a class="header-anchor" href="#程序生成过程" aria-hidden="true">#</a> 程序生成过程</h2><figure><img src="'+f+`" alt="image-20231230103243664" tabindex="0" loading="lazy"><figcaption>image-20231230103243664</figcaption></figure><p>首先我们编写源代码f.c 经过编译后，我们会得到 f.obj 文件，f.obj 文件中均为0101 类型的机器码，也就是 cpu 能够识别的微指令（英特尔的机器指令）去运行，<u>f.obj 文件并不能执行，因为我们调用的<strong>标准库函数的代码</strong>并不在 f.obj 文件中</u>，例如上面 main.c 的printf 函数，printf 函数的代码并不在 main.obj 中，这时<u>经过链接，就得到可执行文件 f.exe</u>，了解这个编译过程，对于我们后面编写程序遇到编译错误后，分析编译错误，我们可以<strong>区分清楚是编译错误，还是链接错误</strong>。</p><h3 id="预编译指令" tabindex="-1"><a class="header-anchor" href="#预编译指令" aria-hidden="true">#</a> 预编译指令</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">#include</span><span style="color:#ABB2BF;"> 头文件包含</span></span>
<span class="line"><span style="color:#ABB2BF;">#define 宏定义</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>右侧项目代码-&gt;属性-&gt;配置属性-&gt;c/c+±&gt;预编译器-&gt;预处理到文件（是）</p><figure><img src="`+m+'" alt="image-20231230111457047" tabindex="0" loading="lazy"><figcaption>image-20231230111457047</figcaption></figure><p>预处理c和C++源文件并将预处理的输出写到文件，此选项取消编译，因此不会生成.obj文件</p><figure><img src="'+_+'" alt="image-20231230111622514" tabindex="0" loading="lazy"><figcaption>image-20231230111622514</figcaption></figure><h5 id="include-和-include-的区别" tabindex="-1"><a class="header-anchor" href="#include-和-include-的区别" aria-hidden="true">#</a> <code>#include＜＞</code>和<code>#include&quot;&quot;</code>的区别</h5><p><code>#include&lt;&gt;</code>：编译器直接从<strong>系统类库目录</strong>里查找头文件</p><ul><li><p>比如在VS2013中，编译器会直接在&lt;Visual studio 2013安装目录&gt;\\VC\\include目录下查找到stdio.h这个文件，这就是编译器的类库目录；</p></li><li><p>在Linux GCC编译环境下，一般为/user/include和/usr/local/include。</p></li></ul><p>例如，我们自定义一个头文件<u>&quot;test.h&quot;，把它放在项目工程文件所在目录，然后用“#include &lt;&gt;”的形式加载头文件test.h，编译时会直接报错</u>：No such file or directory.</p><p><code>#include&quot;&quot;</code>：默认从<strong>项目当前目录</strong>查找头文件，如果在项目当前目录下查找失败，再从<strong>项目配置的头文件引用目录</strong>查找头文件</p><p>所谓项目配置的引用目录，就是我们在项目工程中设置的头文件引用目录，Windows VS编译环境如下图所示。在Linux GCC编译环境下，则一般通过在Makefile文件中使用参数指定引用目录。</p><figure><img src="'+b+'" alt="image-20231230104904001" tabindex="0" loading="lazy"><figcaption>image-20231230104904001</figcaption></figure>',47),v=i("strong",null,"重名的头文件",-1),k=i("u",null,"头文件覆盖的问题",-1),y=i("u",null,"程序编译时的效率也会相对更高",-1);function z(L,V){const n=t("font");return o(),s("div",null,[C,r("more"),B,i("p",null,[e('虽然#include""的查找范围更广，但是这并不意味着，不论是系统头文件，还是自定义头文件，一律用#include""包含。'),c(n,{color:"red"},{default:d(()=>[e('因为#include""的查找顺序存在先后关系，如果项目当前目录或者引用目录下存在和系统目录下'),v,e("，那么编译器在当前目录或者引用目录查找成功后，将不会继续查找，所以存在"),k,e("。另外，对于系统头文件，用#include<>包含，查找时一步到位，"),y,e("。")]),_:1})])])}const q=a(x,[["render",z],["__file","前言.html.vue"]]);export{q as default};
