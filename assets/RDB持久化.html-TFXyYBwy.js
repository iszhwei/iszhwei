import{_ as r}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as o,o as d,c as t,d as s,e as a,f as n,w as l,a as i}from"./app-m9pC5KT-.js";const c="/assets/f1fea8e0eb08482faa4552ce01864d4c-S9IFq4hJ.png",p="/assets/46b056ab3d7d468899bb1fce495045be-fsG3LCjz.png",g="/assets/068edebea96f4b558a9894edea5d0365-oMRMpvrM.png",u="/assets/1ce1290d95004fd49220fdb08adbc798-WoGzqamQ.png",b="/assets/17431f5867174942b989560d8e15fe16-Y0jPYu2m.png",f="/assets/ac4e22a5a8a44ce19fbcac04d1543859-ytlAjYxe.png",h="/assets/0c3da629d01a424c9c69f97e41817945-R7KpNND9.png",_="/assets/177727173d9e4b9d8fee04d19cb01d21-lZ20IseI.png",v="/assets/8390bcccb1e34ebb8cdc715a77507977-dKSvijGu.png",m="/assets/70cd07afb2934ab4ae4b9fc8455c4581-mIbIDFBr.png",B="/assets/c2c68a749eb249fb81f2d0fbfc97ea63-_w1fO3T6.png",y="/assets/16592064f66b46bb8fb5e365dac63986-FQcGzrRc.png",x="/assets/ae10cee1f7f845e59e6d57c43c890e34-7xnv42X3.png",D="/assets/d37e1efae73b4d50acf8cce30a4b8c22-KRK54Zbc.png",k="/assets/f225b0091bbf489c8b12d1cdfb77018b-RxJxbwjp.png",A="/assets/7813d1a84c974a9ba9ea8039cb3373ed-xAaYMqUV.png",R="/assets/f7be597932d6425f8a7abfd67abdfb6e-WyFG1byn.png",F="/assets/5c968e0f864a46a0a96a2afe562f2e28-1l5VT3rT.png",z="/assets/68d70b18a43641e6949b89e448e661ac-FAyAjOlA.png",q="/assets/557806720f3547bea194698d95737757-HkeBNs69.png",C="/assets/a8217b2908764c3eb62be67fef2addd4-4HyH425E.png",w="/assets/7c4f2c923bfc405eada3ddde96d97dd3-DfCMBC1p.png",M="/assets/f9fc6b398e3041dabdb68b46cb7b8067-hzuMO3wQ.png",N={},O=i('<h1 id="rdb持久化" tabindex="-1"><a class="header-anchor" href="#rdb持久化" aria-hidden="true">#</a> RDB持久化</h1><h2 id="一、持久化简介" tabindex="-1"><a class="header-anchor" href="#一、持久化简介" aria-hidden="true">#</a> 一、持久化简介</h2><h3 id="什么是持久化" tabindex="-1"><a class="header-anchor" href="#什么是持久化" aria-hidden="true">#</a> 什么是持久化？</h3><p>将内存中的数据保存至永久性存储介质称为持久化</p><h3 id="为什么要持久化" tabindex="-1"><a class="header-anchor" href="#为什么要持久化" aria-hidden="true">#</a> 为什么要持久化？</h3><p><u>防止数据的意外丢失</u>，确保数据安全性</p><h3 id="如何防止数据丢失" tabindex="-1"><a class="header-anchor" href="#如何防止数据丢失" aria-hidden="true">#</a> 如何防止数据丢失？</h3>',7),j=s("strong",null,"RDB持久化",-1),I=s("strong",null,"AOF持久化",-1),V=s("u",null,"以追加的方式写入文件，类似于MySQL的binlog",-1),G=i('<figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="二、数据快照rdb" tabindex="-1"><a class="header-anchor" href="#二、数据快照rdb" aria-hidden="true">#</a> 二、数据快照RDB</h2><p>RDB，<strong>默认的</strong>持久化方案。<strong>在指定的时间间隔内，执行指定次数的写操作，则会将内存中的数据写入到磁盘中</strong>。即在指定目录下生成一个dump.rdb文件。Redis 重启会通过加载dump.rdb文件恢复数据。（/var/lib/redis/6379）</p><h3 id="_1-save指令" tabindex="-1"><a class="header-anchor" href="#_1-save指令" aria-hidden="true">#</a> 1. save指令</h3><p>使用save指令即可通过RBD方式进行数据持久化，<strong>需要手动执行save操作</strong>，持久化时会把redis中的<strong>数据默认保存在dump.rdb中，可在配置文件中指定目录</strong></p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端在内存创建数据，并进行save持久化</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查看指定dump.rdb中是否有内容</p><figure><img src="'+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这就表示内存中的数据已经保存在硬盘文件里了</p><h3 id="_2-rdb文件相关配置" tabindex="-1"><a class="header-anchor" href="#_2-rdb文件相关配置" aria-hidden="true">#</a> 2. RDB文件相关配置</h3><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">dbfilename </span><span style="color:#D19A66;">dump</span><span style="color:#ABB2BF;">.</span><span style="color:#D19A66;">rdb</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>说明：设置本地数据库文件名，默认为<code>dump.rdb</code></li><li>经验：通常设置为<code>dump-端口号.rdb</code></li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">dir /var/lib/redis/</span><span style="color:#D19A66;">6379</span><span style="color:#ABB2BF;"> #默认</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>说明：设置<strong>存储.rdb文件的路径</strong></li><li>经验：<strong>通常设置成存储空间较大的目录中，目录名称data</strong></li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">rdbcompression yes</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,17),K=s("li",null,[a("说明：设置存储至本地数据库时"),s("strong",null,"是否压缩数据，默认为yes，采用LZF压缩")],-1),Q=i(`<div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">rdbchecksum yes</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,1),S=s("li",null,[a("说明：设置读写.rdb文件时是否进行RDB文件的校验，该校验过程"),s("strong",null,"在写文件和读文件过程均进行，避免读写已损坏的文件")],-1),T=i(`<div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">stop</span><span style="color:#ABB2BF;">-writes-</span><span style="color:#C678DD;">on</span><span style="color:#ABB2BF;">-bgsave-error yes</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>说明：<strong>后台存储过程中如果出现错误，是否停止保存操作</strong></li><li>经验：通常默认为开启状态</li></ul><p>修改配置后，<strong>需要重启服务程序才能生效</strong>，重启后将按照配置文件指定的文件路径和工作方式运行</p><figure><img src="`+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="验证save后数据保存在了rdb文件" tabindex="-1"><a class="header-anchor" href="#验证save后数据保存在了rdb文件" aria-hidden="true">#</a> 验证save后数据保存在了rdb文件</h4><p>服务端杀掉进程后，重新使用配置文件启动</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端创建两个数据并save</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查看rdb文件，已有相关记录</p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="验证重启服务后-程序会从rdb文件中恢复数据到内存" tabindex="-1"><a class="header-anchor" href="#验证重启服务后-程序会从rdb文件中恢复数据到内存" aria-hidden="true">#</a> 验证重启服务后，程序会从rdb文件中恢复数据到内存</h4><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端重新连接，发现数据还存在，这是<strong>因为服务进程启动时读取了rdb文件，进而恢复到内存中</strong></p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-bgsave指令" tabindex="-1"><a class="header-anchor" href="#_3-bgsave指令" aria-hidden="true">#</a> 3. bgsave指令</h3>',16),Y=s("strong",null,"Redis是单线程的，所有命令都会在队列中排好队",-1),H=s("figure",null,[s("img",{src:B,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),L=s("p",null,[s("strong",null,"访问量很大时，单线程又得执行save，还得处理客户请求，造成效率降低，如何处理？")],-1),Z=s("figure",null,[s("img",{src:y,alt:"",tabindex:"0",loading:"lazy"}),s("figcaption")],-1),E=i('<h4 id="验证bgsave工作原理" tabindex="-1"><a class="header-anchor" href="#验证bgsave工作原理" aria-hidden="true">#</a> 验证bgsave工作原理</h4><p>客户端发送bgsave，可以看到给我们提示的是Background saving started</p><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们查看RDB文件，已经数据addr保存好了</p><figure><img src="'+D+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们查看一下日志文件（配置文件中的logfile）</p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_4-配置自动持久化" tabindex="-1"><a class="header-anchor" href="#_4-配置自动持久化" aria-hidden="true">#</a> 4.<strong>配置自动持久化</strong></h3><p>到目前为止，save和bgsave都是手动的保存指令，那么会引入以下问题：</p>',9),J=i(`<div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">save</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">second</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">changes</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>second：监控时间范围</li><li>changes：监控key的变化量</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">save</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">900</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">1</span><span style="color:#ABB2BF;">        # 900s内有1个key发生变化，则进行bgsave持久化</span></span>
<span class="line"><span style="color:#C678DD;">save</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">300</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">10</span><span style="color:#ABB2BF;">       # 300s内有10个key发生变化，则进行bgsave持久化</span></span>
<span class="line"><span style="color:#C678DD;">save</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">60</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">10000</span><span style="color:#ABB2BF;">     # 60s内有10000个key发生变化，则进行bgsave持久化</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>修改配置conf文件</p><figure><img src="`+A+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>启动服务程序</p><figure><img src="'+R+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端添加一个数据</p><figure><img src="'+F+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查看服务器是否进行了持久化（rdb文件已提前清空）</p><figure><img src="'+z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>客户端再添加一条数据，此时服务器按照配置文件，自动执行bgsave</p><figure><img src="'+q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>此时服务器的rdb文件已经出现</p><figure><img src="'+C+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>无论get多少次，数据都不会改变，不会进行持久化；由于不进行数据比对，也就意味着对同一个数据连续修改两次，也会进行持久化</strong></p><p>save使用注意事项：</p><ul><li>save配置要根据实际业务情况进行设置，<strong>持久化的频度过高或过低都会出现性能问题</strong>，结果可能是灾难性的</li><li>save配置中对second与changes设置通常具有互补对应关系，尽量不要设置成包含性关系</li><li><strong>save配置启动后执行的是bgsave操作</strong></li></ul><h3 id="_5-rdb三种启动方式对比" tabindex="-1"><a class="header-anchor" href="#_5-rdb三种启动方式对比" aria-hidden="true">#</a> 5. RDB三种启动方式对比</h3>',20),P=i('<figure><img src="'+M+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>save：由单进程执行，是同步的；save和其他的客户端请求都是排队处理的，若执行时间过长会阻塞其他指令；没有fork子进程，无额外内存消耗</li><li>bgsave：由子进程执行，主进程可以继续处理其他请求，不会阻塞其他指令，是异步的，<strong>同时有额外内存开销（子进程）</strong></li></ul><h3 id="_6-rdb特殊启动形式" tabindex="-1"><a class="header-anchor" href="#_6-rdb特殊启动形式" aria-hidden="true">#</a> 6. rdb特殊启动形式</h3><ul><li>全量复制（在主从复制中用到）</li><li>服务器运行过程中重启</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">debug reloads</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>关闭服务器时指定保存数据</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">shutdown</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">save</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><blockquote><p>触发快照的方式：</p><p>1、执行shutdown命令，会触发快照</p><p>2、flushall命令，也会触发快照。</p><p>3、手动执行save命令，也可以触发快照。（bgsave （异步）命令）</p><p>4、在指定的时间间隔内，执行指定次数的写操作。</p></blockquote><h3 id="_7-rdb优缺点" tabindex="-1"><a class="header-anchor" href="#_7-rdb优缺点" aria-hidden="true">#</a> 7. RDB优缺点</h3><p><strong>RDB优点</strong></p>`,10),U=s("li",null,[a("RDB是一个紧凑"),s("strong",null,"压缩的二进制文件，存储效率较高")],-1),W=s("li",null,[a("RDB内部存储的是redis在某个时间点的数据快照，非常"),s("strong",null,"适合用于数据备份，全量复制"),a("等场景")],-1),X=s("li",null,[a("RDB"),s("strong",null,"恢复数据的速度要比AOF快"),a("很多")],-1),$=s("p",null,[s("strong",null,"RDB缺点")],-1),ss=s("p",null,[s("strong",null,"RDB存储的弊端")],-1),as=s("li",null,"基于fork创建子进程，内存产生额外消耗",-1),es=s("blockquote",null,[s("p",null,"优点"),s("p",null,"1、适合大规模的数据恢复，与AOF相比,在恢复大的数据集的时候，RDB方式会更快一些 2、如果业务对数据完整性和一致性要求不高，RDB是很好的选择。"),s("p",null,"缺点："),s("p",null,"1、对数据的完整性与一致性不高。"),s("p",null,"2、备份时占用内存")],-1);function ns(ls,is){const e=o("font");return d(),t("div",null,[O,s("ul",null,[s("li",null,[s("p",null,[j,a("：将当前**"),n(e,{color:"cornflowerblue"},{default:l(()=>[a("数据")]),_:1}),a("**保存到硬盘（原理是将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化）")]),s("p",null,[I,a("：将每次执行的写**"),n(e,{color:"cornflowerblue"},{default:l(()=>[a("命令")]),_:1}),a("**保存到硬盘（原理是将Reids的操作日志"),V,a("）")])])]),G,s("ul",null,[K,s("li",null,[a("经验：通常默认为开启状态，"),n(e,{color:"red"},{default:l(()=>[a("如果设置成no，可以节省CPU运行时间，但会使存储的文件变大（巨大）")]),_:1})])]),Q,s("ul",null,[S,s("li",null,[a("经验：通常默认为开启状态，"),n(e,{color:"red"},{default:l(()=>[a("如果设置为no，可以节约读写性过程约10%时间消耗，但是存储一定的数据损坏风险")]),_:1})])]),T,s("p",null,[Y,a("，"),n(e,{color:"red"},{default:l(()=>[a("不建议使用save指令，因为save指令的执行会阻塞当前Redis服务器，直到当前RDB过程完成，有可能会造成长时间阻塞，线上环境不建议使用")]),_:1})]),H,L,s("p",null,[a("用bgsave解决："),n(e,{color:"green"},{default:l(()=>[a("客户端发送bgsave后，redis会选择一个合适的时间执行后台执行，并不是像save一样收到指令立即执行")]),_:1})]),Z,s("p",null,[a("注意： "),s("strong",null,[a("bgsave命令是针对save阻塞问题做的优化，"),n(e,{color:"green"},{default:l(()=>[a("Redis内部所有涉及到RDB操作都采用bgsave的方式，save命令可以放弃使用")]),_:1})])]),E,s("ul",null,[s("li",null,[n(e,{color:"red"},{default:l(()=>[a("反复执行保存命令，忘记了怎么办？")]),_:1})]),s("li",null,[n(e,{color:"red"},{default:l(()=>[a("不知道数据产生了多少变化，何时保存？")]),_:1})])]),s("p",null,[a("Redis提供了一种自动进行数据持久化的方式：指定时间范围内，发生变化（这个变化包括**"),n(e,{color:"red"},{default:l(()=>[a("增加、修改、删除")]),_:1}),a("**）的key达到指定数量就进行持久化，需要在配置文件中进行一下配置：")]),J,s("p",null,[a("由于"),n(e,{color:"green"},{default:l(()=>[a("配置文件启动save的方式，执行的就是bgsave")]),_:1}),a("，这里只比较save和bgsave")]),P,s("ul",null,[U,W,X,s("li",null,[a("应用："),n(e,{color:"green"},{default:l(()=>[a("服务器中每X小时执行bgsave备份，并将RDB文件拷贝到远程机器中，用于灾难恢复")]),_:1})])]),$,s("ul",null,[s("li",null,[n(e,{color:"red"},{default:l(()=>[a("save频率低容易丢数据，save频率高会影响请求处理速度")]),_:1})]),s("li",null,[n(e,{color:"red"},{default:l(()=>[a("bgsave指令每次运行要执行fork操作创建子进程，要牺牲掉一些性能")]),_:1})]),s("li",null,[a("Redis的众多版本中未进行RDB文件格式的版本不统一，"),n(e,{color:"red"},{default:l(()=>[a("有可能出现这个版本的redis生成的rbd文件，用其他版本的redis打不开")]),_:1})])]),ss,s("ul",null,[s("li",null,[a("存储数据量较大，效率较低——基于快照思想，"),n(e,{color:"red"},{default:l(()=>[a("每次读写都是全部数据，当数据量巨大时，效率非常低")]),_:1})]),s("li",null,[n(e,{color:"red"},{default:l(()=>[a("大数据量下的IO性能较低")]),_:1})]),as,s("li",null,[n(e,{color:"red"},{default:l(()=>[a("宕机会带来数据丢失")]),_:1})])]),es])}const ds=r(N,[["render",ns],["__file","RDB持久化.html.vue"]]);export{ds as default};
