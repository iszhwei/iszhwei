import{_ as o}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as i,o as r,c as _,d as a,e,f as n,w as s,a as l}from"./app-2pke9_a8.js";const c="/assets/image-20240419150312478-pI4JWCa2.png",d="/assets/image-20240419152203342-kgagj_mU.png",p="/assets/image-20240419155029940-UQZHk1D8.png",g="/assets/image-20240419155523434-S8pkQXmU.png",u="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAQnVnTWFrZXItc2hlbg___size_20_color_FFFFFF_t_70_g_se_x_16-6ZxHTRal.png",h="/assets/image-20240419160425457-KciXWCqG.png",m="/assets/image-20240419161539787-SeXT8wo6.png",f="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAQnVnTWFrZXItc2hlbg___size_20_color_FFFFFF_t_70_g_se_x_16-17135150545263-Rzm3gD-o.png",A="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAQnVnTWFrZXItc2hlbg___size_13_color_FFFFFF_t_70_g_se_x_16-j4EgUnzg.png",b="/assets/image-20240419170044052-uskcU9h6.png",y="/assets/image-20240419170124628-lTq7jo5s.png",x={},T=a("h1",{id:"mysql事务的隔离级别",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#mysql事务的隔离级别","aria-hidden":"true"},"#"),e(" MySQL事务的隔离级别")],-1),F=a("h2",{id:"隔离级别概念",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#隔离级别概念","aria-hidden":"true"},"#"),e(" 隔离级别概念")],-1),B=a("p",null,[e("事务的隔离级别就是"),a("strong",null,"对事务并发的控制")],-1),E=a("p",null,"MySQL支持的四种隔离级别是：",-1),N=a("strong",null,"TRANSACTION_READ_UNCOMMITTED：未提交读",-1),C=a("strong",null,"TRANSACTION_READ_COMMITTED：已提交读（oracle默认）",-1),S=a("strong",null,"TRANSACTION_REPEATABLE_READ：可重复读（MySQL默认）",-1),Q=a("u",null,"再次读取相同的数据而不会失败，即使其他的事务把这个数据改了",-1),z=a("u",null,"完全可以保证两次查询的结果是一样的",-1),D=a("strong",null,"TRANSACTION_SERIALIZABLE：串行化",-1),I=a("figure",null,[a("img",{src:c,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),R=a("li",null,[a("p",null,[e("事务隔离级别越高，为避免冲突所"),a("u",null,"花费的性能也就越多")])],-1),L=l(`<p>两个MySQL客户端默认工作在可重复读级别</p><h2 id="查看隔离级别" tabindex="-1"><a class="header-anchor" href="#查看隔离级别" aria-hidden="true">#</a> 查看隔离级别</h2><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">select</span><span style="color:#ABB2BF;"> @@tx_isolation;	#</span><span style="color:#D19A66;">MySQL5</span><span style="color:#ABB2BF;">.</span><span style="color:#D19A66;">7</span></span>
<span class="line"><span style="color:#C678DD;">select</span><span style="color:#ABB2BF;"> @@transaction_isolation; #</span><span style="color:#D19A66;">8</span><span style="color:#ABB2BF;">.</span><span style="color:#D19A66;">0</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',4),M={id:"测试read-uncommitted隔离级别",tabindex:"-1"},k=a("a",{class:"header-anchor",href:"#测试read-uncommitted隔离级别","aria-hidden":"true"},"#",-1),v=a("figure",null,[a("img",{src:p,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),O=a("ul",null,[a("li",null,"两个会话都需要设置成read-uncommitted隔离级别"),a("li",null,"注意要加单引号"),a("li",null,"可以看到一个客户端读到了另一个客户端未提交的数据-脏读")],-1),w=l('<figure><img src="'+g+'" alt="image-20240419155523434" tabindex="0" loading="lazy"><figcaption>image-20240419155523434</figcaption></figure><h2 id="测试transaction-read-committed隔离级别" tabindex="-1"><a class="header-anchor" href="#测试transaction-read-committed隔离级别" aria-hidden="true">#</a> 测试TRANSACTION_READ_COMMITTED隔离级别</h2><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由于设置了已提交读隔离级别，事务B并<strong>没有发生脏读</strong>，这是由各种锁机制以及事务并发的MVCC版本控制实现的</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查询到了已经commit的数据，<strong>发生了不可重复读</strong>，这在已提交读隔离级别是允许发生的</p><p>既然发生了不可重复读，幻读就肯定可以发生了</p><h2 id="测试transaction-repeatable-read隔离级别" tabindex="-1"><a class="header-anchor" href="#测试transaction-repeatable-read隔离级别" aria-hidden="true">#</a> 测试TRANSACTION_REPEATABLE_READ隔离级别</h2><figure><img src="'+m+'" alt="image-20240419161539787" tabindex="0" loading="lazy"><figcaption>image-20240419161539787</figcaption></figure><p>可重复读隔离级别：<u>对于一个事务来说，可以放心读数据，就算有其他事务修改了数据并且已经提交了，也不会在当前事务表现出来</u>。<strong>只要自己没改，数据都是不会变的</strong></p><p>在可重复读隔离级别，测试幻读（<strong>在一定程度上防止了幻读，但没有完全防止</strong>）</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',12),V=a("p",null,"右边的客户端update左侧客户端insert的数据：",-1),X=a("figure",null,[a("img",{src:A,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),Z=a("p",null,"实际上，事务A已经插入并且提交了，aaa已经存在，所以事务B update aaa的年龄成功了",-1),q=a("p",null,[a("strong",null,"前后两次同样的查询，后一次查询与前一次查询的数据量不同，就发生了幻读"),e("。也就是可重复读隔离级别下，并没有解决幻读的问题，要彻底解决幻读，就需要设置串行化隔离级别")],-1),U=a("h2",{id:"测试transaction-serializable隔离级别",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#测试transaction-serializable隔离级别","aria-hidden":"true"},"#"),e(" 测试TRANSACTION_SERIALIZABLE隔离级别")],-1),W=a("figure",null,[a("img",{src:b,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),j=a("strong",null,"不会",-1),H=a("strong",null,"永远阻塞",-1),P=a("figure",null,[a("img",{src:y,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1);function G(J,K){const t=i("font");return r(),_("div",null,[T,F,B,E,a("ol",null,[a("li",null,[a("p",null,[N,e("。说明在提交前事务A可以看到事务B的变化。这样"),n(t,{color:"red"},{default:s(()=>[e("脏读")]),_:1}),e("，"),n(t,{color:"red"},{default:s(()=>[e("不可重复读")]),_:1}),e("和"),n(t,{color:"red"},{default:s(()=>[e("幻读")]),_:1}),e("都是可能发生的。")])]),a("li",null,[a("p",null,[C,e("，说明读取未提交的数据是不允许的（防止脏读）。在这个级别"),n(t,{color:"red"},{default:s(()=>[e("不可重复读")]),_:1}),e("和"),n(t,{color:"red"},{default:s(()=>[e("幻读")]),_:1}),e("可能发生的。")])]),a("li",null,[a("p",null,[S,e("，说明事务保证能够"),Q,e("，你也不会看到前后两次查询的数据的不同，"),z,e("，但是"),n(t,{color:"red"},{default:s(()=>[e("幻读")]),_:1}),e("仍然会出现。")])]),a("li",null,[a("p",null,[D,e("，是最高的事务隔离级别，它防止脏读，不可重复读和幻读。串行执行，"),n(t,{color:"red"},{default:s(()=>[e("相当于是单线程操作，并发能力最低")]),_:1}),e("，一般不会用")])])]),I,a("ul",null,[R,a("li",null,[a("p",null,[e("在可重复读级别，实际上可以解决部分（"),n(t,{color:"red"},{default:s(()=>[e("insert和delete")]),_:1}),e("）的幻读问题，但是"),n(t,{color:"red"},{default:s(()=>[e("不能防止update")]),_:1}),e("更新产生的幻读问题，要禁止幻读产生，还是需要设置串行化隔离级别")])])]),L,a("h2",M,[k,e(" 测试read-uncommi"),n(t,{color:"red"},{default:s(()=>[e("tted")]),_:1}),e("隔离级别")]),v,O,n(t,{color:"red"},{default:s(()=>[e("若此时A客户端rollback了，数据库中lisi的年龄恢复成了25，那这时候已经来不及了，B客户端拿着年龄21去做业务了")]),_:1}),w,a("ul",null,[a("li",null,[e("可以看到，在当前的可重复读隔离级别，右侧事务无法查询到左侧事务insert的数据，虽然看不到，但"),n(t,{color:"blue"},{default:s(()=>[e("由于左侧事务已经提交，数据库表中是存在name为aaa的数据的，由于MVCC控制，右侧事务无法看见。但可以直接操作这条看不见的数据，操作以后，数据可以出现")]),_:1})])]),V,X,Z,q,U,W,a("p",null,[e("由于"),n(t,{color:"red"},{default:s(()=>[e("事务B正在读数据，此时事务A再写数据就被阻塞了（用读写锁实现，允许读读，不允许读写或者写写）")]),_:1})]),a("p",null,[e("MySQL server"),j,e("让自己执行事务的线程"),H,e("，导致当前线程占用的锁无法释放，而使得其他执行事务的线程也无法获得锁而永远阻塞。所以"),n(t,{color:"green"},{default:s(()=>[e("当线程等待时间过长时，会让超时线程释放锁，并会返回一个错误")]),_:1}),e("：")]),P])}const aa=o(x,[["render",G],["__file","MySQL事务的隔离级别.html.vue"]]);export{aa as default};
