import{_ as l}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as c,o as g,c as d,d as a,e,f as s,w as t,a as n}from"./app-rY1SOIco.js";const o="/assets/x_16-9qsftArL.png",p="/assets/image-20240419220313295-tEOf3j4o.png",f="/assets/image-20240419221151210-jWIJ4_kW.png",u="/assets/image-20240419225713877-NhUKzMgw.png",_="/assets/7e56cf48e50247cca6eaea61808e480c-wIH4jCSE.png",h="/assets/148999a2cc6042ce9aff48ce7f9f033f-0xZCNdcU.png",m="/assets/2a61d8d2d8354c5d87e000129d3e00b5-34cmKmBg.png",b="/assets/image-20240419232209103-758rfwBw.png",y="/assets/0e9795879e63412486e5a4f19002551e-4v_VucyJ.png",x="/assets/image-20240419231953567-VyRsQcmM.png",r="/assets/image-20240420104024248-VzLjughh.png",B="/assets/image-20240420105448793-OgAIxLGe.png",k="/assets/watermark_type_d3F5LXplbmhlaQ_shadow_50_text_Q1NETiBAQnVnTWFrZXItc2hlbg___size_16_color_FFFFFF_t_70_g_se_x_16-17135818779125-bv0sF7sV.png",F="/assets/image-20240420111426951-n9egIkRm.png",z="/assets/image-20240420112427834-HnLKEOj2.png",w="/assets/image-20240420114458649-gWManqyL.png",D={},Q=a("h1",{id:"mysql间隙锁-幻读解决原理",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#mysql间隙锁-幻读解决原理","aria-hidden":"true"},"#"),e(" MySQL间隙锁（幻读解决原理）")],-1),v=a("h2",{id:"一、间隙锁概念",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#一、间隙锁概念","aria-hidden":"true"},"#"),e(" 一、间隙锁概念")],-1),L=a("li",null,"当我们用范围条件而不是相等条件检索数据， 并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)” ，InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁",-1),A=a("li",null,'举例来说， 假如 user 表中只有 101 条记录， 其userid 的值分别是 1,2,…,100,101， 下面的 SQL： select * from user where userid > 100 for update;是一个范围条件的检索，InnoDB 不仅会对符合条件的 userid 值为 101 的记录加锁，也会对userid 大 于 101（但是这些记录并不存在）的"间隙"加锁，防止其它事务在表的末尾增加数据',-1),q=n('<p>InnoDB串行化隔离级别使用间隙锁（gap lock）解决幻读（事务并发情况下两次查询的数据量不同）问题</p><p>间隙锁专用于串行化隔离级别，可解决幻读问题，幻读问题表现为：<strong>当前事务没做操作，前后两次相同的查询语句，显示的数据量不一致</strong></p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们把事务2 select的指定的条件分为2类：范围查询、等值查询</p><p>record lock：记录锁，就是行锁 gap lock：间隙锁，不包含记录本身 next-key lock：record lock（记录本身） + gap lock（不包括记录本身）</p><h2 id="二、测试间隙锁范围加锁" tabindex="-1"><a class="header-anchor" href="#二、测试间隙锁范围加锁" aria-hidden="true">#</a> 二、测试间隙锁范围加锁</h2><p>设置事务为手动提交，然后把隔离级别设置成串行化</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="场景1-用不可重复的主键id测试间隙锁" tabindex="-1"><a class="header-anchor" href="#场景1-用不可重复的主键id测试间隙锁" aria-hidden="true">#</a> 场景1：用不可重复的<strong>主键</strong>id测试间隙锁</h3><blockquote><p><strong>范围查询</strong></p></blockquote><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>事务2的select操作只给三行数据加了共享锁，为什么插入id为9的数据也不行呢？</p>',12),I=n(`<div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">select</span><span style="color:#ABB2BF;"> * </span><span style="color:#C678DD;">from</span><span style="color:#ABB2BF;"> user </span><span style="color:#C678DD;">where</span><span style="color:#ABB2BF;"> id</span><span style="color:#56B6C2;">&gt;</span><span style="color:#D19A66;">11</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="`+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',2),C=n('<p>也就是说，我们可以在id小于11的地方update/delete，加排它锁。但是操作了id&lt;=11的部分，不影响相同的select * from stu where id&gt;11所获取的数据量，这样就能防止幻读发生</p><p><mark>串行化隔离级别通过给select的部分加间隙锁，防止其他事务在加了间隙锁的区间进行增加或删除数据，就能防止幻读</mark></p><h3 id="场景2-用可重复的age-有索引-测试间隙锁" tabindex="-1"><a class="header-anchor" href="#场景2-用可重复的age-有索引-测试间隙锁" aria-hidden="true">#</a> 场景2：用可重复的age（有索引）测试间隙锁</h3><blockquote><p><strong>测试辅助索引树上，间隙锁的范围</strong></p></blockquote><figure><img src="'+u+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">select</span><span style="color:#ABB2BF;"> * </span><span style="color:#C678DD;">from</span><span style="color:#ABB2BF;"> user </span><span style="color:#C678DD;">where</span><span style="color:#ABB2BF;"> age</span><span style="color:#56B6C2;">&gt;</span><span style="color:#D19A66;">20</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>很明显，由于age&gt;20的区间都被事务1加上了间隙锁（这里加的是共享锁），所以事务2插入age=22和age=21都失败了</p><figure><img src="`+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>幻读就是同一事务两次用相同的条件查询数据，下一次查出的数据量和上一次的数据量不一样，就算事务1把age=20的数据插入表，事务2再用age&gt;20查询，得到的数据量也不会改变。</p><p>那事务1插入age=20的数据能否成功呢？</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>依然不能成功，这是因为我们插入的数据id是自增的，所以这条数据(age=20，id=24)，位于辅助索引树中(age=20，id=12)的右边，由于(age=20，id=12)右边都被上了锁，(age=20，id=24)自然无法插入</p><p>也就是说，如果我们指定age=20，id合法且&lt;12，则可插入</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>很显然，事务1插入的age=18和age=19都不在事务2上锁的范围，所以可以插入</p>',15),S=a("strong",null,"如果只是在辅助索引树上查找，",-1),V=a("strong",null,"不回表，那么主键索引树上不会加锁",-1),M=n('<figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>select id from stu where age&gt;14</code>后，辅助索引树加锁区间如下：</p><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+x+'" alt="image-20240419231953567" tabindex="0" loading="lazy"><figcaption>image-20240419231953567</figcaption></figure><h3 id="场景3-mysql5-7实际情况需要具体分析用的到底是行锁还是表锁" tabindex="-1"><a class="header-anchor" href="#场景3-mysql5-7实际情况需要具体分析用的到底是行锁还是表锁" aria-hidden="true">#</a> 场景3：MySQL5.7实际情况需要具体分析用的到底是行锁还是表锁</h3><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>MySQL5.7过滤出的数据占了整张表的一大半，MySQL server没使用索引。</strong></p><figure><img src="https://img-blog.csdnimg.cn/cf0ccfede829420bae7af86bbfba6558.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',9),N=a("figure",null,[a("img",{src:o,alt:"",tabindex:"0",loading:"lazy"}),a("figcaption")],-1),E=n('<figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="三、测试等值间隙锁" tabindex="-1"><a class="header-anchor" href="#三、测试等值间隙锁" aria-hidden="true">#</a> 三、测试等值间隙锁</h2><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_1-测试不能重复的主键索引" tabindex="-1"><a class="header-anchor" href="#_1-测试不能重复的主键索引" aria-hidden="true">#</a> 1. 测试不能重复的主键索引</h3><p>此时事务2 select，由于是等值查询，相当于给这条数据加上了共享锁，事务1现在插入新的数据是可以成功的，因为主键id不能重复，我们不能再插入主键id=3的数据</p><figure><img src="'+F+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在这种情况下，由于id=3的数据已经存在，主键和唯一键是不能重复的，事务2进行等值查询时，事务1插入一个新的数据，不用担心这条新插入的数据和查询条件是一样的，如果主键一样，SQL语句执行失败，所以肯定能成功</p><h3 id="_2-测试能重复的辅助索引" tabindex="-1"><a class="header-anchor" href="#_2-测试能重复的辅助索引" aria-hidden="true">#</a> 2. 测试能重复的辅助索引</h3><p>事务2等值查询，给age=21这行数据加上共享锁（record-lock），</p><figure><img src="'+z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>事务1插入age=21，这是不能允许的，否则事务2再查询age=18就有两条记录了（幻读）</p><p>奇怪的是，我们插入age=18，21都被阻塞了，而22、17成功了</p><figure><img src="https://img-blog.csdnimg.cn/80bbac2dfdef4342805e53c20671032d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_9,color_FFFFFF,t_70,g_se,x_16" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这是因为，<mark>为了防止幻读，除了age=21这条数据加了<strong>共享锁</strong>，其两侧也被加上了<strong>间隙锁</strong></mark></p><ul><li>因为在这种情况下，插入(age=21,id=5)和(age=21,id=9)是会发生幻读的，所以在一切会影响select * from user where age=18查询结果的地方都加上了间隙锁，但这也会导致一些本不影响查询结果的语句也执行失败，比如插入(age=17，id=10)虽然不影响上述SQL执行结果，由于在间隙锁范围内，依然无法插入</li></ul><p><u>插入(age=22)就可以成功，<mark>根据辅助索引值相同，按照主键值升序排列</mark>，(age=22，id=9)应该放在(age=22,id=4)前面，不在间隙锁范围内</u></p><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><p>间隙锁是给<strong>不存在的数据记录</strong>的<strong>范围加锁</strong>：</p><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',19),T=a("strong",null,"串行隔离级别",-1),W=a("strong",null,"等值查询",-1);function X(j,Z){const i=c("font");return g(),d("div",null,[Q,v,a("ol",null,[L,A,a("li",null,[e("InnoDB "),a("strong",null,[s(i,{color:"red"},{default:t(()=>[e("使用间隙锁的目的，是为了防止幻读，以满足串行化serializable隔离级别的要求")]),_:1})]),e(" ，对于上面的例子，要是不使用间隙锁，如果其他事务插入了 userid 大于 100 的任何记录，那么本事务如果再次执行上述语句，就会发生幻读")])]),q,a("p",null,[e("这是因为在串行化隔离级别中，"),a("strong",null,[e("不仅仅是获取了满足条件的这3行的行锁，而且把表记录之间以及后边空洞的地方也加上了"),s(i,{color:"red"},{default:t(()=>[e("间隙锁")]),_:1})])]),I,a("p",null,[e("图中"),s(i,{color:"red"},{default:t(()=>[e("红色线")]),_:1}),e("的地方都上了"),s(i,{color:"red"},{default:t(()=>[e("next-key锁")]),_:1}),e("，上锁范围（左开右闭）为：( 11 , 12 ] ∪ ( 12 ， 22 ] ∪ ( 22 ， 23 ] ∪ ( 23 ， + ∞ ]")]),s(i,{color:"blue"},{default:t(()=>[e("上述select不仅仅获取了12，22，23的共享行锁（record-lock），还把间隙加了间隙锁，其实就是给间隙加上共享锁或者排他锁，由于我们这里是select，所以是给间隙加上了共享锁（我们select id>11还是可以的，但是不能update、insert、delete id>11的数据）")]),_:1}),C,a("p",null,[a("mark",null,[S,s(i,{color:"red"},{default:t(()=>[V]),_:1})])]),M,a("p",null,[e("没有加行锁，"),s(i,{color:"red"},{default:t(()=>[e("只能加表锁（这时加的是共享锁），所以事务1无论插入什么数据都不行")]),_:1})]),N,a("p",null,[e("age>20用到了"),s(i,{color:"red"},{default:t(()=>[e("索引")]),_:1}),e("，所以可以用"),s(i,{color:"red"},{default:t(()=>[e("行锁")]),_:1})]),E,a("ul",null,[a("li",null,[e("对于"),s(i,{color:"red"},{default:t(()=>[e("辅助索引，若值允许重复")]),_:1}),e("，在"),T,e("中如果进行"),W,e("，InnoDB会给数据加上"),s(i,{color:"blue"},{default:t(()=>[e("record-lock和gap-lock")]),_:1}),e("（"),s(i,{color:"green"},{default:t(()=>[e("防止别的事务插入索引值重复的数据，造成幻读")]),_:1}),e("）")]),a("li",null,[e("对于"),s(i,{color:"red"},{default:t(()=>[e("主键索引，或者唯一键索引，值不允许重复")]),_:1}),e("，那只需要"),s(i,{color:"blue"},{default:t(()=>[e("加行锁")]),_:1}),e("就够了，不需要再加间隙锁（"),s(i,{color:"green"},{default:t(()=>[e("对于唯一键索引，不可能发生插入索引值重复的数据")]),_:1}),e("）")])]),a("p",null,[a("strong",null,[e("串行化隔离级别"),a("u",null,[e("通过"),s(i,{color:"cornflowerblue"},{default:t(()=>[e("排它锁")]),_:1}),e("和"),s(i,{color:"cornflowerblue"},{default:t(()=>[e("共享锁")]),_:1}),e("解决"),s(i,{color:"cornflowerblue"},{default:t(()=>[e("脏读、不可重复读")]),_:1}),e("（两次查询的数据内容不同）")]),e("，"),a("u",null,[e("通过"),s(i,{color:"green"},{default:t(()=>[e("间隙锁")]),_:1}),e("解决"),s(i,{color:"green"},{default:t(()=>[e("幻读")]),_:1}),e("（两次查询的数据量不同）")])])])])}const G=l(D,[["render",X],["__file","MySQL间隙锁（幻读解决原理）.html.vue"]]);export{G as default};
