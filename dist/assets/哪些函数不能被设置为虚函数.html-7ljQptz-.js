const t=JSON.parse('{"key":"v-5e6716c0","path":"/ccpp/07%20%E5%A4%9A%E6%80%81/%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E8%A2%AB%E8%AE%BE%E7%BD%AE%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0.html","title":"哪些函数不能被设置为虚函数？","lang":"zh-CN","frontmatter":{"title":"哪些函数不能被设置为虚函数？","icon":"file","order":4,"headerDepth":4,"category":["c/c++"],"tag":["多态"],"description":"成为虚函数的条件 1.要成为虚函数，函数地址就要记录在虚函数表中，即虚函数能产生函数地址，存储在vftable中。 2.vfptr指针需要依赖对象，对象必须存在。（vfptr-&gt;vftable-&gt;虚函数地址\\t） 哪些函数不能被设置为虚函数？ 普通函数（非成员函数）：定义虚函数的主要目的是为了重写达到多态，所以普通函数声明为虚函数没有意义，因此编译器在****就绑定了它。 静态成员函数：静态成员函数对于每个类都只有一份代码，所有对象都可以共享这份代码，他**，所以它也没有动态绑定的必要。(静态函数发生在**，虚函数体现多态发生在运行时) 不可能出现 static + virtual 或 virtual + static 内联成员函数：内联函数本就是为了减少函数调用的代价，所以在代码中直接展开。但虚函数一定要创建虚函数表，这两者不可能统一。另外，内联函数在****，而虚函数在运行时才动态绑定。 构造函数：这个原因很简单，主要从语义上考虑。因为构造函数本来是为了初始化对象成员才产生的，然而虚函数的目的是为了在完全不了解细节的情况下也能正确处理对象，两者根本不能“ 好好相处 ”。因为**** 友元函数：当我们把一个函数声明为一个类的友元函数时，它只是一个可以访问类内成员的普通函数，并不是这个类的成员函数，自然也不能在自己的类内将它声明为虚函数。(，比如在自己类里面设置为虚函数，但是作为另一个类的友元)","head":[["meta",{"property":"og:url","content":"https://iszhwei.gitee.io/ccpp/07%20%E5%A4%9A%E6%80%81/%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E8%A2%AB%E8%AE%BE%E7%BD%AE%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0.html"}],["meta",{"property":"og:site_name","content":"张威的编程学习笔记"}],["meta",{"property":"og:title","content":"哪些函数不能被设置为虚函数？"}],["meta",{"property":"og:description","content":"成为虚函数的条件 1.要成为虚函数，函数地址就要记录在虚函数表中，即虚函数能产生函数地址，存储在vftable中。 2.vfptr指针需要依赖对象，对象必须存在。（vfptr-&gt;vftable-&gt;虚函数地址\\t） 哪些函数不能被设置为虚函数？ 普通函数（非成员函数）：定义虚函数的主要目的是为了重写达到多态，所以普通函数声明为虚函数没有意义，因此编译器在****就绑定了它。 静态成员函数：静态成员函数对于每个类都只有一份代码，所有对象都可以共享这份代码，他**，所以它也没有动态绑定的必要。(静态函数发生在**，虚函数体现多态发生在运行时) 不可能出现 static + virtual 或 virtual + static 内联成员函数：内联函数本就是为了减少函数调用的代价，所以在代码中直接展开。但虚函数一定要创建虚函数表，这两者不可能统一。另外，内联函数在****，而虚函数在运行时才动态绑定。 构造函数：这个原因很简单，主要从语义上考虑。因为构造函数本来是为了初始化对象成员才产生的，然而虚函数的目的是为了在完全不了解细节的情况下也能正确处理对象，两者根本不能“ 好好相处 ”。因为**** 友元函数：当我们把一个函数声明为一个类的友元函数时，它只是一个可以访问类内成员的普通函数，并不是这个类的成员函数，自然也不能在自己的类内将它声明为虚函数。(，比如在自己类里面设置为虚函数，但是作为另一个类的友元)"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"张威"}],["meta",{"property":"article:tag","content":"多态"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"哪些函数不能被设置为虚函数？\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"张威\\",\\"url\\":\\"https://iszhwei.gitee.io\\"}]}"]]},"headers":[{"level":2,"title":"成为虚函数的条件","slug":"成为虚函数的条件","link":"#成为虚函数的条件","children":[]},{"level":2,"title":"哪些函数不能被设置为虚函数？","slug":"哪些函数不能被设置为虚函数","link":"#哪些函数不能被设置为虚函数","children":[]},{"level":2,"title":"为什么析构函数可以成为虚函数","slug":"为什么析构函数可以成为虚函数","link":"#为什么析构函数可以成为虚函数","children":[]}],"git":{},"readingTime":{"minutes":2.4,"words":721},"filePathRelative":"ccpp/07 多态/哪些函数不能被设置为虚函数.md","excerpt":"<h2> 成为虚函数的条件</h2>\\n<p><strong>1.要成为虚函数，函数地址就要记录在虚函数表中，即<u>虚函数能产生函数地址，存储在vftable中</u>。</strong>\\n<strong>2.<u>vfptr指针需要依赖对象，对象必须存在</u>。</strong>（vfptr-&gt;vftable-&gt;虚函数地址\\t）</p>\\n<h2> 哪些函数不能被设置为虚函数？</h2>\\n<ol>\\n<li><strong>普通函数（非成员函数）</strong>：定义<u>虚函数的主要目的是为了重写达到多态</u>，所以普通函数声明为虚函数没有意义，因此编译器在****就绑定了它。</li>\\n<li><strong>静态成员函数</strong>：静态成员函数对于每个类都只有一份代码，所有对象都可以共享这份代码，他**<strong>，所以它也没有动态绑定的必要。(静态函数发生在</strong>**，虚函数体现多态发生在运行时)\\n<ul>\\n<li>不可能出现 <code>static + virtual</code> 或 <code>virtual + static</code></li>\\n</ul>\\n</li>\\n<li><strong>内联成员函数</strong>：内联函数本就<u>是为了<strong>减少函数调用的代价</strong>，所以在代码中直接展开</u>。<u>但虚函数<strong>一定要创建虚函数表</strong>，这两者不可能统一</u>。另外，内联函数在****，而虚函数在<u>运行时才动态绑定</u>。</li>\\n<li><strong>构造函数</strong>：这个原因很简单，主要从语义上考虑。因为构造函数本来是为了初始化对象成员才产生的，然而虚函数的目的是为了在完全不了解细节的情况下也能正确处理对象，两者根本不能“ 好好相处 ”。因为****</li>\\n<li><strong>友元函数</strong>：<u>当我们把一个函数声明为一个类的友元函数时，它只是一个可以访问类内成员的<strong>普通函数</strong>，并不是这个类的成员函数</u>，自然也不能在自己的类内将它声明为虚函数。(<strong></strong>，比如在自己类里面设置为虚函数，但是作为另一个类的友元)</li>\\n</ol>","autoDesc":true}');export{t as data};
