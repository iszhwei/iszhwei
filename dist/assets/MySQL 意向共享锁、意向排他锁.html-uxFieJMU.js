import{_ as o}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as t,o as r,c as i,d as n,e as s,f as a,w as e,a as c}from"./app-9OmaxHRC.js";const d={},p=c(`<h1 id="mysql-意向共享锁、意向排他锁" tabindex="-1"><a class="header-anchor" href="#mysql-意向共享锁、意向排他锁" aria-hidden="true">#</a> MySQL 意向共享锁、意向排他锁</h1><p>![image-20240420193947369](MySQL 意向共享锁、意向排他锁.assets/image-20240420193947369.png)</p><h2 id="一、innodb表级锁" tabindex="-1"><a class="header-anchor" href="#一、innodb表级锁" aria-hidden="true">#</a> 一、InnoDB表级锁</h2><p>我们知道，InnoDB是支持行锁，但不是每次都获取行锁，如果不使用索引的，那还是获取的表锁。而且有的时候，我们希望直接去使用表锁</p><h3 id="适合使用表索的情况" tabindex="-1"><a class="header-anchor" href="#适合使用表索的情况" aria-hidden="true">#</a> 适合使用表索的情况</h3><p>在绝大部分情况下都应该使用行锁，因为事务的并发效率比表锁更高，但个别情况下也使用表级锁：</p><ul><li><p>事务需要<strong>更新大部分或全部数据，表又比较大</strong>，如果使用默认的行锁，给大部分行都加锁（此时不如直接加表锁），不仅这个事务执行效率低，而且可能造成其他事务长时间等待和锁冲突</p></li><li><p><strong>事务涉及多个表</strong>，比较复杂，如果都用行锁，很可能引起死锁，造成大量事务回滚</p></li></ul><h3 id="表索的相关命令" tabindex="-1"><a class="header-anchor" href="#表索的相关命令" aria-hidden="true">#</a> 表索的相关命令</h3><p>当我们希望获取表锁时，可以使用以下命令：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#ABB2BF;">LOCK </span><span style="color:#C678DD;">TABLE</span><span style="color:#ABB2BF;"> user </span><span style="color:#C678DD;">READ</span><span style="color:#ABB2BF;">  </span><span style="color:#7F848E;font-style:italic;">-- 获取这张表的读锁</span></span>
<span class="line"><span style="color:#ABB2BF;">LOCK </span><span style="color:#C678DD;">TABLE</span><span style="color:#ABB2BF;"> user WRITE </span><span style="color:#7F848E;font-style:italic;">-- 获取这张表的写锁</span></span>
<span class="line"></span>
<span class="line"><span style="color:#ABB2BF;">事务执行...</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C678DD;">COMMIT</span><span style="color:#ABB2BF;">/</span><span style="color:#C678DD;">ROLLBACK</span><span style="color:#ABB2BF;">;      </span><span style="color:#7F848E;font-style:italic;">-- 事务提交或者回滚</span></span>
<span class="line"><span style="color:#C678DD;">UNLOCK</span><span style="color:#ABB2BF;"> TABLES;        </span><span style="color:#7F848E;font-style:italic;">-- 本身自带提交事务，释放线程占用的所有表锁</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="在使用表锁的时候-涉及到效率的问题" tabindex="-1"><a class="header-anchor" href="#在使用表锁的时候-涉及到效率的问题" aria-hidden="true">#</a> 在使用表锁的时候，涉及到效率的问题</h3>`,11),_=n("p",null,[s("假如这张表有1000万个数据，那我"),n("u",null,"怎么知道这1000万行哪些有行锁哪些没有行锁呢？")],-1),u=n("p",null,"除了挨个检查，没有更好的办法，这就导致效率低下的问题",-1),h=n("p",null,[s("我们这里学习的"),n("strong",null,"意向共享锁和意向排他锁"),s("就是用来解决，由于需要加表锁而去挨个遍历数据，确定是否有某些数据被加了行锁，而导致的效率低下问题。"),n("strong",null,"作用就是快速判断表里是否有记录被加锁")],-1),B=n("h2",{id:"二、意向共享锁和意向排他锁-表锁而非行锁",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#二、意向共享锁和意向排他锁-表锁而非行锁","aria-hidden":"true"},"#"),s(" 二、意向共享锁和意向排他锁（表锁而非行锁）")],-1),y=n("strong",null,"意向锁的作用",-1),m=n("p",null,[n("strong",null,"意向共享锁（IS锁）"),s("：事务在给一行记录加共享锁前，必须先取得该表的IS锁 "),n("strong",null,"意向排他锁（IX锁）"),s("：事务在给一行记录加排他锁前，必须先取得该表的IX锁")],-1),f=n("p",null,"![](MySQL 意向共享锁、意向排他锁.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16.png)",-1),g=n("p",null,[s("（上面表格所有的锁都是"),n("strong",null,"针对整表"),s("）")],-1),b=n("strong",null,"自动",-1),v=n("u",null,"表的IS或IX锁",-1),F=n("li",null,[n("mark",null,"意向锁之间都兼容，不会产生冲突")],-1),I=n("li",null,[n("mark",null,"意向锁存在的意义是为了更高效的获取表锁"),s("（表格中的X、S、IX、IS指的是表锁，不是行锁）")],-1),S=n("li",null,[s("意向锁是"),n("strong",null,"表级锁"),s("，协调表锁和行锁的共存关系，主要目的是"),n("strong",null,"显示事务正在锁定某行或者试图锁定某行。")],-1),X=n("p",null,"分析事务1获取行X锁和事务2获取表S锁：",-1),D=n("p",null,"首先事务1需要给表的第10行数据加X锁，于是InnoDB存储引擎自动给整张表加上了IX锁。当事务2再想获取整张表的S锁时，看到这张表已经有别的事务获取了IX锁了，就说明这张表肯定有某些数据被加上了X锁，这就导致事务2不能给整张表加S锁了。此时事务2只能等待，无法成功获取表S锁",-1),x=n("p",null,[n("mark",null,"当某个事务要获取表的X锁时，不需要再检查哪些行被加上了X或S锁，只需要检查整表是否被加上IX或IS锁即可")],-1);function A(L,C){const l=t("font");return r(),i("div",null,[p,n("p",null,[s("如果我们"),a(l,{color:"red"},{default:e(()=>[s("要获取一张表的排它锁X，最起码得确定，这张表没有被其他事务获取过S锁或X锁，以及这张表没有任何行被其他事务获取过行S或X锁")]),_:1})]),_,u,h,B,n("p",null,[y,s("：为了可以更快速的"),a(l,{color:"red"},{default:e(()=>[s("获取表锁")]),_:1})]),m,f,g,n("ol",null,[n("li",null,[n("mark",null,[s("在"),a(l,{color:"red"},{default:e(()=>[s("加行锁")]),_:1}),s("之前，由InnoDB存储引擎"),b,s("加上"),v,s("，我们无法手动获取IS或IX锁")])]),F,I,S]),X,D,x])}const Q=o(d,[["render",A],["__file","MySQL 意向共享锁、意向排他锁.html.vue"]]);export{Q as default};
