import{_ as c}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as i,o as t,c as r,d as s,e as l,f as n,w as e,a as o}from"./app--8O2lHwG.js";const d="/assets/image-20240310154324639-c2eiQY36.png",p="/assets/image-20240310173458700-Lo8kgZZq.png",u={},B=o(`<h1 id="gcc-g-常见的编译命令" tabindex="-1"><a class="header-anchor" href="#gcc-g-常见的编译命令" aria-hidden="true">#</a> gcc/g++ 常见的编译命令</h1><h2 id="基本编译命令" tabindex="-1"><a class="header-anchor" href="#基本编译命令" aria-hidden="true">#</a> 基本编译命令</h2><ul><li>编译C程序：<code>gcc filename.c -o outputname</code></li><li>编译C++程序：<code>g++ filename.cpp -o outputname</code></li></ul><h2 id="添加编译选项" tabindex="-1"><a class="header-anchor" href="#添加编译选项" aria-hidden="true">#</a> 添加编译选项</h2><ul><li><p><code>-g</code>：添加调试信息，用于gdb等调试器。</p></li><li><p><code>-O2</code> 或 <code>-O3</code>：优化代码，提高运行效率。</p></li><li><p><code>-Wall</code>：显示所有警告信息。</p></li><li><p><code>-Wextra</code>：显示额外的警告信息。</p></li><li><p><code>-Werror</code>：将所有警告当作错误处理。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">gcc</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-g</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-O2</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-Wall</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">filename.c</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-o</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">outputname</span></span>
<span class="line"><span style="color:#61AFEF;">g++</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">main.cc</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-m32</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-g</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-o</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">main.o</span><span style="color:#ABB2BF;">	</span><span style="color:#7F848E;font-style:italic;">#-m32指定编译为32位程序</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><figure><img src="`+d+`" alt="image-20240310154324639" tabindex="0" loading="lazy"><figcaption>image-20240310154324639</figcaption></figure><h2 id="包含头文件和库" tabindex="-1"><a class="header-anchor" href="#包含头文件和库" aria-hidden="true">#</a> 包含头文件和库</h2><ul><li><code>-I</code>：指定头文件搜索路径。</li><li><code>-L</code>：指定库文件搜索路径。</li><li><code>-l</code>：链接指定的库。 例如：<code>gcc -I/path/to/headers -L/path/to/libs -lmylib filename.c -o outputname</code></li></ul><h2 id="编译多个源文件" tabindex="-1"><a class="header-anchor" href="#编译多个源文件" aria-hidden="true">#</a> 编译多个源文件</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">gcc</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">file1.c</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">file2.c</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">file3.c</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-o</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">outputname</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="预处理、编译、汇编和链接" tabindex="-1"><a class="header-anchor" href="#预处理、编译、汇编和链接" aria-hidden="true">#</a> 预处理、编译、汇编和链接</h2><ul><li><code>-E</code>：只进行预处理，输出到标准输出。</li><li><code>-S</code>：编译并汇编，输出汇编代码。</li><li><code>-c</code>：编译并汇编，输出目标文件（.o）。</li></ul><p>例如，只进行预处理：<code>gcc -E filename.c -o output.i</code></p><h2 id="使用静态库和动态库" tabindex="-1"><a class="header-anchor" href="#使用静态库和动态库" aria-hidden="true">#</a> 使用静态库和动态库</h2><p>静态库：在链接时，库文件会被拷贝到可执行程序中（产品中打包了库文件）</p><p>动态库：在链接时库文件会提供自己的位置，在运行时根据位置进行加载（运行时加载的库文件）</p><table><thead><tr><th>特点</th><th>可执行程序的大小</th><th>安装难度</th><th>升级</th></tr></thead><tbody><tr><td>静态</td><td>大</td><td>低</td><td>难</td></tr><tr><td>动态</td><td>小</td><td>高</td><td>容易</td></tr></tbody></table>`,17),y=s("li",null,[s("strong",null,"创建静态库"),l("： "),s("ul",null,[s("li",null,[l("生成目标文件"),s("code",null,"gcc -c mylib.c -o amylib.o")]),s("li",null,[l("打包成库文件"),s("code",null,"ar crsv libmylib.a mylib.o")])])],-1),h=s("strong",null,"创建动态库",-1),g=s("strong",null,"位置无关的目标文件",-1),b=s("code",null,"gcc -c mylib.c -o amylib.o -fpic",-1),m=s("li",null,[l("从目标文件生成动态文件"),s("code",null,"gcc -shared -o libmylib.so mylib.o")],-1),_=s("li",null,[s("strong",null,"链接静态库"),l("："),s("code",null,"gcc filename.c -L. -lmylib -o outputname")],-1),A=s("li",null,[s("strong",null,"链接动态库"),l("：除了上面的链接命令（"),s("code",null,"gcc filename.c -L. -lmylib -o outputname"),l(" ），还需要在运行时指定动态库的位置，可以使用"),s("code",null,"LD_LIBRARY_PATH"),l("环境变量或"),s("code",null,"/etc/ld.so.conf"),l("文件来实现。")],-1),F=s("h3",{id:"如何更新动态库🍗🍗🍗",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#如何更新动态库🍗🍗🍗","aria-hidden":"true"},"#"),l(" 如何更新动态库🍗🍗🍗")],-1),f=s("p",null,"动态库的好处：用户不需要重新链接就能更新库文件",-1),v=o(`<li><p><strong>重新编译库</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">gcc</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-shared</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-o</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">libmylib.so</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">mylib.c</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-fPIC</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>`,1),C=s("strong",null,"更新版本号",-1),x=o(`<p><strong>安装新库</strong>：需要将它安装到系统中合适的位置。这通常意味着将库文件复制到某个标准库目录，如 <code>/usr/local/lib</code> 或 <code>/usr/lib</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">mv</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">libmylib.so</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">libmylib.so.0.0.1</span></span>
<span class="line"><span style="color:#61AFEF;">sudo</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">cp</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">libmylib.so.0.0.1</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">/usr/lib/</span><span style="color:#ABB2BF;">	</span></span>
<span class="line"></span>
<span class="line"><span style="color:#61AFEF;">sudo</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">rm</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">libmylib.so</span><span style="color:#ABB2BF;">	</span><span style="color:#7F848E;font-style:italic;">#删除旧的软链接</span></span>
<span class="line"><span style="color:#61AFEF;">sudo</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">ln</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-s</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">libmylib.so.0.0.1</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">libmylib.so</span><span style="color:#ABB2BF;"> </span><span style="color:#7F848E;font-style:italic;">#重新建立新链接</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+p+'" alt="image-20240310173458700" tabindex="0" loading="lazy"><figcaption>image-20240310173458700</figcaption></figure><ul><li>版本号决定了新旧程序</li><li>保存所有版本的库文件（因为不知道新版本的库文件是否会产生bug）</li><li>建立库文件和libmylib.so的软链接（为了让程序链接或运行过程中能正确找到相应的库文件）</li><li>如果更新，重建软链接即可</li></ul>',4),k=o(`<li><p><strong>更新库缓存</strong>：在某些系统上，如 Linux，当新的共享库被安装后，你可能需要更新系统的库缓存。这通常可以通过运行 <code>ldconfig</code> 命令完成，该命令会重新生成 <code>/etc/ld.so.cache</code> 文件，该文件包含了系统中所有共享库的列表。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">sudo</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">ldconfig</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者，如果你的库安装在一个<strong>非标准目录</strong>，你可能需要编辑 <code>/etc/ld.so.conf</code> 文件并添加你的库目录，然后再运行 <code>ldconfig</code>。</p></li>`,1),D=o('<h3 id="gcc-fpic-什么作用-了解" tabindex="-1"><a class="header-anchor" href="#gcc-fpic-什么作用-了解" aria-hidden="true">#</a> gcc -fpic 什么作用（了解）</h3><ol><li>主要用于<strong>生成位置无关代码（Position Independent Code，简称 PIC</strong>）。这种代码的特性在于没有绝对跳转，所有的跳转都是相对跳转，因此<u>代码可以被加载器加载到内存的任意位置</u>并正确执行（<u>因为共享库在加载到内存时，其位置不是固定的</u>，因此必须能够处理这种不确定性）。</li><li>使用 <code>-fPIC</code> 选项编译的源文件在引用函数头文件时，有更宽松的尺度。例如，只需要包含函数的声明头文件，即使没有相应的 C 文件来实现这些函数，编译成共享库（.so 文件）也可以成功</li></ol><h3 id="ar-crsv-作用" tabindex="-1"><a class="header-anchor" href="#ar-crsv-作用" aria-hidden="true">#</a> ar crsv 作用</h3><p><code>ar</code> 是 Unix-like 系统中的一个工具，用于<u>创建、修改和提取</u><strong>静态库文件</strong>（通常具有 <code>.a</code> 扩展名）</p><ul><li><code>c</code>：创建一个库。如果库已经存在，则替换它。</li><li><code>r</code>：将文件插入库中。如果文件已存在于库中，则替换它。</li><li><code>s</code>：创建或更新库的目标文件索引。这对于加速链接过程很有用，因为链接器可以使用索引来快速找到库中的特定符号。</li><li><code>v</code>：详细模式。显示正在执行的操作的详细信息。</li></ul><p><strong>示例</strong>：</p><p>当你使用 <code>ar crsv libname.a file1.o file2.o</code> 这样的命令时，你实际上是在告诉 <code>ar</code>：</p><ol><li>创建一个名为 <code>libname.a</code> 的静态库（如果它不存在的话）。</li><li>将 <code>file1.o</code> 和 <code>file2.o</code> 这两个目标文件添加到库中（如果它们已经存在于库中，则替换它们）。</li><li>更新或创建库的索引。</li><li>显示执行过程中的详细信息。</li></ol><h3 id="同时存在动态库-共享库-和静态库" tabindex="-1"><a class="header-anchor" href="#同时存在动态库-共享库-和静态库" aria-hidden="true">#</a> 同时存在动态库（共享库）和静态库</h3>',9),E=s("strong",null,"默认行为",-1),L=s("strong",null,"动态库",-1),I=s("strong",null,"因为它们通常更小，多个程序可以共享同一个库文件，从而节省磁盘空间",-1),P=s("li",null,[s("strong",null,"链接器选项"),l("：链接器通常接受一些选项来控制它应该优先链接到哪种类型的库。例如，GCC 链接器接受 "),s("code",null,"-static"),l(" 和 "),s("code",null,"-shared"),l(" 选项来分别指示链接器优先链接到静态库或动态库。")],-1),R=o(`<p>如果你想要控制链接的优先级，你可以使用以下策略：</p><ul><li><strong>显式指定库文件</strong>：在链接时，你可以直接指定要链接的库文件的路径。例如，使用 <code>-L</code> 选项来添加库文件的搜索路径，并使用 <code>-l</code> 选项来指定库名。如果你想要链接到静态库，你可以直接指定静态库文件的路径（包括 <code>.a</code> 扩展名）。🍔</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">gcc</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">your_program.o</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-L/path/to/libs</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-l:libmylib.a</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-o</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">your_program</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,3),N=o(`<ul><li><strong>使用链接器选项</strong>：使用 <code>-static</code> 选项告诉链接器优先链接静态库。🍔</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#61AFEF;">gcc</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">your_program.o</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-static</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-lmylib</span><span style="color:#ABB2BF;"> </span><span style="color:#D19A66;">-o</span><span style="color:#ABB2BF;"> </span><span style="color:#98C379;">your_program_static</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,2),T=s("strong",null,"修改环境变量",-1),V=s("code",null,"LD_LIBRARY_PATH",-1),W=s("code",null,"LIBRARY_PATH",-1);function Y(H,O){const a=i("font");return t(),r("div",null,[B,s("ul",null,[y,s("li",null,[h,l("： "),s("ul",null,[s("li",null,[l("编译时生成与"),n(a,{color:"red"},{default:e(()=>[g]),_:1}),b]),m])]),_,A]),F,f,s("ol",null,[v,s("li",null,[s("p",null,[C,l("：如果服务端"),n(a,{color:"red"},{default:e(()=>[l("更改了协议，必须更新库文件（升级）才能使用")]),_:1}),l("；如果不更新协议，可以多个客户端版本共用一个服务端。")]),x]),k]),D,s("ol",null,[s("li",null,[E,l("：在许多系统中，如果"),s("u",null,[l("没有显式指定，链接器默认会优先链接到"),n(a,{color:"red"},{default:e(()=>[L]),_:1})]),l("，"),I,l("。")]),P]),R,n(a,{color:"red"},{default:e(()=>[l("注意 `-l:` 前缀用于直接指定库文件，而不是库名。")]),_:1}),N,s("ul",null,[s("li",null,[T,l("：某些系统允许通过设置环境变量（如 "),V,l(" 对于运行时动态库搜索，或者 "),W,l(" 对于链接时库搜索）来影响库的搜索顺序。"),n(a,{color:"red"},{default:e(()=>[l("然而，这些变量主要影响运行时库的搜索，而不是链接时的行为。")]),_:1})])])])}const S=c(u,[["render",Y],["__file","gcc_g__常见的编译命令.html.vue"]]);export{S as default};
