const e=JSON.parse('{"key":"v-5dfb342e","path":"/mysql/06%20MySQL%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/%E8%AE%B0%E5%BD%95%E9%94%81_%E9%97%B4%E9%9A%99%E9%94%81%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB%E5%90%97.html","title":"记录锁+间隙锁可以防止删除操作而导致的幻读吗？","lang":"zh-CN","frontmatter":{"title":"记录锁+间隙锁可以防止删除操作而导致的幻读吗？","icon":"file","order":9,"headerDepth":4,"category":["mysql"],"tag":["mysql锁机制"],"description":"记录锁+间隙锁可以防止删除操作而导致的幻读吗？ MySQL 是怎么解决幻读的？ MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种： 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。 针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。","head":[["meta",{"property":"og:url","content":"https://iszhwei.gitee.io/mysql/06%20MySQL%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/%E8%AE%B0%E5%BD%95%E9%94%81_%E9%97%B4%E9%9A%99%E9%94%81%E5%8F%AF%E4%BB%A5%E9%98%B2%E6%AD%A2%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B9%BB%E8%AF%BB%E5%90%97.html"}],["meta",{"property":"og:site_name","content":"张威的编程学习笔记"}],["meta",{"property":"og:title","content":"记录锁+间隙锁可以防止删除操作而导致的幻读吗？"}],["meta",{"property":"og:description","content":"记录锁+间隙锁可以防止删除操作而导致的幻读吗？ MySQL 是怎么解决幻读的？ MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种： 针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。 针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"张威"}],["meta",{"property":"article:tag","content":"mysql锁机制"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"记录锁+间隙锁可以防止删除操作而导致的幻读吗？\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"张威\\",\\"url\\":\\"https://iszhwei.gitee.io\\"}]}"]]},"headers":[{"level":2,"title":"MySQL 是怎么解决幻读的？","slug":"mysql-是怎么解决幻读的","link":"#mysql-是怎么解决幻读的","children":[]},{"level":2,"title":"加锁分析","slug":"加锁分析","link":"#加锁分析","children":[{"level":3,"title":"如果对 age 没有索引，事务 A 这条查询会加什么锁呢？","slug":"如果对-age-没有索引-事务-a-这条查询会加什么锁呢","link":"#如果对-age-没有索引-事务-a-这条查询会加什么锁呢","children":[]},{"level":3,"title":"如果对 age 建立索引，事务 A 这条查询会加什么锁呢？","slug":"如果对-age-建立索引-事务-a-这条查询会加什么锁呢","link":"#如果对-age-建立索引-事务-a-这条查询会加什么锁呢","children":[]}]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{},"readingTime":{"minutes":3.57,"words":1071},"filePathRelative":"mysql/06 MySQL的锁机制/记录锁+间隙锁可以防止删除操作而导致的幻读吗.md","excerpt":"<h1> 记录锁+间隙锁可以防止删除操作而导致的幻读吗？</h1>\\n<h2> MySQL 是怎么解决幻读的？</h2>\\n<p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p>\\n<ul>\\n<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，<u>因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</u></li>\\n<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，<u>如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题</u>。</li>\\n</ul>","autoDesc":true}');export{e as data};
