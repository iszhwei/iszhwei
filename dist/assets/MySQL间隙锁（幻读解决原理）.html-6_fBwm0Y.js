const e=JSON.parse('{"key":"v-1029a01f","path":"/mysql/06%20MySQL%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/MySQL%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88%E5%B9%BB%E8%AF%BB%E8%A7%A3%E5%86%B3%E5%8E%9F%E7%90%86%EF%BC%89.html","title":"MySQL间隙锁（幻读解决原理）","lang":"zh-CN","frontmatter":{"title":"MySQL间隙锁（幻读解决原理）","icon":"file","order":3,"headerDepth":4,"category":["mysql"],"tag":["mysql锁机制"],"description":"MySQL间隙锁（幻读解决原理） 一、间隙锁概念 当我们用范围条件而不是相等条件检索数据， 并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)” ，InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁 举例来说， 假如 user 表中只有 101 条记录， 其userid 的值分别是 1,2,…,100,101， 下面的 SQL： select * from user where userid &gt; 100 for update;是一个范围条件的检索，InnoDB 不仅会对符合条件的 userid 值为 101 的记录加锁，也会对userid 大 于 101（但是这些记录并不存在）的\\"间隙\\"加锁，防止其它事务在表的末尾增加数据 InnoDB ，对于上面的例子，要是不使用间隙锁，如果其他事务插入了 userid 大于 100 的任何记录，那么本事务如果再次执行上述语句，就会发生幻读","head":[["meta",{"property":"og:url","content":"https://iszhwei.gitee.io/mysql/06%20MySQL%E7%9A%84%E9%94%81%E6%9C%BA%E5%88%B6/MySQL%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88%E5%B9%BB%E8%AF%BB%E8%A7%A3%E5%86%B3%E5%8E%9F%E7%90%86%EF%BC%89.html"}],["meta",{"property":"og:site_name","content":"张威的编程学习笔记"}],["meta",{"property":"og:title","content":"MySQL间隙锁（幻读解决原理）"}],["meta",{"property":"og:description","content":"MySQL间隙锁（幻读解决原理） 一、间隙锁概念 当我们用范围条件而不是相等条件检索数据， 并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)” ，InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁 举例来说， 假如 user 表中只有 101 条记录， 其userid 的值分别是 1,2,…,100,101， 下面的 SQL： select * from user where userid &gt; 100 for update;是一个范围条件的检索，InnoDB 不仅会对符合条件的 userid 值为 101 的记录加锁，也会对userid 大 于 101（但是这些记录并不存在）的\\"间隙\\"加锁，防止其它事务在表的末尾增加数据 InnoDB ，对于上面的例子，要是不使用间隙锁，如果其他事务插入了 userid 大于 100 的任何记录，那么本事务如果再次执行上述语句，就会发生幻读"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"张威"}],["meta",{"property":"article:tag","content":"mysql锁机制"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL间隙锁（幻读解决原理）\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"张威\\",\\"url\\":\\"https://iszhwei.gitee.io\\"}]}"]]},"headers":[{"level":2,"title":"一、间隙锁概念","slug":"一、间隙锁概念","link":"#一、间隙锁概念","children":[]},{"level":2,"title":"二、测试间隙锁范围加锁","slug":"二、测试间隙锁范围加锁","link":"#二、测试间隙锁范围加锁","children":[{"level":3,"title":"场景1：用不可重复的主键id测试间隙锁","slug":"场景1-用不可重复的主键id测试间隙锁","link":"#场景1-用不可重复的主键id测试间隙锁","children":[]},{"level":3,"title":"场景2：用可重复的age（有索引）测试间隙锁","slug":"场景2-用可重复的age-有索引-测试间隙锁","link":"#场景2-用可重复的age-有索引-测试间隙锁","children":[]},{"level":3,"title":"场景3：MySQL5.7实际情况需要具体分析用的到底是行锁还是表锁","slug":"场景3-mysql5-7实际情况需要具体分析用的到底是行锁还是表锁","link":"#场景3-mysql5-7实际情况需要具体分析用的到底是行锁还是表锁","children":[]}]},{"level":2,"title":"三、测试等值间隙锁","slug":"三、测试等值间隙锁","link":"#三、测试等值间隙锁","children":[{"level":3,"title":"1. 测试不能重复的主键索引","slug":"_1-测试不能重复的主键索引","link":"#_1-测试不能重复的主键索引","children":[]},{"level":3,"title":"2. 测试能重复的辅助索引","slug":"_2-测试能重复的辅助索引","link":"#_2-测试能重复的辅助索引","children":[]},{"level":3,"title":"小结","slug":"小结","link":"#小结","children":[]}]}],"git":{},"readingTime":{"minutes":7.82,"words":2346},"filePathRelative":"mysql/06 MySQL的锁机制/MySQL间隙锁（幻读解决原理）.md","excerpt":"<h1> MySQL间隙锁（幻读解决原理）</h1>\\n<h2> 一、间隙锁概念</h2>\\n<ol>\\n<li>当我们用范围条件而不是相等条件检索数据， 并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)” ，InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁</li>\\n<li>举例来说， 假如 user 表中只有 101 条记录， 其userid 的值分别是 1,2,…,100,101， 下面的 SQL： select * from user where userid &gt; 100 for update;是一个范围条件的检索，InnoDB 不仅会对符合条件的 userid 值为 101 的记录加锁，也会对userid 大 于 101（但是这些记录并不存在）的\\"间隙\\"加锁，防止其它事务在表的末尾增加数据</li>\\n<li>InnoDB <strong></strong> ，对于上面的例子，要是不使用间隙锁，如果其他事务插入了 userid 大于 100 的任何记录，那么本事务如果再次执行上述语句，就会发生幻读</li>\\n</ol>","autoDesc":true}');export{e as data};
