import{_ as a}from"./plugin-vue_export-helper-x3n3nnut.js";import{r,o as d,c as i,d as l,e as o,f as e,w as s,a as t}from"./app--8O2lHwG.js";const u="/assets/image-20240418111306805-0bUGQyXm.png",c="/assets/image-20240418124754255-W-oO3ogF.png",_="/assets/image-20240418143002912-ABgw2KTI.png",p={},g=t('<h1 id="索引的底层实现原理" tabindex="-1"><a class="header-anchor" href="#索引的底层实现原理" aria-hidden="true">#</a> 索引的底层实现原理</h1><p><mark>数据库索引是<strong>存储在磁盘上</strong>的，当数据量大时，就不能把整个索引全部加载到内存了，只能<strong>逐一加载每一个磁盘块（对应索引树的节点</strong>），<u>索引树越低，越“矮胖”，磁盘IO次数就少</u></mark></p><h2 id="avl平衡二叉树索引" tabindex="-1"><a class="header-anchor" href="#avl平衡二叉树索引" aria-hidden="true">#</a> AVL平衡二叉树索引</h2><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>不管是，增加，删除，还是等值查找，<strong>时间复杂度都是O(logn)</strong>，n 是数据页的数目。并且<strong>支持范围查找</strong>。</p>',5),h=t('<blockquote><p>数据、索引都是存放在磁盘上，MySQL Server查询数据时需要花费磁盘IO<strong>按块读取数据</strong>（块一般为16K，内存页面的整数倍）读到内存中</p><p>c/c++分配内存：</p><p>malloc/new 4字节时，实际上内核的内存管理是<strong>按页面</strong>（4K）为单位的，如果返回了2个页面，<code>2 * 4K =8K</code>有8K字节，剩余的字节 <code>8k - 4</code>个字节有libc.so或libc++.so库的malloc实现ptmalloc(c库)或者tcmalloc（c++库）来管理</p><ul><li>缓存，下次再申请内存时直接在ptmalloc或者tcmalloc上申请，不需要访问内核空间</li></ul></blockquote><blockquote><p>树的层数=log<sub>2</sub>N=log<sub>10</sub>N/log<sub>10</sub>2=logN/log2</p><ul><li>写代码时需要<strong>强转换成int</strong>类型，否则有小数 <code>for(i=0;i&lt; (int)(log(N)/log(2));i++) </code></li><li>2000W数据，最坏情况（这些节点都不在一个磁盘块上，一次磁盘IO读取的数据放在一个节点上）下读取一个索引就需要25次磁盘IO</li><li>若m=500阶的平衡树处理log20000000/log500大约需要3次IO就可以</li></ul></blockquote><h2 id="b树索引" tabindex="-1"><a class="header-anchor" href="#b树索引" aria-hidden="true">#</a> B树索引</h2><p>MySQL支持两种索引，一种的<strong>B-树索引</strong>（但实际上MySQL采用的是B+树结构），一种是<strong>哈希索引</strong>，大家知道，B-树和哈希表在数据<strong>查询时</strong>的效率是非常高的。</p><p>B-树是一种<strong>m阶平衡树</strong>，<strong>叶子节点都在同一层</strong>，<u>由于每一个节点存储的数据量比较大，索引整个B-树的层数是非常低的，基本上不超过三层。</u></p>',5),B=l("u",null,"一次磁盘I/O把一个磁盘块的数据全部存储下来",-1),m=l("strong",null,"磁盘I/O的操作次数是最少的",-1),b=t(`<p>MyISAM: <code>*.MYD *.MYI</code></p><p>InnoDB: <code>*.ibd</code></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="shiki one-dark-pro" style="background-color:#282c34;" tabindex="0"><code><span class="line"><span style="color:#C678DD;">select</span><span style="color:#ABB2BF;"> * </span><span style="color:#C678DD;">from</span><span style="color:#ABB2BF;"> student </span><span style="color:#C678DD;">where</span><span style="color:#ABB2BF;"> </span><span style="color:#C678DD;">uid</span><span style="color:#56B6C2;">=</span><span style="color:#D19A66;">5</span><span style="color:#ABB2BF;">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,3),f=l("p",null,[l("strong",null,"没有索引只能做整表搜索，比较慢"),o("(一行行的搜索)；有索引则加载索引，构建成B树")],-1),y=l("figure",null,[l("img",{src:c,alt:"",tabindex:"0",loading:"lazy"}),l("figcaption")],-1),k=l("li",null,[l("p",null,"键值就是索引值，比如以name为索引，紫色键值存放的就是name")],-1),I=l("li",null,[l("p",null,[l("mark",null,[o("每个节点的数据都是有序的，因此在一个节点内的搜索是"),l("strong",null,"二分搜索"),o("log"),l("sub",null,"2"),o("N O(logN)")])])],-1),O=l("sub",null,"2",-1),x=l("li",null,[l("u",null,"不是读取全部的索引加载到内存，磁盘读取是按块读取，B-树的节点大小一般设置为和磁盘块大小一致")],-1),D=t('<h3 id="data-存储的是数据本身内容-还是磁盘上的地址" tabindex="-1"><a class="header-anchor" href="#data-存储的是数据本身内容-还是磁盘上的地址" aria-hidden="true">#</a> data：存储的是数据本身内容？还是磁盘上的地址？？</h3><p>这主要看是什么存储引擎，MyISAM数据和索引分开存储，因此存放的是数据在磁盘上的地址；InnoDB数据和索引存放在同一文件，因此data为数据的内容</p><h2 id="b-树" tabindex="-1"><a class="header-anchor" href="#b-树" aria-hidden="true">#</a> B+树</h2><h3 id="为什么mysql-myisam和innodb-索引底层选择b-树而不是b树呢" tabindex="-1"><a class="header-anchor" href="#为什么mysql-myisam和innodb-索引底层选择b-树而不是b树呢" aria-hidden="true">#</a> 为什么MySQL(MyISAM和InnoDB)索引底层选择B+树而不是B树呢？？？</h3>',4),M=l("p",null,"由上面的三个原因，因此选B+树来构建索引",-1),N=l("figure",null,[l("img",{src:_,alt:"",tabindex:"0",loading:"lazy"}),l("figcaption")],-1),v=l("u",null,"有序的链表",-1),A=l("strong",null,"索引树的搜素",-1),q=l("strong",null,"整表搜索",-1),S=l("li",null,[o("做"),l("strong",null,"范围查询"),o("的时候，直接遍历叶子节点的有序链表即可！！")],-1),w=l("sub",null,"2",-1),C=l("h3",{id:"总结回答为什么使用b-树构建索引",tabindex:"-1"},[l("a",{class:"header-anchor",href:"#总结回答为什么使用b-树构建索引","aria-hidden":"true"},"#"),o(" 总结回答为什么使用B+树构建索引？")],-1),L=l("ol",null,[l("li",null,"B-树的每一个节点，存了关键字和对应的数据地址，而B+树的非叶子节点只存关键字，不存数据地址。因此B+树的每一个非叶子节点存储的关键字是远远多于B-树的，B+树的叶子节点存放关键字和数据，因此，从树的高度上来说，B+树的高度要小于B-树，使用的磁盘I/O次数少，因此查询会更快一些。"),l("li",null,"B-树由于每个节点都存储关键字和数据，因此离根节点进的数据，查询的就快，离根节点远的数据，查询的就慢；B+树所有的数据都存在叶子节点上，因此在B+树上搜索关键字，找到对应数据的时间是比较平均的，没有快慢之分。"),l("li",null,"在B-树上如果做区间查找，遍历的节点是非常多的；B+树所有叶子节点被连接成了有序链表结构，因此做整表遍历和区间查找是非常容易的。")],-1);function K(Q,V){const n=r("font");return d(),i("div",null,[g,l("p",null,[o("但是当"),e(n,{color:"red"},{default:s(()=>[o("数据量比较大，页的数目很多时，二叉树的高度会比较高。IO 的次数会比较多")]),_:1}),o("。查找效率低。")]),h,l("p",null,[o("由于磁盘的读取也是按block块操作的（内存是按page页面操作的），因此**"),e(n,{color:"red"},{default:s(()=>[o("B-树的节点大小一般设置为和磁盘块大小一致")]),_:1}),o("**，这样一个B-树节点，就可以通过"),B,o("，所以当使用B-树存储索引的时候，"),m,o("（"),e(n,{color:"red"},{default:s(()=>[o("MySQL的读写效率，主要集中在磁盘I/O上")]),_:1}),o("）。")]),l("blockquote",null,[b,l("p",null,[l("mark",null,[l("strong",null,[e(n,{color:"red"},{default:s(()=>[o("索引搜索的原理")]),_:1}),o("：先检查where过滤字段是否有索引，uid有索引 =》 存储引擎 =》kernel =》 磁盘IO（读索引文件）=》内存上 =》用索引文的数据构建B树，B树的好处是减少磁盘IO加速搜索")])])]),f]),y,l("ul",null,[k,I,l("li",null,[l("p",null,[l("mark",null,[o("单纯看内存上搜索都是O(logN)和AVL树一样，但是好处在于**"),e(n,{color:"green"},{default:s(()=>[o("磁盘IO次数少")]),_:1}),o("**")])])]),l("li",null,[l("p",null,[o("**即索引搜索涉及"),e(n,{color:"red"},{default:s(()=>[o("两个过程")]),_:1}),o("，一个是读取索引文件到内存上构建B树的磁盘IO，另一个就是在内存上B树的搜索是log"),O,o("N **")]),l("ul",null,[x,l("li",null,[o("如m=500搜2000W的数据，"),e(n,{color:"red"},{default:s(()=>[o("磁盘IO花费3次")]),_:1}),o("，内存上搜索25次")])])])]),D,l("p",null,[o("B树**"),e(n,{color:"red"},{default:s(()=>[o("索引和数据是一起存放的")]),_:1}),o("**")]),l("ol",null,[l("li",null,[l("p",null,[o("B树的 索引+数据内容 分散在不同的节点上，离根节点近，搜索就快；离根节点远，搜索就慢！ 因此，花费的"),e(n,{color:"red"},{default:s(()=>[o("磁盘IO次数不平均")]),_:1}),o("，每一次数据花费的时间也不平均")])]),l("li",null,[l("p",null,[o("每一个非叶子节点上，不仅要存储 索引（key），还要存储索引值所在的哪一行的data的数据。因此一个节点"),e(n,{color:"red"},{default:s(()=>[o("存放的索引key的个数")]),_:1}),o("，比只存放key值的节点要"),e(n,{color:"red"},{default:s(()=>[o("少")]),_:1}),o("得多！")])]),l("li",null,[l("p",null,[o("B树不方便做"),e(n,{color:"red"},{default:s(()=>[o("范围搜索，整表遍历")]),_:1}),o("看起来也不方便")])])]),M,N,l("ul",null,[l("li",null,[o("每一个非叶子节点只存放key，不存储data! "),l("ul",null,[l("li",null,[o("每一个节点存放的key值更多，因此B+树理论上来说，"),e(n,{color:"green"},{default:s(()=>[o("层数会更低")]),_:1}),o("一些，搜索的效率会更好一些")])])]),l("li",null,[o("叶子节点上存储了所有的索引值以及对应的data "),l("ul",null,[l("li",null,[o("搜索每一个索引对应的值data，都需要跑到叶子节点，这样每一行记录搜索的"),e(n,{color:"green"},{default:s(()=>[o("时间比较平均")]),_:1})])])]),l("li",null,[o("叶子节点被串在一个链表当中，形成了一个"),v,l("ul",null,[l("li",null,[o("如果要进行"),A,o("或者"),q,o("，直接"),e(n,{color:"green"},{default:s(()=>[o("遍历链表")]),_:1}),o("即可！！")]),S])])]),l("blockquote",null,[l("p",null,[l("mark",null,[l("strong",null,[e(n,{color:"red"},{default:s(()=>[o("索引搜索的原理")]),_:1}),o("：先检查where过滤字段是否有索引，没有索引就做整表搜索，效率比较低；如果有索引，操作系统内核kernel花费磁盘IO，读索引文件到内存上 ，用索引文的数据构建B+树，因为B+树是平衡树，搜索效率比较高；而且是一个节点一个节点构建，一个节点对应一个磁盘IO，非叶子叶节点只存储key，单个节点存储的key值比较多，所有的key和data都是存在叶子节点，"),e(n,{color:"red"},{default:s(()=>[o("所以使用B+树构建索引树会以花费最少IO次数、二分搜索的次数log"),w,o("N来找索引对应的数据")]),_:1})])])])]),C,L])}const W=a(p,[["render",K],["__file","索引的底层实现原理.html.vue"]]);export{W as default};
