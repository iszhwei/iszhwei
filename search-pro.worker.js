const nt="ENTRIES",V="KEYS",T="VALUES",F="";class D{set;_type;_path;constructor(t,s){const n=t._tree,u=Array.from(n.keys());this.set=t,this._type=s,this._path=u.length>0?[{node:n,keys:u}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=E(this._path);if(E(s)===F)return{done:!1,value:this.result()};const n=t.get(E(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=E(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>E(t)).filter(t=>t!==F).join("")}value(){return E(this._path).node.get(F)}result(){switch(this._type){case T:return this.value();case V:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const E=e=>e[e.length-1],ut=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const u=t.length+1,o=u+s,i=new Uint8Array(o*u).fill(s+1);for(let r=0;r<u;++r)i[r]=r;for(let r=1;r<o;++r)i[r*u]=r;return R(e,t,s,n,i,1,u,""),n},R=(e,t,s,n,u,o,i,r)=>{const d=o*i;t:for(const l of e.keys())if(l===F){const a=u[d-1];a<=s&&n.set(r,[e.get(l),a])}else{let a=o;for(let h=0;h<l.length;++h,++a){const m=l[h],p=i*a,f=p-i;let c=u[p];const g=Math.max(0,a-s-1),_=Math.min(i-1,a+s);for(let y=g;y<_;++y){const b=m!==t[y],z=u[f+y]+ +b,A=u[f+y+1]+1,w=u[p+y]+1,L=u[p+y+1]=Math.min(z,A,w);L<c&&(c=L)}if(c>s)continue t}R(e.get(l),t,s,n,u,a,i,r+l)}};class C{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=x(this._tree,t.slice(this._prefix.length));if(s===void 0){const[u,o]=M(n);for(const i of u.keys())if(i!==F&&i.startsWith(o)){const r=new Map;return r.set(i.slice(o.length),u.get(i)),new C(r,t)}}return new C(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new D(this,nt)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return ut(this._tree,t,s)}get(t){const s=I(this._tree,t);return s!==void 0?s.get(F):void 0}has(t){const s=I(this._tree,t);return s!==void 0&&s.has(F)}keys(){return new D(this,V)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,O(this._tree,t).set(F,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);return n.set(F,s(n.get(F))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=O(this._tree,t);let u=n.get(F);return u===void 0&&n.set(F,u=s()),u}values(){return new D(this,T)}[Symbol.iterator](){return this.entries()}static from(t){const s=new C;for(const[n,u]of t)s.set(n,u);return s}static fromObject(t){return C.from(Object.entries(t))}}const x=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==F&&t.startsWith(n))return s.push([e,n]),x(e.get(n),t.slice(n.length),s);return s.push([e,t]),x(void 0,"",s)},I=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==F&&t.startsWith(s))return I(e.get(s),t.slice(s.length))},O=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const o of e.keys())if(o!==F&&t[n]===o[0]){const i=Math.min(s-n,o.length);let r=1;for(;r<i&&t[n+r]===o[r];)++r;const d=e.get(o);if(r===o.length)e=d;else{const l=new Map;l.set(o.slice(r),d),e.set(t.slice(n,n+r),l),e.delete(o),e=l}n+=r;continue t}const u=new Map;return e.set(t.slice(n),u),u}return e},ot=(e,t)=>{const[s,n]=x(e,t);if(s!==void 0){if(s.delete(F),s.size===0)W(n);else if(s.size===1){const[u,o]=s.entries().next().value;q(n,u,o)}}},W=e=>{if(e.length===0)return;const[t,s]=M(e);if(t.delete(s),t.size===0)W(e.slice(0,-1));else if(t.size===1){const[n,u]=t.entries().next().value;n!==F&&q(e.slice(0,-1),n,u)}},q=(e,t,s)=>{if(e.length===0)return;const[n,u]=M(e);n.set(u+t,s),n.delete(u)},M=e=>e[e.length-1],it=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},rt=/[\n\r -#%-*,-/:;?@[-\]_{}\u00A0\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u1680\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2000-\u200A\u2010-\u2029\u202F-\u2043\u2045-\u2051\u2053-\u205F\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u3000-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]+/u,S="or",$="and",ct="and_not",lt=(e,t)=>{e.includes(t)||e.push(t)},P=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},N=({score:e},{score:t})=>t-e,ht=()=>new Map,k=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,dt={[S]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:u,terms:o,match:i}=t.get(s);n.score=n.score+u,n.match=Object.assign(n.match,i),P(n.terms,o)}}return e},[$]:(e,t)=>{const s=new Map;for(const n of t.keys()){const u=e.get(n);if(u==null)continue;const{score:o,terms:i,match:r}=t.get(n);P(u.terms,i),s.set(n,{score:u.score+o,terms:u.terms,match:Object.assign(u.match,r)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},at=(e,t,s,n,u,o)=>{const{k:i,b:r,d}=o;return Math.log(1+(s-t+.5)/(t+.5))*(d+e*(i+1)/(e+i*(1-r+r*n/u)))},ft=e=>(t,s,n)=>{const u=typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy||!1,o=typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0;return{term:t,fuzzy:u,prefix:o}},H=(e,t,s,n)=>{for(const u of Object.keys(e._fieldIds))if(e._fieldIds[u]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${u}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},gt=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const u=e._index.fetch(n,ht),o=u.get(t);o==null||o.get(s)==null?H(e,s,t,n):o.get(s)<=1?o.size<=1?u.delete(t):o.delete(s):o.set(s,o.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},pt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(rt),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:S,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},Ft={combineWith:$,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},U={minDirtFactor:.1,minDirtCount:20},yt={..._t,...U},Y=(e,t=S)=>{if(e.length===0)return new Map;const s=t.toLowerCase();return e.reduce(dt[s])||new Map},B=(e,t,s,n,u,o,i,r,d=new Map)=>{if(u==null)return d;for(const l of Object.keys(o)){const a=o[l],h=e._fieldIds[l],m=u.get(h);if(m==null)continue;let p=m.size;const f=e._avgFieldLength[h];for(const c of m.keys()){if(!e._documentIds.has(c)){gt(e,h,c,s),p-=1;continue}const g=i?i(e._documentIds.get(c),s,e._storedFields.get(c)):1;if(!g)continue;const _=m.get(c),y=e._fieldLength.get(c)[h],b=at(_,p,e._documentCount,y,f,r),z=n*a*g*b,A=d.get(c);if(A){A.score+=z,lt(A.terms,t);const w=G(A.match,s);w?w.push(l):A.match[s]=[l]}else d.set(c,{score:z,terms:[t],match:{[s]:[l]}})}}return d},At=(e,t,s)=>{const n={...e._options.searchOptions,...s},u=(n.fields||e._options.fields).reduce((c,g)=>({...c,[g]:G(n.boost,g)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:r,bm25:d}=n,{fuzzy:l,prefix:a}={...J.weights,...i},h=e._index.get(t.term),m=B(e,t.term,t.term,1,h,u,o,d);let p,f;if(t.prefix&&(p=e._index.atPrefix(t.term)),t.fuzzy){const c=t.fuzzy===!0?.2:t.fuzzy,g=c<1?Math.min(r,Math.round(t.term.length*c)):c;g&&(f=e._index.fuzzyGet(t.term,g))}if(p)for(const[c,g]of p){const _=c.length-t.term.length;if(!_)continue;f?.delete(c);const y=a*c.length/(c.length+.3*_);B(e,t.term,c,y,g,u,o,d,m)}if(f)for(const c of f.keys()){const[g,_]=f.get(c);if(!_)continue;const y=l*c.length/(c.length+_);B(e,t.term,c,y,g,u,o,d,m)}return m},X=(e,t,s={})=>{if(typeof t!="string"){const a={...s,...t,queries:void 0},h=t.queries.map(m=>X(e,m,a));return Y(h,a.combineWith)}const{tokenize:n,processTerm:u,searchOptions:o}=e._options,i={tokenize:n,processTerm:u,...o,...s},{tokenize:r,processTerm:d}=i,l=r(t).flatMap(a=>d(a)).filter(a=>!!a).map(ft(i)).map(a=>At(e,a,i));return Y(l,i.combineWith)},K=(e,t,s={})=>{const n=X(e,t,s),u=[];for(const[o,{score:i,terms:r,match:d}]of n){const l=r.length,a={id:e._documentIds.get(o),score:i*l,terms:Object.keys(d),match:d};Object.assign(a,e._storedFields.get(o)),(s.filter==null||s.filter(a))&&u.push(a)}return u.sort(N),u},Ct=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:o,terms:i}of K(e,t,s)){const r=i.join(" "),d=n.get(r);d!=null?(d.score+=o,d.count+=1):n.set(r,{score:o,terms:i,count:1})}const u=[];for(const[o,{score:i,terms:r,count:d}]of n)u.push({suggestion:o,terms:r,score:i/d});return u.sort(N),u};class Et{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...pt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions||{}},autoSuggestOptions:{...Ft,...t.autoSuggestOptions||{}}},this._index=new C,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=U,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const u={};for(const[o,i]of n)u[o]=Object.fromEntries(i);t.push([s,u])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const zt=({index:e,documentCount:t,nextId:s,documentIds:n,fieldIds:u,fieldLength:o,averageFieldLength:i,storedFields:r,dirtCount:d,serializationVersion:l},a)=>{if(l!==1&&l!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const h=new Et(a);h._documentCount=t,h._nextId=s,h._documentIds=k(n),h._idToShortId=new Map,h._fieldIds=u,h._fieldLength=k(o),h._avgFieldLength=i,h._storedFields=k(r),h._dirtCount=d||0,h._index=new C;for(const[m,p]of h._documentIds)h._idToShortId.set(p,m);for(const[m,p]of e){const f=new Map;for(const c of Object.keys(p)){let g=p[c];l===1&&(g=g.ds),f.set(parseInt(c,10),k(g))}h._index.set(m,f)}return h},Q=Object.entries,wt=Object.fromEntries,j=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),u=[];let o=0,i=0;const r=(l,a=!1)=>{let h="";i===0?h=l.length>20?`… ${l.slice(-20)}`:l:a?h=l.length+i>100?`${l.slice(0,100-i)}… `:l:h=l.length>20?`${l.slice(0,20)} … ${l.slice(-20)}`:l,h&&u.push(h),i+=h.length,a||(u.push(["mark",t]),i+=t.length,i>=100&&u.push(" …"))};let d=s.indexOf(n,o);if(d===-1)return null;for(;d>=0;){const l=d+n.length;if(r(e.slice(o,d)),o=l,i>100)break;d=s.indexOf(n,o)}return i<100&&r(e.slice(o),!0),u},Z=/[\u4e00-\u9fa5]/g,tt=(e={})=>({fuzzy:.2,prefix:!0,processTerm:t=>{const s=t.match(Z)||[],n=t.replace(Z,"").toLowerCase();return n?[n,...s]:[...s]},...e}),xt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),kt=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),et=(e,t,s={})=>{const n={};return K(t,e,tt({boost:{h:2,t:1,c:4},...s})).forEach(u=>{const{id:o,terms:i,score:r}=u,d=o.includes("@"),l=o.includes("#"),[a,h]=o.split(/[#@]/),m=i.sort((f,c)=>f.length-c.length).filter((f,c)=>i.slice(c+1).every(g=>!g.includes(f))),{contents:p}=n[a]??={title:"",contents:[]};if(d)p.push([{type:"customField",key:a,index:h,display:m.map(f=>u.c.map(c=>j(c,f))).flat().filter(f=>f!==null)},r]);else{const f=m.map(c=>j(u.h,c)).filter(c=>c!==null);if(f.length&&p.push([{type:l?"heading":"title",key:a,...l&&{anchor:h},display:f},r]),"t"in u)for(const c of u.t){const g=m.map(_=>j(c,_)).filter(_=>_!==null);g.length&&p.push([{type:"text",key:a,...l&&{anchor:h},display:g},r])}}}),Q(n).sort(([,u],[,o])=>"max"==="total"?xt(u,o):kt(u,o)).map(([u,{title:o,contents:i}])=>{if(!o){const r=it(t,u);r&&(o=r.h)}return{title:o,contents:i.map(([r])=>r)}})},st=(e,t,s={})=>Ct(t,e,tt(s)).map(({suggestion:n})=>n),v=wt(Q(JSON.parse("{\"/\":{\"documentCount\":1960,\"nextId\":1960,\"documentIds\":{\"0\":\"v-184f4da6\",\"1\":\"v-8daa1a0e\",\"2\":\"v-3a1d2930\",\"3\":\"v-3a1d2930#基因序列比对工具-mutialin\",\"4\":\"v-3a1d2930#工具内容\",\"5\":\"v-3a1d2930#使用方法\",\"6\":\"v-3a1d2930#回答两点\",\"7\":\"v-144c90e3\",\"8\":\"v-08062d61\",\"9\":\"v-08062d61@0\",\"10\":\"v-08062d61@1\",\"11\":\"v-1a144c13\",\"12\":\"v-1a144c13@0\",\"13\":\"v-1a144c13@1\",\"14\":\"v-1464ca76\",\"15\":\"v-f0383c18\",\"16\":\"v-40bd95c1\",\"17\":\"v-40bd95c1#文件的分类\",\"18\":\"v-40bd95c1@0\",\"19\":\"v-40bd95c1@1\",\"20\":\"v-eb072ff4\",\"21\":\"v-24f2d5ba\",\"22\":\"v-450e8862\",\"23\":\"v-450e8862@0\",\"24\":\"v-450e8862@1\",\"25\":\"v-dc384366\",\"26\":\"v-4628d8d3\",\"27\":\"v-4628d8d3#脚本开机自启\",\"28\":\"v-4628d8d3#使用\",\"29\":\"v-4628d8d3#编写typora修改颜色的快捷键\",\"30\":\"v-4628d8d3#代码解释\",\"31\":\"v-25b47c13\",\"32\":\"v-7945696f\",\"33\":\"v-7945696f#设置输入法兼容旧版本-否则使用sourceinsight会卡死\",\"34\":\"v-7945696f#新建文件夹-将工程文件放在源码的附近\",\"35\":\"v-7945696f#源码加进来后记得同步一下\",\"36\":\"v-7945696f#需要将-cc类型配置到c-文件类型里\",\"37\":\"v-7945696f#高亮设置\",\"38\":\"v-7945696f#高亮快捷键修改\",\"39\":\"v-7945696f#高亮当前行\",\"40\":\"v-7945696f#高亮当前选中\",\"41\":\"v-7945696f#查找定位及reference等功能\",\"42\":\"v-7945696f#设置注释与反注释的快捷键\",\"43\":\"v-5095ca42\",\"44\":\"v-5095ca42#右键新建文件中没有-md\",\"45\":\"v-5095ca42#新建markdown时使用模板\",\"46\":\"v-5095ca42#微软输入法自定义快捷键快速修改日期\",\"47\":\"v-5095ca42#增加快捷键修改颜色功能\",\"48\":\"v-5095ca42#修改下划线的颜色和高度\",\"49\":\"v-5095ca42#设置代码快边框的样式\",\"50\":\"v-5095ca42#修改加粗样式\",\"51\":\"v-5095ca42#标题、目录、大纲自动编号\",\"52\":\"v-5095ca42#添加代码块折叠按钮\",\"53\":\"v-5095ca42#在单个代码块添加代码收缩按钮\",\"54\":\"v-5095ca42#添加收缩文件全部代码块按钮\",\"55\":\"v-5095ca42#文档间锚点、文档间跳转返回、突破typora的iframe登录限制、代码块收缩\",\"56\":\"v-5095ca42#文档间锚点\",\"57\":\"v-5095ca42#文档间跳转返回\",\"58\":\"v-5095ca42#突破typora的iframe登录限制\",\"59\":\"v-5095ca42#代码块收缩\",\"60\":\"v-5095ca42#typora清理不用的图片\",\"61\":\"v-5095ca42#给typora的代码块设置默认语言\",\"62\":\"v-5095ca42#如何设置高亮快捷键\",\"63\":\"v-5095ca42#win10上typora卡顿的问题及其解决方案\",\"64\":\"v-5095ca42#上万字后打字出现卡顿\",\"65\":\"v-5095ca42#关闭微软输入法的兼容模式\",\"66\":\"v-5095ca42#为typora选择使用-高性能-nvidia处理器\",\"67\":\"v-0072b68a\",\"68\":\"v-0072b68a@0\",\"69\":\"v-0072b68a@1\",\"70\":\"v-4a6b903e\",\"71\":\"v-4a6b903e@0\",\"72\":\"v-4a6b903e@1\",\"73\":\"v-92d2378e\",\"74\":\"v-92d2378e@0\",\"75\":\"v-92d2378e@1\",\"76\":\"v-3945022c\",\"77\":\"v-3945022c#同向双指针法\",\"78\":\"v-3945022c#相向双指针法\",\"79\":\"v-3945022c@0\",\"80\":\"v-3945022c@1\",\"81\":\"v-0edaacb7\",\"82\":\"v-0edaacb7@0\",\"83\":\"v-0edaacb7@1\",\"84\":\"v-8fe9fd22\",\"85\":\"v-8fe9fd22@0\",\"86\":\"v-8fe9fd22@1\",\"87\":\"v-69d65be6\",\"88\":\"v-69d65be6@0\",\"89\":\"v-69d65be6@1\",\"90\":\"v-a277331a\",\"91\":\"v-a277331a#使用条件\",\"92\":\"v-a277331a#基础版\",\"93\":\"v-a277331a#左闭右闭\",\"94\":\"v-a277331a#左闭右开\",\"95\":\"v-a277331a#升级版-可以有重复值\",\"96\":\"v-a277331a#最左值\",\"97\":\"v-a277331a#最右值\",\"98\":\"v-a277331a@0\",\"99\":\"v-a277331a@1\",\"100\":\"v-2e7fb111\",\"101\":\"v-2e7fb111#数组的实现\",\"102\":\"v-2e7fb111@0\",\"103\":\"v-2e7fb111@1\",\"104\":\"v-75ce370a\",\"105\":\"v-75ce370a@0\",\"106\":\"v-75ce370a@1\",\"107\":\"v-1f0c41ec\",\"108\":\"v-1f0c41ec@0\",\"109\":\"v-1f0c41ec@1\",\"110\":\"v-98398990\",\"111\":\"v-98398990@0\",\"112\":\"v-98398990@1\",\"113\":\"v-752e9b82\",\"114\":\"v-752e9b82#方法一\",\"115\":\"v-752e9b82#方法二\",\"116\":\"v-752e9b82@0\",\"117\":\"v-752e9b82@1\",\"118\":\"v-c01690d8\",\"119\":\"v-c01690d8@0\",\"120\":\"v-c01690d8@1\",\"121\":\"v-74d93789\",\"122\":\"v-74d93789@0\",\"123\":\"v-74d93789@1\",\"124\":\"v-155542a2\",\"125\":\"v-155542a2#方法一-哈希\",\"126\":\"v-155542a2#方法二-双指针\",\"127\":\"v-155542a2@0\",\"128\":\"v-155542a2@1\",\"129\":\"v-6e9dbc4c\",\"130\":\"v-6e9dbc4c@0\",\"131\":\"v-6e9dbc4c@1\",\"132\":\"v-cdbdf9f8\",\"133\":\"v-cdbdf9f8#方法一-双指针🍗\",\"134\":\"v-cdbdf9f8#去重逻辑的思考🍔🍔🍔\",\"135\":\"v-cdbdf9f8#a的去重\",\"136\":\"v-cdbdf9f8#b与c的去重\",\"137\":\"v-cdbdf9f8#方法二-哈希表-思想\",\"138\":\"v-cdbdf9f8@0\",\"139\":\"v-cdbdf9f8@1\",\"140\":\"v-21edb74e\",\"141\":\"v-21edb74e#方法一-哈希\",\"142\":\"v-21edb74e#方法二-二分查找\",\"143\":\"v-21edb74e#方法三-双指针法\",\"144\":\"v-21edb74e@0\",\"145\":\"v-21edb74e@1\",\"146\":\"v-525b6569\",\"147\":\"v-525b6569#分析\",\"148\":\"v-525b6569#方法一-快慢指针\",\"149\":\"v-525b6569#方法二-哈希表\",\"150\":\"v-525b6569@0\",\"151\":\"v-525b6569@1\",\"152\":\"v-30fc6476\",\"153\":\"v-30fc6476#方法一\",\"154\":\"v-30fc6476#方法二-利用不能重复的特点-思路\",\"155\":\"v-30fc6476#map\",\"156\":\"v-30fc6476@0\",\"157\":\"v-30fc6476@1\",\"158\":\"v-30a803f7\",\"159\":\"v-30a803f7@0\",\"160\":\"v-30a803f7@1\",\"161\":\"v-115ac7e7\",\"162\":\"v-115ac7e7#分析\",\"163\":\"v-115ac7e7#lower-bound-和upper-bound\",\"164\":\"v-115ac7e7@0\",\"165\":\"v-115ac7e7@1\",\"166\":\"v-534e82f8\",\"167\":\"v-534e82f8@0\",\"168\":\"v-534e82f8@1\",\"169\":\"v-e58201ee\",\"170\":\"v-e58201ee#数组做哈希表\",\"171\":\"v-e58201ee#unordered-set做哈希表\",\"172\":\"v-e58201ee@0\",\"173\":\"v-e58201ee@1\",\"174\":\"v-21b182ee\",\"175\":\"v-21b182ee@0\",\"176\":\"v-21b182ee@1\",\"177\":\"v-deb0c8ec\",\"178\":\"v-deb0c8ec#方法一-哈希表\",\"179\":\"v-deb0c8ec#方法二-排序-双指针\",\"180\":\"v-deb0c8ec@0\",\"181\":\"v-deb0c8ec@1\",\"182\":\"v-eeb8a63a\",\"183\":\"v-eeb8a63a@0\",\"184\":\"v-eeb8a63a@1\",\"185\":\"v-c84ce682\",\"186\":\"v-c84ce682@0\",\"187\":\"v-c84ce682@1\",\"188\":\"v-1a50115e\",\"189\":\"v-1a50115e@0\",\"190\":\"v-1a50115e@1\",\"191\":\"v-53acd735\",\"192\":\"v-53acd735@0\",\"193\":\"v-53acd735@1\",\"194\":\"v-00fc7494\",\"195\":\"v-00fc7494#性能\",\"196\":\"v-00fc7494#为何堆排序是不稳定排序\",\"197\":\"v-00fc7494@0\",\"198\":\"v-00fc7494@1\",\"199\":\"v-380a6c84\",\"200\":\"v-380a6c84@0\",\"201\":\"v-380a6c84@1\",\"202\":\"v-4b65c060\",\"203\":\"v-4b65c060@0\",\"204\":\"v-4b65c060@1\",\"205\":\"v-0cc447aa\",\"206\":\"v-0cc447aa@0\",\"207\":\"v-0cc447aa@1\",\"208\":\"v-64dd32fe\",\"209\":\"v-64dd32fe@0\",\"210\":\"v-64dd32fe@1\",\"211\":\"v-85d8c71c\",\"212\":\"v-85d8c71c#计数排序应用场景\",\"213\":\"v-85d8c71c#步骤\",\"214\":\"v-85d8c71c#代码实现\",\"215\":\"v-85d8c71c@0\",\"216\":\"v-85d8c71c@1\",\"217\":\"v-64c90a94\",\"218\":\"v-64c90a94@0\",\"219\":\"v-64c90a94@1\",\"220\":\"v-155d00d3\",\"221\":\"v-155d00d3@0\",\"222\":\"v-155d00d3@1\",\"223\":\"v-f1165cc2\",\"224\":\"v-f1165cc2#顺序栈的实现\",\"225\":\"v-f1165cc2@0\",\"226\":\"v-f1165cc2@1\",\"227\":\"v-038e0b34\",\"228\":\"v-038e0b34#d-和-s的区别\",\"229\":\"v-038e0b34@0\",\"230\":\"v-038e0b34@1\",\"231\":\"v-403c82cd\",\"232\":\"v-403c82cd#栈空间\",\"233\":\"v-403c82cd#esp和ebp\",\"234\":\"v-403c82cd#🍗🍗🍗示例\",\"235\":\"v-403c82cd#在main函数的入口和退出-会进行入栈操作-进行出栈操作\",\"236\":\"v-403c82cd#main函数内\",\"237\":\"v-403c82cd#函数调用参数的压栈顺序-参数由右向左压入堆栈。\",\"238\":\"v-403c82cd#执行call-sum-0f8108ch-执行call\",\"239\":\"v-403c82cd#栈空间大小\",\"240\":\"v-403c82cd#栈溢出\",\"241\":\"v-403c82cd@0\",\"242\":\"v-403c82cd@1\",\"243\":\"v-5aef7a82\",\"244\":\"v-5aef7a82#重点\",\"245\":\"v-5aef7a82#链接主要工作🍔\",\"246\":\"v-5aef7a82#示例\",\"247\":\"v-5aef7a82#编译阶段\",\"248\":\"v-5aef7a82#查看符号表\",\"249\":\"v-5aef7a82#查看main-o符号表\",\"250\":\"v-5aef7a82#查看sum-o符号表\",\"251\":\"v-5aef7a82#分析main-o文件头\",\"252\":\"v-5aef7a82#打印目标文件各个段\",\"253\":\"v-5aef7a82#分析main-o的-text段\",\"254\":\"v-5aef7a82#链接阶段\",\"255\":\"v-5aef7a82#链接的过程🍔🍔🍔\",\"256\":\"v-5aef7a82#可执行文件\",\"257\":\"v-5aef7a82#查看可执行文件a-out的符号表\",\"258\":\"v-5aef7a82#分析可执行文件的elf头\",\"259\":\"v-5aef7a82#再看一下a-out的汇编代码\",\"260\":\"v-5aef7a82#objdump-s查看汇编\",\"261\":\"v-5aef7a82#gdb查看汇编\",\"262\":\"v-5aef7a82#查看可执行程序的program-headers段\",\"263\":\"v-5aef7a82#物理内存和虚拟内存映射🍗🍗🍗\",\"264\":\"v-5aef7a82#进阶阅读\",\"265\":\"v-5aef7a82@0\",\"266\":\"v-5aef7a82@1\",\"267\":\"v-4d611284\",\"268\":\"v-4d611284@0\",\"269\":\"v-4d611284@1\",\"270\":\"v-f103c4b8\",\"271\":\"v-f103c4b8#为了代码分块-比仅仅使用-更直观些。例如在cocos2d-x代码中\",\"272\":\"v-f103c4b8#宏展开的时候不会出错\",\"273\":\"v-f103c4b8#不使用-把action1-、action2-包起来\",\"274\":\"v-f103c4b8#使用-把action1-、action2-包起来\",\"275\":\"v-f103c4b8#使用do-while-0-来定义宏\",\"276\":\"v-f103c4b8#用到空宏\",\"277\":\"v-f103c4b8#我想跳到另外一段代码了-剩下的不执行了\",\"278\":\"v-f103c4b8@0\",\"279\":\"v-f103c4b8@1\",\"280\":\"v-fd4b7500\",\"281\":\"v-fd4b7500#前言\",\"282\":\"v-fd4b7500#malloc概述\",\"283\":\"v-fd4b7500#小于128k的内存分配\",\"284\":\"v-fd4b7500#大于128k的内存分配\",\"285\":\"v-fd4b7500#分配虚拟内存的细节\",\"286\":\"v-fd4b7500#malloc-实现\",\"287\":\"v-fd4b7500#free实现\",\"288\":\"v-fd4b7500#缺页中断\",\"289\":\"v-fd4b7500#查看缺页中断的次数\",\"290\":\"v-fd4b7500#发生缺页中断后-执行了哪些操作\",\"291\":\"v-fd4b7500@0\",\"292\":\"v-fd4b7500@1\",\"293\":\"v-332dfae6\",\"294\":\"v-332dfae6@0\",\"295\":\"v-332dfae6@1\",\"296\":\"v-062c257f\",\"297\":\"v-062c257f@0\",\"298\":\"v-062c257f@1\",\"299\":\"v-70779923\",\"300\":\"v-70779923#为什么叫c语言\",\"301\":\"v-70779923#unix和c语言的发展史\",\"302\":\"v-70779923#为什么说c语言移植性强\",\"303\":\"v-70779923#为什么c语言不能叫跨平台\",\"304\":\"v-70779923#c语言的优势\",\"305\":\"v-70779923#学习c语言的目标\",\"306\":\"v-70779923#vs-studio-调试方法\",\"307\":\"v-70779923#内存地址及内存空间\",\"308\":\"v-70779923#内存地址只是一个编号-代表一个内存空间-容易产生误区\",\"309\":\"v-70779923#显示代码行号\",\"310\":\"v-70779923#程序生成过程\",\"311\":\"v-70779923#预编译指令\",\"312\":\"v-70779923#include-和-include-的区别\",\"313\":\"v-70779923@0\",\"314\":\"v-70779923@1\",\"315\":\"v-198bd17a\",\"316\":\"v-198bd17a#变量命名-标识符-的规定\",\"317\":\"v-198bd17a#数据类型\",\"318\":\"v-198bd17a@0\",\"319\":\"v-198bd17a@1\",\"320\":\"v-a688fcfc\",\"321\":\"v-a688fcfc@0\",\"322\":\"v-a688fcfc@1\",\"323\":\"v-505a1229\",\"324\":\"v-505a1229@0\",\"325\":\"v-505a1229@1\",\"326\":\"v-1c610f8b\",\"327\":\"v-1c610f8b@0\",\"328\":\"v-1c610f8b@1\",\"329\":\"v-573fd3b5\",\"330\":\"v-573fd3b5#有符号整型\",\"331\":\"v-573fd3b5#无符号整型\",\"332\":\"v-573fd3b5#溢出\",\"333\":\"v-573fd3b5#有符号溢出-机器数运算修改了符号位\",\"334\":\"v-573fd3b5#无符号溢出-机器数运算高位舍弃了\",\"335\":\"v-573fd3b5@0\",\"336\":\"v-573fd3b5@1\",\"337\":\"v-63c16f9b\",\"338\":\"v-63c16f9b#浮点数字面值表示方法\",\"339\":\"v-63c16f9b#浮点数的存储方式\",\"340\":\"v-63c16f9b#浮点数的精度丢失问题\",\"341\":\"v-63c16f9b@0\",\"342\":\"v-63c16f9b@1\",\"343\":\"v-a253b292\",\"344\":\"v-a253b292#为什么需要补码\",\"345\":\"v-a253b292#补码的实现\",\"346\":\"v-a253b292#两个机器数比较大小\",\"347\":\"v-a253b292@0\",\"348\":\"v-a253b292@1\",\"349\":\"v-35cd92ed\",\"350\":\"v-35cd92ed@0\",\"351\":\"v-35cd92ed@1\",\"352\":\"v-2a2097b4\",\"353\":\"v-2a2097b4#什么是容器\",\"354\":\"v-2a2097b4#特点\",\"355\":\"v-2a2097b4#简单版\",\"356\":\"v-2a2097b4@0\",\"357\":\"v-2a2097b4@1\",\"358\":\"v-4ee2bd74\",\"359\":\"v-4ee2bd74#为什么要定义模板\",\"360\":\"v-4ee2bd74#模板的定义\",\"361\":\"v-4ee2bd74#模板的类型\",\"362\":\"v-4ee2bd74#函数模板\",\"363\":\"v-4ee2bd74#注意\",\"364\":\"v-4ee2bd74#实例化-隐式实例化与显示实例化\",\"365\":\"v-4ee2bd74#模板函数-用模板实现的函数\",\"366\":\"v-4ee2bd74#函数模板、普通函数间的关系\",\"367\":\"v-4ee2bd74#模板的特化-偏特化与全特化\",\"368\":\"v-4ee2bd74#全特化\",\"369\":\"v-4ee2bd74#偏特化-函数模板不能偏特化\",\"370\":\"v-4ee2bd74#注意区分偏特化和重载\",\"371\":\"v-4ee2bd74#函数模板的参数类型\",\"372\":\"v-4ee2bd74#成员函数模板\",\"373\":\"v-4ee2bd74@0\",\"374\":\"v-4ee2bd74@1\",\"375\":\"v-93ba2c5c\",\"376\":\"v-93ba2c5c#模板参数包\",\"377\":\"v-93ba2c5c#函数参数包\",\"378\":\"v-93ba2c5c#可变模板参数的优势\",\"379\":\"v-93ba2c5c@0\",\"380\":\"v-93ba2c5c@1\",\"381\":\"v-97506104\",\"382\":\"v-97506104#容器为什么需要空间配置器-不用空间配置器会怎么样\",\"383\":\"v-97506104#问题分析\",\"384\":\"v-97506104#解决思路\",\"385\":\"v-97506104#allocator实现\",\"386\":\"v-97506104@0\",\"387\":\"v-97506104@1\",\"388\":\"v-ca1f584c\",\"389\":\"v-ca1f584c#模板的嵌套\",\"390\":\"v-ca1f584c@0\",\"391\":\"v-ca1f584c@1\",\"392\":\"v-5f9477f2\",\"393\":\"v-5f9477f2@0\",\"394\":\"v-5f9477f2@1\",\"395\":\"v-31530dfb\",\"396\":\"v-31530dfb#缺省的拷贝构造函数\",\"397\":\"v-31530dfb#浅拷贝和深拷贝\",\"398\":\"v-31530dfb#拷贝构造函数的调用时机\",\"399\":\"v-31530dfb#q-拷贝构造函数参数中的引用符号可以去掉吗\",\"400\":\"v-31530dfb#q-拷贝构造函数参数中的const可以去掉吗\",\"401\":\"v-31530dfb#q-为什么拷贝时候要使用for循环-使用memcpy函数补上更简单吗\",\"402\":\"v-31530dfb@0\",\"403\":\"v-31530dfb@1\",\"404\":\"v-3bc3bfaf\",\"405\":\"v-3bc3bfaf#实现string类型\",\"406\":\"v-3bc3bfaf#实现循环队列queue\",\"407\":\"v-3bc3bfaf@0\",\"408\":\"v-3bc3bfaf@1\",\"409\":\"v-3a9cf65c\",\"410\":\"v-3a9cf65c#普通成员变量\",\"411\":\"v-3a9cf65c#在栈上定义一个对象\",\"412\":\"v-3a9cf65c#在堆上定义一个对象\",\"413\":\"v-3a9cf65c#静态成员变量\",\"414\":\"v-3a9cf65c#指向普通成员方法的指针\",\"415\":\"v-3a9cf65c#指向静态成员方法的指针\",\"416\":\"v-3a9cf65c@0\",\"417\":\"v-3a9cf65c@1\",\"418\":\"v-10e1c6eb\",\"419\":\"v-10e1c6eb#构造函数\",\"420\":\"v-10e1c6eb#构造函数的特点\",\"421\":\"v-10e1c6eb#示例\",\"422\":\"v-10e1c6eb#初始化列表\",\"423\":\"v-10e1c6eb#必须在初始化列表中进行初始化的情况有哪些\",\"424\":\"v-10e1c6eb#析构函数\",\"425\":\"v-10e1c6eb#析构函数的特点\",\"426\":\"v-10e1c6eb#示例-1\",\"427\":\"v-10e1c6eb#析构函数在哪些时候会被调用呢\",\"428\":\"v-10e1c6eb#注意\",\"429\":\"v-10e1c6eb@0\",\"430\":\"v-10e1c6eb@1\",\"431\":\"v-451c83e2\",\"432\":\"v-451c83e2#常量数据成员\",\"433\":\"v-451c83e2#引用数据成员\",\"434\":\"v-451c83e2#类对象成员\",\"435\":\"v-451c83e2#静态数据成员\",\"436\":\"v-451c83e2@0\",\"437\":\"v-451c83e2@1\",\"438\":\"v-6577db5e\",\"439\":\"v-6577db5e#静态成员函数\",\"440\":\"v-6577db5e#const成员函数\",\"441\":\"v-6577db5e#为什么const成员无法调用普通成员方法\",\"442\":\"v-6577db5e@0\",\"443\":\"v-6577db5e@1\",\"444\":\"v-e41f0618\",\"445\":\"v-e41f0618#什么是oop思想\",\"446\":\"v-e41f0618#oop编程方法\",\"447\":\"v-e41f0618#面向对象基本概念\",\"448\":\"v-e41f0618#oop语言的四大特征是什么\",\"449\":\"v-e41f0618#c-中类的定义\",\"450\":\"v-e41f0618#class与struct的区别\",\"451\":\"v-e41f0618@0\",\"452\":\"v-e41f0618@1\",\"453\":\"v-3eca3d30\",\"454\":\"v-3eca3d30#const对象\",\"455\":\"v-3eca3d30#指向对象的指针\",\"456\":\"v-3eca3d30#对象数组\",\"457\":\"v-3eca3d30#对象数组的声明\",\"458\":\"v-3eca3d30#对象数组的初始化-可以在声明时进行初始化。\",\"459\":\"v-3eca3d30#堆对象\",\"460\":\"v-3eca3d30@0\",\"461\":\"v-3eca3d30@1\",\"462\":\"v-1da04370\",\"463\":\"v-1da04370#形式\",\"464\":\"v-1da04370#深拷贝和浅拷贝问题\",\"465\":\"v-1da04370#q-引用符号可以去掉吗\",\"466\":\"v-1da04370#q-const可以去掉吗\",\"467\":\"v-1da04370#q-赋值运算符函数的返回类型可以是void\",\"468\":\"v-1da04370#空类\",\"469\":\"v-1da04370#一个空的类-编译器会自动提供哪些函数\",\"470\":\"v-1da04370#空类的大小不为0\",\"471\":\"v-1da04370@0\",\"472\":\"v-1da04370@1\",\"473\":\"v-66aab0b0\",\"474\":\"v-66aab0b0@0\",\"475\":\"v-66aab0b0@1\",\"476\":\"v-1073124a\",\"477\":\"v-1073124a@0\",\"478\":\"v-1073124a@1\",\"479\":\"v-3cc85216\",\"480\":\"v-3cc85216#const关键字修饰变量\",\"481\":\"v-3cc85216#常考题-const常量与宏定义的区别是什么\",\"482\":\"v-3cc85216#const和普通变量的区别\",\"483\":\"v-3cc85216#c和c-中const修饰变量有什么不同\",\"484\":\"v-3cc85216#c-中const特性\",\"485\":\"v-3cc85216#const修饰的量常见错误\",\"486\":\"v-3cc85216#const关键字修饰指针\",\"487\":\"v-3cc85216#对于指针需要关注两点\",\"488\":\"v-3cc85216#常量指针和指针常量\",\"489\":\"v-3cc85216#顶层const和底层const\",\"490\":\"v-3cc85216#const与二级-多级-指针结合\",\"491\":\"v-3cc85216#const和指针的类型转换-没有约束的可以给有约束的赋值-🍗🍗🍗\",\"492\":\"v-3cc85216#习题\",\"493\":\"v-3cc85216#函数指针、指针函数、数组指针、指针数组\",\"494\":\"v-3cc85216#在-c-语言中-可以通过函数指针和结构体来模拟多态性\",\"495\":\"v-3cc85216#const关键字修饰成员函数\",\"496\":\"v-3cc85216#const关键字修饰对象\",\"497\":\"v-3cc85216#课堂代码\",\"498\":\"v-3cc85216@0\",\"499\":\"v-3cc85216@1\",\"500\":\"v-ba4c1c2a\",\"501\":\"v-ba4c1c2a#什么是内联函数\",\"502\":\"v-ba4c1c2a#inline内联函数和普通函数的区别🍗🍗🍗\",\"503\":\"v-ba4c1c2a#内联函数和带参数的宏定义\",\"504\":\"v-ba4c1c2a#将内联函数放入头文件\",\"505\":\"v-ba4c1c2a#谨慎地使用内联\",\"506\":\"v-ba4c1c2a#课堂代码\",\"507\":\"v-ba4c1c2a@0\",\"508\":\"v-ba4c1c2a@1\",\"509\":\"v-c97d844a\",\"510\":\"v-c97d844a#开辟一个元素的空间\",\"511\":\"v-c97d844a#有几种new的方式\",\"512\":\"v-c97d844a#开辟一个数组的空间\",\"513\":\"v-c97d844a#常考题-new-delete表达式与malloc-free的区别是\",\"514\":\"v-c97d844a#既然new-delete的功能完全覆盖了malloc-free-为什么c-还保留malloc-free呢\",\"515\":\"v-c97d844a#课堂代码\",\"516\":\"v-c97d844a#new和deletea原理\",\"517\":\"v-c97d844a#new-和delete-或者说new和delete-能混用吗-c-如何区分单个元素和数组内存分配和释放\",\"518\":\"v-c97d844a#深入理解c-new-delete-new-delete-动态内存管理\",\"519\":\"v-c97d844a#delete-实际做了这样几件事情\",\"520\":\"v-c97d844a#new最后将开辟好内存用指针p返回-pa接收它。可为什么p-和pa-会差上4字节\",\"521\":\"v-c97d844a#new-delete-new-delete-malloc-free配套使用\",\"522\":\"v-c97d844a#malloc-delete的组合\",\"523\":\"v-c97d844a#delete-delete-之间误用-值得注意\",\"524\":\"v-c97d844a#针对内置类型\",\"525\":\"v-c97d844a#null、0、nullptr-区别分析\",\"526\":\"v-c97d844a#c的null\",\"527\":\"v-c97d844a#c-的0\",\"528\":\"v-c97d844a#为什么c-的书都推荐使用0而不是null来表示空指针呢\",\"529\":\"v-c97d844a#c-11的nullptr\",\"530\":\"v-c97d844a#在没有c-11的nullptr的时候-我们怎么解决避免这个问题呢\",\"531\":\"v-c97d844a#内存溢出、踩内存、内存越界、野指针、悬空指针\",\"532\":\"v-c97d844a@0\",\"533\":\"v-c97d844a@1\",\"534\":\"v-6ef0e0ae\",\"535\":\"v-6ef0e0ae#c风格字符串\",\"536\":\"v-6ef0e0ae#c-风格字符串\",\"537\":\"v-6ef0e0ae#string对象的构造\",\"538\":\"v-6ef0e0ae#string与c风格字符串的转换\",\"539\":\"v-6ef0e0ae#元素遍历和存取\",\"540\":\"v-6ef0e0ae#字符串的长度和容量相关\",\"541\":\"v-6ef0e0ae#元素追加和相加\",\"542\":\"v-6ef0e0ae#提取子串\",\"543\":\"v-6ef0e0ae#元素删除\",\"544\":\"v-6ef0e0ae#元素清空\",\"545\":\"v-6ef0e0ae#字符串比较\",\"546\":\"v-6ef0e0ae#搜索与查找\",\"547\":\"v-6ef0e0ae#课堂代码\",\"548\":\"v-6ef0e0ae#实现一个string类\",\"549\":\"v-6ef0e0ae@0\",\"550\":\"v-6ef0e0ae@1\",\"551\":\"v-f8fc3194\",\"552\":\"v-f8fc3194#对齐规则\",\"553\":\"v-f8fc3194#为什么要内存对齐\",\"554\":\"v-f8fc3194#内存对齐的三大规则\",\"555\":\"v-f8fc3194#数据成员对齐规则\",\"556\":\"v-f8fc3194#结构-或联合-的整体对齐规则\",\"557\":\"v-f8fc3194#结构体作为成员\",\"558\":\"v-f8fc3194@0\",\"559\":\"v-f8fc3194@1\",\"560\":\"v-14c9e918\",\"561\":\"v-14c9e918#关注重点🍖🍖🍖\",\"562\":\"v-14c9e918#c-为什么支持函数重载-c语言不支持函数重载\",\"563\":\"v-14c9e918#函数重载需要注意什么\",\"564\":\"v-14c9e918#什么是多态-一个东西有多种多样的形态-怎么理解多态\",\"565\":\"v-14c9e918#c-和c语言代码之间如何相互调用\",\"566\":\"v-14c9e918#c-调用c函数\",\"567\":\"v-14c9e918#如果c代码明确表示用c方式编译\",\"568\":\"v-14c9e918#已经使用c编译方式编译成了可重定向的文件\",\"569\":\"v-14c9e918#直接使用c-兼容c\",\"570\":\"v-14c9e918#c调用c-的函数代码\",\"571\":\"v-14c9e918#课堂代码\",\"572\":\"v-14c9e918#nm查看二进制文件\",\"573\":\"v-14c9e918#extern-和extern-c-关键字\",\"574\":\"v-14c9e918#extern关键字\",\"575\":\"v-14c9e918#extern-的使用场景1\",\"576\":\"v-14c9e918#extern-的使用场景2\",\"577\":\"v-14c9e918#extern-c-的理解和用法\",\"578\":\"v-14c9e918#未加extern-c-声明\",\"579\":\"v-14c9e918@0\",\"580\":\"v-14c9e918@1\",\"581\":\"v-1155c5a0\",\"582\":\"v-1155c5a0#为什么要使用命名空间\",\"583\":\"v-1155c5a0#什么是命名空间\",\"584\":\"v-1155c5a0#基本格式\",\"585\":\"v-1155c5a0#存放的类型\",\"586\":\"v-1155c5a0#可见域\",\"587\":\"v-1155c5a0#命名空间的使用方式\",\"588\":\"v-1155c5a0#using编译指令\",\"589\":\"v-1155c5a0#作用域限定符\",\"590\":\"v-1155c5a0#using声明机制👍\",\"591\":\"v-1155c5a0#匿名命名空间\",\"592\":\"v-1155c5a0#命名空间的嵌套及覆盖\",\"593\":\"v-1155c5a0#对命名空间的思考和总结\",\"594\":\"v-1155c5a0#课内代码\",\"595\":\"v-1155c5a0@0\",\"596\":\"v-1155c5a0@1\",\"597\":\"v-636256d6\",\"598\":\"v-636256d6#异常出现之前-c语言-处理错误的方式\",\"599\":\"v-636256d6#捕获异常\",\"600\":\"v-636256d6#发生异常的位置-throw表达式\",\"601\":\"v-636256d6#发生异常的位置\",\"602\":\"v-636256d6#课堂代码\",\"603\":\"v-636256d6#寻找处理代码的过程-匹配catch的过程\",\"604\":\"v-636256d6#c-定义的标准异常类\",\"605\":\"v-636256d6#使用c-的标准异常类实例\",\"606\":\"v-636256d6#如何定义和使用自己的异常类\",\"607\":\"v-636256d6#异常规范-c-11标例子准中已经被废弃\",\"608\":\"v-636256d6#c-中使用异常时应注意的问题-总结\",\"609\":\"v-636256d6@0\",\"610\":\"v-636256d6@1\",\"611\":\"v-51ee3d17\",\"612\":\"v-51ee3d17#什么是引用\",\"613\":\"v-51ee3d17#引用和取地址的区别\",\"614\":\"v-51ee3d17#引用的本质\",\"615\":\"v-51ee3d17#引用作为函数参数\",\"616\":\"v-51ee3d17#引用作为函数的返回值\",\"617\":\"v-51ee3d17#引用总结\",\"618\":\"v-51ee3d17#课堂代码\",\"619\":\"v-51ee3d17#引用和指针的区别\",\"620\":\"v-51ee3d17#左值引用\",\"621\":\"v-51ee3d17#右值引用\",\"622\":\"v-51ee3d17#总结\",\"623\":\"v-51ee3d17#例题\",\"624\":\"v-51ee3d17#写一句代码在内存的0x0018ff44处写一个4字节的10\",\"625\":\"v-51ee3d17#判断对错🍗🍗🍗\",\"626\":\"v-51ee3d17@0\",\"627\":\"v-51ee3d17@1\",\"628\":\"v-132402e1\",\"629\":\"v-132402e1#static-cast\",\"630\":\"v-132402e1#const-cast\",\"631\":\"v-132402e1#dynamic-cast\",\"632\":\"v-132402e1#reinterpret-cast\",\"633\":\"v-132402e1#课堂代码\",\"634\":\"v-132402e1@0\",\"635\":\"v-132402e1@1\",\"636\":\"v-01408bc4\",\"637\":\"v-01408bc4#默认参数的目的\",\"638\":\"v-01408bc4#调用效率问题-汇编\",\"639\":\"v-01408bc4#默认参数的声明\",\"640\":\"v-01408bc4#默认参数的顺序规定\",\"641\":\"v-01408bc4#默认参数与函数重载\",\"642\":\"v-01408bc4#课堂代码\",\"643\":\"v-01408bc4@0\",\"644\":\"v-01408bc4@1\",\"645\":\"v-0cf00a94\",\"646\":\"v-0cf00a94#形式\",\"647\":\"v-0cf00a94#class不写出来就是私有继承\",\"648\":\"v-0cf00a94#构造和析构顺序\",\"649\":\"v-0cf00a94#派生类构造函数初始化列表不写时-构造和析构顺序\",\"650\":\"v-0cf00a94#派生类初始化列表顺序和派生列表顺序不一致时\",\"651\":\"v-0cf00a94#小结\",\"652\":\"v-0cf00a94#成员名冲突的二义性\",\"653\":\"v-0cf00a94#菱形继承的二义性问题\",\"654\":\"v-0cf00a94@0\",\"655\":\"v-0cf00a94@1\",\"656\":\"v-2f0a2344\",\"657\":\"v-2f0a2344#访问限定表\",\"658\":\"v-2f0a2344#总结-派生类的访问权限规则如下\",\"659\":\"v-2f0a2344#如果我们不写继承方式的话-那么它会以什么方式继承呢\",\"660\":\"v-2f0a2344@0\",\"661\":\"v-2f0a2344@1\",\"662\":\"v-7eb7ea5a\",\"663\":\"v-7eb7ea5a@0\",\"664\":\"v-7eb7ea5a@1\",\"665\":\"v-11fe42b7\",\"666\":\"v-11fe42b7#形式\",\"667\":\"v-11fe42b7#如何初始化基类的成员变量\",\"668\":\"v-11fe42b7#派生类构造调用基类构造\",\"669\":\"v-11fe42b7#派生类有显式定义构造函数-而基类没有显示定义构造函数\",\"670\":\"v-11fe42b7#如果派生类没有显式定义构造函数-而基类有显示定义构造函数\",\"671\":\"v-11fe42b7#派生类有构造函数-基类有默认构造函数\",\"672\":\"v-11fe42b7#派生类和基类都有构造函数-但基类没有默认的无参构造函数\",\"673\":\"v-11fe42b7#结论\",\"674\":\"v-11fe42b7#派生类构造函数调用顺序\",\"675\":\"v-11fe42b7#派生类对象的销毁\",\"676\":\"v-11fe42b7@0\",\"677\":\"v-11fe42b7@1\",\"678\":\"v-103be5d9\",\"679\":\"v-103be5d9@0\",\"680\":\"v-103be5d9@1\",\"681\":\"v-7e0a1cbb\",\"682\":\"v-7e0a1cbb#继承的本质\",\"683\":\"v-7e0a1cbb#形式\",\"684\":\"v-7e0a1cbb#派生类的生成过程包含3个步骤\",\"685\":\"v-7e0a1cbb#不能从基类继承下来的\",\"686\":\"v-7e0a1cbb@0\",\"687\":\"v-7e0a1cbb@1\",\"688\":\"v-210e34fe\",\"689\":\"v-210e34fe@0\",\"690\":\"v-210e34fe@1\",\"691\":\"v-eb58d93a\",\"692\":\"v-eb58d93a#_1-重载-overload\",\"693\":\"v-eb58d93a#重写-覆盖-override\",\"694\":\"v-eb58d93a#重载与重写的区别\",\"695\":\"v-eb58d93a#_3-隐藏-hide\",\"696\":\"v-eb58d93a@0\",\"697\":\"v-eb58d93a@1\",\"698\":\"v-733883fe\",\"699\":\"v-733883fe#实现迭代器iterator\",\"700\":\"v-733883fe#auto\",\"701\":\"v-733883fe#foreach\",\"702\":\"v-733883fe@0\",\"703\":\"v-733883fe@1\",\"704\":\"v-0aad1b8c\",\"705\":\"v-0aad1b8c@0\",\"706\":\"v-0aad1b8c@1\",\"707\":\"v-6a78bf1e\",\"708\":\"v-6a78bf1e#我们先来看一下-malloc与new、delete与free区别\",\"709\":\"v-6a78bf1e#new与delete实现原理进行剖析\",\"710\":\"v-6a78bf1e#operator-new的实现\",\"711\":\"v-6a78bf1e#operator-delete的实现\",\"712\":\"v-6a78bf1e#问题一-平常我们new与delete都是正常使用的-但是new与delete能混用吗-c-为什么区分单个元素和数组的内存分配和释放呢\",\"713\":\"v-6a78bf1e#情况1-int类型下将其混用\",\"714\":\"v-6a78bf1e#情况2-类类型下将其混用\",\"715\":\"v-6a78bf1e#分析\",\"716\":\"v-6a78bf1e#问题二-c-中如何设计一个程序检查内训泄露问题\",\"717\":\"v-6a78bf1e#要求一个类只能创建栈对象\",\"718\":\"v-6a78bf1e#要求一个类只能创建堆对象\",\"719\":\"v-6a78bf1e@0\",\"720\":\"v-6a78bf1e@1\",\"721\":\"v-7d06c0d6\",\"722\":\"v-7d06c0d6#友元函数\",\"723\":\"v-7d06c0d6#友元类\",\"724\":\"v-7d06c0d6#友元的性质\",\"725\":\"v-7d06c0d6@0\",\"726\":\"v-7d06c0d6@1\",\"727\":\"v-f0f10ec2\",\"728\":\"v-f0f10ec2#运算符重载的规则\",\"729\":\"v-f0f10ec2#测试sizeof是运算符\",\"730\":\"v-f0f10ec2#究竟把运算符重载作为类的成员函数好-还是友元函数好\",\"731\":\"v-f0f10ec2#代码实现\",\"732\":\"v-f0f10ec2@0\",\"733\":\"v-f0f10ec2@1\",\"734\":\"v-253e305c\",\"735\":\"v-253e305c#注意事项\",\"736\":\"v-253e305c#实现代码\",\"737\":\"v-253e305c@0\",\"738\":\"v-253e305c@1\",\"739\":\"v-62b6f00d\",\"740\":\"v-62b6f00d#迭代器失效问题\",\"741\":\"v-62b6f00d#迭代器失效情况\",\"742\":\"v-62b6f00d#失效问题1-把vec容器中所有的偶数全部删除\",\"743\":\"v-62b6f00d#失效问题2-给vec容器中所有的偶数前面添加一个小于偶数值1的数字\",\"744\":\"v-62b6f00d#如何解决迭代器失效问题\",\"745\":\"v-62b6f00d#解决失效问题1-解决删除问题\",\"746\":\"v-62b6f00d#解决失效问题2-解决增加问题\",\"747\":\"v-62b6f00d#解决迭代器失效底层原理\",\"748\":\"v-62b6f00d@0\",\"749\":\"v-62b6f00d@1\",\"750\":\"v-02dd1ab7\",\"751\":\"v-02dd1ab7#使用队列的push和pop入队和出队操作模拟一个简单对象池的实现的例子\",\"752\":\"v-02dd1ab7@0\",\"753\":\"v-02dd1ab7@1\",\"754\":\"v-152dfd8d\",\"755\":\"v-152dfd8d#方法一-数组-双指针\",\"756\":\"v-152dfd8d#方法二-反转后半部链表-空间复杂度o-1\",\"757\":\"v-152dfd8d@0\",\"758\":\"v-152dfd8d@1\",\"759\":\"v-735dfe06\",\"760\":\"v-735dfe06@0\",\"761\":\"v-735dfe06@1\",\"762\":\"v-d977ced4\",\"763\":\"v-d977ced4@0\",\"764\":\"v-d977ced4@1\",\"765\":\"v-64506cc7\",\"766\":\"v-64506cc7@0\",\"767\":\"v-64506cc7@1\",\"768\":\"v-13ade0aa\",\"769\":\"v-13ade0aa@0\",\"770\":\"v-13ade0aa@1\",\"771\":\"v-641d44d2\",\"772\":\"v-641d44d2@0\",\"773\":\"v-641d44d2@1\",\"774\":\"v-8a944abe\",\"775\":\"v-8a944abe@0\",\"776\":\"v-8a944abe@1\",\"777\":\"v-703548b8\",\"778\":\"v-703548b8@0\",\"779\":\"v-703548b8@1\",\"780\":\"v-711b4cec\",\"781\":\"v-711b4cec#分治思想\",\"782\":\"v-711b4cec#方法一-顺序合并\",\"783\":\"v-711b4cec#方法二-分治合并\",\"784\":\"v-711b4cec#优先队列\",\"785\":\"v-711b4cec@0\",\"786\":\"v-711b4cec@1\",\"787\":\"v-fb458a48\",\"788\":\"v-fb458a48@0\",\"789\":\"v-fb458a48@1\",\"790\":\"v-67248f78\",\"791\":\"v-67248f78#单链表\",\"792\":\"v-67248f78#双向链表\",\"793\":\"v-67248f78@0\",\"794\":\"v-67248f78@1\",\"795\":\"v-db839be2\",\"796\":\"v-db839be2@0\",\"797\":\"v-db839be2@1\",\"798\":\"v-16787a3c\",\"799\":\"v-16787a3c@0\",\"800\":\"v-16787a3c@1\",\"801\":\"v-a323322a\",\"802\":\"v-a323322a#方法一-穿针引线\",\"803\":\"v-a323322a#方法二-一次遍历「穿针引线」反转链表-头插法\",\"804\":\"v-a323322a@0\",\"805\":\"v-a323322a@1\",\"806\":\"v-4e6f8416\",\"807\":\"v-4e6f8416@0\",\"808\":\"v-4e6f8416@1\",\"809\":\"v-ebfa549c\",\"810\":\"v-ebfa549c#情景一\",\"811\":\"v-ebfa549c#情景二\",\"812\":\"v-ebfa549c#情景三\",\"813\":\"v-ebfa549c@0\",\"814\":\"v-ebfa549c@1\",\"815\":\"v-08a1ce30\",\"816\":\"v-08a1ce30#单向链表\",\"817\":\"v-08a1ce30#单向链表的实现\",\"818\":\"v-08a1ce30#单向循环链表\",\"819\":\"v-08a1ce30#单向循环链表的实现\",\"820\":\"v-08a1ce30#双向链表\",\"821\":\"v-08a1ce30#基础版\",\"822\":\"v-08a1ce30#升级版\",\"823\":\"v-08a1ce30#双向循环链表\",\"824\":\"v-08a1ce30@0\",\"825\":\"v-08a1ce30@1\",\"826\":\"v-16792cec\",\"827\":\"v-16792cec@0\",\"828\":\"v-16792cec@1\",\"829\":\"v-73dfb9d4\",\"830\":\"v-73dfb9d4#_1、代理模式\",\"831\":\"v-73dfb9d4#_2、装饰器模式\",\"832\":\"v-73dfb9d4#_3、适配器模式\",\"833\":\"v-73dfb9d4@0\",\"834\":\"v-73dfb9d4@1\",\"835\":\"v-ef005662\",\"836\":\"v-ef005662#什么是单例模式\",\"837\":\"v-ef005662#为什么需要单例模式\",\"838\":\"v-ef005662#线程安全\",\"839\":\"v-ef005662#什么是线程安全\",\"840\":\"v-ef005662#如何保证线程安全\",\"841\":\"v-ef005662#单例类的特点\",\"842\":\"v-ef005662#单例模式分类\",\"843\":\"v-ef005662#懒汉式\",\"844\":\"v-ef005662#饿汉式\",\"845\":\"v-ef005662#单例模式实现\",\"846\":\"v-ef005662#普通懒汉式单例-线程不安全\",\"847\":\"v-ef005662#加锁的懒汉式单例-线程安全\",\"848\":\"v-ef005662#方法1-返回普通指针\",\"849\":\"v-ef005662#方法2-返回智能指针\",\"850\":\"v-ef005662#静态局部变量的懒汉单例-c-11线程安全\",\"851\":\"v-ef005662#饿汉式单例-线程安全\",\"852\":\"v-ef005662#使用-c-11-std-call-once-实现单例-c-11线程安全\",\"853\":\"v-ef005662#单例模式的自动释放\",\"854\":\"v-ef005662#可以使用友元形式进行设计\",\"855\":\"v-ef005662#内部类加静态数据成员形式\",\"856\":\"v-ef005662#atexit方式进行\",\"857\":\"v-ef005662#pthread-once形式\",\"858\":\"v-ef005662@0\",\"859\":\"v-ef005662@1\",\"860\":\"v-44042d12\",\"861\":\"v-44042d12#简单工厂-simple-factory\",\"862\":\"v-44042d12#_1-1、采用new的方式创建对象\",\"863\":\"v-44042d12#_1-2、采用简单工厂\",\"864\":\"v-44042d12#实现\",\"865\":\"v-44042d12#_2、工厂方法-factory-method\",\"866\":\"v-44042d12#_2-1、类图\",\"867\":\"v-44042d12#抽象工厂-abstract-factory\",\"868\":\"v-44042d12#简单工厂-工厂方法-抽象工厂对比\",\"869\":\"v-44042d12@0\",\"870\":\"v-44042d12@1\",\"871\":\"v-5f0f0675\",\"872\":\"v-5f0f0675@0\",\"873\":\"v-5f0f0675@1\",\"874\":\"v-5e6716c0\",\"875\":\"v-5e6716c0#成为虚函数的条件\",\"876\":\"v-5e6716c0#哪些函数不能被设置为虚函数\",\"877\":\"v-5e6716c0#为什么析构函数可以成为虚函数\",\"878\":\"v-5e6716c0@0\",\"879\":\"v-5e6716c0@1\",\"880\":\"v-72de4250\",\"881\":\"v-72de4250#多态的定义\",\"882\":\"v-72de4250#为什么用多态\",\"883\":\"v-72de4250#多态的分类\",\"884\":\"v-72de4250#案例1-静多态-函数重载\",\"885\":\"v-72de4250#案例2-静多态-模板-模板的实例化发生在编译阶段\",\"886\":\"v-72de4250#案例3-动多态-实现一个动物类\",\"887\":\"v-72de4250@0\",\"888\":\"v-72de4250@1\",\"889\":\"v-e3980572\",\"890\":\"v-e3980572#多基派生的二义性\",\"891\":\"v-e3980572#菱形继承\",\"892\":\"v-e3980572@0\",\"893\":\"v-e3980572@1\",\"894\":\"v-54b6e5ba\",\"895\":\"v-54b6e5ba@0\",\"896\":\"v-54b6e5ba@1\",\"897\":\"v-5ed5a75a\",\"898\":\"v-5ed5a75a#纯虚函数\",\"899\":\"v-5ed5a75a#抽象类\",\"900\":\"v-5ed5a75a#抽象类的形式\",\"901\":\"v-5ed5a75a#为什么定义抽象类-抽象类和普通类的区别\",\"902\":\"v-5ed5a75a@0\",\"903\":\"v-5ed5a75a@1\",\"904\":\"v-7c62f63c\",\"905\":\"v-7c62f63c#题目一-猫狗叫声问题\",\"906\":\"v-7c62f63c#题目二-继承结构中基类派生类同名覆盖方法不同默认值问题\",\"907\":\"v-7c62f63c#题目三-派生类的方法写成私有的可以正常调用吗\",\"908\":\"v-7c62f63c#题目四-下面两段代码是否正确\",\"909\":\"v-7c62f63c@0\",\"910\":\"v-7c62f63c@1\",\"911\":\"v-7ef7d845\",\"912\":\"v-7ef7d845#虚函数的定义\",\"913\":\"v-7ef7d845#派生类对虚函数的重定义\",\"914\":\"v-7ef7d845#虚函数的实现机制🍗🍗🍗\",\"915\":\"v-7ef7d845#虚函数描述、特点\",\"916\":\"v-7ef7d845#虚函数机制是如何被激活的呢-或者说动态多态是怎么表现出来的呢\",\"917\":\"v-7ef7d845@0\",\"918\":\"v-7ef7d845@1\",\"919\":\"v-68c3f3ca\",\"920\":\"v-68c3f3ca#指针访问\",\"921\":\"v-68c3f3ca#向下强转-不安全\",\"922\":\"v-68c3f3ca#引用访问\",\"923\":\"v-68c3f3ca#对象访问\",\"924\":\"v-68c3f3ca#成员函数中访问\",\"925\":\"v-68c3f3ca#构造函数和析构函数中访问\",\"926\":\"v-68c3f3ca#注意\",\"927\":\"v-68c3f3ca#虚函数的调用一定就是动态绑定吗\",\"928\":\"v-68c3f3ca@0\",\"929\":\"v-68c3f3ca@1\",\"930\":\"v-849483e2\",\"931\":\"v-849483e2#定义\",\"932\":\"v-849483e2#virtual作用\",\"933\":\"v-849483e2#语法\",\"934\":\"v-849483e2#示例\",\"935\":\"v-849483e2#内存分布\",\"936\":\"v-849483e2#查看方法\",\"937\":\"v-849483e2#简单虚继承内存分布\",\"938\":\"v-849483e2#含虚函数的内存分布\",\"939\":\"v-849483e2#菱形继承内存分布\",\"940\":\"v-849483e2#小结\",\"941\":\"v-849483e2@0\",\"942\":\"v-849483e2@1\",\"943\":\"v-0e539496\",\"944\":\"v-0e539496@0\",\"945\":\"v-0e539496@1\",\"946\":\"v-600c7550\",\"947\":\"v-600c7550#什么时候需要把基类的析构函数必须实现成虚函数\",\"948\":\"v-600c7550#示例一-基类的指针-引用-指向堆上new出来的派生类对象的时候\",\"949\":\"v-600c7550#示例二-类内有申请的动态内存-需要清理和释放的时候\",\"950\":\"v-600c7550@0\",\"951\":\"v-600c7550@1\",\"952\":\"v-f51389fa\",\"953\":\"v-f51389fa#静态绑定\",\"954\":\"v-f51389fa#动态绑定\",\"955\":\"v-f51389fa#sizeof变化的原因\",\"956\":\"v-f51389fa#pb的类型-typeid\",\"957\":\"v-f51389fa#rtti运行时的类型信息\",\"958\":\"v-f51389fa#vs-查看内存分布\",\"959\":\"v-f51389fa#总结\",\"960\":\"v-f51389fa@0\",\"961\":\"v-f51389fa@1\",\"962\":\"v-55ae1b9a\",\"963\":\"v-55ae1b9a#我们经常提到stl-那么stl究竟是什么呢\",\"964\":\"v-55ae1b9a#一、vector容器\",\"965\":\"v-55ae1b9a#_1-1使用方式\",\"966\":\"v-55ae1b9a#_1-2使用实例\",\"967\":\"v-55ae1b9a#二、deque容器\",\"968\":\"v-55ae1b9a#_2-1底层实现\",\"969\":\"v-55ae1b9a#_2-2使用方式\",\"970\":\"v-55ae1b9a#三、list容器\",\"971\":\"v-55ae1b9a#四、vector、deque、list对比分析\",\"972\":\"v-55ae1b9a#deque底层内存是否是连续的\",\"973\":\"v-55ae1b9a#vector与deque容器之间的区别\",\"974\":\"v-55ae1b9a#vector与list容器之间的区别\",\"975\":\"v-55ae1b9a@0\",\"976\":\"v-55ae1b9a@1\",\"977\":\"v-8365f3e8\",\"978\":\"v-8365f3e8#一、函数对象与函数指针\",\"979\":\"v-8365f3e8#问题一-什么是函数对象呢\",\"980\":\"v-8365f3e8#问题二-那么使用函数对象有什么好处呢\",\"981\":\"v-8365f3e8#使用c语言中函数指针解决\",\"982\":\"v-8365f3e8#使用c-中函数对象解决\",\"983\":\"v-8365f3e8#二、使用实例\",\"984\":\"v-8365f3e8#实例1-优先级队列\",\"985\":\"v-8365f3e8#实例2-set\",\"986\":\"v-8365f3e8@0\",\"987\":\"v-8365f3e8@1\",\"988\":\"v-62b566a8\",\"989\":\"v-62b566a8#一、容器适配器\",\"990\":\"v-62b566a8#二、栈\",\"991\":\"v-62b566a8#三、队列\",\"992\":\"v-62b566a8#四、优先级队列\",\"993\":\"v-62b566a8#问题一-stack与queue第二个模板类型参数依赖deque-为什么不依赖vector-而优先级队列为什么底层依赖vector\",\"994\":\"v-62b566a8#问题二-优先级队列为什么底层依赖vector\",\"995\":\"v-62b566a8@0\",\"996\":\"v-62b566a8@1\",\"997\":\"v-4b15d926\",\"998\":\"v-4b15d926#一、无序关联容器\",\"999\":\"v-4b15d926#_1-1单重集合与多重集合\",\"1000\":\"v-4b15d926#_1-2单重映射表与多重映射表\",\"1001\":\"v-4b15d926#_1-3海量数据\",\"1002\":\"v-4b15d926#二、有序关联容器\",\"1003\":\"v-4b15d926#总结\",\"1004\":\"v-4b15d926@0\",\"1005\":\"v-4b15d926@1\",\"1006\":\"v-2c413a2b\",\"1007\":\"v-2c413a2b#一、泛型算法\",\"1008\":\"v-2c413a2b#二、绑定器\",\"1009\":\"v-2c413a2b@0\",\"1010\":\"v-2c413a2b@1\",\"1011\":\"v-7c5d97b0\",\"1012\":\"v-7c5d97b0@0\",\"1013\":\"v-7c5d97b0@1\",\"1014\":\"v-43124686\",\"1015\":\"v-43124686#安装\",\"1016\":\"v-43124686#make出现报错-iso-c-17-does-not-allow-dynamic-exception-specifications\",\"1017\":\"v-43124686#log4cpp基本结构\",\"1018\":\"v-43124686#日志类别-category\",\"1019\":\"v-43124686#日志追加器-appender\",\"1020\":\"v-43124686#stringqueueappender-内存队列-多线程调试\",\"1021\":\"v-43124686#日志布局-layout\",\"1022\":\"v-43124686#category、appender和layout三者的关系\",\"1023\":\"v-43124686#日志级别-priority\",\"1024\":\"v-43124686#log4cpp记录日志的原理\",\"1025\":\"v-43124686#系统中默认的优先级等级如下\",\"1026\":\"v-43124686#帮助类\",\"1027\":\"v-43124686#注意\",\"1028\":\"v-43124686#代码使用\",\"1029\":\"v-43124686#windows环境下\",\"1030\":\"v-43124686#linux环境下\",\"1031\":\"v-43124686#测试用例\",\"1032\":\"v-43124686#封装成日志类-单例模式\",\"1033\":\"v-43124686@0\",\"1034\":\"v-43124686@1\",\"1035\":\"v-7c6a87cc\",\"1036\":\"v-7c6a87cc@0\",\"1037\":\"v-7c6a87cc@1\",\"1038\":\"v-0d61d626\",\"1039\":\"v-0d61d626#_1-基础知识\",\"1040\":\"v-0d61d626#裸指针\",\"1041\":\"v-0d61d626#智能指针\",\"1042\":\"v-0d61d626#_2-不带引用计数的智能指针\",\"1043\":\"v-0d61d626#_2-1-auto-ptr\",\"1044\":\"v-0d61d626#auto-ptr怎么解决浅拷贝问题\",\"1045\":\"v-0d61d626#容器中不能使用auto-ptr\",\"1046\":\"v-0d61d626#_2-2-scoped-ptr\",\"1047\":\"v-0d61d626#_2-3-unique-ptr\",\"1048\":\"v-0d61d626@0\",\"1049\":\"v-0d61d626@1\",\"1050\":\"v-778f0618\",\"1051\":\"v-778f0618@0\",\"1052\":\"v-778f0618@1\",\"1053\":\"v-29824dbc\",\"1054\":\"v-29824dbc#带引用计数的智能指针是怎么解决多个指针持有一个资源的\",\"1055\":\"v-29824dbc#带引用计数的智能指针的实现\",\"1056\":\"v-29824dbc#shared-ptr的交叉引用问题\",\"1057\":\"v-29824dbc#weak-ptr怎么使用资源\",\"1058\":\"v-29824dbc@0\",\"1059\":\"v-29824dbc@1\",\"1060\":\"v-6c9710e8\",\"1061\":\"v-6c9710e8@0\",\"1062\":\"v-6c9710e8@1\",\"1063\":\"v-66e8cf78\",\"1064\":\"v-66e8cf78@0\",\"1065\":\"v-66e8cf78@1\",\"1066\":\"v-57c1626a\",\"1067\":\"v-57c1626a#对于对象的优化\",\"1068\":\"v-57c1626a@0\",\"1069\":\"v-57c1626a@1\",\"1070\":\"v-435677cc\",\"1071\":\"v-435677cc#对于c语言\",\"1072\":\"v-435677cc#对于c\",\"1073\":\"v-435677cc#为什么c-空类占用内存大小为1\",\"1074\":\"v-435677cc@0\",\"1075\":\"v-435677cc@1\",\"1076\":\"v-48c23000\",\"1077\":\"v-48c23000@0\",\"1078\":\"v-48c23000@1\",\"1079\":\"v-30a2e42b\",\"1080\":\"v-30a2e42b#一级空间配置器\",\"1081\":\"v-30a2e42b#二级空间配置器\",\"1082\":\"v-30a2e42b#二级空间配置器重要成员解读\",\"1083\":\"v-30a2e42b@0\",\"1084\":\"v-30a2e42b@1\",\"1085\":\"v-02ca19a9\",\"1086\":\"v-02ca19a9#sgi-stl-push-pack-和pop-pack\",\"1087\":\"v-02ca19a9#c-stlpush-pack-和pop-pack\",\"1088\":\"v-02ca19a9@0\",\"1089\":\"v-02ca19a9@1\",\"1090\":\"v-7e13dfea\",\"1091\":\"v-7e13dfea@0\",\"1092\":\"v-7e13dfea@1\",\"1093\":\"v-4e6c7a0a\",\"1094\":\"v-4e6c7a0a@0\",\"1095\":\"v-4e6c7a0a@1\",\"1096\":\"v-a2d2b900\",\"1097\":\"v-a2d2b900@0\",\"1098\":\"v-a2d2b900@1\",\"1099\":\"v-0d093800\",\"1100\":\"v-0d093800@0\",\"1101\":\"v-0d093800@1\",\"1102\":\"v-9ab5c6e8\",\"1103\":\"v-9ab5c6e8@0\",\"1104\":\"v-9ab5c6e8@1\",\"1105\":\"v-a8d7b886\",\"1106\":\"v-a8d7b886@0\",\"1107\":\"v-a8d7b886@1\",\"1108\":\"v-7c0c7a84\",\"1109\":\"v-7c0c7a84#_1、对象使用过程中背后调用了哪些方法\",\"1110\":\"v-7c0c7a84#用临时对象生成新对象\",\"1111\":\"v-7c0c7a84#用临时对象给已存在对象赋值\",\"1112\":\"v-7c0c7a84#显示生成临时对象和隐式生成临时对象\",\"1113\":\"v-7c0c7a84#临时对象的指针和引用\",\"1114\":\"v-7c0c7a84#示例二\",\"1115\":\"v-7c0c7a84#_2、函数调用过程中对象被后续调用的方法太多\",\"1116\":\"v-7c0c7a84#_3、总结三条对象优化原则\",\"1117\":\"v-7c0c7a84@0\",\"1118\":\"v-7c0c7a84@1\",\"1119\":\"v-5b3d8584\",\"1120\":\"v-5b3d8584#_1、cmystirng代码的问题分析\",\"1121\":\"v-5b3d8584#解决方法\",\"1122\":\"v-5b3d8584#operator-效率问题\",\"1123\":\"v-5b3d8584#解决办法\",\"1124\":\"v-5b3d8584#分析下面打印什么\",\"1125\":\"v-5b3d8584@0\",\"1126\":\"v-5b3d8584@1\",\"1127\":\"v-45747b0a\",\"1128\":\"v-45747b0a@0\",\"1129\":\"v-45747b0a@1\",\"1130\":\"v-5d0a9dce\",\"1131\":\"v-5d0a9dce#安装前先安装插件\",\"1132\":\"v-5d0a9dce#amix-的-vim-配置\",\"1133\":\"v-5d0a9dce#个性化配置\",\"1134\":\"v-5d0a9dce#常用的使用方法\",\"1135\":\"v-5d0a9dce#vim-runtime-vimrcs-extended-vim中的设置\",\"1136\":\"v-5d0a9dce#全局查找文件-ctrlp插件\",\"1137\":\"v-5d0a9dce#tab-标签-相关\",\"1138\":\"v-5d0a9dce#目录树-nerd-tree插件\",\"1139\":\"v-5d0a9dce#窗口相关\",\"1140\":\"v-5d0a9dce#如何打开一个工程\",\"1141\":\"v-5d0a9dce#全局搜索字段-ack插件\",\"1142\":\"v-5d0a9dce#常用操作\",\"1143\":\"v-5d0a9dce#配色设置\",\"1144\":\"v-5d0a9dce@0\",\"1145\":\"v-5d0a9dce@1\",\"1146\":\"v-0ccdd78f\",\"1147\":\"v-0ccdd78f#例1—改变排序顺序\",\"1148\":\"v-0ccdd78f#例2—将70按顺序插入到vec容器中\",\"1149\":\"v-0ccdd78f@0\",\"1150\":\"v-0ccdd78f@1\",\"1151\":\"v-0413f5c0\",\"1152\":\"v-0413f5c0@0\",\"1153\":\"v-0413f5c0@1\",\"1154\":\"v-cf2f50ee\",\"1155\":\"v-cf2f50ee#参数占位符\",\"1156\":\"v-cf2f50ee@0\",\"1157\":\"v-cf2f50ee@1\",\"1158\":\"v-474433e4\",\"1159\":\"v-474433e4@0\",\"1160\":\"v-474433e4@1\",\"1161\":\"v-2a36819d\",\"1162\":\"v-2a36819d#区别函数类型和函数指针类型\",\"1163\":\"v-2a36819d#示例\",\"1164\":\"v-2a36819d#无参函数类型\",\"1165\":\"v-2a36819d#有参函数类型\",\"1166\":\"v-2a36819d#function是对一个函数-函数对象的包装\",\"1167\":\"v-2a36819d#function也可以将类的成员方法留下来\",\"1168\":\"v-2a36819d#function使用举例\",\"1169\":\"v-2a36819d@0\",\"1170\":\"v-2a36819d@1\",\"1171\":\"v-2c027fc3\",\"1172\":\"v-2c027fc3#_1、lambda表达式语法\",\"1173\":\"v-2c027fc3#示例\",\"1174\":\"v-2c027fc3#值传递\",\"1175\":\"v-2c027fc3#引用传递\",\"1176\":\"v-2c027fc3#lambda应用\",\"1177\":\"v-2c027fc3#例1—从大到小排序\",\"1178\":\"v-2c027fc3#例2—按序插入元素65\",\"1179\":\"v-2c027fc3#for-each\",\"1180\":\"v-2c027fc3#lambda表达式的应用实践\",\"1181\":\"v-2c027fc3#_1、计算器案例\",\"1182\":\"v-2c027fc3#_2、智能指针案例\",\"1183\":\"v-2c027fc3#_3、优先级队列\",\"1184\":\"v-2c027fc3@0\",\"1185\":\"v-2c027fc3@1\",\"1186\":\"v-08fdb026\",\"1187\":\"v-08fdb026#模板的完全特化\",\"1188\":\"v-08fdb026#模板的部分特例化\",\"1189\":\"v-08fdb026#模板的实参推演\",\"1190\":\"v-08fdb026#总结\",\"1191\":\"v-08fdb026@0\",\"1192\":\"v-08fdb026@1\",\"1193\":\"v-25665f14\",\"1194\":\"v-25665f14#_1、关键字和语法\",\"1195\":\"v-25665f14#_2、绑定器和函数对象\",\"1196\":\"v-25665f14#_3、智能指针\",\"1197\":\"v-25665f14#_4、容器\",\"1198\":\"v-25665f14#_5、c-语言级别支持的多线程编程\",\"1199\":\"v-25665f14@0\",\"1200\":\"v-25665f14@1\",\"1201\":\"v-6ce1e1a6\",\"1202\":\"v-6ce1e1a6#_1、c-多线程介绍\",\"1203\":\"v-6ce1e1a6#_2、多线程编程\",\"1204\":\"v-6ce1e1a6#_1、怎么创建启动一个线程\",\"1205\":\"v-6ce1e1a6#_2、子线程如何结束\",\"1206\":\"v-6ce1e1a6#_3、主线程如何处理子线程\",\"1207\":\"v-6ce1e1a6#子线程睡眠\",\"1208\":\"v-6ce1e1a6#_3、线程间互斥—mutex互斥锁和lock-gard\",\"1209\":\"v-6ce1e1a6#使用mutex-包含头文件-include-mutex\",\"1210\":\"v-6ce1e1a6#lock-guard\",\"1211\":\"v-6ce1e1a6#unique-lock\",\"1212\":\"v-6ce1e1a6#unique-lock源码\",\"1213\":\"v-6ce1e1a6@0\",\"1214\":\"v-6ce1e1a6@1\",\"1215\":\"v-7cc2160e\",\"1216\":\"v-7cc2160e#_1、多线程编程两个问题\",\"1217\":\"v-7cc2160e#_1-1、线程间的互斥\",\"1218\":\"v-7cc2160e#_1-2、线程间的同步通信\",\"1219\":\"v-7cc2160e#_2、生产者-消费者线程模型\",\"1220\":\"v-7cc2160e#_3、lock-gard和unique-lock\",\"1221\":\"v-7cc2160e#_4、流程分析\",\"1222\":\"v-7cc2160e@0\",\"1223\":\"v-7cc2160e@1\",\"1224\":\"v-6c9ca25c\",\"1225\":\"v-6c9ca25c#_1、mutex\",\"1226\":\"v-6c9ca25c#_2、lock-guard\",\"1227\":\"v-6c9ca25c#_3、unique-lock\",\"1228\":\"v-6c9ca25c#_4、lock-gard和unique-lock对比\",\"1229\":\"v-6c9ca25c#_5、notify-all\",\"1230\":\"v-6c9ca25c@0\",\"1231\":\"v-6c9ca25c@1\",\"1232\":\"v-2483becb\",\"1233\":\"v-2483becb#c-11的atomic原子类型\",\"1234\":\"v-2483becb@0\",\"1235\":\"v-2483becb@1\",\"1236\":\"v-dd2c326a\",\"1237\":\"v-dd2c326a#netstat命令各个参数\",\"1238\":\"v-dd2c326a#示例\",\"1239\":\"v-dd2c326a#结果解释\",\"1240\":\"v-dd2c326a#解释一下状态-state\",\"1241\":\"v-dd2c326a@0\",\"1242\":\"v-dd2c326a@1\",\"1243\":\"v-5481f6b5\",\"1244\":\"v-5481f6b5#windows-上tree查看文件名\",\"1245\":\"v-5481f6b5#linux-tree常用命令\",\"1246\":\"v-5481f6b5@0\",\"1247\":\"v-5481f6b5@1\",\"1248\":\"v-70781306\",\"1249\":\"v-70781306#使用wget下载单个文件\",\"1250\":\"v-70781306#使用wget-i下载多个文件\",\"1251\":\"v-70781306#使用wget-o下载并重命名\",\"1252\":\"v-70781306#使用wget-c断点续传\",\"1253\":\"v-70781306#使用wget-b后台下载\",\"1254\":\"v-70781306#使用wget-ftp下载\",\"1255\":\"v-70781306#伪装代理名称下载\",\"1256\":\"v-70781306#使用wget-–tries增加重试次数\",\"1257\":\"v-70781306@0\",\"1258\":\"v-70781306@1\",\"1259\":\"v-fae24824\",\"1260\":\"v-fae24824#tar的使用方法\",\"1261\":\"v-fae24824#gzip和bzip的介绍\",\"1262\":\"v-fae24824#unzip命令处理-zip文件\",\"1263\":\"v-fae24824#总结\",\"1264\":\"v-fae24824@0\",\"1265\":\"v-fae24824@1\",\"1266\":\"v-29390dd2\",\"1267\":\"v-29390dd2#硬链接\",\"1268\":\"v-29390dd2#软链接\",\"1269\":\"v-29390dd2#ln命令\",\"1270\":\"v-29390dd2#给file1创建硬链接\",\"1271\":\"v-29390dd2#给file1创建软链接-file2为创建的软链接名\",\"1272\":\"v-29390dd2#软链接的删除\",\"1273\":\"v-29390dd2@0\",\"1274\":\"v-29390dd2@1\",\"1275\":\"v-45955c7c\",\"1276\":\"v-45955c7c#网络设置\",\"1277\":\"v-45955c7c#为什么配置成静态ip\",\"1278\":\"v-45955c7c#静态ip配置之桥接模式-适用于使用路由器连接网络的同学\",\"1279\":\"v-45955c7c#静态ip配置之nat模式-适用于所有同学\",\"1280\":\"v-45955c7c#安装必备工具\",\"1281\":\"v-45955c7c#修改-bahsrc\",\"1282\":\"v-45955c7c#修改ps1样式\",\"1283\":\"v-45955c7c#修改ll\",\"1284\":\"v-45955c7c#换源\",\"1285\":\"v-45955c7c#安装vmware-tool\",\"1286\":\"v-45955c7c#美化vim\",\"1287\":\"v-45955c7c#方法一-安装vimplus\",\"1288\":\"v-45955c7c#方法二-使用amix-vimrc\",\"1289\":\"v-45955c7c#安装前先安装插件\",\"1290\":\"v-45955c7c#amix-的-vim-配置\",\"1291\":\"v-45955c7c#个性化配置\",\"1292\":\"v-45955c7c#常用的使用方法\",\"1293\":\"v-45955c7c#报错-no-module-named-distutils-sysconfig\",\"1294\":\"v-45955c7c#可能遇到的报错\",\"1295\":\"v-45955c7c#e-unable-to-locate-package\",\"1296\":\"v-45955c7c#apt-get-update-出现e-could-not-get-lock-var-lib-apt-lists-lock\",\"1297\":\"v-45955c7c@0\",\"1298\":\"v-45955c7c@1\",\"1299\":\"v-7c3e20c2\",\"1300\":\"v-7c3e20c2@0\",\"1301\":\"v-7c3e20c2@1\",\"1302\":\"v-91127220\",\"1303\":\"v-91127220#cmake介绍\",\"1304\":\"v-91127220#安装\",\"1305\":\"v-91127220#linux环境安装cmake\",\"1306\":\"v-91127220#vscode环境安装cmake\",\"1307\":\"v-91127220#使用方法\",\"1308\":\"v-91127220#linux上cmake使用\",\"1309\":\"v-91127220#vscode使用\",\"1310\":\"v-91127220#cmake常用预定义变量\",\"1311\":\"v-91127220#添加可执行文件作为构建目标\",\"1312\":\"v-91127220#同一目录-单个-多个源文件\",\"1313\":\"v-91127220#多个目录-多个源文件\",\"1314\":\"v-91127220#方法一-include-directories指定头文件-aux-source-directory指定源文件\",\"1315\":\"v-91127220#方法二-lib-库-分别在-add-和-sub-目录里各编写一个-cmakelists-txt-文件\",\"1316\":\"v-91127220#常用的组织结构\",\"1317\":\"v-91127220#添加编译选项\",\"1318\":\"v-91127220#添加控制选项\",\"1319\":\"v-91127220#为什么要在-build-目录下运行-cmake\",\"1320\":\"v-91127220#cmake-build-type控制构建类型\",\"1321\":\"v-91127220#ndebug宏的使用\",\"1322\":\"v-91127220#几个目录\",\"1323\":\"v-91127220@0\",\"1324\":\"v-91127220@1\",\"1325\":\"v-4c6cb231\",\"1326\":\"v-4c6cb231#基本编译命令\",\"1327\":\"v-4c6cb231#添加编译选项\",\"1328\":\"v-4c6cb231#包含头文件和库\",\"1329\":\"v-4c6cb231#编译多个源文件\",\"1330\":\"v-4c6cb231#预处理、编译、汇编和链接\",\"1331\":\"v-4c6cb231#使用静态库和动态库\",\"1332\":\"v-4c6cb231#如何更新动态库🍗🍗🍗\",\"1333\":\"v-4c6cb231#gcc-fpic-什么作用-了解\",\"1334\":\"v-4c6cb231#ar-crsv-作用\",\"1335\":\"v-4c6cb231#同时存在动态库-共享库-和静态库\",\"1336\":\"v-4c6cb231@0\",\"1337\":\"v-4c6cb231@1\",\"1338\":\"v-5342bc7a\",\"1339\":\"v-5342bc7a#gdb-设置命令行参数\",\"1340\":\"v-5342bc7a#gdb-基本命令\",\"1341\":\"v-5342bc7a#监视功能display\",\"1342\":\"v-5342bc7a#监视变量值\",\"1343\":\"v-5342bc7a#监视指针指向的内容\",\"1344\":\"v-5342bc7a#监视内存地址的内容\",\"1345\":\"v-5342bc7a#监视表达式的结果\",\"1346\":\"v-5342bc7a#监视结构体成员\",\"1347\":\"v-5342bc7a#x命令来查看指定地址的内存值\",\"1348\":\"v-5342bc7a#示例\",\"1349\":\"v-5342bc7a@0\",\"1350\":\"v-5342bc7a@1\",\"1351\":\"v-f6ba6062\",\"1352\":\"v-f6ba6062#使用方法\",\"1353\":\"v-f6ba6062#书写规则\",\"1354\":\"v-f6ba6062#原则\",\"1355\":\"v-f6ba6062#伪目标\",\"1356\":\"v-f6ba6062#变量名\",\"1357\":\"v-f6ba6062#和-的区别\",\"1358\":\"v-f6ba6062#通配符和模式匹配\",\"1359\":\"v-f6ba6062#使用bash的规则来应用通配符\",\"1360\":\"v-f6ba6062#通配符\",\"1361\":\"v-f6ba6062#内置函数\",\"1362\":\"v-f6ba6062#循环\",\"1363\":\"v-f6ba6062#make命令的-f指定makefile文件\",\"1364\":\"v-f6ba6062#示例\",\"1365\":\"v-f6ba6062#指定源文件生成一个可执行程序\",\"1366\":\"v-f6ba6062#每个源文件生成可执行程序\",\"1367\":\"v-f6ba6062#有头文件的情况\",\"1368\":\"v-f6ba6062#makefile-missing-separator-stop-怎么解决\",\"1369\":\"v-f6ba6062@0\",\"1370\":\"v-f6ba6062@1\",\"1371\":\"v-18f8cde9\",\"1372\":\"v-18f8cde9#_1-连接数据库使用的头文件和库文件\",\"1373\":\"v-18f8cde9#_2、初始化连接句柄\",\"1374\":\"v-18f8cde9#_3-连接数据库\",\"1375\":\"v-18f8cde9#_4-关闭连接\",\"1376\":\"v-18f8cde9#_5-执行sql语句\",\"1377\":\"v-18f8cde9#_6-提取结果\",\"1378\":\"v-18f8cde9#_7-获取结果集中有多少行\",\"1379\":\"v-18f8cde9#_8-取出结果集中的一行记录\",\"1380\":\"v-18f8cde9#_9-查看记录行的列数\",\"1381\":\"v-18f8cde9#_10-释放结果集占用的内存\",\"1382\":\"v-18f8cde9#_11-获取错误信息\",\"1383\":\"v-18f8cde9#_12-连接测试程序\",\"1384\":\"v-18f8cde9#增加、修改、删除的程序\",\"1385\":\"v-18f8cde9#查询的程序\",\"1386\":\"v-18f8cde9@0\",\"1387\":\"v-18f8cde9@1\",\"1388\":\"v-17cb7aa4\",\"1389\":\"v-17cb7aa4#查看当前有没有安装mysql\",\"1390\":\"v-17cb7aa4#执行以下命令-如果执行后什么都没有返回-则进入mysql的安装步骤\",\"1391\":\"v-17cb7aa4#如果执行以上命令-显示如下-就证明mysql已经安装完毕-直接使用mysql即可\",\"1392\":\"v-17cb7aa4#安装mysql\",\"1393\":\"v-17cb7aa4#ubuntu18-04下安装mysql5-7\",\"1394\":\"v-17cb7aa4#ubuntu20-04下安装mysql5-7\",\"1395\":\"v-17cb7aa4#下载安装包-这里以5-7-37为例\",\"1396\":\"v-17cb7aa4#解压安装包\",\"1397\":\"v-17cb7aa4#安装mysql5-7-32\",\"1398\":\"v-17cb7aa4#安装完成之后-输入下面命令进行查看\",\"1399\":\"v-17cb7aa4#使用c-c-操作mysql数据库之前需要安装mysql库\",\"1400\":\"v-17cb7aa4#配置mysql\",\"1401\":\"v-17cb7aa4#初始化配置\",\"1402\":\"v-17cb7aa4#检查mysql的服务状态-输入如下命令\",\"1403\":\"v-17cb7aa4#登录mysql\",\"1404\":\"v-17cb7aa4#ubuntu18-04安装mysql异常问题\",\"1405\":\"v-17cb7aa4#卸载mysql\",\"1406\":\"v-17cb7aa4#安装mysql中常见问题\",\"1407\":\"v-17cb7aa4#密码设置问题error-1819-hy000-your-password-does-not-satisfy-the-current-policy\",\"1408\":\"v-17cb7aa4#使用远程登录的配置修改\",\"1409\":\"v-17cb7aa4#mysql常用命令\",\"1410\":\"v-17cb7aa4#设置mysql的自动补全功能\",\"1411\":\"v-17cb7aa4#在重启mysql时候如果出现打不开-可以查看日志\",\"1412\":\"v-17cb7aa4@0\",\"1413\":\"v-17cb7aa4@1\",\"1414\":\"v-0dd7df9c\",\"1415\":\"v-0dd7df9c#一对一\",\"1416\":\"v-0dd7df9c#一对多\",\"1417\":\"v-0dd7df9c#多对多\",\"1418\":\"v-0dd7df9c@0\",\"1419\":\"v-0dd7df9c@1\",\"1420\":\"v-067342a0\",\"1421\":\"v-067342a0#数值类型\",\"1422\":\"v-067342a0#选取适当的数据类型\",\"1423\":\"v-067342a0#选数据类型两个原则\",\"1424\":\"v-067342a0#int-7-什么意思\",\"1425\":\"v-067342a0#字符串类型\",\"1426\":\"v-067342a0#varchar与char的区别\",\"1427\":\"v-067342a0#日期和时间类型\",\"1428\":\"v-067342a0#enum和set\",\"1429\":\"v-067342a0@0\",\"1430\":\"v-067342a0@1\",\"1431\":\"v-c8a2e14a\",\"1432\":\"v-c8a2e14a#主键约束\",\"1433\":\"v-c8a2e14a#自增键约束\",\"1434\":\"v-c8a2e14a#唯一键约束\",\"1435\":\"v-c8a2e14a#非空约束\",\"1436\":\"v-c8a2e14a#默认值约束\",\"1437\":\"v-c8a2e14a#外键约束\",\"1438\":\"v-c8a2e14a@0\",\"1439\":\"v-c8a2e14a@1\",\"1440\":\"v-a87f8e4c\",\"1441\":\"v-a87f8e4c#字符串函数\",\"1442\":\"v-a87f8e4c#数值函数\",\"1443\":\"v-a87f8e4c#时间和日期函数\",\"1444\":\"v-a87f8e4c#聚合函数\",\"1445\":\"v-a87f8e4c@0\",\"1446\":\"v-a87f8e4c@1\",\"1447\":\"v-1df5d4d6\",\"1448\":\"v-1df5d4d6@0\",\"1449\":\"v-1df5d4d6@1\",\"1450\":\"v-2648a679\",\"1451\":\"v-2648a679#什么是关系型数据库\",\"1452\":\"v-2648a679#常见的数据库有哪些\",\"1453\":\"v-2648a679#mysql区别于其他关系型数据库的特点\",\"1454\":\"v-2648a679#mysql的服务模型是\",\"1455\":\"v-2648a679#epoll比select性能好-为什么不用epoll而是选用select\",\"1456\":\"v-2648a679@0\",\"1457\":\"v-2648a679@1\",\"1458\":\"v-cc05253e\",\"1459\":\"v-cc05253e#范式设计好处\",\"1460\":\"v-cc05253e#第一范式-1nf\",\"1461\":\"v-cc05253e#第二范式-2nf\",\"1462\":\"v-cc05253e#第三范式-3nf\",\"1463\":\"v-cc05253e#bc范式-bcnf\",\"1464\":\"v-cc05253e#第四范式-4nf\",\"1465\":\"v-cc05253e#不满足的范式的表怎么办\",\"1466\":\"v-cc05253e@0\",\"1467\":\"v-cc05253e@1\",\"1468\":\"v-84ceb2f4\",\"1469\":\"v-84ceb2f4#算数运算符\",\"1470\":\"v-84ceb2f4#逻辑运算符\",\"1471\":\"v-84ceb2f4#比较运算符\",\"1472\":\"v-84ceb2f4@0\",\"1473\":\"v-84ceb2f4@1\",\"1474\":\"v-47deb978\",\"1475\":\"v-47deb978#insert增加\",\"1476\":\"v-47deb978#每次插入一条和一次插入多条的区别在于\",\"1477\":\"v-47deb978#注意\",\"1478\":\"v-47deb978#update修改\",\"1479\":\"v-47deb978#注意-1\",\"1480\":\"v-47deb978#delete删除\",\"1481\":\"v-47deb978#主键id是自增的有上限-用完了能否复用被删掉的id\",\"1482\":\"v-47deb978@0\",\"1483\":\"v-47deb978@1\",\"1484\":\"v-68cfc132\",\"1485\":\"v-68cfc132#_1-授予权限grant\",\"1486\":\"v-68cfc132#_2-回收权限revoke\",\"1487\":\"v-68cfc132@0\",\"1488\":\"v-68cfc132@1\",\"1489\":\"v-1509bd1e\",\"1490\":\"v-1509bd1e#_1-增insert\",\"1491\":\"v-1509bd1e#_2-删delete\",\"1492\":\"v-1509bd1e#_3-改update\",\"1493\":\"v-1509bd1e#_4-查select\",\"1494\":\"v-1509bd1e#_1-普通查询\",\"1495\":\"v-1509bd1e#_2-去重查询\",\"1496\":\"v-1509bd1e#_3-排序查询\",\"1497\":\"v-1509bd1e#_4-分组查询-sum-相加-count统计数据个数-year获取年份\",\"1498\":\"v-1509bd1e#_5-等值查询-按照笛卡尔乘积方式处理-效率太低\",\"1499\":\"v-1509bd1e#_6-连接查询-先将范围缩小-再按照笛卡尔乘积方式处理-效率提高。\",\"1500\":\"v-1509bd1e#_6-1外连接查询\",\"1501\":\"v-1509bd1e#_6-2内连接查询-只筛选匹配项-不匹配不显示。\",\"1502\":\"v-1509bd1e#_7-聚合查询\",\"1503\":\"v-1509bd1e@0\",\"1504\":\"v-1509bd1e@1\",\"1505\":\"v-5312ebd6\",\"1506\":\"v-5312ebd6#库操作\",\"1507\":\"v-5312ebd6#库操作小结\",\"1508\":\"v-5312ebd6#其他\",\"1509\":\"v-5312ebd6@0\",\"1510\":\"v-5312ebd6@1\",\"1511\":\"v-cb572402\",\"1512\":\"v-cb572402#去重distinct\",\"1513\":\"v-cb572402#空值查询\",\"1514\":\"v-cb572402#union-合并查询\",\"1515\":\"v-cb572402#带in子查询\",\"1516\":\"v-cb572402#分页查询limit\",\"1517\":\"v-cb572402#limit只是对select显示条数进行限制了-还是说还能影响sql的查询效率呢\",\"1518\":\"v-cb572402#mysql是如何查询的\",\"1519\":\"v-cb572402#如何提高查询效率\",\"1520\":\"v-cb572402#explain查看执行计划\",\"1521\":\"v-cb572402#explain各个字段代表的意思\",\"1522\":\"v-cb572402#limit对于查询的作用\",\"1523\":\"v-cb572402#快速插入海量数据-存储过程\",\"1524\":\"v-cb572402#limit实际应用的优化\",\"1525\":\"v-cb572402#排序order-by\",\"1526\":\"v-cb572402#分组group-by\",\"1527\":\"v-cb572402#mysql5-7-group-by会自动排序-mysql8-0没有\",\"1528\":\"v-cb572402#mysql5-7\",\"1529\":\"v-cb572402#mysql8-0\",\"1530\":\"v-cb572402#注意\",\"1531\":\"v-cb572402#练习题\",\"1532\":\"v-cb572402@0\",\"1533\":\"v-cb572402@1\",\"1534\":\"v-a056d220\",\"1535\":\"v-a056d220#为什么需要连接查询\",\"1536\":\"v-a056d220#概述\",\"1537\":\"v-a056d220#内连接\",\"1538\":\"v-a056d220#练习\",\"1539\":\"v-a056d220#与limit相结合\",\"1540\":\"v-a056d220#大小表\",\"1541\":\"v-a056d220#条件过滤\",\"1542\":\"v-a056d220#外连接\",\"1543\":\"v-a056d220#左外连接查询\",\"1544\":\"v-a056d220#右外连接查询\",\"1545\":\"v-a056d220@0\",\"1546\":\"v-a056d220@1\",\"1547\":\"v-eedfc64a\",\"1548\":\"v-eedfc64a#结构化查询语句sql-structure-query-language\",\"1549\":\"v-eedfc64a@0\",\"1550\":\"v-eedfc64a@1\",\"1551\":\"v-0c1daf9d\",\"1552\":\"v-0c1daf9d#表操作小结\",\"1553\":\"v-0c1daf9d@0\",\"1554\":\"v-0c1daf9d@1\",\"1555\":\"v-15be756c\",\"1556\":\"v-15be756c#查看mysql存储的文件\",\"1557\":\"v-15be756c#q-不同存储引擎有什么区别\",\"1558\":\"v-15be756c#q-为什么innodb不加主键会自动生成一个主键-而myisam不会\",\"1559\":\"v-15be756c#了解\",\"1560\":\"v-15be756c@0\",\"1561\":\"v-15be756c@1\",\"1562\":\"v-32ca78ec\",\"1563\":\"v-32ca78ec#主键\",\"1564\":\"v-32ca78ec#二级索引\",\"1565\":\"v-32ca78ec#回表的过程\",\"1566\":\"v-32ca78ec#练习\",\"1567\":\"v-32ca78ec@0\",\"1568\":\"v-32ca78ec@1\",\"1569\":\"v-f2fadc9e\",\"1570\":\"v-f2fadc9e@0\",\"1571\":\"v-f2fadc9e@1\",\"1572\":\"v-08c9d541\",\"1573\":\"v-08c9d541#慢查询使用方法\",\"1574\":\"v-08c9d541#慢查询日志相关的参数\",\"1575\":\"v-08c9d541#慢查询日志实践\",\"1576\":\"v-08c9d541#_1-打开慢查询日志开关slow-query-log\",\"1577\":\"v-08c9d541#_1-打开慢查询日志开关slow-query-log-1\",\"1578\":\"v-08c9d541#_2-设置合理的、业务可以接受的慢查询时间上限long-query-time\",\"1579\":\"v-08c9d541#_3-压测执行各种业务\",\"1580\":\"v-08c9d541#_4-查看慢查询日志\",\"1581\":\"v-08c9d541#_5-用explain分析这些耗时的sql语句-从而针对性优化\",\"1582\":\"v-08c9d541#show-profiles查看sql具体的运行时间-更详细的时间\",\"1583\":\"v-08c9d541@0\",\"1584\":\"v-08c9d541@1\",\"1585\":\"v-976bf48a\",\"1586\":\"v-976bf48a#问题1-用联合索引优化using-filesort\",\"1587\":\"v-976bf48a#问题2-给区分度高的字段加索引\",\"1588\":\"v-976bf48a#问题3-select的字段会导致回表\",\"1589\":\"v-976bf48a#问题4-多个字段有索引-使用哪个索引\",\"1590\":\"v-976bf48a#问题5-内连接之大表和小表\",\"1591\":\"v-976bf48a#问题6-模糊搜索-范围搜索使用索引\",\"1592\":\"v-976bf48a#问题7-in和not-in是否能用到索引-not-in优化成range范围搜索\",\"1593\":\"v-976bf48a#问题8-索引字段涉及函数以及类型转换-无法用到索引\",\"1594\":\"v-976bf48a#问题9-or不能使用索引\",\"1595\":\"v-976bf48a#总结\",\"1596\":\"v-976bf48a@0\",\"1597\":\"v-976bf48a@1\",\"1598\":\"v-19f8f8e4\",\"1599\":\"v-19f8f8e4#查看索引类型\",\"1600\":\"v-19f8f8e4#注意mysql5-7-show-create-table-反应的索引类型不准\",\"1601\":\"v-19f8f8e4#哈希索引-1\",\"1602\":\"v-19f8f8e4#看起来哈希表比b-树好-那为什么myisam和innodb存储引擎用的是b-树索引\",\"1603\":\"v-19f8f8e4#创建哈希索引\",\"1604\":\"v-19f8f8e4#小结\",\"1605\":\"v-19f8f8e4@0\",\"1606\":\"v-19f8f8e4@1\",\"1607\":\"v-4b2179bb\",\"1608\":\"v-4b2179bb#索引是什么\",\"1609\":\"v-4b2179bb#索引的好处和坏处\",\"1610\":\"v-4b2179bb#索引的分类\",\"1611\":\"v-4b2179bb@0\",\"1612\":\"v-4b2179bb@1\",\"1613\":\"v-4d1339f4\",\"1614\":\"v-4d1339f4#索引的创建和删除\",\"1615\":\"v-4d1339f4#索引的优化\",\"1616\":\"v-4d1339f4#mysql端口号的查看\",\"1617\":\"v-4d1339f4#索引的执行过程\",\"1618\":\"v-4d1339f4#explain结果字段分析\",\"1619\":\"v-4d1339f4@0\",\"1620\":\"v-4d1339f4@1\",\"1621\":\"v-b30276bc\",\"1622\":\"v-b30276bc#avl平衡二叉树索引\",\"1623\":\"v-b30276bc#b树索引\",\"1624\":\"v-b30276bc#data-存储的是数据本身内容-还是磁盘上的地址\",\"1625\":\"v-b30276bc#b-树\",\"1626\":\"v-b30276bc#为什么mysql-myisam和innodb-索引底层选择b-树而不是b树呢\",\"1627\":\"v-b30276bc#总结回答为什么使用b-树构建索引\",\"1628\":\"v-b30276bc@0\",\"1629\":\"v-b30276bc@1\",\"1630\":\"v-1776ebf2\",\"1631\":\"v-1776ebf2#隔离级别概念\",\"1632\":\"v-1776ebf2#查看隔离级别\",\"1633\":\"v-1776ebf2#测试read-uncommitted隔离级别\",\"1634\":\"v-1776ebf2#测试transaction-read-committed隔离级别\",\"1635\":\"v-1776ebf2#测试transaction-repeatable-read隔离级别\",\"1636\":\"v-1776ebf2#测试transaction-serializable隔离级别\",\"1637\":\"v-1776ebf2@0\",\"1638\":\"v-1776ebf2@1\",\"1639\":\"v-51f2dcf6\",\"1640\":\"v-51f2dcf6#事务相关命令\",\"1641\":\"v-51f2dcf6@0\",\"1642\":\"v-51f2dcf6@1\",\"1643\":\"v-0359a68f\",\"1644\":\"v-0359a68f#acid特性\",\"1645\":\"v-0359a68f#innodb-引擎通过什么技术来保证事务的这四个特性的呢\",\"1646\":\"v-0359a68f@0\",\"1647\":\"v-0359a68f@1\",\"1648\":\"v-558f976c\",\"1649\":\"v-558f976c#定义\",\"1650\":\"v-558f976c#代码上的事务操作\",\"1651\":\"v-558f976c#查看当前数据库支持的存储引擎\",\"1652\":\"v-558f976c#修改提交方式\",\"1653\":\"v-558f976c@0\",\"1654\":\"v-558f976c@1\",\"1655\":\"v-3ef06b8b\",\"1656\":\"v-3ef06b8b#一、mvcc概念\",\"1657\":\"v-3ef06b8b#二、mvcc应用于已提交读隔离级别\",\"1658\":\"v-3ef06b8b#_1-解决脏读\",\"1659\":\"v-3ef06b8b#_2-无法解决不可重复读\",\"1660\":\"v-3ef06b8b#_3-无法解决幻读\",\"1661\":\"v-3ef06b8b#三、mvcc应用于可重复读隔离级别\",\"1662\":\"v-3ef06b8b#_1-解决脏读-1\",\"1663\":\"v-3ef06b8b#_2-解决不可重复读\",\"1664\":\"v-3ef06b8b#_3-理解-可重复读隔离级别-只生成一次数据快照\",\"1665\":\"v-3ef06b8b#_4-理解-可重复读隔离级别-只能部分解决幻读\",\"1666\":\"v-3ef06b8b@0\",\"1667\":\"v-3ef06b8b@1\",\"1668\":\"v-a01dbb18\",\"1669\":\"v-a01dbb18#一、innodb表级锁\",\"1670\":\"v-a01dbb18#适合使用表索的情况\",\"1671\":\"v-a01dbb18#表索的相关命令\",\"1672\":\"v-a01dbb18#在使用表锁的时候-涉及到效率的问题\",\"1673\":\"v-a01dbb18#二、意向共享锁和意向排他锁-表锁而非行锁\",\"1674\":\"v-a01dbb18@0\",\"1675\":\"v-a01dbb18@1\",\"1676\":\"v-329074fa\",\"1677\":\"v-329074fa#一、引入-undo-log\",\"1678\":\"v-329074fa#二、undo-log\",\"1679\":\"v-329074fa#_1-undo-log的概念\",\"1680\":\"v-329074fa#_2-undo-log的作用\",\"1681\":\"v-329074fa#_3-undo-log的数据结构\",\"1682\":\"v-329074fa#三、undo-log举例\",\"1683\":\"v-329074fa@0\",\"1684\":\"v-329074fa@1\",\"1685\":\"v-1029a01f\",\"1686\":\"v-1029a01f#一、间隙锁概念\",\"1687\":\"v-1029a01f#二、测试间隙锁范围加锁\",\"1688\":\"v-1029a01f#场景1-用不可重复的主键id测试间隙锁\",\"1689\":\"v-1029a01f#场景2-用可重复的age-有索引-测试间隙锁\",\"1690\":\"v-1029a01f#场景3-mysql5-7实际情况需要具体分析用的到底是行锁还是表锁\",\"1691\":\"v-1029a01f#三、测试等值间隙锁\",\"1692\":\"v-1029a01f#_1-测试不能重复的主键索引\",\"1693\":\"v-1029a01f#_2-测试能重复的辅助索引\",\"1694\":\"v-1029a01f#小结\",\"1695\":\"v-1029a01f@0\",\"1696\":\"v-1029a01f@1\",\"1697\":\"v-664794b6\",\"1698\":\"v-664794b6#显式加锁\",\"1699\":\"v-664794b6#测试不同事务之间排它锁和共享锁的兼容性\",\"1700\":\"v-664794b6#测试行锁加在索引项上\",\"1701\":\"v-664794b6#串行化隔离级别测试\",\"1702\":\"v-664794b6#注意\",\"1703\":\"v-664794b6@0\",\"1704\":\"v-664794b6@1\",\"1705\":\"v-1743001b\",\"1706\":\"v-1743001b#数据库中的死锁\",\"1707\":\"v-1743001b#死锁场景以及解决办法\",\"1708\":\"v-1743001b#操作\",\"1709\":\"v-1743001b@0\",\"1710\":\"v-1743001b@1\",\"1711\":\"v-25bb8896\",\"1712\":\"v-25bb8896#一、事务隔离机制的选择\",\"1713\":\"v-25bb8896#二、表级锁-行级锁\",\"1714\":\"v-25bb8896@0\",\"1715\":\"v-25bb8896@1\",\"1716\":\"v-5dfb342e\",\"1717\":\"v-5dfb342e#mysql-是怎么解决幻读的\",\"1718\":\"v-5dfb342e#加锁分析\",\"1719\":\"v-5dfb342e#如果对-age-没有索引-事务-a-这条查询会加什么锁呢\",\"1720\":\"v-5dfb342e#如果对-age-建立索引-事务-a-这条查询会加什么锁呢\",\"1721\":\"v-5dfb342e#总结\",\"1722\":\"v-5dfb342e@0\",\"1723\":\"v-5dfb342e@1\",\"1724\":\"v-416fc51c\",\"1725\":\"v-416fc51c@0\",\"1726\":\"v-416fc51c@1\",\"1727\":\"v-167ae4a4\",\"1728\":\"v-167ae4a4#一、大批量插入数据\",\"1729\":\"v-167ae4a4#_1-主键顺序插入\",\"1730\":\"v-167ae4a4#_2-关闭唯一性校验\",\"1731\":\"v-167ae4a4#_3-手动提交事务\",\"1732\":\"v-167ae4a4#二、优化insert\",\"1733\":\"v-167ae4a4#_1-逐条插入改为批量插入\",\"1734\":\"v-167ae4a4#_2-在事务中进行数据插入\",\"1735\":\"v-167ae4a4#_3-数据有序插入\",\"1736\":\"v-167ae4a4#三、优化order-by\",\"1737\":\"v-167ae4a4#四、mysql5-7优化group-by\",\"1738\":\"v-167ae4a4#五、优化子查询\",\"1739\":\"v-167ae4a4#六、优化or\",\"1740\":\"v-167ae4a4#七、优化分页查询\",\"1741\":\"v-167ae4a4@0\",\"1742\":\"v-167ae4a4@1\",\"1743\":\"v-fb0c9a20\",\"1744\":\"v-fb0c9a20#一、sql语句和索引的优化\",\"1745\":\"v-fb0c9a20#二、应用优化\",\"1746\":\"v-fb0c9a20#三、mysql-server优化\",\"1747\":\"v-fb0c9a20#自适应哈希索引\",\"1748\":\"v-fb0c9a20#redo-log\",\"1749\":\"v-fb0c9a20#mysql查询缓存\",\"1750\":\"v-fb0c9a20#mysql5-7-支持查询缓存\",\"1751\":\"v-fb0c9a20#mysql8-0-不支持查询缓存\",\"1752\":\"v-fb0c9a20#索引和数据缓存\",\"1753\":\"v-fb0c9a20#mysql线程缓存\",\"1754\":\"v-fb0c9a20#并发连接数量和超时时间\",\"1755\":\"v-fb0c9a20@0\",\"1756\":\"v-fb0c9a20@1\",\"1757\":\"v-403714d4\",\"1758\":\"v-403714d4#一、redo-log概念\",\"1759\":\"v-403714d4#二、缓存、磁盘结构\",\"1760\":\"v-403714d4#是不是commit的时候-buffer-pool里面的脏数据-数据有被修改-同步被写入磁盘\",\"1761\":\"v-403714d4#undo-log本身也是记录在redo-log中\",\"1762\":\"v-403714d4#什么是真正的事务commit成功\",\"1763\":\"v-403714d4#什么叫事务commit成功-和上面的问题一样\",\"1764\":\"v-403714d4@0\",\"1765\":\"v-403714d4@1\",\"1766\":\"v-f10dc5a4\",\"1767\":\"v-f10dc5a4#一、mysql-server层日志简介\",\"1768\":\"v-f10dc5a4#查看日志相关变量\",\"1769\":\"v-f10dc5a4#二、配置文件参数\",\"1770\":\"v-f10dc5a4#三、错误日志\",\"1771\":\"v-f10dc5a4#四、查询日志\",\"1772\":\"v-f10dc5a4#五、二进制日志\",\"1773\":\"v-f10dc5a4#_1-演示binlog记录更改\",\"1774\":\"v-f10dc5a4#_2-演示binlog数据恢复\",\"1775\":\"v-f10dc5a4#mysql数据恢复小结\",\"1776\":\"v-f10dc5a4#六、慢查询日志\",\"1777\":\"v-f10dc5a4@0\",\"1778\":\"v-f10dc5a4@1\",\"1779\":\"v-4dda2b40\",\"1780\":\"v-4dda2b40#主从复制概念\",\"1781\":\"v-4dda2b40#读写分离概念\",\"1782\":\"v-4dda2b40#主库介绍\",\"1783\":\"v-4dda2b40#从库介绍\",\"1784\":\"v-4dda2b40#主从复制流程\",\"1785\":\"v-4dda2b40#主从复制效果展示\",\"1786\":\"v-4dda2b40#查看master当前环境下的工作线程\",\"1787\":\"v-4dda2b40@0\",\"1788\":\"v-4dda2b40@1\",\"1789\":\"v-1015e72b\",\"1790\":\"v-1015e72b#读写分离概念\",\"1791\":\"v-1015e72b#引入中间件mycat\",\"1792\":\"v-1015e72b#mycat服务端口和管理端口\",\"1793\":\"v-1015e72b@0\",\"1794\":\"v-1015e72b@1\",\"1795\":\"v-afe3b5ec\",\"1796\":\"v-afe3b5ec#一、环境准备\",\"1797\":\"v-afe3b5ec#_1-查看主从复制状态\",\"1798\":\"v-afe3b5ec#_2-查看jdk版本\",\"1799\":\"v-afe3b5ec#_3-打开root的远程连接权限\",\"1800\":\"v-afe3b5ec#_4-安装mycat\",\"1801\":\"v-afe3b5ec#二、配置文件\",\"1802\":\"v-afe3b5ec#_1-server-xml\",\"1803\":\"v-afe3b5ec#_2-schema-xml\",\"1804\":\"v-afe3b5ec#三、启动服务\",\"1805\":\"v-afe3b5ec#_1-配置文件问题一\",\"1806\":\"v-afe3b5ec#_2-配置文件问题二\",\"1807\":\"v-afe3b5ec#四、mycat-9066端口和8066端口\",\"1808\":\"v-afe3b5ec#_1-9066管理端口\",\"1809\":\"v-afe3b5ec#_2-8066数据端口\",\"1810\":\"v-afe3b5ec#五、验证读写分离\",\"1811\":\"v-afe3b5ec#_1-打开查询日志general-log\",\"1812\":\"v-afe3b5ec#_2-验证读操作在slave\",\"1813\":\"v-afe3b5ec#_3-验证写操作在master\",\"1814\":\"v-afe3b5ec#验证容灾功能\",\"1815\":\"v-afe3b5ec@0\",\"1816\":\"v-afe3b5ec@1\",\"1817\":\"v-ab0fa402\",\"1818\":\"v-ab0fa402#一、检测通信\",\"1819\":\"v-ab0fa402#二、master配置\",\"1820\":\"v-ab0fa402#_1-开启二进制日志\",\"1821\":\"v-ab0fa402#_2-创建一个用于主从库通信用的账号\",\"1822\":\"v-ab0fa402#_3-获取binlog文件名和position\",\"1823\":\"v-ab0fa402#三、slave配置\",\"1824\":\"v-ab0fa402#_1-配置全局唯一的server-id\",\"1825\":\"v-ab0fa402#_2-使用master创建的账户读取binlog同步数据\",\"1826\":\"v-ab0fa402#_3-启动slave服务\",\"1827\":\"v-ab0fa402#四、配置中可能出现的问题\",\"1828\":\"v-ab0fa402#_1-网络连接问题\",\"1829\":\"v-ab0fa402#_2-binlog的position问题\",\"1830\":\"v-ab0fa402#_3-sql线程出错\",\"1831\":\"v-ab0fa402#总结\",\"1832\":\"v-ab0fa402#master配置\",\"1833\":\"v-ab0fa402#slave配置\",\"1834\":\"v-ab0fa402@0\",\"1835\":\"v-ab0fa402@1\",\"1836\":\"v-18b96408\",\"1837\":\"v-18b96408@0\",\"1838\":\"v-18b96408@1\",\"1839\":\"v-fb24ca0e\",\"1840\":\"v-fb24ca0e@0\",\"1841\":\"v-fb24ca0e@1\",\"1842\":\"v-379adba2\",\"1843\":\"v-379adba2#连接池代码\",\"1844\":\"v-379adba2#mysql-cnf配置文件\",\"1845\":\"v-379adba2#public-h公共头文件\",\"1846\":\"v-379adba2#connection-h数据库操作头文件\",\"1847\":\"v-379adba2#connection-cc数据库操作的封装实现\",\"1848\":\"v-379adba2#connectionpool-h连接池的头文件\",\"1849\":\"v-379adba2#connectionpool-cc连接池的实现\",\"1850\":\"v-379adba2#压力测试\",\"1851\":\"v-379adba2#单线程\",\"1852\":\"v-379adba2@0\",\"1853\":\"v-379adba2@1\",\"1854\":\"v-2247d511\",\"1855\":\"v-2247d511#在vs上使用mysql的头文件和库文件的配置\",\"1856\":\"v-2247d511#代码\",\"1857\":\"v-2247d511@0\",\"1858\":\"v-2247d511@1\",\"1859\":\"v-874c376e\",\"1860\":\"v-874c376e@0\",\"1861\":\"v-874c376e@1\",\"1862\":\"v-5e84d900\",\"1863\":\"v-5e84d900#关键技术点\",\"1864\":\"v-5e84d900#项目背景\",\"1865\":\"v-5e84d900#连接池功能点介绍\",\"1866\":\"v-5e84d900#功能实现设计\",\"1867\":\"v-5e84d900@0\",\"1868\":\"v-5e84d900@1\",\"1869\":\"v-51fa1311\",\"1870\":\"v-51fa1311#重置智能指针析构\",\"1871\":\"v-51fa1311#wait-for-优化\",\"1872\":\"v-51fa1311#最终版-消费者线程处理函数\",\"1873\":\"v-51fa1311@0\",\"1874\":\"v-51fa1311@1\",\"1875\":\"v-47e7636c\",\"1876\":\"v-47e7636c@0\",\"1877\":\"v-47e7636c@1\",\"1878\":\"v-f00ce0e0\",\"1879\":\"v-f00ce0e0@0\",\"1880\":\"v-f00ce0e0@1\",\"1881\":\"v-125a45f0\",\"1882\":\"v-125a45f0@0\",\"1883\":\"v-125a45f0@1\",\"1884\":\"v-73d634fe\",\"1885\":\"v-73d634fe#一、为什么要分库分表\",\"1886\":\"v-73d634fe#二、库表太大产生的问题\",\"1887\":\"v-73d634fe#三、垂直拆分\",\"1888\":\"v-73d634fe#_1-垂直分库\",\"1889\":\"v-73d634fe#_2-垂直分表\",\"1890\":\"v-73d634fe#四、水平分表\",\"1891\":\"v-73d634fe#_1-配置水平分表\",\"1892\":\"v-73d634fe#_2-测试水平分表\",\"1893\":\"v-73d634fe@0\",\"1894\":\"v-73d634fe@1\",\"1895\":\"v-6dabb7d0\",\"1896\":\"v-6dabb7d0#一、json简介\",\"1897\":\"v-6dabb7d0#二、json语法\",\"1898\":\"v-6dabb7d0#_2-1-json语法\",\"1899\":\"v-6dabb7d0#_2-2-json的两种结构\",\"1900\":\"v-6dabb7d0#_2-3-书写格式\",\"1901\":\"v-6dabb7d0#三、数据序列化实例\",\"1902\":\"v-6dabb7d0#_3-1-普通数据序列化\",\"1903\":\"v-6dabb7d0#利用dump-方法-将dict类型的数据转成str。\",\"1904\":\"v-6dabb7d0#_3-2-json添加数组类型\",\"1905\":\"v-6dabb7d0#_3-3-容器序列化\",\"1906\":\"v-6dabb7d0#四、json-parse-数据反序列化实例\",\"1907\":\"v-6dabb7d0#_4-1-普通数据反序列化\",\"1908\":\"v-6dabb7d0#_4-2-数组类型数据反序列化\",\"1909\":\"v-6dabb7d0#容器反序列化\",\"1910\":\"v-6dabb7d0@0\",\"1911\":\"v-6dabb7d0@1\",\"1912\":\"v-5dfb637b\",\"1913\":\"v-5dfb637b#一、protobuf简介\",\"1914\":\"v-5dfb637b#二、protobuf语法\",\"1915\":\"v-5dfb637b#三、protobuf简单使用实例\",\"1916\":\"v-5dfb637b@0\",\"1917\":\"v-5dfb637b@1\",\"1918\":\"v-430f9745\",\"1919\":\"v-a38f78a4\",\"1920\":\"v-7d94f39a\",\"1921\":\"v-4086f3eb\",\"1922\":\"v-25ac69a1\",\"1923\":\"v-161970cb\",\"1924\":\"v-18808a57\",\"1925\":\"v-39d32ddd\",\"1926\":\"v-e5b5c7b4\",\"1927\":\"v-0d4e4374\",\"1928\":\"v-18205b42\",\"1929\":\"v-19c3cc7c\",\"1930\":\"v-b5fbe93e\",\"1931\":\"v-5782c814\",\"1932\":\"v-17daa261\",\"1933\":\"v-bcefe488\",\"1934\":\"v-9fb994fc\",\"1935\":\"v-3f33a400\",\"1936\":\"v-34ae7acc\",\"1937\":\"v-1ce298e7\",\"1938\":\"v-6c43b8e2\",\"1939\":\"v-66256d6e\",\"1940\":\"v-0ee4786c\",\"1941\":\"v-1e2d2742\",\"1942\":\"v-063f0d28\",\"1943\":\"v-7991b247\",\"1944\":\"v-718e2d40\",\"1945\":\"v-6efd5e40\",\"1946\":\"v-14d4901c\",\"1947\":\"v-3899b171\",\"1948\":\"v-5157b212\",\"1949\":\"v-266f8726\",\"1950\":\"v-1f23f62c\",\"1951\":\"v-5764c670\",\"1952\":\"v-ed8603cc\",\"1953\":\"v-9eec0ba4\",\"1954\":\"v-13ac5d5f\",\"1955\":\"v-7c538d12\",\"1956\":\"v-44e73480\",\"1957\":\"v-8f661f1c\",\"1958\":\"v-42abb996\",\"1959\":\"v-706b751e\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,93],\"1\":[1],\"2\":[1],\"3\":[2,10],\"4\":[1,6],\"5\":[1,23],\"6\":[2,11],\"7\":[1],\"8\":[1,46],\"9\":[null,null,1],\"10\":[null,null,2],\"11\":[3,40],\"12\":[null,null,1],\"13\":[null,null,2],\"14\":[2],\"15\":[1],\"16\":[1,38],\"17\":[1,35],\"18\":[null,null,1],\"19\":[null,null,2],\"20\":[1],\"21\":[1],\"22\":[1,46],\"23\":[null,null,1],\"24\":[null,null,2],\"25\":[1],\"26\":[1],\"27\":[1,23],\"28\":[1,14],\"29\":[1,88],\"30\":[1,17],\"31\":[1],\"32\":[2],\"33\":[2,6],\"34\":[2],\"35\":[1,2],\"36\":[3,3],\"37\":[1],\"38\":[1,4],\"39\":[1,2],\"40\":[1,2],\"41\":[1,11],\"42\":[1],\"43\":[1],\"44\":[2,27],\"45\":[1,38],\"46\":[1,14],\"47\":[1,1],\"48\":[1,33],\"49\":[1,64],\"50\":[1,54],\"51\":[3,103],\"52\":[1,11],\"53\":[1,39],\"54\":[1,53],\"55\":[6],\"56\":[1,16],\"57\":[1,4],\"58\":[1,5],\"59\":[1,219],\"60\":[1,163],\"61\":[1,32],\"62\":[1,15],\"63\":[1,28],\"64\":[1],\"65\":[1,5],\"66\":[4,26],\"67\":[3,45],\"68\":[null,null,1],\"69\":[null,null,3],\"70\":[3,47],\"71\":[null,null,1],\"72\":[null,null,2],\"73\":[3,45],\"74\":[null,null,1],\"75\":[null,null,3],\"76\":[3,15],\"77\":[1,28],\"78\":[1,46],\"79\":[null,null,1],\"80\":[null,null,2],\"81\":[3,77],\"82\":[null,null,1],\"83\":[null,null,1],\"84\":[3,31],\"85\":[null,null,1],\"86\":[null,null,2],\"87\":[3,45],\"88\":[null,null,1],\"89\":[null,null,2],\"90\":[1],\"91\":[2,15],\"92\":[1],\"93\":[1,38],\"94\":[1,34],\"95\":[3,17],\"96\":[1,45],\"97\":[1,35],\"98\":[null,null,1],\"99\":[null,null,2],\"100\":[1,22],\"101\":[1,102],\"102\":[null,null,1],\"103\":[null,null,2],\"104\":[1,63],\"105\":[null,null,1],\"106\":[null,null,1],\"107\":[1,74],\"108\":[null,null,1],\"109\":[null,null,1],\"110\":[1,99],\"111\":[null,null,1],\"112\":[null,null,3],\"113\":[1,12],\"114\":[1,16],\"115\":[1,25],\"116\":[null,null,1],\"117\":[null,null,1],\"118\":[1,42],\"119\":[null,null,1],\"120\":[null,null,1],\"121\":[1,26],\"122\":[null,null,1],\"123\":[null,null,2],\"124\":[3,17],\"125\":[2,35],\"126\":[2,38],\"127\":[null,null,1],\"128\":[null,null,2],\"129\":[3,59],\"130\":[null,null,1],\"131\":[null,null,1],\"132\":[3,21],\"133\":[2,45],\"134\":[1],\"135\":[1,62],\"136\":[1,49],\"137\":[4,42],\"138\":[null,null,1],\"139\":[null,null,2],\"140\":[5,32],\"141\":[2,29],\"142\":[2,43],\"143\":[2,31],\"144\":[null,null,1],\"145\":[null,null,3],\"146\":[3,25],\"147\":[1,44],\"148\":[2,24],\"149\":[2,31],\"150\":[null,null,1],\"151\":[null,null,2],\"152\":[3,13],\"153\":[1,23],\"154\":[4,20],\"155\":[1,19],\"156\":[null,null,1],\"157\":[null,null,1],\"158\":[4,46],\"159\":[null,null,1],\"160\":[null,null,1],\"161\":[4,28],\"162\":[1,58],\"163\":[4,73],\"164\":[null,null,1],\"165\":[null,null,3],\"166\":[3,37],\"167\":[null,null,1],\"168\":[null,null,3],\"169\":[5,27],\"170\":[1,41],\"171\":[2,24],\"172\":[null,null,1],\"173\":[null,null,2],\"174\":[3,36],\"175\":[null,null,1],\"176\":[null,null,1],\"177\":[3,24],\"178\":[2,43],\"179\":[4,27],\"180\":[null,null,1],\"181\":[null,null,2],\"182\":[3,81],\"183\":[null,null,1],\"184\":[null,null,1],\"185\":[1,69],\"186\":[null,null,1],\"187\":[null,null,2],\"188\":[1,67],\"189\":[null,null,1],\"190\":[null,null,1],\"191\":[1,86],\"192\":[null,null,1],\"193\":[null,null,1],\"194\":[1,59],\"195\":[1,9],\"196\":[2,3],\"197\":[null,null,1],\"198\":[null,null,1],\"199\":[1,42],\"200\":[null,null,1],\"201\":[null,null,1],\"202\":[1,89],\"203\":[null,null,1],\"204\":[null,null,1],\"205\":[1,36],\"206\":[null,null,1],\"207\":[null,null,1],\"208\":[1],\"209\":[null,null,1],\"210\":[null,null,2],\"211\":[1],\"212\":[1,7],\"213\":[1,11],\"214\":[1,78],\"215\":[null,null,1],\"216\":[null,null,1],\"217\":[1,43],\"218\":[null,null,1],\"219\":[null,null,1],\"220\":[3,42],\"221\":[null,null,1],\"222\":[null,null,1],\"223\":[1],\"224\":[1,62],\"225\":[null,null,1],\"226\":[null,null,2],\"227\":[1,16],\"228\":[4,19],\"229\":[null,null,2],\"230\":[null,null,1],\"231\":[1],\"232\":[1,13],\"233\":[1,28],\"234\":[1,229],\"235\":[3,48],\"236\":[1,47],\"237\":[3,4],\"238\":[6,51],\"239\":[1,82],\"240\":[1,37],\"241\":[null,null,2],\"242\":[null,null,2],\"243\":[1,4],\"244\":[2,41],\"245\":[1,19],\"246\":[1,23],\"247\":[2,9],\"248\":[2,15],\"249\":[2,11],\"250\":[2,1],\"251\":[2,34],\"252\":[2,16],\"253\":[3,12],\"254\":[1],\"255\":[1,49],\"256\":[1],\"257\":[4,7],\"258\":[1,1],\"259\":[4],\"260\":[2,18],\"261\":[1,43],\"262\":[2,16],\"263\":[1,27],\"264\":[1,8],\"265\":[null,null,2],\"266\":[null,null,2],\"267\":[1,141],\"268\":[null,null,2],\"269\":[null,null,2],\"270\":[4],\"271\":[8,26],\"272\":[2],\"273\":[4,28],\"274\":[4,20],\"275\":[5,8],\"276\":[2,14],\"277\":[3,62],\"278\":[null,null,2],\"279\":[null,null,4],\"280\":[2],\"281\":[1,16],\"282\":[1,25],\"283\":[1,33],\"284\":[1,16],\"285\":[1,52],\"286\":[3,76],\"287\":[2,21],\"288\":[1],\"289\":[1,14],\"290\":[3,17],\"291\":[null,null,2],\"292\":[null,null,1],\"293\":[1,38],\"294\":[null,null,2],\"295\":[null,null,1],\"296\":[1,35],\"297\":[null,null,2],\"298\":[null,null,1],\"299\":[1],\"300\":[1,20],\"301\":[1,77],\"302\":[1,19],\"303\":[1,19],\"304\":[1,12],\"305\":[1,3],\"306\":[3,37],\"307\":[1,13],\"308\":[4,26],\"309\":[1,4],\"310\":[1,35],\"311\":[1,19],\"312\":[5,50],\"313\":[null,null,2],\"314\":[null,null,1],\"315\":[1,2],\"316\":[4,12],\"317\":[1,2],\"318\":[null,null,2],\"319\":[null,null,1],\"320\":[1,4],\"321\":[null,null,2],\"322\":[null,null,1],\"323\":[1,35],\"324\":[null,null,2],\"325\":[null,null,1],\"326\":[1,5],\"327\":[null,null,2],\"328\":[null,null,1],\"329\":[3,2],\"330\":[1,7],\"331\":[1,2],\"332\":[1],\"333\":[2,2],\"334\":[2,2],\"335\":[null,null,2],\"336\":[null,null,1],\"337\":[1,3],\"338\":[1,32],\"339\":[1,25],\"340\":[1,37],\"341\":[null,null,2],\"342\":[null,null,1],\"343\":[1],\"344\":[1,12],\"345\":[1,8],\"346\":[1,2],\"347\":[null,null,2],\"348\":[null,null,1],\"349\":[3,11],\"350\":[null,null,2],\"351\":[null,null,1],\"352\":[1],\"353\":[1,13],\"354\":[1,30],\"355\":[1,96],\"356\":[null,null,2],\"357\":[null,null,2],\"358\":[1],\"359\":[2,40],\"360\":[1,14],\"361\":[1,4],\"362\":[1,28],\"363\":[2,10],\"364\":[2,21],\"365\":[2,29],\"366\":[2,36],\"367\":[2,10],\"368\":[1,55],\"369\":[3,2],\"370\":[1,15],\"371\":[1,39],\"372\":[1,29],\"373\":[null,null,2],\"374\":[null,null,1],\"375\":[1,5],\"376\":[1,14],\"377\":[1,19],\"378\":[1,65],\"379\":[null,null,2],\"380\":[null,null,1],\"381\":[1],\"382\":[3,18],\"383\":[2,13],\"384\":[1,8],\"385\":[1,121],\"386\":[null,null,1],\"387\":[null,null,2],\"388\":[1,58],\"389\":[1,37],\"390\":[null,null,2],\"391\":[null,null,1],\"392\":[1,41],\"393\":[null,null,2],\"394\":[null,null,1],\"395\":[1,26],\"396\":[1,9],\"397\":[1,41],\"398\":[1,11],\"399\":[6,10],\"400\":[6,10],\"401\":[5,5],\"402\":[null,null,2],\"403\":[null,null,1],\"404\":[1,3],\"405\":[1,65],\"406\":[1,93],\"407\":[null,null,2],\"408\":[null,null,1],\"409\":[1],\"410\":[1,23],\"411\":[1,16],\"412\":[1,19],\"413\":[1,24],\"414\":[1,13],\"415\":[1,4],\"416\":[null,null,2],\"417\":[null,null,1],\"418\":[2,1],\"419\":[1],\"420\":[2,10],\"421\":[1,31],\"422\":[1,58],\"423\":[1,28],\"424\":[1,6],\"425\":[2,17],\"426\":[1,41],\"427\":[2,17],\"428\":[1,4],\"429\":[null,null,2],\"430\":[null,null,1],\"431\":[1,7],\"432\":[1,30],\"433\":[1,45],\"434\":[1,55],\"435\":[1,74],\"436\":[null,null,2],\"437\":[null,null,1],\"438\":[1,9],\"439\":[1,78],\"440\":[1,69],\"441\":[2,8],\"442\":[null,null,2],\"443\":[null,null,1],\"444\":[1,1],\"445\":[2,11],\"446\":[2,12],\"447\":[1,6],\"448\":[2,18],\"449\":[1,96],\"450\":[1,29],\"451\":[null,null,2],\"452\":[null,null,1],\"453\":[1,8],\"454\":[1,14],\"455\":[1,35],\"456\":[1,3],\"457\":[2,5],\"458\":[3,13],\"459\":[1,78],\"460\":[null,null,2],\"461\":[null,null,1],\"462\":[1,1],\"463\":[1,44],\"464\":[1,41],\"465\":[3,3],\"466\":[3,2],\"467\":[3,1],\"468\":[1,36],\"469\":[2,4],\"470\":[1,43],\"471\":[null,null,2],\"472\":[null,null,1],\"473\":[1,36],\"474\":[null,null,2],\"475\":[null,null,1],\"476\":[1,53],\"477\":[null,null,2],\"478\":[null,null,1],\"479\":[1,6],\"480\":[1,20],\"481\":[3,15],\"482\":[1,3],\"483\":[1,22],\"484\":[1,48],\"485\":[1,23],\"486\":[1],\"487\":[2,11],\"488\":[1,31],\"489\":[1,38],\"490\":[3,70],\"491\":[3,13],\"492\":[1,50],\"493\":[4,27],\"494\":[5,52],\"495\":[1,1],\"496\":[1,13],\"497\":[1,87],\"498\":[null,null,2],\"499\":[null,null,1],\"500\":[1,91],\"501\":[2,30],\"502\":[1,26],\"503\":[1,21],\"504\":[1,74],\"505\":[1,7],\"506\":[1,42],\"507\":[null,null,2],\"508\":[null,null,1],\"509\":[2,30],\"510\":[1,13],\"511\":[1,31],\"512\":[1,23],\"513\":[5,34],\"514\":[6,4],\"515\":[1,70],\"516\":[1,56],\"517\":[5,48],\"518\":[5,50],\"519\":[3,22],\"520\":[6,28],\"521\":[5,17],\"522\":[2,16],\"523\":[4,37],\"524\":[1,24],\"525\":[4],\"526\":[1,29],\"527\":[1,11],\"528\":[2,69],\"529\":[2,24],\"530\":[4,41],\"531\":[5,32],\"532\":[null,null,2],\"533\":[null,null,1],\"534\":[1],\"535\":[1,117],\"536\":[1,74],\"537\":[1,22],\"538\":[1,26],\"539\":[1,32],\"540\":[1,9],\"541\":[1,22],\"542\":[1,11],\"543\":[1,7],\"544\":[1,3],\"545\":[1,14],\"546\":[1,20],\"547\":[1,111],\"548\":[1,52],\"549\":[null,null,2],\"550\":[null,null,1],\"551\":[1],\"552\":[1,4],\"553\":[2,29],\"554\":[1],\"555\":[1,13],\"556\":[3,12],\"557\":[1,73],\"558\":[null,null,2],\"559\":[null,null,2],\"560\":[1,46],\"561\":[1],\"562\":[3,20],\"563\":[2,56],\"564\":[4,7],\"565\":[2,4],\"566\":[1],\"567\":[1,24],\"568\":[1,36],\"569\":[1,28],\"570\":[1,46],\"571\":[1,54],\"572\":[2,83],\"573\":[4],\"574\":[1,30],\"575\":[2,26],\"576\":[2,36],\"577\":[3,39],\"578\":[3,49],\"579\":[null,null,2],\"580\":[null,null,1],\"581\":[1,2],\"582\":[2,16],\"583\":[1,11],\"584\":[1,15],\"585\":[1,28],\"586\":[1,9],\"587\":[1,4],\"588\":[1,38],\"589\":[1,26],\"590\":[1,23],\"591\":[1,35],\"592\":[1,27],\"593\":[1,18],\"594\":[1,83],\"595\":[null,null,2],\"596\":[null,null,1],\"597\":[5,98],\"598\":[3,19],\"599\":[1,149],\"600\":[2,33],\"601\":[1,76],\"602\":[1,32],\"603\":[3,13],\"604\":[1,51],\"605\":[1,73],\"606\":[1,46],\"607\":[3,26],\"608\":[2,30],\"609\":[null,null,2],\"610\":[null,null,1],\"611\":[1],\"612\":[2,34],\"613\":[1,8],\"614\":[1,59],\"615\":[1,45],\"616\":[1,44],\"617\":[2,17],\"618\":[1,93],\"619\":[1,22],\"620\":[1,44],\"621\":[1,74],\"622\":[2,12],\"623\":[1],\"624\":[1,12],\"625\":[2,25],\"626\":[null,null,2],\"627\":[null,null,1],\"628\":[1,27],\"629\":[2,43],\"630\":[2,56],\"631\":[2,71],\"632\":[2,24],\"633\":[1,56],\"634\":[null,null,2],\"635\":[null,null,1],\"636\":[1,6],\"637\":[1,27],\"638\":[3,36],\"639\":[1,25],\"640\":[1,25],\"641\":[1,17],\"642\":[1,32],\"643\":[null,null,2],\"644\":[null,null,1],\"645\":[1],\"646\":[1,8],\"647\":[1,10],\"648\":[1],\"649\":[2,11],\"650\":[1,11],\"651\":[1,9],\"652\":[1,30],\"653\":[1,44],\"654\":[null,null,2],\"655\":[null,null,1],\"656\":[1],\"657\":[1,12],\"658\":[3,12],\"659\":[3,11],\"660\":[null,null,2],\"661\":[null,null,1],\"662\":[1,87],\"663\":[null,null,2],\"664\":[null,null,1],\"665\":[1,9],\"666\":[1,6],\"667\":[1,28],\"668\":[1],\"669\":[2,20],\"670\":[2,19],\"671\":[2,7],\"672\":[2,24],\"673\":[1,13],\"674\":[1,7],\"675\":[1,17],\"676\":[null,null,2],\"677\":[null,null,1],\"678\":[1,69],\"679\":[null,null,2],\"680\":[null,null,1],\"681\":[1],\"682\":[1,11],\"683\":[1,7],\"684\":[2,30],\"685\":[1,10],\"686\":[null,null,2],\"687\":[null,null,1],\"688\":[1,93],\"689\":[null,null,2],\"690\":[null,null,1],\"691\":[5],\"692\":[4,29],\"693\":[4,18],\"694\":[2,8],\"695\":[4,80],\"696\":[null,null,2],\"697\":[null,null,1],\"698\":[1,66],\"699\":[2,75],\"700\":[1,18],\"701\":[1,14],\"702\":[null,null,2],\"703\":[null,null,2],\"704\":[1,137],\"705\":[null,null,2],\"706\":[null,null,2],\"707\":[1,15],\"708\":[3,28],\"709\":[1,12],\"710\":[3,23],\"711\":[3,15],\"712\":[5],\"713\":[2,14],\"714\":[2,26],\"715\":[1,49],\"716\":[5,5],\"717\":[2,20],\"718\":[1,16],\"719\":[null,null,1],\"720\":[null,null,3],\"721\":[1,14],\"722\":[1,26],\"723\":[1,8],\"724\":[1,10],\"725\":[null,null,2],\"726\":[null,null,1],\"727\":[1,14],\"728\":[1,23],\"729\":[1,8],\"730\":[3,18],\"731\":[1,69],\"732\":[null,null,2],\"733\":[null,null,1],\"734\":[1],\"735\":[1,14],\"736\":[1,79],\"737\":[null,null,2],\"738\":[null,null,1],\"739\":[1],\"740\":[1,3],\"741\":[1,13],\"742\":[3,41],\"743\":[4,36],\"744\":[1,4],\"745\":[2,36],\"746\":[2,35],\"747\":[1,171],\"748\":[null,null,2],\"749\":[null,null,2],\"750\":[1,20],\"751\":[1,112],\"752\":[null,null,2],\"753\":[null,null,4],\"754\":[3,13],\"755\":[2,42],\"756\":[5,78],\"757\":[null,null,1],\"758\":[null,null,3],\"759\":[3,41],\"760\":[null,null,1],\"761\":[null,null,2],\"762\":[3,51],\"763\":[null,null,1],\"764\":[null,null,3],\"765\":[5,43],\"766\":[null,null,1],\"767\":[null,null,2],\"768\":[6,44],\"769\":[null,null,1],\"770\":[null,null,2],\"771\":[5,84],\"772\":[null,null,1],\"773\":[null,null,2],\"774\":[5,63],\"775\":[null,null,1],\"776\":[null,null,2],\"777\":[3,41],\"778\":[null,null,1],\"779\":[null,null,1],\"780\":[5,11],\"781\":[1],\"782\":[2,51],\"783\":[2,63],\"784\":[1,116],\"785\":[null,null,1],\"786\":[null,null,4],\"787\":[4,54],\"788\":[null,null,1],\"789\":[null,null,2],\"790\":[3,38],\"791\":[1,65],\"792\":[1,81],\"793\":[null,null,1],\"794\":[null,null,1],\"795\":[5,69],\"796\":[null,null,1],\"797\":[null,null,2],\"798\":[3,39],\"799\":[null,null,1],\"800\":[null,null,2],\"801\":[4,18],\"802\":[2,84],\"803\":[6,2],\"804\":[null,null,1],\"805\":[null,null,2],\"806\":[1,15],\"807\":[null,null,1],\"808\":[null,null,2],\"809\":[1],\"810\":[1,67],\"811\":[1,16],\"812\":[1,20],\"813\":[null,null,1],\"814\":[null,null,2],\"815\":[1,16],\"816\":[1,6],\"817\":[1,80],\"818\":[1,5],\"819\":[1,72],\"820\":[1,6],\"821\":[1,51],\"822\":[1,2],\"823\":[1,6],\"824\":[null,null,1],\"825\":[null,null,2],\"826\":[1,77],\"827\":[null,null,2],\"828\":[null,null,1],\"829\":[3,5],\"830\":[2,88],\"831\":[2,65],\"832\":[2,78],\"833\":[null,null,2],\"834\":[null,null,1],\"835\":[1],\"836\":[1,4],\"837\":[1,7],\"838\":[1],\"839\":[2,4],\"840\":[2,7],\"841\":[1,8],\"842\":[1,6],\"843\":[1,5],\"844\":[1,11],\"845\":[1,3],\"846\":[3,3],\"847\":[3,2],\"848\":[2,63],\"849\":[2,40],\"850\":[3,39],\"851\":[3,45],\"852\":[8,33],\"853\":[1,14],\"854\":[1,29],\"855\":[1,23],\"856\":[1,31],\"857\":[2,37],\"858\":[null,null,2],\"859\":[null,null,1],\"860\":[3,1],\"861\":[4,18],\"862\":[2,27],\"863\":[3,9],\"864\":[1,59],\"865\":[5],\"866\":[3,62],\"867\":[4,78],\"868\":[3,2],\"869\":[null,null,2],\"870\":[null,null,1],\"871\":[1,123],\"872\":[null,null,2],\"873\":[null,null,1],\"874\":[2],\"875\":[1,12],\"876\":[2,42],\"877\":[1,3],\"878\":[null,null,2],\"879\":[null,null,1],\"880\":[1],\"881\":[1,13],\"882\":[1,23],\"883\":[1,36],\"884\":[3,10],\"885\":[4,15],\"886\":[3,60],\"887\":[null,null,2],\"888\":[null,null,1],\"889\":[1,58],\"890\":[1,36],\"891\":[1,68],\"892\":[null,null,2],\"893\":[null,null,1],\"894\":[1,59],\"895\":[null,null,2],\"896\":[null,null,1],\"897\":[1],\"898\":[1,53],\"899\":[1],\"900\":[1,83],\"901\":[2,14],\"902\":[null,null,1],\"903\":[null,null,2],\"904\":[1],\"905\":[2,47],\"906\":[2,53],\"907\":[2,37],\"908\":[2,96],\"909\":[null,null,2],\"910\":[null,null,1],\"911\":[1],\"912\":[1,11],\"913\":[1,45],\"914\":[1,15],\"915\":[3,24],\"916\":[3,10],\"917\":[null,null,2],\"918\":[null,null,1],\"919\":[1,19],\"920\":[1,22],\"921\":[3,4],\"922\":[1,18],\"923\":[1,18],\"924\":[1,5],\"925\":[1,16],\"926\":[1],\"927\":[2,13],\"928\":[null,null,2],\"929\":[null,null,1],\"930\":[1],\"931\":[1,4],\"932\":[2,5],\"933\":[1,22],\"934\":[1,16],\"935\":[1],\"936\":[1,12],\"937\":[1,36],\"938\":[1,5],\"939\":[1,14],\"940\":[1,14],\"941\":[null,null,2],\"942\":[null,null,1],\"943\":[1,65],\"944\":[null,null,2],\"945\":[null,null,1],\"946\":[1,8],\"947\":[2],\"948\":[6,54],\"949\":[4,43],\"950\":[null,null,2],\"951\":[null,null,1],\"952\":[1],\"953\":[1,55],\"954\":[1,54],\"955\":[2,5],\"956\":[4,11],\"957\":[1,14],\"958\":[2,11],\"959\":[1,14],\"960\":[null,null,2],\"961\":[null,null,1],\"962\":[4],\"963\":[3,8],\"964\":[2,11],\"965\":[2,64],\"966\":[2,84],\"967\":[2],\"968\":[2,51],\"969\":[2,46],\"970\":[2,57],\"971\":[4,2],\"972\":[2,6],\"973\":[2,29],\"974\":[2,31],\"975\":[null,null,2],\"976\":[null,null,1],\"977\":[1],\"978\":[2,5],\"979\":[3,8],\"980\":[3,24],\"981\":[2,41],\"982\":[2,45],\"983\":[2],\"984\":[2,49],\"985\":[2,31],\"986\":[null,null,2],\"987\":[null,null,1],\"988\":[4],\"989\":[2,34],\"990\":[2,36],\"991\":[2,39],\"992\":[2,45],\"993\":[5,14],\"994\":[3,13],\"995\":[null,null,2],\"996\":[null,null,1],\"997\":[2],\"998\":[2,8],\"999\":[2,86],\"1000\":[2,66],\"1001\":[2,60],\"1002\":[2,91],\"1003\":[1,2],\"1004\":[null,null,2],\"1005\":[null,null,2],\"1006\":[1],\"1007\":[2,76],\"1008\":[2,58],\"1009\":[null,null,2],\"1010\":[null,null,1],\"1011\":[1,77],\"1012\":[null,null,2],\"1013\":[null,null,1],\"1014\":[1,6],\"1015\":[1,36],\"1016\":[9,21],\"1017\":[1,4],\"1018\":[3,26],\"1019\":[3,32],\"1020\":[3,74],\"1021\":[3,38],\"1022\":[2,12],\"1023\":[3],\"1024\":[1,1],\"1025\":[2,47],\"1026\":[1,64],\"1027\":[1,1],\"1028\":[1],\"1029\":[1,13],\"1030\":[1,32],\"1031\":[1,84],\"1032\":[3,114],\"1033\":[null,null,2],\"1034\":[null,null,1],\"1035\":[1,15],\"1036\":[null,null,2],\"1037\":[null,null,1],\"1038\":[1],\"1039\":[2],\"1040\":[1,18],\"1041\":[1,69],\"1042\":[2,14],\"1043\":[4,22],\"1044\":[3,8],\"1045\":[2,29],\"1046\":[3,7],\"1047\":[4,35],\"1048\":[null,null,2],\"1049\":[null,null,1],\"1050\":[1,56],\"1051\":[null,null,2],\"1052\":[null,null,1],\"1053\":[1,5],\"1054\":[2,17],\"1055\":[1,75],\"1056\":[2,54],\"1057\":[2,66],\"1058\":[null,null,2],\"1059\":[null,null,1],\"1060\":[1,74],\"1061\":[null,null,2],\"1062\":[null,null,2],\"1063\":[2,42],\"1064\":[null,null,2],\"1065\":[null,null,1],\"1066\":[1,15],\"1067\":[2,15],\"1068\":[null,null,2],\"1069\":[null,null,1],\"1070\":[1],\"1071\":[1,4],\"1072\":[1,3],\"1073\":[1,12],\"1074\":[null,null,2],\"1075\":[null,null,1],\"1076\":[1,55],\"1077\":[null,null,2],\"1078\":[null,null,2],\"1079\":[2,68],\"1080\":[1,82],\"1081\":[1,21],\"1082\":[1,132],\"1083\":[null,null,2],\"1084\":[null,null,2],\"1085\":[2,7],\"1086\":[6,50],\"1087\":[5,70],\"1088\":[null,null,2],\"1089\":[null,null,2],\"1090\":[1,62],\"1091\":[null,null,2],\"1092\":[null,null,2],\"1093\":[1,61],\"1094\":[null,null,2],\"1095\":[null,null,2],\"1096\":[1,96],\"1097\":[null,null,2],\"1098\":[null,null,2],\"1099\":[3,111],\"1100\":[null,null,2],\"1101\":[null,null,2],\"1102\":[4,329],\"1103\":[null,null,2],\"1104\":[null,null,2],\"1105\":[1,43],\"1106\":[null,null,2],\"1107\":[null,null,2],\"1108\":[1],\"1109\":[5,2],\"1110\":[1,42],\"1111\":[1,45],\"1112\":[1,34],\"1113\":[1,43],\"1114\":[1,90],\"1115\":[3,86],\"1116\":[2,24],\"1117\":[null,null,2],\"1118\":[null,null,1],\"1119\":[1],\"1120\":[2,52],\"1121\":[1,46],\"1122\":[2,25],\"1123\":[1,60],\"1124\":[1,29],\"1125\":[null,null,2],\"1126\":[null,null,1],\"1127\":[1,147],\"1128\":[null,null,2],\"1129\":[null,null,1],\"1130\":[2],\"1131\":[1,8],\"1132\":[4,17],\"1133\":[1,32],\"1134\":[1],\"1135\":[7,9],\"1136\":[3,6],\"1137\":[3,10],\"1138\":[4,4],\"1139\":[1,12],\"1140\":[1,3],\"1141\":[3,16],\"1142\":[1,19],\"1143\":[1,25],\"1144\":[null,null,1],\"1145\":[null,null,1],\"1146\":[1,15],\"1147\":[2,61],\"1148\":[2,116],\"1149\":[null,null,2],\"1150\":[null,null,1],\"1151\":[1,77],\"1152\":[null,null,2],\"1153\":[null,null,3],\"1154\":[1,65],\"1155\":[1,46],\"1156\":[null,null,1],\"1157\":[null,null,2],\"1158\":[1,72],\"1159\":[null,null,2],\"1160\":[null,null,1],\"1161\":[1,13],\"1162\":[2,9],\"1163\":[1],\"1164\":[1,20],\"1165\":[1,31],\"1166\":[2,24],\"1167\":[1,20],\"1168\":[1,77],\"1169\":[null,null,2],\"1170\":[null,null,1],\"1171\":[1,16],\"1172\":[2,20],\"1173\":[1,54],\"1174\":[1,14],\"1175\":[1,13],\"1176\":[1],\"1177\":[2,28],\"1178\":[2,21],\"1179\":[2,15],\"1180\":[1,11],\"1181\":[2],\"1182\":[2],\"1183\":[2,45],\"1184\":[null,null,2],\"1185\":[null,null,1],\"1186\":[1,35],\"1187\":[1,17],\"1188\":[1,73],\"1189\":[1,47],\"1190\":[1,8],\"1191\":[null,null,2],\"1192\":[null,null,1],\"1193\":[1],\"1194\":[2,40],\"1195\":[2,9],\"1196\":[2,4],\"1197\":[2,7],\"1198\":[2,7],\"1199\":[null,null,2],\"1200\":[null,null,1],\"1201\":[1,5],\"1202\":[2,37],\"1203\":[2,2],\"1204\":[3,4],\"1205\":[2,2],\"1206\":[2,18],\"1207\":[2,72],\"1208\":[4,70],\"1209\":[5,62],\"1210\":[2,42],\"1211\":[2,8],\"1212\":[2,9],\"1213\":[null,null,2],\"1214\":[null,null,1],\"1215\":[4],\"1216\":[2],\"1217\":[2,16],\"1218\":[3,22],\"1219\":[3,159],\"1220\":[3,11],\"1221\":[2,25],\"1222\":[null,null,2],\"1223\":[null,null,1],\"1224\":[3],\"1225\":[2,13],\"1226\":[3,22],\"1227\":[3,35],\"1228\":[4,12],\"1229\":[3,16],\"1230\":[null,null,2],\"1231\":[null,null,1],\"1232\":[1,36],\"1233\":[1,91],\"1234\":[null,null,2],\"1235\":[null,null,1],\"1236\":[1,4],\"1237\":[1,77],\"1238\":[1,90],\"1239\":[1,31],\"1240\":[3,68],\"1241\":[null,null,1],\"1242\":[null,null,1],\"1243\":[1],\"1244\":[2,3],\"1245\":[2,9],\"1246\":[null,null,1],\"1247\":[null,null,1],\"1248\":[1,4],\"1249\":[3,18],\"1250\":[4,15],\"1251\":[4,26],\"1252\":[4,41],\"1253\":[4,31],\"1254\":[2,9],\"1255\":[1,29],\"1256\":[2,9],\"1257\":[null,null,1],\"1258\":[null,null,1],\"1259\":[1],\"1260\":[1,21],\"1261\":[1,32],\"1262\":[2,6],\"1263\":[1,7],\"1264\":[null,null,1],\"1265\":[null,null,1],\"1266\":[3],\"1267\":[1,16],\"1268\":[1,5],\"1269\":[1],\"1270\":[1,4],\"1271\":[2,70],\"1272\":[1,6],\"1273\":[null,null,1],\"1274\":[null,null,1],\"1275\":[1],\"1276\":[1,7],\"1277\":[1,11],\"1278\":[3,25],\"1279\":[3,11],\"1280\":[1,18],\"1281\":[2],\"1282\":[1,21],\"1283\":[1,5],\"1284\":[1,47],\"1285\":[2,25],\"1286\":[1],\"1287\":[2,34],\"1288\":[3],\"1289\":[1,8],\"1290\":[4,17],\"1291\":[1,28],\"1292\":[1,1],\"1293\":[7,8],\"1294\":[1],\"1295\":[6,4],\"1296\":[10,26],\"1297\":[null,null,1],\"1298\":[null,null,1],\"1299\":[1,104],\"1300\":[null,null,1],\"1301\":[null,null,2],\"1302\":[1],\"1303\":[1,10],\"1304\":[1],\"1305\":[1,35],\"1306\":[1,20],\"1307\":[1],\"1308\":[1,7],\"1309\":[1,13],\"1310\":[1,72],\"1311\":[1],\"1312\":[3,57],\"1313\":[2,14],\"1314\":[6,32],\"1315\":[11,65],\"1316\":[1,80],\"1317\":[2,63],\"1318\":[2,105],\"1319\":[5,12],\"1320\":[4,18],\"1321\":[2,32],\"1322\":[1,24],\"1323\":[null,null,1],\"1324\":[null,null,1],\"1325\":[3],\"1326\":[1,9],\"1327\":[1,27],\"1328\":[1,18],\"1329\":[1,8],\"1330\":[3,15],\"1331\":[1,52],\"1332\":[1,64],\"1333\":[5,25],\"1334\":[3,44],\"1335\":[3,55],\"1336\":[null,null,1],\"1337\":[null,null,1],\"1338\":[1,47],\"1339\":[2,2],\"1340\":[2,68],\"1341\":[2,20],\"1342\":[1,9],\"1343\":[1,4],\"1344\":[1,10],\"1345\":[1,13],\"1346\":[1,10],\"1347\":[2,48],\"1348\":[1,22],\"1349\":[null,null,1],\"1350\":[null,null,1],\"1351\":[1],\"1352\":[1,3],\"1353\":[1,12],\"1354\":[1,3],\"1355\":[1,11],\"1356\":[1,56],\"1357\":[3,19],\"1358\":[1],\"1359\":[1,5],\"1360\":[2,27],\"1361\":[1,36],\"1362\":[1,17],\"1363\":[3,7],\"1364\":[1],\"1365\":[1,41],\"1366\":[1,24],\"1367\":[1,33],\"1368\":[5,2],\"1369\":[null,null,1],\"1370\":[null,null,1],\"1371\":[1,6],\"1372\":[2,10],\"1373\":[2,11],\"1374\":[2,48],\"1375\":[2,7],\"1376\":[2,19],\"1377\":[2,16],\"1378\":[2,17],\"1379\":[2,13],\"1380\":[2,7],\"1381\":[2,11],\"1382\":[2,11],\"1383\":[2,32],\"1384\":[3,60],\"1385\":[1,74],\"1386\":[null,null,1],\"1387\":[null,null,2],\"1388\":[2],\"1389\":[1],\"1390\":[3,6],\"1391\":[4,2],\"1392\":[1],\"1393\":[3,15],\"1394\":[3,4],\"1395\":[5,35],\"1396\":[1,14],\"1397\":[3,41],\"1398\":[2,10],\"1399\":[2,16],\"1400\":[1],\"1401\":[1,6],\"1402\":[2,10],\"1403\":[1,5],\"1404\":[2],\"1405\":[1,33],\"1406\":[1],\"1407\":[11,94],\"1408\":[1,43],\"1409\":[1,18],\"1410\":[1,39],\"1411\":[2,11],\"1412\":[null,null,1],\"1413\":[null,null,1],\"1414\":[1],\"1415\":[1,38],\"1416\":[1,2],\"1417\":[1,6],\"1418\":[null,null,1],\"1419\":[null,null,1],\"1420\":[1],\"1421\":[1,2],\"1422\":[1,4],\"1423\":[1,8],\"1424\":[3,10],\"1425\":[1,8],\"1426\":[2,29],\"1427\":[1,9],\"1428\":[1,37],\"1429\":[null,null,1],\"1430\":[null,null,1],\"1431\":[2],\"1432\":[1,4],\"1433\":[1,3],\"1434\":[1,7],\"1435\":[1,2],\"1436\":[1,1],\"1437\":[1,43],\"1438\":[null,null,1],\"1439\":[null,null,1],\"1440\":[1],\"1441\":[1],\"1442\":[1],\"1443\":[1,19],\"1444\":[1,6],\"1445\":[null,null,1],\"1446\":[null,null,1],\"1447\":[1,44],\"1448\":[null,null,1],\"1449\":[null,null,1],\"1450\":[1],\"1451\":[2,23],\"1452\":[2,20],\"1453\":[1,4],\"1454\":[2,2],\"1455\":[3,3],\"1456\":[null,null,1],\"1457\":[null,null,1],\"1458\":[1],\"1459\":[1,7],\"1460\":[3,10],\"1461\":[3,20],\"1462\":[3,18],\"1463\":[3,15],\"1464\":[3,15],\"1465\":[1,3],\"1466\":[null,null,1],\"1467\":[null,null,1],\"1468\":[1],\"1469\":[1,12],\"1470\":[1,8],\"1471\":[1,28],\"1472\":[null,null,1],\"1473\":[null,null,1],\"1474\":[2,1],\"1475\":[1,32],\"1476\":[5,4],\"1477\":[2,12],\"1478\":[1,9],\"1479\":[1,4],\"1480\":[1,16],\"1481\":[3,8],\"1482\":[null,null,1],\"1483\":[null,null,1],\"1484\":[1],\"1485\":[3,22],\"1486\":[3,25],\"1487\":[null,null,1],\"1488\":[null,null,1],\"1489\":[1,4],\"1490\":[3,19],\"1491\":[3,11],\"1492\":[3,12],\"1493\":[3],\"1494\":[2,16],\"1495\":[2,7],\"1496\":[2,14],\"1497\":[6,12],\"1498\":[4],\"1499\":[6],\"1500\":[2,33],\"1501\":[5,17],\"1502\":[3,12],\"1503\":[null,null,1],\"1504\":[null,null,1],\"1505\":[1],\"1506\":[1,11],\"1507\":[1,33],\"1508\":[1,13],\"1509\":[null,null,1],\"1510\":[null,null,1],\"1511\":[1,32],\"1512\":[2,11],\"1513\":[1,11],\"1514\":[3,21],\"1515\":[3,15],\"1516\":[2,10],\"1517\":[3],\"1518\":[1,5],\"1519\":[2,4],\"1520\":[2,1],\"1521\":[1,65],\"1522\":[1,4],\"1523\":[2,51],\"1524\":[1,4],\"1525\":[2,41],\"1526\":[2,14],\"1527\":[6],\"1528\":[2,2],\"1529\":[2,2],\"1530\":[1,3],\"1531\":[1,36],\"1532\":[null,null,1],\"1533\":[null,null,1],\"1534\":[2],\"1535\":[1,11],\"1536\":[1,6],\"1537\":[1,134],\"1538\":[1,42],\"1539\":[1,26],\"1540\":[1,17],\"1541\":[1,19],\"1542\":[1],\"1543\":[1,22],\"1544\":[1,48],\"1545\":[null,null,1],\"1546\":[null,null,1],\"1547\":[1],\"1548\":[5,43],\"1549\":[null,null,1],\"1550\":[null,null,1],\"1551\":[1,43],\"1552\":[1,89],\"1553\":[null,null,1],\"1554\":[null,null,1],\"1555\":[1,16],\"1556\":[1,11],\"1557\":[2,20],\"1558\":[3,7],\"1559\":[1,2],\"1560\":[null,null,1],\"1561\":[null,null,1],\"1562\":[1],\"1563\":[1,21],\"1564\":[1,10],\"1565\":[1],\"1566\":[1,24],\"1567\":[null,null,1],\"1568\":[null,null,1],\"1569\":[1,77],\"1570\":[null,null,1],\"1571\":[null,null,1],\"1572\":[1,7],\"1573\":[1,29],\"1574\":[1,27],\"1575\":[1],\"1576\":[4],\"1577\":[4,20],\"1578\":[5,12],\"1579\":[2,4],\"1580\":[2,6],\"1581\":[3,19],\"1582\":[3,12],\"1583\":[null,null,1],\"1584\":[null,null,1],\"1585\":[1],\"1586\":[3,11],\"1587\":[2,4],\"1588\":[2,5],\"1589\":[4,4],\"1590\":[2,9],\"1591\":[3,12],\"1592\":[5,20],\"1593\":[6,12],\"1594\":[3,13],\"1595\":[1],\"1596\":[null,null,1],\"1597\":[null,null,1],\"1598\":[1],\"1599\":[1,5],\"1600\":[6,17],\"1601\":[1,10],\"1602\":[3,4],\"1603\":[1,56],\"1604\":[1,14],\"1605\":[null,null,1],\"1606\":[null,null,1],\"1607\":[1],\"1608\":[1,5],\"1609\":[1,34],\"1610\":[1,80],\"1611\":[null,null,1],\"1612\":[null,null,1],\"1613\":[1],\"1614\":[1,49],\"1615\":[1,14],\"1616\":[1,6],\"1617\":[1,27],\"1618\":[1,74],\"1619\":[null,null,1],\"1620\":[null,null,1],\"1621\":[1,9],\"1622\":[1,60],\"1623\":[1,68],\"1624\":[4,5],\"1625\":[1],\"1626\":[4,52],\"1627\":[2,30],\"1628\":[null,null,1],\"1629\":[null,null,1],\"1630\":[1],\"1631\":[1,39],\"1632\":[1,9],\"1633\":[4,7],\"1634\":[3,8],\"1635\":[3,32],\"1636\":[2,7],\"1637\":[null,null,1],\"1638\":[null,null,1],\"1639\":[4,73],\"1640\":[1,26],\"1641\":[null,null,1],\"1642\":[null,null,1],\"1643\":[1],\"1644\":[1,40],\"1645\":[3,33],\"1646\":[null,null,1],\"1647\":[null,null,1],\"1648\":[1],\"1649\":[1,27],\"1650\":[1,14],\"1651\":[1,3],\"1652\":[1,18],\"1653\":[null,null,1],\"1654\":[null,null,1],\"1655\":[4],\"1656\":[2,182],\"1657\":[2],\"1658\":[2,47],\"1659\":[2,5],\"1660\":[2,27],\"1661\":[2],\"1662\":[2,4],\"1663\":[2,35],\"1664\":[4,17],\"1665\":[4,73],\"1666\":[null,null,1],\"1667\":[null,null,3],\"1668\":[2,8],\"1669\":[2,7],\"1670\":[1,15],\"1671\":[1,18],\"1672\":[2,11],\"1673\":[4,57],\"1674\":[null,null,1],\"1675\":[null,null,1],\"1676\":[2],\"1677\":[4,55],\"1678\":[3],\"1679\":[3,20],\"1680\":[3,8],\"1681\":[3,92],\"1682\":[3,57],\"1683\":[null,null,1],\"1684\":[null,null,3],\"1685\":[3],\"1686\":[2,75],\"1687\":[2,2],\"1688\":[4,34],\"1689\":[4,42],\"1690\":[3,7],\"1691\":[2],\"1692\":[2,16],\"1693\":[2,44],\"1694\":[1,11],\"1695\":[null,null,1],\"1696\":[null,null,1],\"1697\":[1,17],\"1698\":[2,10],\"1699\":[1,16],\"1700\":[1,33],\"1701\":[1,38],\"1702\":[1,8],\"1703\":[null,null,1],\"1704\":[null,null,1],\"1705\":[1],\"1706\":[1,31],\"1707\":[1,15],\"1708\":[1,15],\"1709\":[null,null,1],\"1710\":[null,null,1],\"1711\":[1,12],\"1712\":[2,25],\"1713\":[3,43],\"1714\":[null,null,1],\"1715\":[null,null,1],\"1716\":[2],\"1717\":[3,36],\"1718\":[1,9],\"1719\":[7,70],\"1720\":[7,18],\"1721\":[1,8],\"1722\":[null,null,1],\"1723\":[null,null,1],\"1724\":[1,26],\"1725\":[null,null,1],\"1726\":[null,null,1],\"1727\":[1],\"1728\":[2,3],\"1729\":[2,19],\"1730\":[2,9],\"1731\":[2,9],\"1732\":[2],\"1733\":[2,13],\"1734\":[2,15],\"1735\":[2,17],\"1736\":[3,68],\"1737\":[4,15],\"1738\":[2,24],\"1739\":[2,5],\"1740\":[2,38],\"1741\":[null,null,1],\"1742\":[null,null,1],\"1743\":[1,6],\"1744\":[2,15],\"1745\":[2,25],\"1746\":[3,8],\"1747\":[1,24],\"1748\":[2,15],\"1749\":[1,8],\"1750\":[3,22],\"1751\":[3],\"1752\":[1,17],\"1753\":[1,13],\"1754\":[1,44],\"1755\":[null,null,1],\"1756\":[null,null,1],\"1757\":[2,30],\"1758\":[3,112],\"1759\":[3,41],\"1760\":[6,15],\"1761\":[3,14],\"1762\":[2,54],\"1763\":[3,32],\"1764\":[null,null,1],\"1765\":[null,null,1],\"1766\":[1],\"1767\":[3,45],\"1768\":[1,15],\"1769\":[2,44],\"1770\":[2,30],\"1771\":[2,20],\"1772\":[2,67],\"1773\":[2,87],\"1774\":[2,103],\"1775\":[1,22],\"1776\":[2,75],\"1777\":[null,null,1],\"1778\":[null,null,2],\"1779\":[1,7],\"1780\":[1,14],\"1781\":[1,15],\"1782\":[1,2],\"1783\":[1,21],\"1784\":[1,38],\"1785\":[1,19],\"1786\":[1,3],\"1787\":[null,null,1],\"1788\":[null,null,1],\"1789\":[1],\"1790\":[1,54],\"1791\":[1,41],\"1792\":[1,10],\"1793\":[null,null,1],\"1794\":[null,null,1],\"1795\":[1],\"1796\":[2,18],\"1797\":[2,2],\"1798\":[2,3],\"1799\":[2,49],\"1800\":[2,30],\"1801\":[2,2],\"1802\":[3,26],\"1803\":[3,91],\"1804\":[2,7],\"1805\":[2,10],\"1806\":[2,16],\"1807\":[3,1],\"1808\":[2,21],\"1809\":[2,15],\"1810\":[2,4],\"1811\":[3,4],\"1812\":[2,11],\"1813\":[2,10],\"1814\":[1,24],\"1815\":[null,null,1],\"1816\":[null,null,1],\"1817\":[1],\"1818\":[2,64],\"1819\":[2],\"1820\":[2,98],\"1821\":[2,76],\"1822\":[2,8],\"1823\":[2],\"1824\":[3,5],\"1825\":[2,28],\"1826\":[2,13],\"1827\":[2],\"1828\":[2,68],\"1829\":[2,29],\"1830\":[2,52],\"1831\":[1,2],\"1832\":[1,6],\"1833\":[1,14],\"1834\":[null,null,1],\"1835\":[null,null,1],\"1836\":[1,59],\"1837\":[null,null,1],\"1838\":[null,null,1],\"1839\":[1,137],\"1840\":[null,null,1],\"1841\":[null,null,1],\"1842\":[1],\"1843\":[1],\"1844\":[3,16],\"1845\":[3,15],\"1846\":[3,53],\"1847\":[3,54],\"1848\":[3,95],\"1849\":[3,182],\"1850\":[1,1],\"1851\":[1,71],\"1852\":[null,null,1],\"1853\":[null,null,1],\"1854\":[1],\"1855\":[1,19],\"1856\":[1,106],\"1857\":[null,null,1],\"1858\":[null,null,1],\"1859\":[1,212],\"1860\":[null,null,1],\"1861\":[null,null,1],\"1862\":[1],\"1863\":[1,14],\"1864\":[1,34],\"1865\":[1,51],\"1866\":[1,36],\"1867\":[null,null,1],\"1868\":[null,null,1],\"1869\":[1,38],\"1870\":[1,17],\"1871\":[3,30],\"1872\":[2,49],\"1873\":[null,null,1],\"1874\":[null,null,1],\"1875\":[1,193],\"1876\":[null,null,1],\"1877\":[null,null,1],\"1878\":[1,213],\"1879\":[null,null,1],\"1880\":[null,null,1],\"1881\":[1,52],\"1882\":[null,null,1],\"1883\":[null,null,1],\"1884\":[1],\"1885\":[2,29],\"1886\":[2,34],\"1887\":[2,1],\"1888\":[2,94],\"1889\":[2,14],\"1890\":[2,19],\"1891\":[2,105],\"1892\":[2,26],\"1893\":[null,null,1],\"1894\":[null,null,1],\"1895\":[1],\"1896\":[2,61],\"1897\":[2],\"1898\":[3,12],\"1899\":[3,25],\"1900\":[3,11],\"1901\":[2,24],\"1902\":[3,23],\"1903\":[5,28],\"1904\":[3,30],\"1905\":[3,28],\"1906\":[4,11],\"1907\":[3,35],\"1908\":[4,32],\"1909\":[1,39],\"1910\":[null,null,1],\"1911\":[null,null,1],\"1912\":[1],\"1913\":[2,29],\"1914\":[2,28],\"1915\":[2,92],\"1916\":[null,null,1],\"1917\":[null,null,1],\"1918\":[2],\"1919\":[1],\"1920\":[2],\"1921\":[1],\"1922\":[2],\"1923\":[1],\"1924\":[2],\"1925\":[2],\"1926\":[2],\"1927\":[2],\"1928\":[3],\"1929\":[2],\"1930\":[2],\"1931\":[2],\"1932\":[2],\"1933\":[2],\"1934\":[5],\"1935\":[2],\"1936\":[2],\"1937\":[2],\"1938\":[2],\"1939\":[6],\"1940\":[2],\"1941\":[2],\"1942\":[2],\"1943\":[3],\"1944\":[2],\"1945\":[2],\"1946\":[2],\"1947\":[5],\"1948\":[6],\"1949\":[5],\"1950\":[6],\"1951\":[5],\"1952\":[5],\"1953\":[5],\"1954\":[5],\"1955\":[5],\"1956\":[2],\"1957\":[2],\"1958\":[2],\"1959\":[1]},\"averageFieldLength\":[1.8341526082134458,33.036082256661594,1.1786458942113591],\"storedFields\":{\"0\":{\"h\":\"简历\",\"t\":[\"张威/男/1998\",\"硕士/华南师范大学（211）电子信息\",\"技术博客：http://old.ftqq.com\",\"Github：http://github.com/easychen\",\"期望职位：c/c++后端开发工程师\",\"期望薪资：15k~20k\",\"期望城市：广州\",\"、\",\"（我一般主张将技能清单写入到工作经历里边去。不过很难完整，所以有这么一段也不错）\",\"以下均为我熟练使用的技能\",\"Web开发：PHP/Hack/Node\",\"Web框架：ThinkPHP/Yaf/Yii/Lavarel/LazyPHP\",\"前端框架：Bootstrap/AngularJS/EmberJS/HTML5/Cocos2dJS/ionic\",\"前端工具：Bower/Gulp/SaSS/LeSS/PhoneGap\",\"数据库相关：MySQL/PgSQL/PDO/SQLite\",\"版本管理、文档和自动化部署工具：Svn/Git/PHPDoc/Phing/Composer\",\"单元测试：PHPUnit/SimpleTest/Qunit\",\"云和开放平台：SAE/BAE/AWS/微博开放平台/微信应用开发\",\"（HR会打印你的简历，用于在面试的时候联系，所以联系方式放到最上边会比较方便）\",\"手机：135.... （如果是外地手机，可注明。如经常关机，要写上最优联系时间）\",\"Email：goodman@gmail.com （虽然我觉得QQ邮箱无所谓，不过有些技术人员比较反感，建议用G，非要用的话，不要用数字邮箱名）\",\"QQ/微信号：6...（提供一个通过网络可以联系到你的方式）\"]},\"1\":{\"h\":\"博客主页\"},\"2\":{\"h\":\"工具分享\"},\"3\":{\"h\":\"基因序列比对工具-mutialin\",\"t\":[\"虽然有很多优秀的软件能做双序列比对，但对于每个基因要对几十个甚至上百个样品测序结果比对步骤太繁琐，浪费大量时间和人力，因此编写了个小工具解放劳动力，现在把它分享出来，希望能对医学方向的同学和生物方面研究的同学提供些许帮助。 这个软件尤其是对做基因编辑方向的同学简直就是福音感觉有用的同学请不吝fork、star一下哦\",\"这是一个基因序列比对工具，主要用于1个模板比对N个测序结果\"]},\"4\":{\"h\":\"工具内容\",\"t\":[\"三个文件夹“result”、“sequence”、“wt”\",\"multalin.exe\"]},\"5\":{\"h\":\"使用方法\",\"t\":[\"sequence文件夹用于存放测序后的结果。解压后的“.seq”和“.ab1”文件可以直接放在这个文件夹内\",\"wt文件夹用于存放模板序列。每次比对只能放该基因的模板序列\",\"比对后的结果以照片的形式保存在result文件夹内，为了方便日后查看又把结果自动存储到word内便于编辑\",\"每次比对只需要改动wt内的模板序列和sequence内的测序结果，result内的结果照片会在比对开始自动清空\",\"image-20240115124235596\",\"image-20240115124252212\",\"下载地址1：https://githubfast.com/iszhwei/mutalin\",\"下载地址2：https://github.com/iszhwei/mutalin\"]},\"6\":{\"h\":\"回答两点：\",\"t\":[\"有小伙伴问我模板格式是什么样的\",\"//template.txt 注意内容为fasta格式 >tempalteName ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATC \",\"为什么不用PyQt做个好看点界面？首先实用为主，操作也很简单，暂时没必要。\"]},\"7\":{\"h\":\"算法与数据结构\"},\"8\":{\"h\":\"统计单词的个数\",\"t\":[\"输入一行字符串（单词和若干空格）， 输出该行单词个数。\",\"Input：____hello_________world_ how___are___you___\\\\n Output: 5 \",\" #include <iostream> using std::cout; using std::endl; int main() { int word = 0; bool flag = 0; char content; cout << \\\"请输入一行字符：\\\" << endl; while((content = getchar()) && (content != '\\\\n')) { if((content >= 'a' && content <= 'z') || (content >= 'A' && content <= 'Z')) { if(flag == 0) { ++word; flag = 1; } } else if(content == ' '){ flag = 0; } } cout << \\\"个数为：\\\" << word << endl; return 0; } \"]},\"9\":{\"c\":[\"使用指南\"]},\"10\":{\"c\":[\"页面配置\",\"使用指南\"]},\"11\":{\"h\":\"统计字母、数字、空格个数\",\"t\":[\"#include <iostream> using std::cout; using std::endl; int main() { int letter = 0; int space = 0; int number = 0; char content; cout << \\\"请输入一行字符：\\\" << endl; while((content = getchar()) && (content != '\\\\n')) { if((content >= 'a' && content <= 'z') || (content >= 'A' && content <= 'Z')) { letter++; } else if(content >= '0' && content <= '9') { number++; } else if(content == ' ') { space++; } } cout << \\\"英文字母个数为：\\\" << letter << endl; cout << \\\"空格个数为：\\\" << space << endl; cout << \\\"数字个数为：\\\" << number << endl; return 0; } \",\"统计单词个数\"]},\"12\":{\"c\":[\"使用指南\"]},\"13\":{\"c\":[\"页面配置\",\"使用指南\"]},\"14\":{\"h\":\"c/c++\"},\"15\":{\"h\":\"linux操作系统\"},\"16\":{\"h\":\"页面配置\",\"t\":[\"文件：狭义上的文件，指的是磁盘上数据的集合；广义上的文件指的是一类容量大、读写慢、可以长期存储的数据\",\"FILE结构体是满足ISOC标准的文件流/文件缓冲区；本次学习的是遵循POSIX标准的文件读写的系统调用\",\"image-20240312103817142\",\"ISO C是国际标准化组织（ISO）为了提高C语言的移植性而设立的C语言标准。它包含两部分：C语法及语义，以及C标准函数库。ISO C主要定义了C语言的语法规则、语义以及标准库中的函数原型和功能，但并未定义函数的具体实现。它的目标是确保不同的编译器在遵循ISO C标准时，对C语言的解释和执行方式保持一致。\",\"POSIX是Portable Operating System Interfaces的缩写，意为可移植操作系统接口。这是一组由IEEE制定的标准簇，旨在提升应用程序在不同UNIX系统环境之间的可移植性。POSIX标准不仅包含了ISO C的部分内容，还定义了很多系统服务接口，例如socket相关接口、pthread线程相关接口等。这些接口使得应用程序能够更方便地访问和操作系统提供的各种功能。\",\"，而****。\"]},\"17\":{\"h\":\"文件的分类\",\"t\":[\"Linux文件类型：\",\"普通文件：也称为磁盘文件，可以随机存储数据\",\"目录文件 ：实际上是一个链表，每个结点称为目录项\",\"符号链接/软链接：存储另一个文件的路径\",\"字符设备文件：IO设备到文件的映射，如鼠标、键盘、显示器\",\"块设备文件：磁盘、固态硬盘\",\"管道：进程间通信\",\"socket：网络通信\",\"Windows系统使用\\\\r\\\\n作为换行符\",\"Windows上r模式读取linux保存的文件，自动将\\\\n转换为\\\\r\\\\n\",\"使用rb（二进制读取）模式打开文件时，读取到的换行符会保持文件中的原始形式。\",\"linux下rb模式和r模式读取文本文件时，换行符都是\\\\n\"]},\"18\":{\"c\":[\"使用指南\"]},\"19\":{\"c\":[\"页面配置\",\"使用指南\"]},\"20\":{\"h\":\"MySQL\"},\"21\":{\"h\":\"计算机网络\"},\"22\":{\"h\":\"TCP和UDP的区别\",\"t\":[\"1.二者的区别本质上就是tcp提供的一些控制功能，控制就 需要有一些状态 而维护状态就需要连接，所以tcp是面向连接的而udp是不需要连接的。 2.Tcp提供的控制首先就是可靠传输，而udp是尽最大努力交付，不保证可靠交付数据 3.为了重传的效率更高二者分片也不同，tcp的数据大小如果大于MSS大小，则会在传输层进行分片，，如果中途丢失了一个分片，传输丢失的这个分片即可， udp的数据大小如果大于mtu大小，则会在ip层进行分片 4.TCP还有拥塞控制和流量控制 udp则没有 5.要实现这么多控制所以tcp首部长度较长，会有一定的开销，首部在没有使用选项字段时是20个字节，udp首部只有8个字节 6.Udp既然没那么多控制功能，也是有好处的 udp支持一对一，一对多，多对多的通信 而tcp则是一对一的两点服务 7.最后就是二者的传输方式 TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。\",\"image-20240315130548521\",\"image-20240315130939110\"]},\"23\":{\"c\":[\"使用指南\"]},\"24\":{\"c\":[\"页面配置\",\"使用指南\"]},\"25\":{\"h\":\"Redis\"},\"26\":{\"h\":\"Autohotkey笔记\"},\"27\":{\"h\":\"脚本开机自启\",\"t\":[\"将 .ahk （Ahk脚本）文件，创建快捷方式，并把快捷方式放入 C:\\\\ProgramData\\\\Microsoft\\\\Windows\\\\Start Menu\\\\Programs\\\\Startup 文件夹即可。如需取消开机自启，就删除这个快捷方式。\",\"方法二：win + R 输入shell:startup回车后自动打开开机自启目录\"]},\"28\":{\"h\":\"使用\",\"t\":[\"如果第一次使用的话，双击 .ahk 文件（Ahk脚本所使用的文件名后缀）会弹出打开方式选择框，点“更多应用->在这台电脑上查找其他应用”，然后找到并选中上一步解压文件夹里的 “AutoHotkeyU64.exe” 文件即可。\"]},\"29\":{\"h\":\"编写typora修改颜色的快捷键\",\"t\":[\"1.桌面新建txt文件 2.将后缀改为.ahk 3.重命名为MyTyporaHotkeyScript.ahk\",\"; Typora ; 快捷增加字体颜色 ; SendInput {Text} 解决中文输入法问题 ; autohotkey 1.1.37.01 #IfWinActive ahk_exe Typora.exe { ; Ctrl+Alt+o 橙色 ^!o::addFontColor(\\\"orange\\\") ; Ctrl+Alt+r 红色 ^!r::addFontColor(\\\"red\\\") ; Ctrl+Alt+b 浅蓝色 ^!b::addFontColor(\\\"cornflowerblue\\\") } ; 快捷增加字体颜色 addFontColor(color){ clipboard := \\\"\\\" ; 清空剪切板 Send {ctrl down}c{ctrl up} ; 复制 ; SendInput {Text} ; 解决中文输入法问题 SendInput {TEXT}<font color='%color%'> SendInput {ctrl down}v{ctrl up} ; 粘贴 If(clipboard = \\\"\\\"){ SendInput {TEXT}</font> ; Typora 在这不会自动补充 }else{ SendInput {TEXT}</ ; Typora中自动补全标签 } } \",\"1.双击ahk脚本运行 2.Typora检测 Ctrl+Alt+O——橙色Orange Ctrl+Alt+R——红色Red Ctrl+Alt+B——蓝色Blue\",\"按Ctrl+\\\\取消样式！\",\" ; alt+0 黑色 !0::addFontColor(\\\"black\\\") ; alt+1 红色 !1::addFontColor(\\\"red\\\") ; alt+2 绿色 !2::addFontColor(\\\"green\\\") ; alt+3 浅蓝色 ;!3::addFontColor(\\\"blue\\\") !3::addFontColor(\\\"cornflowerblue\\\") ; alt+4 橙色 !4::addFontColor(\\\"orange\\\") ; alt+5 黄色 !5::addFontColor(\\\"yellow\\\") ; alt+6 青色 !6::addFontColor(\\\"cyan\\\") ; alt+7 紫色 !7::addFontColor(\\\"purple\\\") \"]},\"30\":{\"h\":\"代码解释\",\"t\":[\";分号后面的是注释（不是脚本！！！）我就说我测试了这么长时间都不管用！ 热键标记 !感叹号代表Alt键 # 井号代表 Windows 键 ^ 上三角号代表 Ctrl键 + 加号代表 Shift 键 执行 ::代表按下前面快捷键后会执行后面的命令。 \"]},\"31\":{\"h\":\"随笔\"},\"32\":{\"h\":\"Source Insight使用\"},\"33\":{\"h\":\"设置输入法兼容旧版本，否则使用SourceInsight会卡死\",\"t\":[\"输入法： 设置-常规-兼容性（打开） \"]},\"34\":{\"h\":\"新建文件夹，将工程文件放在源码的附近\"},\"35\":{\"h\":\"源码加进来后记得同步一下\",\"t\":[\"image-20240409142503015\"]},\"36\":{\"h\":\"需要将 .cc 类型配置到c++文件类型里\",\"t\":[\"​ \",\"image-20240409140210893\"]},\"37\":{\"h\":\"高亮设置\"},\"38\":{\"h\":\"高亮快捷键修改\",\"t\":[\"image-20240409140346944\",\"搜索high\",\"image-20240409141923954\"]},\"39\":{\"h\":\"高亮当前行\",\"t\":[\"image-20240409142046712\"]},\"40\":{\"h\":\"高亮当前选中\",\"t\":[\"image-20240409142125992\"]},\"41\":{\"h\":\"查找定位及Reference等功能\",\"t\":[\"在进行源程序的阅读中，我们要查看函数变量的定义原型，可以右击选择Jump To Definition来定位，或者点击工具栏中的，当然也可以通过上面提到的Context窗口定位。\",\"然后就是Source Insight中的Reference功能，可以快速找出整个工程中所有的标记，并且在该行程序前加上红色双向箭头快速定位\"]},\"42\":{\"h\":\"设置注释与反注释的快捷键\"},\"43\":{\"h\":\"typora配置\"},\"44\":{\"h\":\"右键新建文件中没有 .md\",\"t\":[\"Windows Registry Editor Version 5.00 [HKEY_CLASSES_ROOT\\\\.md] @=\\\"Typora.exe\\\" [HKEY_CLASSES_ROOT\\\\.md\\\\ShellNew] \\\"NullFile\\\"=\\\"\\\" [HKEY_CLASSES_ROOT\\\\Typora.exe] @=\\\"Markdown\\\" \",\"@=“Typora.exe” 指定.md文件的运行程序 @=“Markdown” 指定右键新建的.md文件的默认名字, 也指定右键菜单新建相应选项名为 MarkDown\",\"重名为TyporaNewFile.reg(后缀为.reg就行)，双击运行\"]},\"45\":{\"h\":\"新建markdown时使用模板\",\"t\":[\"//Template.md --- # 这是文章的标题 title: 页面配置 # 这是页面的图标 icon: file # 这是侧边栏的顺序 order: 3 # 设置写作时间 date: 2020-01-01 # 一个页面可以有多个分类 category: - 使用指南 # 一个页面可以有多个标签 tag: - 页面配置 - 使用指南 --- <!--more--> \",\"把模板文件放到C:\\\\Windows\\\\ShellNew下\",\"win + R输入regedit打开注册表\",\"ctl + F搜.md，配置如下（没有的就新建）刚开始也是不行，多重复几遍就好了\",\"image-20240114222645084\"]},\"46\":{\"h\":\"微软输入法自定义快捷键快速修改日期\",\"t\":[\"由于微软自带的日期格式2024年1月15日与blog匹配的格式不一样需要改成2024-01-15，步骤如下：\",\"打开输入法设置->词库和自学习->用户自定义的短语->添加或编辑自定义的短语->添加%yyyy%-%MM%-%dd% \",\"image-20240115123654224\"]},\"47\":{\"h\":\"增加快捷键修改颜色功能\",\"t\":[\"autohotkey笔记\"]},\"48\":{\"h\":\"修改下划线的颜色和高度\",\"t\":[\"默认的下划线样式就好像一条舔狗，死死地咬着文本不放\",\"在主题文件夹下打开\\\"base.user.css\\\"文件（没有就新建），加入\",\"方法一：\",\"/* 自定义红色下划线样式 */ u { text-decoration: underline; text-decoration-color: red; } \",\"方法二（正在用）：\",\"u {/*处理下划线显示，对应快捷键Ctrl+U*/ text-decoration: none; border-width: 0 0 2px 0; /*下划线线条粗细*/ border-color: red; border-style: solid; padding: 0 0 0px 0; /*下划线与文字距离*/ } \"]},\"49\":{\"h\":\"设置代码快边框的样式\",\"t\":[\"在主题文件夹下打开\\\"base.user.css\\\"文件（没有就新建），加入\",\"/* 设置代码块边框样式 */ #write .md-fences { border: 1px solid rgb(0 0 0); } \",\"/* 修改代码块的样式 */ #write .md-fences { border: 1px solid rgb(0 0 0); /*设置代码块的边框*/ -webkit-font-smoothing: initial; margin: 0.5rem 0 !important; /* padding: 0.3rem 0 !important; */ padding: 3px 5px; line-height: 1.55rem; border-radius: 2px; /*font-family: 'Roboto Mono', 'Source Sans Pro', 'Microsoft YaHei', '微软雅黑' !important;*/ /*font-family: 'Roboto Mono', 'Source Sans Pro', 'Microsoft YaHei', '微软雅黑';*/ font-family: Consolas, 'Source Han SerifCN', Georgia, Times, 'SimSun' !important; /*font-size: 0.9rem;*/ font-size: 17px; font-weight: normal; word-wrap: normal; } /**apply to code fences with plan text**/ \"]},\"50\":{\"h\":\"修改加粗样式\",\"t\":[\"/* 修改加粗样式 */ strong { color: #00F; font-size: 1.05em; } \",\"在CSS中，使用text-decoration属性来定义段落文本的下划线、删除线和顶划线。none即为默认值，可以用这个属性值也可以去掉已经有下划线或删除线或顶划线的样式\",\"text-decoration是三个属性的缩写：text-decoration-line，text-decoration-color，text-decoration-style\",\"1、text-decoration-line\",\"定义：用来规定文本修饰要使用的线条类型。\",\"取值：none，underline，line-through(规定文本中间将显示一条线)等等。\",\"2、text-decoration-color\",\"定义：用来规定文本修饰（下划线 underline、上划线 overline、中划线 line-through）的颜色。\",\"取值：所有颜色表示法。\",\"3、text-decoration-style\",\"定义：用来规定线条如何显示。\",\"取值：solid和double和dotted和dashed等等。\",\"img\",\"常用的CSS文本属性：\",\"1、font-size 字体大小\",\"2、color 字体颜色\",\"3、line-height 行高\",\"4、text-decoration 文本修饰(如下划线)\",\"5、text-indent 文本缩进\",\"6、background-color 背景颜色\"]},\"51\":{\"h\":\"标题、目录、大纲自动编号\",\"t\":[\"在主题文件夹下打开\\\"base.user.css\\\"文件（没有就新建），加入\",\"/* 注意：1. 计数是从第二级标题开始的，第一级标题做题目 2. 必须得有一级标题才能计数，不能直接写第2级标题，否则乱序 */ /*文章内容自动编号*/ /** initialize css counter */ h1 { counter-reset: h2 } h2 { counter-reset: h3 } h3 { counter-reset: h4 } h4 { counter-reset: h5 } h5 { counter-reset: h6 } /** put counter result into headings */ #write h2:before { counter-increment: h2; content: counter(h2) \\\". \\\" } #write h3:before, h3.md-focus.md-heading:before /** override the default style for focused headings */ { counter-increment: h3; content: counter(h2) \\\".\\\" counter(h3) \\\". \\\" } #write h4:before, h4.md-focus.md-heading:before { counter-increment: h4; content: counter(h2) \\\".\\\" counter(h3) \\\".\\\" counter(h4) \\\". \\\" } #write h5:before, h5.md-focus.md-heading:before { counter-increment: h5; content: counter(h2) \\\".\\\" counter(h3) \\\".\\\" counter(h4) \\\".\\\" counter(h5) \\\". \\\" } #write h6:before, h6.md-focus.md-heading:before { counter-increment: h6; content: counter(h2) \\\".\\\" counter(h3) \\\".\\\" counter(h4) \\\".\\\" counter(h5) \\\".\\\" counter(h6) \\\". \\\" } /** override the default style for focused headings */ #write>h3.md-focus:before, #write>h4.md-focus:before, #write>h5.md-focus:before, #write>h6.md-focus:before, h3.md-focus:before, h4.md-focus:before, h5.md-focus:before, h6.md-focus:before { color: inherit; border: inherit; border-radius: inherit; position: inherit; left:initial; float: none; top:initial; font-size: inherit; padding-left: inherit; padding-right: inherit; vertical-align: inherit; font-weight: inherit; line-height: inherit; } /*文章主题自动编号*/ /* No link underlines in TOC */ .md-toc-inner { text-decoration: none; } .md-toc-h1 { margin-left: 0; font-size: 1.5rem; counter-reset: h2toc } .md-toc-h2 { font-size: 1.1rem; margin-left: 2rem; counter-reset: h3toc } .md-toc-h3 { margin-left: 3rem; font-size: .9rem; counter-reset: h4toc } .md-toc-h4 { margin-left: 4rem; font-size: .85rem; counter-reset: h5toc } .md-toc-h5 { margin-left: 5rem; font-size: .8rem; counter-reset: h6toc } .md-toc-h6 { margin-left: 6rem; font-size: .75rem; } .md-toc-h2:before { color: black; counter-increment: h2toc; content: counter(h2toc) \\\". \\\" } .md-toc-h2 .md-toc-inner { margin-left: 0; } .md-toc-h3:before { color: black; counter-increment: h3toc; content: counter(h2toc) \\\". \\\" counter(h3toc) \\\". \\\" } .md-toc-h3 .md-toc-inner { margin-left: 0; } .md-toc-h4:before { color: black; counter-increment: h4toc; content: counter(h2toc) \\\". \\\" counter(h3toc) \\\". \\\" counter(h4toc) \\\". \\\" } .md-toc-h4 .md-toc-inner { margin-left: 0; } .md-toc-h5:before { color: black; counter-increment: h5toc; content: counter(h2toc) \\\". \\\" counter(h3toc) \\\". \\\" counter(h4toc) \\\". \\\" counter(h5toc) \\\". \\\" } .md-toc-h5 .md-toc-inner { margin-left: 0; } .md-toc-h6:before { color: black; counter-increment: h6toc; content: counter(h2toc) \\\". \\\" counter(h3toc) \\\". \\\" counter(h4toc) \\\". \\\" counter(h5toc) \\\". \\\" counter(h6toc) \\\". \\\" } .md-toc-h6 .md-toc-inner { margin-left: 0; } /*文章大纲自动编号*/ .outline-h1 { counter-reset: h2 } .outline-h2 { counter-reset: h3 } .outline-h3 { counter-reset: h4 } .outline-h4 { counter-reset: h5 } .outline-h5 { counter-reset: h6 } .outline-h2>.outline-item>.outline-label:before { counter-increment: h2; content: counter(h2) \\\". \\\" } .outline-h3>.outline-item>.outline-label:before { counter-increment: h3; content: counter(h2) \\\".\\\" counter(h3) \\\". \\\" } .outline-h4>.outline-item>.outline-label:before { counter-increment: h4; content: counter(h2) \\\".\\\" counter(h3) \\\".\\\" counter(h4) \\\". \\\" } .outline-h5>.outline-item>.outline-label:before { counter-increment: h5; content: counter(h2) \\\".\\\" counter(h3) \\\".\\\" counter(h4) \\\".\\\" counter(h5) \\\". \\\" } .outline-h6>.outline-item>.outline-label:before { counter-increment: h6; content: counter(h2) \\\".\\\" counter(h3) \\\".\\\" counter(h4) \\\".\\\" counter(h5) \\\".\\\" counter(h6) \\\". \\\" } \"]},\"52\":{\"h\":\"添加代码块折叠按钮\",\"t\":[\"先备份下面文件，然后在进行修改\",\"D:\\\\Typora\\\\resources\\\\appsrc\\\\window\\\\frame.js \",\"在文件 frame.js的末尾添加如下代码\"]},\"53\":{\"h\":\"在单个代码块添加代码收缩按钮\",\"t\":[\"// 添加代码收缩功能 content.addEventListener(\\\"mouseover\\\", function () { window.setTimeout(function () { codeDivs.forEach((div, index) => { if (div.firstChild.nodeName != \\\"BUTTON\\\") { var button = document.createElement(\\\"button\\\"); button.className = \\\"contract-code-button\\\"; button.innerText = \\\"代码收缩\\\"; button.onclick = (e) => { if (div.style.height != \\\"2.9em\\\") { button.innerText = \\\"代码展开\\\"; div.style.height = \\\"2.9em\\\"; } else { button.innerText = \\\"代码收缩\\\"; div.style.height = \\\"inherit\\\"; } } div.insertBefore(button, div.firstChild) } }); }, 1000); }, true); \"]},\"54\":{\"h\":\"添加收缩文件全部代码块按钮\",\"t\":[\"// 添加收缩全部按钮 var isAdd = false; content.addEventListener(\\\"load\\\", function () { window.setTimeout(function () { if (!isAdd) { var footer = document.getElementsByTagName(\\\"footer\\\")[0]; // 全部收缩按钮 var contractButton = document.createElement(\\\"button\\\"); contractButton.innerText = \\\"全部收缩\\\"; contractButton.name = \\\"contarctAllButton\\\"; contractButton.className = \\\"contract-all-button\\\"; contractButton.onclick = (e) => { var buttons = document.getElementsByClassName(\\\"contract-code-button\\\"); buttons.forEach((button, index) => { var div = button.parentNode; button.innerText = \\\"代码展开\\\"; div.style.height = \\\"2.9em\\\"; }); } // 全部展开按钮 var expandButton = document.createElement(\\\"button\\\"); expandButton.innerText = \\\"全部展开\\\"; expandButton.name = \\\"expandAllButton\\\"; expandButton.className = \\\"expand-all-button\\\"; expandButton.onclick = (e) => { var buttons = document.getElementsByClassName(\\\"contract-code-button\\\"); buttons.forEach((button, index) => { var div = button.parentNode; button.innerText = \\\"代码收缩\\\"; div.style.height = \\\"inherit\\\"; }); } footer.append(contractButton); footer.append(expandButton); isAdd = true; } }, 1000); }, true); \"]},\"55\":{\"h\":\"文档间锚点、文档间跳转返回、突破Typora的 iframe 登录限制、代码块收缩\"},\"56\":{\"h\":\"文档间锚点\",\"t\":[\"[]() //ctrl + k 创建超链接 [要展现的文字] (#标题名称) // 使用#可以实现跳转到标题 \",\"跳转到修改下划线\",\"使用Typora记录笔记的时候虽然支持页间跳转,但是不支持文档之间的跳转,很不方便。所以,我自己为Typora添加一点小功能,毕竟这是个伪装成Markdown编辑器的浏览器。\"]},\"57\":{\"h\":\"文档间跳转返回\",\"t\":[\"在使用超链接在一个md中跳转之后，我有时候希望返回到超链接的位置，所以我做了一个点击后就会返回的按钮。\"]},\"58\":{\"h\":\"突破Typora的iframe登录限制\",\"t\":[\"在Typora中Iframe是无法登录的，修改沙箱属性也没办法。所以我通过自建立节点的方式来脱离它的控制，这里我会使用百度脑图作为演示。\"]},\"59\":{\"h\":\"代码块收缩\",\"t\":[\"可以让代码块编程一行，便于排版吧，个人想加个这个功能，这功能可能不太大众。\",\"//# sourceMappingURL=http://typora/app/window/frame.js.map var content = document.getElementsByTagName(\\\"content\\\")[0]; var jumpTime = 100; var jumpCount = 5; var write = document.getElementById(\\\"write\\\"); var hasAddIframe = false; var codeDivs = document.getElementsByClassName(\\\"CodeMirror\\\"); content.addEventListener(\\\"mouseover\\\", function() { window.setTimeout(function() { var elements = document.querySelectorAll(\\\"#write a\\\"); // 为每一个标记都添加事件,用于存储锚点 for (let index = 0; index < elements.length; index++) { const element = elements[index]; if(element.getAttribute(\\\"isAddAnchorEvent\\\") !== true){ element.addEventListener(\\\"mouseover\\\", function(e) { var reg = new RegExp('\\\\#[^\\\\\\\"]+', [\\\"g\\\"]); var outText = element.outerHTML; var regResult = reg.exec(outText); if(regResult != null){ var jumpValue = decodeURI(regResult[0]); window.localStorage.setItem(\\\"jump\\\", jumpValue); console.log(jumpValue); } }, true); // 设置标记 element.setAttribute(\\\"isAddAnchorEvent\\\",true); } } }, 1000); },true); // 跳转文档后，使用锚点 content.addEventListener(\\\"load\\\", function() { window.setTimeout(function() { var value = localStorage.getItem(\\\"jump\\\"); if(value != null){ var name = value.substring(1,value.length); var element; var hs = document.querySelectorAll(\\\"h1,h2,h3,h4,h5,h6\\\"); var top; // 先搜索标题 hs.forEach(function(h) { if (h.innerText.toLowerCase() == name.toLowerCase()) { element = h; top = h.offsetTop; return; } }); // 再搜索name if(element == undefined){ var selector = \\\"[name=\\\" + name + \\\"]\\\"; element = document.querySelector(selector); top = findTop(element); } content.scrollTop=top; console.log(\\\"跳转高度:\\\" + top); } }, 1000); },true); // 删除锚点 content.addEventListener(\\\"load\\\", function() { window.setTimeout(function() { console.log(\\\"删除锚点记录\\\"); // 开始删除jump localStorage.removeItem(\\\"jump\\\"); }, 30000); },true); // 解除Typora的登录限制功能，结合百度脑图 content.addEventListener(\\\"mouseover\\\", function() { window.setTimeout(function() { if(!hasAddIframe){ var iframeDivs = document.getElementsByName(\\\"iframe\\\"); iframeDivs.forEach((iframeDiv)=>{ if (iframeDiv!=null&&iframeDiv.childElementCount == 0) { var iframe = document.createElement(\\\"iframe\\\"); iframe.src = iframeDiv.getAttribute(\\\"style\\\"); iframe.sandbox = \\\"allow-scripts allow-same-origin allow-popups allow-top-navigation allow-pointer-lock allow-forms\\\"; iframe.scrolling = \\\"no\\\"; iframe.height = \\\"100%\\\"; iframe.width = \\\"100%\\\"; iframeDiv.appendChild(iframe); } }); console.log(\\\"添加iframe成功\\\"); hasAddIframe = true; } }, 1000); },true); // 添加代码收缩公共能 content.addEventListener(\\\"mouseover\\\", function() { window.setTimeout(function() { codeDivs.forEach((div,index)=>{ if(div.firstChild.nodeName != \\\"BUTTON\\\"){ var button = document.createElement(\\\"button\\\"); button.className = \\\"contract-code-button\\\"; button.innerText = \\\"代码收缩\\\"; button.onclick = (e)=>{ if(div.style.height != \\\"2.9em\\\"){ button.innerText = \\\"代码展开\\\"; div.style.height = \\\"2.9em\\\"; } else{ button.innerText = \\\"代码收缩\\\"; div.style.height = \\\"inherit\\\"; } } div.insertBefore(button,div.firstChild) } }); }, 1000); },true); // 添加收缩全部按钮 var isAdd = false; content.addEventListener(\\\"load\\\", function() { window.setTimeout(function() { if(!isAdd){ var footer = document.getElementsByTagName(\\\"footer\\\")[0]; // 全部收缩按钮 var contractButton = document.createElement(\\\"button\\\"); contractButton.innerText = \\\"全部收缩\\\"; contractButton.name=\\\"contarctAllButton\\\"; contractButton.className = \\\"contract-all-button\\\"; contractButton.onclick = (e)=>{ var buttons = document.getElementsByClassName(\\\"contract-code-button\\\"); buttons.forEach((button,index)=>{ var div = button.parentNode; button.innerText = \\\"代码展开\\\"; div.style.height = \\\"2.9em\\\"; }); } // 全部展开按钮 var expandButton = document.createElement(\\\"button\\\"); expandButton.innerText = \\\"全部展开\\\"; expandButton.name=\\\"expandAllButton\\\"; expandButton.className = \\\"expand-all-button\\\"; expandButton.onclick = (e)=>{ var buttons = document.getElementsByClassName(\\\"contract-code-button\\\"); buttons.forEach((button,index)=>{ var div = button.parentNode; button.innerText = \\\"代码收缩\\\"; div.style.height = \\\"inherit\\\"; }); } footer.append(contractButton); footer.append(expandButton); isAdd = true; } }, 1000); },true); // 添加业内返回跳转功能 content.addEventListener(\\\"mouseover\\\", function() { window.setTimeout(function() { var elements = document.querySelectorAll(\\\"a\\\"); // 未添加事件 if(elements.length!=0){ // 为每一个标记都添加事件 for (let index = 0; index < elements.length; index++) { const element = elements[index]; element.addEventListener(\\\"click\\\", function(e) { if(e.ctrlKey==true){ var footer = document.getElementsByTagName(\\\"footer\\\")[0]; var buttons = document.querySelectorAll(\\\"[name=backButton]\\\"); if (buttons.length != 0) { removeChilds(footer,buttons); } var button = document.createElement(\\\"button\\\"); var cancelButton = document.createElement(\\\"button\\\"); // 跳转的按钮 button.innerText = \\\"返回\\\"; button.name=\\\"backButton\\\"; button.className = \\\"back-button\\\"; // 清除的按钮 cancelButton.innerText = \\\"取消\\\"; cancelButton.name=\\\"backButton\\\"; cancelButton.className = \\\"cancel-button\\\"; footer.append(button); footer.append(cancelButton); buttons = document.querySelectorAll(\\\"[name=backButton]\\\"); button.onclick = (e) => { e.cancelBubble = true; var jumpValue = localStorage.getItem(\\\"jump\\\"); var top = findTop(element); jumpTo(top,jumpTime,jumpCount); console.log(\\\"跳转高度:\\\" + top); console.log(buttons); removeChilds(footer,buttons); }; cancelButton.onclick = (e) => { e.cancelBubble = true; console.log(buttons); removeChilds(footer,buttons); }; } }, true); } } }, 100); },true); function removeChilds(parent,children){ children.forEach((child,index)=>{ parent.removeChild(child); }); } function findTop(element){ var topElement = element; while(topElement.parentElement != write){ topElement = topElement.parentElement; } // ol元素中的特殊处理 if(topElement.nodeName.toLowerCase() == \\\"ol\\\" ||topElement.nodeName.toLowerCase() == \\\"ul\\\" ){ var liElement = element; var array = []; var result = 0; // 最外层 array.push(topElement.offsetTop); // 直到ol次外层 while(liElement.parentElement.parentElement != write){ liElement = liElement.parentElement; if(liElement.nodeName.toLowerCase() == \\\"li\\\"||liElement.nodeName.toLowerCase() == \\\"ol\\\" ||liElement.nodeName.toLowerCase() == \\\"ul\\\"){ console.log(liElement); console.log(liElement.nodeName.toLowerCase() + \\\":\\\" + liElement.offsetTop); array.push(liElement.offsetTop); } } array.forEach((value)=>{ result += value; }); return result; } return topElement.offsetTop; } function jumpTo(to, time, count) { var from = content.scrollTop; var length = to - from; var everyLength = parseFloat(length / count); var jumpCount=0; var interval = window.setInterval(() => { if(jumpCount++>=count){ content.scrollTop = to; clearInterval(interval); }else{ content.scrollTop += everyLength; } }, time / count); } \"]},\"60\":{\"h\":\"typora清理不用的图片\",\"t\":[\"输入G:\\\\笔记\\\\typora配置.md\",\"#include <iostream> #include <fstream> #include <sstream> #include <vector> #include <algorithm> class TyporaClean { public: // 清理未使用的图片 static void CleanUnusedPic(const std::vector<std::string>& allPicFiles, const std::vector<std::string>& usedPicNames) { if (allPicFiles.empty()) { return; } std::string assetPath = getParentDirectory(allPicFiles[0]); for (const std::string& curPicFile : allPicFiles) { std::string curFileName = getFileName(curPicFile); bool isUsed = std::find(usedPicNames.begin(), usedPicNames.end(), curFileName) != usedPicNames.end(); if (!isUsed) { std::cout << \\\"已删除无用图片: \\\" << curPicFile << std::endl; removeFile(curPicFile); } } } // 获取MD文件中使用到的所有图片名称 static std::vector<std::string> getUsedPicNames(const std::string& curFile) { std::string mdFileContent = readMdFileContent(curFile); std::vector<std::string> imageNames = extractImageNames(mdFileContent); return imageNames; } // 执行单个MD文件的图片瘦身 static void CleanUnnecessaryPic(const std::string& curFile, const std::string& curAssetFile) { std::vector<std::string> allPicFiles = getAllPicFiles(curAssetFile); std::vector<std::string> usedPicNames = getUsedPicNames(curFile); CleanUnusedPic(allPicFiles, usedPicNames); } // 执行Typora瘦身程序 static void doSinglePicClean(const std::string& curFile) { std::string curFileName = getFileName(curFile); if (!endsWith(curFileName, \\\".md\\\")) { return; } std::string curFilNameWithoutMd = curFileName.substr(0, curFileName.length() - 3); std::string curAssetName = curFilNameWithoutMd + \\\".assets\\\"; std::string curAssetAbsolutePath = getParentDirectory(curFile) + \\\"\\\\\\\\\\\" + curAssetName; bool iscurAssetExist = directoryExists(curAssetAbsolutePath); if (iscurAssetExist) { CleanUnnecessaryPic(curFile, curAssetAbsolutePath); } } // 执行Typora瘦身程序 static void doClean(const std::string& destPath) { std::vector<std::string> allFiles = getAllFiles(destPath); for (const std::string& curFile : allFiles) { bool isDirectory = directoryExists(curFile); if (isDirectory) { std::string absolutePath = getAbsolutePath(curFile); if (endsWith(absolutePath, \\\".assets\\\")) { continue; } doClean(absolutePath); } else { doSinglePicClean(curFile); } } } // 获取指定路径下的所有文件 static std::vector<std::string> getAllFiles(const std::string& path) { // 实现获取目录下所有文件的逻辑 // ... return std::vector<std::string>(); // 占位符 } // 获取指定路径下的所有图片文件 static std::vector<std::string> getAllPicFiles(const std::string& path) { // 实现获取目录下所有图片文件的逻辑 // ... return std::vector<std::string>(); // 占位符 } // 获取指定路径的父目录 static std::string getParentDirectory(const std::string& path) { // 实现获取父目录的逻辑 // ... return \\\"\\\"; // 占位符 } // 获取指定路径的绝对路径 static std::string getAbsolutePath(const std::string& path) { // 实现获取绝对路径的逻辑 // ... return \\\"\\\"; // 占位符 } // 从指定路径中获取文件名 static std::string getFileName(const std::string& path) { // 实现从路径中获取文件名的逻辑 // ... return \\\"\\\"; // 占位符 } // 判断字符串是否以指定后缀结尾 static bool endsWith(const std::string& str, const std::string& suffix) { return str.size() >= suffix.size() && str.compare(str.size() - suffix.size(), suffix.size(), suffix) == 0; } // 判断目录是否存在 static bool directoryExists(const std::string& path) { // 实现判断目录是否存在的逻辑 // ... return false; // 占位符 } // 读取MD文件的内容 static std::string readMdFileContent(const std::string& curFile) { // 实现读取MD文件内容的逻辑 // ... return \\\"\\\"; // 占位符 } // 从MD文件内容中提取图片名称 static std::vector<std::string> extractImageNames(const std::string& mdFileContent) { // 实现从MD文件内容中提取图片名称的逻辑 // ... return std::vector<std::string>(); // 占位符 } // 删除指定文件 static void removeFile(const std::string& filePath) { // 实现删除文件的逻辑 // ... } }; int main(int argc, char* argv[]) { std::string noteRootPath; if (argc == 1) { noteRootPath = \\\"G:\\\\\\\\笔记\\\\\\\\\\\"; } else { noteRootPath = argv[1]; } TyporaClean::doClean(noteRootPath); return 0; } \",\"import os def MdCancelIma(md_dir): mdIma_dir = md_dir + \\\".assets\\\"#填入对应assets文件路径 for root, dirs, files in os.walk(mdIma_dir): with open(md_dir, 'r', encoding='utf-8') as md: text = md.read() for imaName in files: if text.find(imaName)==-1: print(\\\"删除的图片名为: \\\",imaName) path=mdIma_dir+\\\"\\\\\\\\\\\"+imaName os.remove(path) def findmd(path, mdFiles): for filename in os.listdir(path) : mdFile = os.path.join(path, filename) if os.path.isfile(mdFile): if mdFile.endswith(\\\".md\\\"): mdFiles.append(mdFiles) else: findmd(de_path, mdFile) if __name__ == '__main__': data = input(\\\"请输入md文件路径: \\\") if(data): MdCancelIma(data) else: path = \\\"G:\\\\\\\\笔记\\\" mdFiles = [] flag = input(\\\"遍历G:\\\\笔记文件下所有md文件，确认 1，取消 0\\\") if（flag != 0）: findmd(path, mdFiles) for mdFile in mdFiles: print(mdFile) \"]},\"61\":{\"h\":\"给Typora的代码块设置默认语言\",\"t\":[\"打开Typora的安装目录： 右键图标，打开文件所在位置：然后依下边路径找到找到frame.js文件\",\"Typora\\\\resources\\\\appsrc\\\\window \",\"右键选择打开方式，用记事本打开，然后Ctrl+F全局搜索以下字符串，然后按照下图将其后的双引号里面的内容改写。保存退出 注意：最好先备份frame.js文件，改写之后要保存再退出\",\"\\\"select a language\\\")+\\\"'></span>\\\",t.childNodes[0].textContent=e \",\"image-20231217144250890\",\"重启Typora，在试试代码块就可以看到默认预言了，不过得按回车后才能被渲染\"]},\"62\":{\"h\":\"如何设置高亮快捷键\",\"t\":[\"设置方式：文件 > 偏好设置 > 通用 > 打开高级设置 > 会看到两个json文件，打开其中一个 > 在 “keyBinding” 中添加 \\\"Highlight\\\":\\\"Ctrl+Shift+H\\\"> 保存 > 另一个json文件也在 \\\"keyBinding\\\" 中添加 \\\"Highlight\\\":\\\"Ctrl+Shift+H\\\" > 保存\"]},\"63\":{\"h\":\"win10上Typora卡顿的问题及其解决方案\",\"t\":[\"电脑上运行较多应用，内存占用较高，发现Typora特别卡顿,Typora使用了0号显卡，怀疑是导致其卡顿的原因。于是决定关闭GPU, 找到Typora的配置文件\",\"4544e7fbc99146958a485af81a2458cc\",\"typora --> 文件 --> 偏好设置 --> 通用 --> 打开高级设置 \",\"打开后能看到两个配置文件\",\"编辑conf.user.json,修改flags,保存并重启typora，就不再使用GPU了:\",\" \\\"flags\\\": [[\\\"disable-gpu\\\"]] \",\"禁用GPU之后，软件启动的时候比之前慢，但是打开之后不卡顿了。\"]},\"64\":{\"h\":\"上万字后打字出现卡顿\"},\"65\":{\"h\":\"关闭微软输入法的兼容模式\",\"t\":[\"微软拼音输入法设置–>选项–>常规—>兼容性 \"]},\"66\":{\"h\":\"为typora选择使用 “高性能 NVIDIA处理器”\",\"t\":[\"打开电脑 NVIDIA控制面板，右键这个图标\",\"image.png\",\"进入“管理3D设置”，点击程序设置，找到Typora，大家第一次可能电脑没有把Typora添加进来，大家就自己点击“添加”，然后找到 Typora\",\"image.png\",\"选择使用 “高性能 NVIDIA处理器”\",\"image.png\",\"最后点击右下角“应用”，恭喜你！重新获得了一个流畅的Typora！\",\"注意： 如果以上方法都不行的话，证明可能是你的电脑CPU计算能力不行了，该换电脑了！\"]},\"67\":{\"h\":\"leetcode 344. 反转字符串\",\"t\":[\"leetcode344. 反转字符串\",\"题目描述：编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\",\"不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\",\"**原地算法（in-place algorithm）**基本上不需要额外辅助的数据结构,然而,允许少量额外的辅助变量来转换数据的算法。当算法运行时，输入的数据通常会被要输出的部分覆盖掉，\",\"class Solution { public: void reverseString(vector<char>& s) { int left = 0; int right = s.size() - 1; while(left < right) { swap(s[left++], s[right--]); } } }; \",\"void reverseString(vector<char>& s) { for (int i = 0, j = s.size() - 1; i < s.size()/2; i++, j--) { swap(s[i],s[j]); } } \"]},\"68\":{\"c\":[\"数据结构与算法\"]},\"69\":{\"c\":[\"数组\",\"双指针\",\"字符串\"]},\"70\":{\"h\":\"Leetcode 905. 按奇偶排序数组\",\"t\":[\"Leetcode 905. 按奇偶排序数组\",\"题目描述：整形数组，把偶数调整到数组的左边，把奇数调整到数组的右边\",\"void ajustArray(int arr[], int len) // 整形数组，把偶数调整到数组的左边，把奇数调整到数组的右边 { int left = 0; int right = len - 1; while(left < right) { while(left < right && (arr[right] & 0x01) == 1) {//位操作一定加括号 right--; } while(left < right && (arr[left] & 0x01) == 0) { left++; } if(left < right) { std::swap(arr[left],arr[right]); left++; right--; } } } int main() { int arr[10] = {0}; srand(time(nullptr)); for(int i = 0; i < 10; i++) { arr[i] = rand()%100; } for(auto i : arr) { cout << i << \\\" \\\" ; } cout << endl; ajustArray(arr, 10); for(auto i : arr) { cout << i << \\\" \\\" ; } cout << endl; return 0; } \",\"位操作判断奇偶性比 x%2 == 1要快，但是！！！\"]},\"71\":{\"c\":[\"数据结构与算法\"]},\"72\":{\"c\":[\"数组\",\"双指针\"]},\"73\":{\"h\":\"LeetCode 209.长度最小的子数组\",\"t\":[\"LeetCode 209.长度最小的子数组\",\"题目描述：给定正整数数组nums和正整数target，找和>=target的长度最小的**连续子数组；**找到返回其长度，找不到返回0；\",\"滑动窗口：[left, right]，一层for：对于每一个固定的右界，找符合条件的左界，更新最小长度\",\"class Solution { public: int minSubArrayLen(int target, vector<int>& nums) { int fast = 0; int slow = 0; int sum = 0; int result = nums.size() + 1; while(fast < nums.size()) { sum += nums[fast]; while(sum >= target) { int temp = fast - slow + 1; result = min(temp, result); sum -= nums[slow]; ++slow; } ++fast; } if(result == nums.size() + 1) { return 0; } return result; } }; \"]},\"74\":{\"c\":[\"数据结构与算法\"]},\"75\":{\"c\":[\"数组\",\"双指针\",\"滑动窗口\"]},\"76\":{\"h\":\"LeetCode 27. 移除元素\",\"t\":[\"LeetCode 27. 移除元素\",\"**题目描述：**数组nums中原地移除值为val的元素，返回新数组长度\",\"双指针：一层查找，一层覆盖\",\"双指针：一层查找，一层覆盖\",\"通过这道题大致了解erase()的大致实现\",\"由这道题可知erase()函数的时间复杂度应是O(n)\"]},\"77\":{\"h\":\"同向双指针法\",\"t\":[\"​ slow表示新数组下标；\",\"​ 用fast扫描原数组，寻找用于新数组的值，找到后直接赋给slow位置即可；\",\"​ 最终slow即为新数组元素个数。\",\"class Solution { public: int removeElement(vector<int>& nums, int val) { int fast = 0; int slow = 0; for(; fast < nums.size(); ++fast) { if(nums[fast] != val) { nums[slow++] =nums[fast];//注意赋值后slow也要往前走一步 } } return slow; } }; \"]},\"78\":{\"h\":\"相向双指针法\",\"t\":[\"若题目描述，要确保了移动最少元素、可以改变元素的相对顺序，可以相向的双指针\",\"left表示新数组下标；\",\"left遇到用于新数组的值（非val)直接跳过，遇到val停下；\",\"right遇到val跳过，遇到用于新数组的值（非val)停下；\",\"若left < right，则将right位置元素赋给left位置，并更新left、right；\",\"两指针相遇，表示还有最后一个数需处理，故while（left <= right);\",\"最终left即为新数组元素个数。\",\"class Solution { public: int removeElement(vector<int>& nums, int val) { int left = 0; int right = nums.size() - 1; while(left <= right) { while(left <= right&&nums[left] != val) {//注意left<=right确保合法 ++left; } while(left <= right&&nums[right] == val) { --right; } if(left < right) { nums[left++] = nums[right--];//1.数组是覆盖不是swap；2.left\\\\right要跳到下一个位置 } } return left; } }; \"]},\"79\":{\"c\":[\"数据结构与算法\"]},\"80\":{\"c\":[\"数组\",\"双指针\"]},\"81\":{\"h\":\"LeetCode 59.螺旋矩阵Ⅱ\",\"t\":[\"LeetCode 59.螺旋矩阵Ⅱ\",\"**题目描述：**给定正整数n，将1到n²按顺时针顺序填入n×n的正方形矩阵，返回该矩阵。\",\"img\",\"循环不变量：考虑每一圈的四条边按左闭右开进行处理\",\"思路：\",\"每一圈从(startx, starty)位置开始 \",\"上：行号不变，列号从 starty（闭）到 starty + n - offset（开）\",\"右：行号从 startx（闭）到 startx + n - offset（开），列号不变\",\"下：行号不变，列号从 starty + n - offset（闭）到 starty（开）\",\"左：行号从 startx + n - offset（闭）到 startx（开）\",\"更新startx、starty、offset（每次+2）\",\"n为奇数，单独处理中心位置\",\"![img](LeetCode 59.螺旋矩阵Ⅱ.assets/d8bc6e4874094de4849792b5a05963c0.png)\",\"class Solution { public: vector<vector<int>> generateMatrix(int n) { int offSet = 1; int count = 1; int startx = 0; int starty = 0; int loop = 0; vector<vector<int>> result(n,vector<int>(n,0)); //定义一个返回值 while(loop < n/2) {//根据规律找需要循环的次数 int i = startx; int j = starty; for(; j < n - offSet; ++j) {//前闭后开 result[i][j] = count++; } for(; i < n - offSet; ++i) { result[i][j] = count++; } for(; j > starty ; --j) { result[i][j] = count++; } for(; i > startx; --i) { result[i][j] = count++; } ++offSet; //n - offSet为x末端 ++startx; //x的前端 ++starty; ++loop; //循环次数 } if(n % 2 == 1) {//若为奇数，会剩最后一个 result[n/2][n/2] = count;//最后一个元素 } return result; } }; \"]},\"82\":{\"c\":[\"数据结构与算法\"]},\"83\":{\"c\":[\"数组\"]},\"84\":{\"h\":\"LeetCode 704.二分查找\",\"t\":[\"LeetCode 704.二分查找\",\"题目描述：有序数组nums，查找target，成功返回下标，失败返回-1\",\"int binarySearch(vector<int> &nums, int target) { int left = 0; int right = nums.size(); while(left < right) { int middle = left + (right - left) / 2; if(nums[middle] < target) { left = middle + 1; } else if( nums[middle] == target) {// 注意==，而不是= return middle; } else { right = middle; } } return -1; } \"]},\"85\":{\"c\":[\"数据结构与算法\"]},\"86\":{\"c\":[\"二分查找\",\"数组\"]},\"87\":{\"h\":\"LeetCode 977.有序数组的平方\",\"t\":[\"LeetCode 977.有序数组的平方\",\"**题目描述：**非递减数组nums，将各元素平方按非递减顺序排列，返回新数组\",\"思路： \",\"nums元素组成可能为：①全正；②全负；③有正有负；\",\"对于有正有负的情况，需要比较负数平方与正数平方，才能决定在新数组中的位置\",\"用一个指针扫描负数，一个指针扫描正数，①②可合并到③（一个指针始终未更新）\",\"class Solution { public: vector<int> sortedSquares(vector<int>& nums) { vector<int> ans(nums.size(), 0); int left = 0; int right = nums.size() - 1; for (int i = nums.size() - 1; i >= 0; i--) { if (nums[left] * nums[left] > nums[right] * nums[right]) {//保证有序 ans[i] = nums[left] * nums[left];//最大的在后面，升序 left++; } else { ans[i] = nums[right] * nums[right]; right--; } } return ans; } }; \"]},\"88\":{\"c\":[\"数据结构与算法\"]},\"89\":{\"c\":[\"数组\",\"双指针\"]},\"90\":{\"h\":\"二分查找总结\"},\"91\":{\"h\":\"使用条件：\",\"t\":[\"线性表是有序表\",\"二分查找要求数据结构必须是顺序表，也就是类似于数组的连续存储，因为只有这样才能一下定位出数组的中间位置（直接使用类似a[len / 2]），然后就可以把数组一分为二，进行后面的操作。 但是对于链表，由于存储是离散的，不能像数组一样，快速定位中间位置，来把链表一分为二，所以一般的二分查找不能直接应用于链表\"]},\"92\":{\"h\":\"基础版\"},\"93\":{\"h\":\"左闭右闭\",\"t\":[\"int binary_search(vector<int> nums, int target) { int start=0, end=nums.size()-1; //注意end while(start <= end) { //注意循环条件 int mid = start+(end-start)/2; //计算中间下标 if(nums[mid] == target) //如果找到了，就返回下标 return mid; if(nums[mid] < target) start=mid+1; //如果发现这个数比目标数字小，就说明左半边都没有，直接从mid+1开始 else end=mid-1; //如果发现这个数比目标数字大，就说明右半边都没有，直接从mid-1开始 } } \"]},\"94\":{\"h\":\"左闭右开\",\"t\":[\"int binary_search(vector<int> nums,int target) { int start=0, end=nums.size(); //注意end while(start < end) { //注意循环条件 int mid = start+(end-start)/2; //计算中间下标 if(nums[mid] == target) //如果找到了，就返回下标 return mid; if(nums[mid] < target) start=mid+1; //如果发现这个数比目标数字小， //就说明左半边都没有，直接从mid+1开始 else end=mid; //因为右边界取不到，所有不需要减一 } } \"]},\"95\":{\"h\":\"升级版（可以有重复值)\",\"t\":[\"当数组中有重复值的时候,返回该值第一个出现或者最后一个出现的下标. 比如[1,2,2,2,2,2,3],如果返回第一个出现的地方,应该返回1,如果返回最后一个,应该返回5. 首先我们可以想到,可以通过二分法拿到某一个目标值,然后向左或者向右遍历找到边界 适用于： 一个就是很直接让你查找目标值的最左或者最右,另一个就是需要你查出目标值的区间起始下标.\"]},\"96\":{\"h\":\"最左值\",\"t\":[\"//缩小左区间求左边界 int binary_search_L(vector<int> nums, int target) { int left = 0, right = nums.size(); while(left<right) { int mid = left + (right - left)/2; if(nums[mid] < target) left = mid + 1; else right = mid; //相等时让右边界为目标值，继续缩小左区间[left,mid) if(left == nums.size() || nums[left] != target) return -1; return left; } } \",\"//F2 class Solution { public: int search(vector<int>& nums, int target) { int left = 0, right = nums.size()-1; while(left<=right) { int mid = left + (right - left)/2; if(target > nums[mid]) left = mid + 1; else right = mid-1; //相等时让右边界为目标值，继续缩小左区间[left,mid) } if(left == nums.size() || nums[left] != target) return -1; return left; } }; \",\"为什么该算法能够搜索左侧边界？ 关键在对于 nums[mid]==target 这种情况的处理，找到 target 时不要立即返回，而是缩小搜索区间的上界 right ，在区间 [left,mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。\"]},\"97\":{\"h\":\"最右值\",\"t\":[\"//向右逼近右边界 F1 左闭右开 int binary_search_R(vector<int> nums, int target) { int left = 0, right = nums.size(); while(left<right) { int mid = left + (right - left)/2+1; if(target < nums[mid]) right = mid; else left = mid + 1; if(0 right||) return -1; return right - 1;//或返回left[mid,right) } } \",\"//F2 左闭右闭 int search(vector<int>& nums, int target) { if(nums.empty()) return -1; int left = 0, right = nums.size() - 1; while(left <= right) { auto mid = left + (right - left)/2; if(target < nums[mid]) right = mid - 1; else left = mid + 1; } if(right < 0 || nums[right] != target) return -1; return right; } \"]},\"98\":{\"c\":[\"数据结构与算法\"]},\"99\":{\"c\":[\"数组\",\"二分查找\"]},\"100\":{\"h\":\"数组基础\",\"t\":[\"特点：内存是连续的\",\"优点\",\"下标访问（随机访问）时间复杂度是O(1)\",\"末尾位置增加/删除元素时间复杂度是O(1)\",\"访问元素前后相邻位置的元素非常方便\",\"缺点\",\"非末尾位置增加/删除元素需要进行大量的数据移动O(n)\",\"搜索的时间复杂度\",\"无序数组-线性搜索O(n)\",\"有序数组-二分搜索O(logn)\",\"数组扩容消耗比较大\",\"扩容\"]},\"101\":{\"h\":\"数组的实现\",\"t\":[\"#include <iostream> #include <time.h> //time() #include <stdlib.h> //srand() #include <string.h> //memcpy() using std::cout; using std::endl; //using std::time; //using std::srand; class Arrary { public: Arrary():_size(0), _capacity(10) { //默认容量大小为10 _data = new int[10](); } ~Arrary() { delete[] _data; _data = nullptr; } public: //尾插 void push_back(int val) { if(_size == _capacity) { expand(2 * _capacity); // O(n) } _data[_size] = val; //O(1) //操作完，看一下是否需要修改属性 ++_size; } //尾删 void pop_back() { if(_size == 0) { return; } --_size; } //按位置插 void insert(int pos, int val) { //pos下标 //注意应先判断下标的有效性 if(pos < 0 || pos > _size) { return; // throw \\\"pos invalid!\\\"; } if(_size == _capacity) { expand(2*_capacity); } // 移动元素 O(n) for(int i = _size - 1; i >= pos; --i) { //_size 不要写size_t（unsigned int）这里无法停止 _data[i + 1] = _data[i]; } _data[pos] = val; ++_size; } //按位置删除 void erase(int pos){ if(pos < 0 || pos >= _size) { return; } // O(n) for(int i = pos + 1; i < _size; ++i) { _data[i - 1] = _data[i]; } --_size; } //查找元素的位置 size_t find(int data) { for(int i = 0; i < _size; ++i) { if(_data[i] == data) { return i; } } return -1; } //打印 void show(){ for(int i = 0; i < _size; ++i) { cout << _data[i] << \\\" \\\" ; } cout << endl; } private: void expand(size_t size) { //扩容 int* temp = new int[size]; /*for(int i = 0; i < _size; ++i) { temp[i] = _data[i]; }*/ memcpy(temp, _data, sizeof(int) * _size); delete[] _data; _data = temp; _capacity = size;//记得修改属性 } private: size_t _size;//大小 size_t _capacity;//容量 int* _data; }; int main() { Arrary arr; srand(time(nullptr)); for(int i = 0; i < 10; ++i) { arr.push_back(rand()%100); } arr.show(); cout << \\\"arr.push_back(666);arr.erase(0) = \\\" ; arr.push_back(666); arr.erase(0); arr.show(); cout << \\\"arr.erase(2);arr.insert(0, 100);arr.pop_back() = \\\"; arr.erase(2); arr.insert(0, 100); arr.pop_back(); arr.show(); cout << \\\"arr.erase(arr.find(100)); = \\\"; int pos = arr.find(100); if(-1 != pos) { arr.erase(pos); } arr.show(); return 0; } \",\"$./main 77 22 76 81 53 96 48 11 45 34 arr.push_back(666);arr.erase(0) = 22 76 81 53 96 48 11 45 34 666 arr.erase(2);arr.insert(0, 100);arr.pop_back() = 100 22 76 53 96 48 11 45 34 arr.erase(arr.find(100)); = 22 76 53 96 48 11 45 34 \",\"注意：\",\"2.下标访问先判断下标的有效性\",\"3.成员函数执行完操作后，要注意是否需要修改属性\"]},\"102\":{\"c\":[\"数据结构与算法\"]},\"103\":{\"c\":[\"数组\",\"基础知识\"]},\"104\":{\"h\":\"查找N个数组的公共元素\",\"t\":[\" #include <iostream> #include <vector> #include <unordered_set> using std::cout; using std::endl; using std::cin; using std::vector; using std::unordered_set; //因为set比数组占用的空间大，并且set把数值映射到key都要做hash计算，速度也比数组慢 //如果数组数值范围可控可以使用数组做hash const int M = 20; //数值的范围 vector<int> getIntersection3(const vector<int>& nums1, const vector<int>& nums2) { unordered_set<int> result_set; //给结果去重 int hashTable[M] = {0}; for(int num : nums1) { hashTable[num] = 1; } for(int num : nums2) { if(hashTable[num] == 1) { result_set.insert(num); } } return vector(result_set.begin(), result_set.end()); } void print(const vector<int>& vec) { for(int i : vec) { cout << i << ' '; } cout << endl; } int main() { vector<vector<int>> arr = { {0,1,2,3,4,5,6,7,8,9},{1,1,2,2,3,4,5,6,7,9},{1,2,3,3,4, 4,4,6,6,7},{1,2,3,4,6,7,8,9,10,10},{1,1,2,2,3,3,4,4,6,8} }; vector<int> ret = getIntersection3(arr[0],arr[1]); for(int i = 2; i < arr.size(); ++i) { ret = getIntersection3(arr[i], ret); } print(ret); } \"]},\"105\":{\"c\":[\"数据结构与算法\"]},\"106\":{\"c\":[\"数组\"]},\"107\":{\"h\":\"查找三个数组的公共元素\",\"t\":[\" #include <iostream> #include <vector> #include <unordered_set> using std::cout; using std::endl; using std::cin; using std::vector; using std::unordered_set; //因为set比数组占用的空间大，并且set把数值映射到key都要做hash计算，速度也比数组慢 //如果数组数值范围可控可以使用数组做hash const int M = 20; //数值的范围 vector<int> getIntersection3(const vector<int>& nums1, const vector<int>& nums2) { unordered_set<int> result_set; //给结果去重 int hashTable[M] = {0}; for(int num : nums1) { hashTable[num] = 1; } for(int num : nums2) { if(hashTable[num] == 1) { result_set.insert(num); } } return vector(result_set.begin(), result_set.end()); } void print(const vector<int>& vec) { for(int i : vec) { cout << i << ' '; } cout << endl; } int main() { vector<int> v1 = { 1,2,2,3,4,5,5,5,8,9,11,13 }; vector<int> v2 = { 2,2,2,3,5,6,7,7,8,9,10,12,12,13,13,14 }; vector<int> v3 = { 1,1,1,2,2,4,5,6,7,7,8,9,10,14,14,17,18,20 }; //print(v1); //print(v2); //vector<int> ret = getIntersection(v1, v2); //print(ret); //vector<int> ret2 = getIntersection2(v1, v2); //print(ret2); //vector<int> ret3 = getIntersection3(v1, v2); //print(ret3); cout << \\\"----------------三个有序数组的各个元素为\\\" << endl; print(v1); print(v2); print(v3); vector<int> temp = getIntersection2(v1, v2); vector<int> ret4 = getIntersection2(temp, v3); print(ret4); return 0; } \"]},\"108\":{\"c\":[\"数据结构与算法\"]},\"109\":{\"c\":[\"数组\"]},\"110\":{\"h\":\"查找两个有序数组的公共部分\",\"t\":[\"#include <iostream> #include <vector> #include <unordered_set> using std::cout; using std::endl; using std::cin; using std::vector; using std::unordered_set; //查找两个有序数组的公共部分 //不去重版本 vector<int> getIntersection(const vector<int>& nums1, const vector<int>& nums2) { vector<int> result; int p1 = 0; int p2 = 0; while(p1 < nums1.size() || p2 < nums2.size()) { if(nums1[p1] == nums2[p2]) { result.push_back(nums1[p1]); ++p1; ++p2; } else if(nums1[p1] > nums2[p2]) { ++p2; } else { ++p1; } } return result; } void print(const vector<int>& vec) { for(int i : vec) { cout << i << ' '; } cout << endl; } int main() { vector<int> v1 = { 1,2,2,3,4,5,5,5,8,9,11,13 }; vector<int> v2 = { 2,2,2,3,5,6,7,7,8,9,10,12,12,13,13,14 }; print(v1); print(v2); vector<int> ret = getIntersection(v1, v2); print(ret); vector<int> ret2 = getIntersection2(v1, v2); print(ret2); vector<int> ret3 = getIntersection3(v1, v2); print(ret3); } \",\"[leetcode 349. 两个数组的交集（有相同的数字） | 张威的编程学习笔记 (gitee.io)](https://iszhwei.gitee.io/algo/03 哈希算法/349.两个数组的交集.html)\",\" //去重版 vector<int> getIntersection2(const vector<int>& nums1, const vector<int>& nums2) { unordered_set<int> result_set; unordered_set<int> nums_set(nums1.begin(), nums1.end()); for(int num : nums2) { if(nums_set.find(num) != nums_set.end()) { result_set.insert(num); } } return vector<int>(result_set.begin(), result_set.end()); } \",\" //因为set比数组占用的空间大，并且set把数值映射到key都要做hash计算，速度也比数组慢 //如果数组数值范围可控可以使用数组做hash const int M = 20; //数值的范围 vector<int> getIntersection3(const vector<int>& nums1, const vector<int>& nums2) { unordered_set<int> result_set; //给结果去重 int hashTable[M] = {0}; for(int num : nums1) { hashTable[num] = 1; } for(int num : nums2) { if(hashTable[num] == 1) { result_set.insert(num); } } return vector(result_set.begin(), result_set.end()); } \"]},\"111\":{\"c\":[\"数据结构与算法\"]},\"112\":{\"c\":[\"数组\",\"双指针\",\"哈希\"]},\"113\":{\"h\":\"查找出现次数超过一半的元素\",\"t\":[\"给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于⌊ n/2 ⌋ 的元素。\",\"你可以假设数组是非空的，并且给定的数组总是存在多数元素。\"]},\"114\":{\"h\":\"方法一\",\"t\":[\"class Solution { public: int majorityElement(vector<int>& nums) { sort(nums.begin(), nums.end()); return nums[nums.size()/2]; } }; \",\"复杂度O(nlogn)。\"]},\"115\":{\"h\":\"方法二\",\"t\":[\"class Solution { public: int majorityElement(vector<int>& nums) { int count = 1; int val = nums[0]; for(int i = 1; i < nums.size(); ++i) { if(val == nums[i]) { ++count; } else if(count == 0) { val = nums[i]; count = 1; } else { count--; } } return val; } }; \",\"复杂度O(n)\"]},\"116\":{\"c\":[\"数据结构与算法\"]},\"117\":{\"c\":[\"数组\"]},\"118\":{\"h\":\"查找最大和次大的元素\",\"t\":[\"#include <iostream> #include <vector> #include <climits> //INT_MIN using std::cout; using std::endl; using std::vector; void find1and2big(vector<int>& nums, int& big1, int& big2) { if(nums.size() < 2) { return; } big1 = INT_MIN; big2 = INT_MIN; for(int num : nums) { if(num > big1) { big2 = big1; big1 = num; } else if(num > big2 && num < big1) { big2 = num; } } if(big2 == INT_MIN) { cout << \\\"数组中所有元素都相同或数组大小小于2，无法找到次大值\\\" << endl; } } int main() { vector<int> vec = {12, 13, 1, 10, 34, 2}; for(int i : vec) { cout << i << ' '; } cout << endl; int big1, big2; find1and2big(vec, big1, big2); cout << big1 << ' ' << big2 << endl; return 0; } \"]},\"119\":{\"c\":[\"数据结构与算法\"]},\"120\":{\"c\":[\"数组\"]},\"121\":{\"h\":\"上滤\",\"t\":[\"用于往堆内插入数据\",\"//nums 待插入的数组 //pos 待插入的下标 //val 待插入的值 void upAdjust(vector<int>& nums, int pos, int val) { while(pos > 0) { //最多计算到根节点 int parent = (pos - 1) / 2; if(val > nums[parent]) { //如果本身为大根堆，调整使用> nums[pos] = nums[parent]; pos = parent; } else { break; } } //把val放到i的位置 nums[pos] = val; } \"]},\"122\":{\"c\":[\"使用指南\"]},\"123\":{\"c\":[\"页面配置\",\"使用指南\"]},\"124\":{\"h\":\"leetcode 1. 两数之和\",\"t\":[\"1. 两数之和\",\"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值target 的那 两个 整数，并返回它们的数组下标。\",\"你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\",\"你可以按任意顺序返回答案。\"]},\"125\":{\"h\":\"方法一：哈希\",\"t\":[\"class Solution { public: vector<int> twoSum(vector<int>& nums, int target) { unordered_map<int, int> hashMap; for(int i = 0; i < nums.size(); ++i) { // 遍历当前元素，并在map中寻找是否有匹配的key if(hashMap.count(target - nums[i])) { return {hashMap[target-nums[i]], i}; } /* auto iter = hashMap.find(target - nums[i]); if(iter != hashMap.end()) { return {iter->second, i}; } */ hashMap[nums[i]] = i; // hashMap.insert(pair<int, int>(nums[i], i)); } return {}; } }; \",\"时间复杂度O(N)\",\"空间复杂度O(N)\"]},\"126\":{\"h\":\"方法二：双指针\",\"t\":[\"vector<int> twoSum(vector<int>& nums, int target) { // 先对数组排序 sort(nums.begin(), nums.end()); // 左右指针 int left = 0, right = nums.size() - 1; while (left < right) { int sum = nums[left] + nums[right]; // 根据 sum 和 target 的比较，移动左右指针 if (sum < target) { left++; } else if (sum > target) { right--; } else if (sum == target) { return {nums[left], nums[right]}; } } return {}; } \",\"排序的时间复杂度是 O(n log n)，而双指针技术是 O(n)，因此算法的总体时间复杂度是 O(n log n)。\",\"空间复杂度是 O(1)\"]},\"127\":{\"c\":[\"数据结构与算法\"]},\"128\":{\"c\":[\"哈希\",\"双指针\"]},\"129\":{\"h\":\"leetcode 128. 最长连续序列\",\"t\":[\"128. 最长连续序列\",\"给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\",\"请你设计并实现时间复杂度为 O(n) 的算法解决此问题。\",\"示例 1：\",\"输入：nums = [100,4,200,1,3,2] 输出：4 解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 \",\"示例 2：\",\"输入：nums = [0,3,7,2,5,8,4,6,0,1] 输出：9 \",\"class Solution { public: int longestConsecutive(vector<int>& nums) { unordered_set<int> set; //由示例2可知，结果是去重的 for(const int n : nums) { set.insert(n); } int longestLen = 0; for(const int num : set) { if(!set.count(num - 1)) { //如果前面不是连续的，则重新开始 int currentLen = 1; int cur = num; while(set.count(cur + 1)) { currentLen++; cur++; } longestLen = max(longestLen, currentLen); } } return longestLen; } }; \"]},\"130\":{\"c\":[\"数据结构与算法\"]},\"131\":{\"c\":[\"哈希\"]},\"132\":{\"h\":\"leetcode 15. 三数之和\",\"t\":[\"15. 三数之和\",\"给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\",\"你返回所有和为 0 且不重复的三元组。\",\"**注意：**答案中不可以包含重复的三元组。\"]},\"133\":{\"h\":\"方法一: 双指针🍗\",\"t\":[\"class Solution { public: vector<vector<int>> threeSum(vector<int>& nums) { vector<vector<int>> result; sort(nums.begin(), nums.end()); //使用双指针前要先排序 for(int i = 0; i < nums.size() - 2; ++i) { // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了 if (nums[i] > 0) { return result; } // 避免重复的第一个元素 if(i > 0 && nums[i] == nums[i - 1]) { continue; } int left = i + 1; int right = nums.size() - 1; while(left < right) { int sum = nums[i] + nums[left] + nums[right]; if(sum > 0) { right--; } else if(sum < 0){ left++; } else { result.push_back(vector<int>{nums[i], nums[left], nums[right]}); // 避免重复的第二个元素 while(left < right && nums[left] == nums[left + 1]) { left++; } // 避免重复的第三个元素 while(left < right && nums[right] == nums[right - 1]) { right--; } // 找到答案时，双指针同时收缩 left++; right--; } } } return result; } }; \"]},\"134\":{\"h\":\"去重逻辑的思考🍔🍔🍔\"},\"135\":{\"h\":\"a的去重\",\"t\":[\"说到去重，其实主要考虑三个数的去重。a, b ,c,对应的就是 nums[i]，nums[left]，nums[right]\",\"a 如果重复了怎么办，a是nums里遍历的元素，那么应该直接跳过去。\",\"但这里有一个问题，是判断nums[i]与 nums[i + 1]是否相同，还是判断 nums[i] 与nums[i-1]是否相同。\",\"有同学可能想，这不都一样吗。\",\"其实不一样！\",\"都是和 nums[i]进行比较，是比较它的前一个，还是比较它的后一个。\",\"如果我们的写法是 这样：\",\"if (nums[i] == nums[i + 1]) { // 去重操作 continue; } \",\"那我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。\",\"我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！\",\"所以这里是有两个重复的维度。\",\"那么应该这么写：\",\"if (i > 0 && nums[i] == nums[i - 1]) { continue; } \",\"这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。\",\"这是一个非常细节的思考过程。\"]},\"136\":{\"h\":\"b与c的去重\",\"t\":[\"很多同学写本题的时候，去重的逻辑多加了 对right 和left 的去重：（代码中注释部分）\",\"while (right > left) { if (nums[i] + nums[left] + nums[right] > 0) { right--; // 去重 right while (left < right && nums[right] == nums[right + 1]) right--; } else if (nums[i] + nums[left] + nums[right] < 0) { left++; // 去重 left while (left < right && nums[left] == nums[left - 1]) left++; } else { } } \",\"但细想一下，这种去重其实对提升程序运行效率是没有帮助的。\",\"拿right去重为例，即使不加这个去重逻辑，依然根据 while (right > left) 和 if (nums[i] + nums[left] + nums[right] > 0) 去完成right-- 的操作。\",\"多加了 while (left < right && nums[right] == nums[right + 1]) right--; 这一行代码，其实就是把需要执行的逻辑提前执行了，但并没有减少 判断的逻辑。\",\"最直白的思考过程，就是right还是一个数一个数的减下去的，所以在哪里减的都是一样的。\",\"所以这种去重 是可以不加的。 仅仅是 把去重的逻辑提前了而已。\",\"while (right > left) { // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组 /* while (right > left && nums[right] == nums[right - 1]) right--; while (right > left && nums[left] == nums[left + 1]) left++; */ if (nums[i] + nums[left] + nums[right] > 0) right--; ... } \"]},\"137\":{\"h\":\"方法二: 哈希表(思想)\",\"t\":[\"class Solution { public: vector<vector<int>> threeSum(vector<int>& nums) { vector<vector<int>> result; sort(nums.begin(), nums.end()); // 先对数组进行排序 for (int i = 0; i < nums.size(); ++i) { if (i > 0 && nums[i] == nums[i - 1]) { continue; // 避免重复的第一个元素 } unordered_set<int> seen; // 用于记录已经遍历过的元素 for (int j = i + 1; j < nums.size(); ++j) { int c = 0 - (nums[i] + nums[j]); if (seen.count(c)) { result.push_back({nums[i], c, nums[j]}); while (j + 1 < nums.size() && nums[j] == nums[j + 1]) { ++j; // 跳过重复的第二个元素 } } seen.insert(nums[j]); } } return result; } }; \"]},\"138\":{\"c\":[\"数据结构与算法\"]},\"139\":{\"c\":[\"哈希\",\"双指针\"]},\"140\":{\"h\":\"leetcode 167. 两数之和 II - 输入有序数组\",\"t\":[\"167. 两数之和 II - 输入有序数组\",\"给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。\",\"以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。\",\"你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\",\"你所设计的解决方案必须只使用常量级的额外空间。\"]},\"141\":{\"h\":\"方法一：哈希\",\"t\":[\"class Solution { public: vector<int> twoSum(vector<int>& numbers, int target) { unordered_map<int, int> hashMap; for(int i = 0; i < numbers.size(); ++i) { if(hashMap.count(target - numbers[i])) { return {hashMap[target - numbers[i]] + 1,i + 1}; } hashMap[numbers[i]] = i; } return {}; } }; \",\"一般用于\",\"时间复杂度O(n) 空间复杂度O(n)\"]},\"142\":{\"h\":\"方法二：二分查找\",\"t\":[\"对有序数组 可以使用二分查找法 查找target - nums.at(i)\",\"时间复杂度O(nlogn) 空间复杂度O(1)\",\"class Solution { public: vector<int> twoSum(vector<int>& numbers, int target) { for(int i = 0; i < numbers.size(); ++i) { int ret = binarySearch(numbers, i + 1, numbers.size() - 1 , target - numbers[i]); if(ret > -1) { return {i + 1, ret + 1}; } } return {-1, -1}; } int binarySearch(vector<int>& nums,int left, int right, int target) { //左闭右闭 if(left < 0 || right > nums.size() || left > right) { return -1; } while(left <= right) { int middle = left + (right - left) / 2; if(target > nums[middle]) { left = middle + 1; } else if(target == nums[middle]) {//判断相等时一定要小心，不要写成赋值 return middle; } else { right = middle - 1; } } return -1; } }; \"]},\"143\":{\"h\":\"方法三 ：双指针法\",\"t\":[\"时间复杂度：O(n)，其中 n 是数组的长度。两个指针移动的总次数最多为 n 次。\",\"空间复杂度：O(1)。\",\"class Solution { public: vector<int> twoSum(vector<int>& numbers, int target) { int left = 0; int right = numbers.size() - 1; if(numbers[left] > target && numbers[left] > 0) { return {-1, -1}; } while(left < right) { while(left < right && numbers[left] + numbers[right] > target) { --right; } while(left < right && numbers[left] + numbers[right] < target) { ++left; } if(numbers[left] + numbers[right] == target) { return {left + 1, right + 1}; } } return {-1, -1}; } }; \"]},\"144\":{\"c\":[\"数据结构与算法\"]},\"145\":{\"c\":[\"哈希\",\"二分查找\",\"双指针\"]},\"146\":{\"h\":\"leetcode 202. 快乐数\",\"t\":[\"leetcode 202. 快乐数\",\"编写一个算法来判断一个数 n 是不是快乐数。\",\"「快乐数」 定义为：\",\"对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\",\"然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\",\"如果这个过程 结果为 1，那么这个数就是快乐数。\",\"如果 n 是 快乐数 就返回 true ；不是，则返回 false 。\"]},\"147\":{\"h\":\"分析\",\"t\":[\"题⽬告诉我们，，死的⽅式有两种： ▪ 情况⼀：⼀直在 1 中死循环，即 1 -> 1 -> 1 -> 1...... ▪ 情况⼆：在历史的数据中死循环，但始终变不到 1 由于上述两种情况只会出现⼀种，因此，只要我们能确定循环是在「情况⼀」中进⾏，还是在「情况⼆」中进⾏，就能得到结果。\",\"简单证明： a. 经过⼀次变化之后的最⼤值 9^2 * 10 = 810 ( 2^31-1=2147483647 。选⼀个更⼤的最⼤ 9999999999 )，也就是变化的区间在 [1, 810] 之间； b. 根据「鸽巢原理」，⼀个数变化 811 次之后，必然会形成⼀个循环； c. 因此，变化的过程最终会⾛到⼀个圈⾥⾯，因此可以⽤「快慢指针」来解决。\"]},\"148\":{\"h\":\"方法一：快慢指针\",\"t\":[\"class Solution { public: bool isHappy(int n) { int slow = n; int fast = getSum(n); while(slow != fast) { slow = getSum(slow); fast = getSum(getSum(fast)); } return slow == 1; } int getSum(int num) { //获取 数值各个位上的数字的平方和 int sum = 0; while(num) { int x = num % 10; sum += x * x; num /= 10; } return sum; } }; \"]},\"149\":{\"h\":\"方法二：哈希表\",\"t\":[\"class Solution { public: bool isHappy(int n) { unordered_set<int> set; while(1) { n = getSum(n); if(n == 1) { //⼀直在 1 中死循环 return true; } if(set.count(n)) { //在历史的数据中死循环 return false; } set.insert(n); } } int getSum(int num) { int sum = 0; while(num) { int x = num % 10; sum += x * x; num /= 10; } return sum; } }; \"]},\"150\":{\"c\":[\"数据结构与算法\"]},\"151\":{\"c\":[\"哈希\",\"双指针\"]},\"152\":{\"h\":\"Leetcode 217.存在重复元素\",\"t\":[\"leetcode 217. 存在重复元素\",\"题目描述：给定一个整数数组，判断是否存在重复元素。\",\"如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。\"]},\"153\":{\"h\":\"方法一\",\"t\":[\"class Solution { public: bool containsDuplicate(vector<int>& nums) { unordered_set<int> set; for(auto i : nums) { if(set.find(i) != set.end()) { return true; } else { set.insert(i); } } return false; } }; \"]},\"154\":{\"h\":\"方法二 利用不能重复的特点（思路）\",\"t\":[\"//利用set容器不能存储重复元素的特点 class Solution { public: bool containsDuplicate(vector<int>& nums) { unordered_set<int> set(nums.begin(), nums.end()); if(nums.size() > set.size()) { return true; } return false; } }; \"]},\"155\":{\"h\":\"map\",\"t\":[\"class Solution { public: bool containsDuplicate(vector<int>& nums) { for(auto i : nums) { hash[i]++; if(hash[i] > 1) { return true; } } return false; } }; \"]},\"156\":{\"c\":[\"数据结构与算法\"]},\"157\":{\"c\":[\"哈希表\"]},\"158\":{\"h\":\"leetcode 219. 存在重复元素 II\",\"t\":[\"leetcode 219. 存在重复元素 II\",\"给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。如果存在，返回 true ；否则，返回 false 。\",\"class Solution { public: bool containsNearbyDuplicate(vector<int>& nums, int k) { unordered_map<int, int> hash; for(int i = 0; i < nums.size(); ++i) { if(hash.find(nums[i]) != hash.end()) { if(abs(i - hash[nums[i]]) <= k) { return true; } hash[nums[i]] = i; } else { hash[nums[i]] = i; } } return false; } }; \"]},\"159\":{\"c\":[\"数据结构与算法\"]},\"160\":{\"c\":[\"哈希表\"]},\"161\":{\"h\":\"leetcode 220. 存在重复元素 III\",\"t\":[\"leetcode 220. 存在重复元素 III\",\"给你一个整数数组 nums 和两个整数 indexDiff 和 valueDiff 。\",\"找出满足下述条件的下标对 (i, j)：\",\"i != j,\",\"abs(i - j) <= indexDiff\",\"abs(nums[i] - nums[j]) <= valueDiff\",\"如果存在，返回 true *；*否则，返回 false 。\",\"提示：\",\"2 <= nums.length <= 105\",\"-109 <= nums[i] <= 109\",\"1 <= indexDiff <= nums.length\",\"0 <= valueDiff <= 109\"]},\"162\":{\"h\":\"分析\",\"t\":[\"由题意知，在区域下标内查找是否存在两个值，该两个值的差小于某一阈值\",\"遇到绝对值先化简\",\"abs(nums[i]-nums[j]) <= valueDiff -valueDiff <= nums[i] - nums[j] <= valueDiff -valueDiff - nums[i] <= -nums[j] <= valueDiff - nums[i] -valueDiff + nums[i] <= nums[j] <= valueDiff + nums[i] \",\"转变为查找在区域内是否存在一个值属于[-valueDiff + nums[i],valueDiff + nums[i]]\",\"class Solution { public: bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) { multiset<long long> set; for(int i = 0; i < nums.size(); ++i) { if(i > indexDiff) { //维持窗口大小为k(indexDiff) //set.erase(nums[i-indexDiff-1])//multiset指定元素删除，会删掉所有这个值的元素 set.erase(set.find(nums[i-indexDiff-1]));//find()返回的是查找到的第一个元素位置的迭代器 } /* 遇到绝对值先化简 abs(nums[i]-nums[j]) <= valueDiff -valueDiff <= nums[i] - nums[j] <= valueDiff -valueDiff - nums[i] <= -nums[j] <= valueDiff - nums[i] -valueDiff + nums[i] <= nums[j] <= valueDiff + nums[i] */ auto leftBound = set.lower_bound(nums[i] - (long long)valueDiff);// multiset是有序的，可以使用二分查找查询边界 auto rightBound = set.upper_bound(valueDiff + (long long)nums[i]);//实际上返回的是第1个大于valueDiff + (long long)nums[i]的元素的位置 if(leftBound != rightBound) { //若存在则至少有一个，所以 return true; } set.insert(nums[i]);//前面的元素不满足条件，那么察看下一个位置的元素 } return false; } }; \"]},\"163\":{\"h\":\"lower_bound( )和upper_bound( )\",\"t\":[\"lower_bound( )和upper_bound( )都是利用二分查找的方法在一个排好序的数组中进行查找的。\",\"在中，\",\"lower_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找第一个num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。\",\"upper_bound( begin,end,num)：从数组的begin位置到end-1位置二分查找num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。\",\"在，重载lower_bound()和upper_bound()\",\"lower_bound( begin,end,num,greater<type>() ):从数组的begin位置到end-1位置二分查找第一个num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。\",\"upper_bound( begin,end,num,greater<type>() ):从数组的begin位置到end-1位置二分查找num的数字，找到返回该数字的地址，不存在则返回end。通过返回的地址减去起始地址begin,得到找到数字在数组中的下标。\",\"#include<bits/stdc++.h> using namespace std; const int maxn=100000+10; const int INF=2*int(1e9)+10; #define LL long long int cmd(int a,int b){ return a>b; } int main(){ int num[6]={1,2,4,7,15,34}; sort(num,num+6); //按从小到大排序 int pos1=lower_bound(num,num+6,7)-num; //返回数组中第一个大于或等于被查数的值 int pos2=upper_bound(num,num+6,7)-num; //返回数组中第一个大于被查数的值 cout<<pos1<<\\\" \\\"<<num[pos1]<<endl; cout<<pos2<<\\\" \\\"<<num[pos2]<<endl; sort(num,num+6,cmd); //按从大到小排序 int pos3=lower_bound(num,num+6,7,greater<int>())-num; //返回数组中第一个小于或等于被查数的值 int pos4=upper_bound(num,num+6,7,greater<int>())-num; //返回数组中第一个小于被查数的值 cout<<pos3<<\\\" \\\"<<num[pos3]<<endl; cout<<pos4<<\\\" \\\"<<num[pos4]<<endl; return 0; } \"]},\"164\":{\"c\":[\"数据结构与算法\"]},\"165\":{\"c\":[\"哈希表\",\"二分查找\",\"滑动窗口\"]},\"166\":{\"h\":\"leetcode 242. 有效的字母异位词\",\"t\":[\"242. 有效的字母异位词\",\"给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\",\"**注意：**若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。\",\"class Solution { public: bool isAnagram(string s, string t) { int hash[26] = {0}; for(int i = 0; i < s.size(); ++i) { hash[s[i] - 'a']++; } for(int i = 0; i < t.size(); ++i) { hash[t[i] - 'a']--; } for(int i = 0; i < 26; ++i) { if(hash[i] != 0 ) { return false; } } return true; } }; \"]},\"167\":{\"c\":[\"数据结构与算法\"]},\"168\":{\"c\":[\"哈希\",\"数组\",\"字符串\"]},\"169\":{\"h\":\"leetcode 349. 两个数组的交集（有相同的数字）\",\"t\":[\"349. 两个数组的交集（有相同的数字）\",\"给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。\",\"示例 1：\",\"输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] \",\"示例 2：\",\"输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 解释：[4,9] 也是可通过的 \"]},\"170\":{\"h\":\"数组做哈希表\",\"t\":[\"数值范围：\",\"1 <= nums1.length, nums2.length <= 1000\",\"0 <= nums1[i], nums2[i] <= 1000\",\"所以就可以 使用数组来做哈希表了， 因为数组都是 1000以内的\",\"class Solution { public: vector<int> intersection(vector<int>& nums1, vector<int>& nums2) { int hash[1001] = {0}; for(auto num : nums1) { hash[num] = 1; } //使用unordered_set而不是vector是因为可能有多个相同的值出现，需要去重 unordered_set<int> resultSet; //unordered_set 不是unorder_set for(auto num : nums2) { if(hash[num] == 1) { resultSet.insert(num); } } return vector(resultSet.begin(), resultSet.end()); } }; \"]},\"171\":{\"h\":\"unordered_set做哈希表\",\"t\":[\"class Solution { public: vector<int> intersection(vector<int>& nums1, vector<int>& nums2) { unordered_set<int> Set1(nums1.begin(), nums1.end()); unordered_set<int> resultSet; for(auto num : nums2) { if(Set1.find(num) != Set1.end()) { //注意std find返回的是迭代器不是bool resultSet.insert(num); } } return vector<int>(resultSet.begin(), resultSet.end()); } }; \"]},\"172\":{\"c\":[\"数据结构与算法\"]},\"173\":{\"c\":[\"哈希\",\"数组\"]},\"174\":{\"h\":\"leetcode 383. 赎金信\",\"t\":[\"383. 赎金信\",\"给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。\",\"如果可以，返回 true ；否则返回 false 。\",\"magazine 中的每个字符只能在 ransomNote 中使用一次。\",\"class Solution { public: bool canConstruct(string ransomNote, string magazine) { int hash[26]; for(char c : ransomNote) { hash[c - 'a']++; } for(char c : magazine) { hash[c - 'a']--; } for(int n : hash) { if(n > 0) { return false; } } return true; } }; \"]},\"175\":{\"c\":[\"数据结构与算法\"]},\"176\":{\"c\":[\"哈希\"]},\"177\":{\"h\":\"leetcode 594. 最长和谐子序列\",\"t\":[\"leetcode 594. 最长和谐子序列\",\"和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。\",\"现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。\",\"数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。\",\"示例 1：\",\"输入：nums = [1,3,2,2,5,2,3,7] 输出：5 解释：最长的和谐子序列是 [3,2,2,2,3] \"]},\"178\":{\"h\":\"方法一：哈希表\",\"t\":[\"class Solution { public: int findLHS(vector<int>& nums) { unordered_map<int,int> hashMap; for(auto n : nums) { //记录元素出现的次数 hashMap[n]++; } int res = 0; for(auto [key, value] : hashMap) { if(hashMap.count(key + 1)) { res = max(res, value + hashMap[key + 1]); } } /*另一种写法 1.使用pair接收 2.find查找和count查找 for(const auto& p : hashMap){ //用p来接收hashMap的值(是pair) if(visited.find(p.first+1) != visited.end()) { //能找到p.first+1的值 res = max(res, p.second+visited[p.first+1]); } } */ return res; } }; \"]},\"179\":{\"h\":\"方法二：排序 + 双指针\",\"t\":[\"class Solution { public: int findLHS(vector<int>& nums) { sort(nums.begin(), nums.end()); int begin = 0; int res = 0; for(int end = 0; end < nums.size(); end++) { while(nums[end] - nums[begin] > 1) { ++begin; } if(nums[end] - nums[begin] == 1) { res = max(res, end - begin + 1); } } return res; } }; \"]},\"180\":{\"c\":[\"数据结构与算法\"]},\"181\":{\"c\":[\"哈希\",\"双指针\"]},\"182\":{\"h\":\"leetcode 232.用栈实现队列\",\"t\":[\"leetcode 232.用栈实现队列\",\"使用栈实现队列的下列操作：\",\"push(x) -- 将一个元素放入队列的尾部。 pop() -- 从队列首部移除元素。 peek() -- 返回队列首部的元素。 empty() -- 返回队列是否为空。\",\"示例:\",\"MyQueue queue = new MyQueue(); queue.push(1); queue.push(2); queue.peek(); // 返回 1 queue.pop(); // 返回 1 queue.empty(); // 返回 false \",\"说明:\",\"你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\",\"你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\",\"假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。\",\"class MyQueue { public: MyQueue() { } void push(int x) { stIn.push(x); } int pop() { int val = peek(); stOut.pop(); return val; } int peek() { if(empty()) { throw runtime_error(string(\\\"队列为空\\\")); } if(stOut.empty()) { while(!stIn.empty()) { //int val = stIn.top(); //stIn.pop(); //stOut.push(val); stOut.push(stIn.top()); stIn.pop } } int val = stOut.top(); return val; } bool empty() { if(stIn.empty() && stOut.empty()) { return true; } return false; } private: stack<int> stIn; stack<int> stOut; }; /** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj->push(x); * int param_2 = obj->pop(); * int param_3 = obj->peek(); * bool param_4 = obj->empty(); */ \"]},\"183\":{\"c\":[\"数据结构与算法\"]},\"184\":{\"c\":[\"队列\"]},\"185\":{\"h\":\"页面配置\",\"t\":[\"#include <iostream> using std::cout; using std::endl; //对头指针_front与队尾指针_rear在进行变化的时候，需要考虑边界条件 class Queue { public: Queue(int sz = 10) : _size(sz) , _front(0) , _rear(0) , _data(new int[_size]()) { cout << \\\"Queue(int = 10)\\\" << endl; } bool empty() { return _front == _rear; } bool full() { return _front == (_rear + 1)% _size; } void push(const int &value) { if(!full()) { _data[_rear++] = value; _rear %= _size; } else { cout << \\\"The queue is full\\\" << endl; return; } } void pop() { if(!empty()) { ++_front; _front %= _size; } else { cout << \\\"The queue is empty\\\" << endl; return; } } int front() const { return _data[_front]; } int back() const { return _data[(_rear - 1 + _size)%_size]; } int getFront() const { return _front; } int getRear() const { return _rear; } ~Queue() { cout << \\\"~Queue()\\\" << endl; if(_data) { delete [] _data; _data = nullptr; } } private: int _size; int _front; int _rear; int *_data; }; int main(int argc, char **argv) { Queue que; cout << \\\"此时队列是否为空?\\\" << que.empty() << endl; que.push(1); cout << \\\"此时队列是否为满?\\\" << que.full() << endl; for(size_t idx = 2; idx != 12; ++idx) { que.push(idx); } cout << \\\"此时队列是否为满?\\\" << que.full() << endl; cout << \\\"打印队列头尾\\\" << endl << endl; cout << \\\"队头元素\\\" << que.front() << endl; cout << \\\"对头指针\\\" << que.getFront() << endl; cout << \\\"队尾元素\\\" << que.back() << endl; cout << \\\"对尾指针\\\" << que.getRear() << endl; while(!que.empty()) { cout << que.front() << endl; que.pop(); } cout << \\\"此时队列是否为空?\\\" << que.empty() << endl; return 0; } \"]},\"186\":{\"c\":[\"使用指南\"]},\"187\":{\"c\":[\"页面配置\",\"使用指南\"]},\"188\":{\"h\":\"冒泡排序\",\"t\":[\"把⼩的元素往前调或者把⼤的元素往后调，⽐较是相邻的两个元素⽐较，交换也发⽣在这两个元素之间。\",\"外循环表示需要N-1轮循环\",\"内循环表示每轮循环需要比较的次数\",\"如果前面的元素比后面的大，则交换\",\"//bubbleSort.h #ifndef _BUBBLE_SORT_H_ #define _BUBBLE_SORT_H_ #include <vector> using std::vector; using std::swap; void bubbleSort(vector<int>& nums); #endif //_BUBBLE_SORT_H_ \",\"//bubbleSort.cc #include \\\"bubbleSort.h\\\" void bubbleSort(vector<int>& nums) { int len = nums.size(); bool flag; for(int i = 0; i < len - 1; ++i) { flag = true; for(int j = 0; j < len - 1 - i; ++j) { if(nums[j] > nums[j + 1]) { swap(nums[j], nums[j + 1]); flag = false; } } if(flag) { break; } } } \",\"//main.cc #include <iostream> #include <vector> #include <cstdlib> #include <ctime> #include \\\"bubbleSort.h\\\" using std::cout; using std::endl; using std::vector; using std::srand; using std::time; const int dataSize = 10; void getTestDate(vector<int> &nums) { srand(time(nullptr)); for(int i = 0; i < dataSize; ++i){ nums.push_back(rand()%99); } } void print(const vector<int> &nums) { for(auto i : nums) { cout << i << \\\" \\\"; } cout << endl; } int main() { vector<int> nums; getTestDate(nums); print(nums); bubbleSort(nums); print(nums); } \"]},\"189\":{\"c\":[\"数据结构与算法\"]},\"190\":{\"c\":[\"排序算法\"]},\"191\":{\"h\":\"基数排序\",\"t\":[\"将整数按位数切割成不同的数字，然后按每个位数分别比较,从最低位开始排序。\",\"#include <iostream> #include <vector> #include <string> #include <cstdlib> #include <ctime> #include <climits> using std::cout; using std::endl; using std::vector; //只有正整数和0 void radixSort(vector<int>& nums) { if(nums.empty()) { return; } int maxNum = INT_MIN; for(int num : nums) { if(num > maxNum) { maxNum = num; } } int maxNunLen = std::to_string(maxNum).size(); int mod = 10; int div = 1; vector<vector<int>> bucket; for(int i = 0; i < maxNunLen; ++i, mod *= 10, div *= 10) { bucket.resize(10); for(size_t j = 0; j < nums.size(); ++j) { int index = (nums[j] % mod) / div; bucket[index].push_back(nums[j]); } int count = 0; for(auto vec : bucket) { for(int num : vec) { nums[count++] = num; } } bucket.clear(); } } //nums含有负数 void radixSort2(vector<int>& nums) { int maxNum = INT_MIN; for(int num : nums) { if(abs(num) > maxNum) { //正负数中长的数字 maxNum = abs(num); } } int maxNunLen = std::to_string(maxNum).size(); int mod = 10; int div = 1; vector<vector<int>> bucket; for(int i = 0; i < maxNunLen; ++i, mod *= 10, div *= 10) { bucket.resize(20); //更改桶的数量 for(int j = 0; j < nums.size(); ++j) { int index = (nums[j] % mod) / div + 10; //-10~9 映射到下标0~19 bucket[index].push_back(nums[j]); } int count = 0; for(auto vec : bucket) { for(int num : vec) { nums[count++] = num; } } bucket.clear(); } } void print(const vector<int>& nums) { for(int num : nums) { cout << num << ' '; } cout << endl; } void getTestDate(vector<int>& nums) { srand(time(nullptr)); for(int i = 0; i < 10; ++i) { nums.push_back(rand()%99); } } void getTestDate2(vector<int>& nums) { srand(time(nullptr)); for(int i = 0; i < 10; ++i) { nums.push_back(rand()%199 - 100); } } int main() { vector<int> nums1; getTestDate(nums1); print(nums1); radixSort(nums1); print(nums1); vector<int> nums2 = {-1234,7, -89, 256}; print(nums2); radixSort2(nums2); print(nums2); } \"]},\"192\":{\"c\":[\"数据结构与算法\"]},\"193\":{\"c\":[\"排序算法\"]},\"194\":{\"h\":\"🍖堆排序\",\"t\":[\"堆排序 = 建堆 +排序（交换）\",\"//heapSort.h #ifndef _HEAP_SORT_H_ #define _HEAP_SORT_H_ #include <vector> #include <iostream> using std::cout; using std::endl; using std::vector; using std::swap; void heapify(vector<int>&nums, size_t N, size_t parent); //大顶堆,下沉 void heapSort(vector<int>& nums); #endif //_HEAP_SORT_H_ \",\"//heapSort.cc #include \\\"heapSort.h\\\" void heapify(vector<int>&nums, size_t N, size_t parent) { //大顶堆,下沉 size_t son = 2 * parent + 1; //默认先选择左孩子 while(son < N) { if(son + 1 < N && nums[son + 1] > nums[son]) { //右孩子存在且比左孩子大 ++son; //son为右孩子 } if(nums[son] > nums[parent]) { swap(nums[son], nums[parent]); parent = son; son = 2 * parent + 1; } else { break; //如果父结点最大，终止循环 } } } void heapSort(vector<int>& nums) { //建堆 size_t len = nums.size(); for(int i = len / 2 - 1; i >= 0; --i) { //最后一个父结点的位置为N/2 - 1 heapify(nums, len, i); } swap(nums[0], nums[len - 1]); //排序 for(int l = len - 1; l > 0; --l) { heapify(nums, l, 0); swap(nums[0], nums[l - 1]); } } \"]},\"195\":{\"h\":\"性能\",\"t\":[\"建堆的时间复杂度为O(N)\",\"heapify复杂度O(logN)\",\"堆排序对N个数进行heapify\",\"堆排序的时间复杂度：O(NlogN)\"]},\"196\":{\"h\":\"为何堆排序是不稳定排序?\",\"t\":[\"当数组中有相等元素时，堆排序算法对这些元素的处理方法不止一种，故是不稳定的\"]},\"197\":{\"c\":[\"数据结构与算法\"]},\"198\":{\"c\":[\"排序算法\"]},\"199\":{\"h\":\"希尔排序\",\"t\":[\"希尔排序是插入排序(gap = 1)的升级版，插入排序的gap = n/2，n/4，……\",\"#ifndef _SHELL_SORT_H_ #define _SHELL_SORT_H_ #include <vector> using std::vector; using std::swap; void shellSortCore(vector<int> &nums, int gap, int pos); void shellSort(vector<int>& nums); #endif //_SHELLSORT_H_ \",\"#include \\\"shellSort.h\\\" void shellSortCore(vector<int>& nums, int gap, int i) { int j; int inserted = nums[i]; for(j = i - gap; j >= 0 && inserted < nums[j]; j -= gap) { nums[j + gap] = nums[j]; } nums[j + gap] = inserted; } void shellSort(vector<int>& nums) { int n = nums.size(); for(int gap = n/2; gap > 0; gap /= 2) { for(int i = gap; i < n; ++i) { shellSortCore(nums,gap,i); } } } \"]},\"200\":{\"c\":[\"数据结构与算法\"]},\"201\":{\"c\":[\"排序算法\"]},\"202\":{\"h\":\"归并排序\",\"t\":[\"将⼀个⼤的⽆序数组有序，我们可以把⼤的数组分成两个，然后对这两个数组分别进⾏排序，之后在把这两个数组合并成⼀个有序的数组。由于两个⼩的数组都是有序的，所以在合并的时候是很快的。 通过递归的⽅式将⼤的数组⼀直分割，直到数组的⼤⼩为 1，此时只有⼀个元素，那么该数组就是有序的了，之后 再把两个数组⼤⼩为1的合并成⼀个⼤⼩为2的，再把两个⼤⼩为2的合并成4的 … 直到全部⼩的数组合并起来。\",\"该算法是采⽤分治法（Divide and Conquer）的⼀个⾮常典型的应⽤。将已有序的⼦序列合并，得到完全有序的序列；即先使每个⼦序列有序，再使⼦序列段间有序。若将两个有序表合并成⼀个有序表，称为2-路归并。\",\"算法思想 1、把⻓度为n的输⼊序列分成两个⻓度为n/2的⼦序列； 2、对这两个⼦序列分别采⽤归并排序； 3、 将两个排序好的⼦序列合并成⼀个最终的排序序列。[leetcode 21. 合并两个有序链表](# leetcode 21. 合并两个有序链表)\",\"性能分析\",\"分组的深度为O(logN) 合并的复杂度为O(N) 时间复杂度O(NlogN) 优点:时间复杂度低\",\"//mergeSort.h #include <vector> #include <cstring> using std::vector; void my_merge(vector<int>& nums, int left, int mid, int right); void merge_sort(vector<int>& nums, int left, int right); \",\"//mergeSort.cc #include \\\"mergeSort.h\\\" void my_merge(vector<int>& nums, int left, int mid, int right) {//类比合并2个链表 vector<int> buffer(nums); int i = left; //i表示左半边的下标，j表示右半边的下标，k表示结果的下标 int j = mid + 1; int k = left; while(i <= mid && j <= nums.size()) { if(buffer[i] < buffer[j]) { nums[k] = buffer[i]; ++i; } else { nums[k] = buffer[j]; ++j; } ++K; } //剩余的数据 while(i <= mid){ //i的结束时是等于mid ，而不是nums.size() nums[k] = buffer[i]; ++k; ++i; } while(j <= nums.size()) { nums[k] = buffer[j]; ++k; ++j; } } void merge_sort(vector<int>& nums, int left, int right) { if(left < right) { int mid = left + (right - left) / 2; merge_sort(nums, left, mid); merge_sort(nums, mid + 1, right); my_merge(nums, left, mid, right); } } \"]},\"203\":{\"c\":[\"数据结构与算法\"]},\"204\":{\"c\":[\"排序算法\"]},\"205\":{\"h\":\"插入排序\",\"t\":[\"//insertSort.h #ifndef _INSERT_SORT_H_ #define _INSERT_SORT_H_ #include <vector> using std::vector; using std::swap; void insertSort(vector<int> &nums); #endif //_INSERT_SORT_H_ \",\"#include \\\"insertSort.h\\\" void insertSort(vector<int>& nums) { if(nums.size() < 2) { return; } for(int i = 1; i < nums.size(); ++i) { if(nums[i] < nums[i - 1]) { int j = i - 1; int data = nums[i]; while(j >= 0 && nums[j] > data) { nums[j + 1] = nums[j]; --j; } nums[j + 1] = data; } } } \"]},\"206\":{\"c\":[\"数据结构与算法\"]},\"207\":{\"c\":[\"排序算法\"]},\"208\":{\"h\":\"页面配置\"},\"209\":{\"c\":[\"使用指南\"]},\"210\":{\"c\":[\"页面配置\",\"使用指南\"]},\"211\":{\"h\":\"计数排序\"},\"212\":{\"h\":\"计数排序应用场景\",\"t\":[\"计数排序只适用于**的序列的排序**，若待排序列的数据较分散，则会造成空间浪费，并且计数排序只适用于整型排序，不适用与浮点型排序。\"]},\"213\":{\"h\":\"步骤\",\"t\":[\"先找出序列中最大值和最小值，计算出计数数组的范围\",\"遍历序列，统计出现的次数\",\"为了使排序具有稳定性（保证相同值的前后顺序），计数数组累计求和，累计和就是该元素要存放的位置\",\"倒叙遍历序列，查找该元素存放的位置（）\"]},\"214\":{\"h\":\"代码实现\",\"t\":[\"#include <iostream> #include <vector> #include <climits> #include <algorithm> //min_element(),max_element()返回下标 using std::cout; using std::endl; using std::vector; void countSort(const vector<int>& nums, vector<int>& result) { if (nums.empty()) { return; // 如果输入为空，则直接返回，避免不必要的操作 } //int maxNum = *max_element(nums.begin(), nums.end()); //int minNum = *min_element(nums.begin(), nums.end()); int maxNum = nums[0]; int minNum = nums[0]; for (int num : nums) { if (num > maxNum) { maxNum = num; } if (num < minNum) { // 不需要else if，因为可能同时遇到更大和更小的数 minNum = num; } } int range = maxNum - minNum + 1; vector<int> countVec(range, 0); //此时记录的是出现的次数 for (int num : nums) { ++countVec[num - minNum]; } // 累积计数，注意从第二个元素开始（index为1） for (size_t i = 1; i < countVec.size(); ++i) { countVec[i] += countVec[i - 1]; //此时元素下标代表元素，而元素值代表应该放置的位置 } // 反向遍历输入数组，以便稳定排序 result.resize(nums.size()); for (int i = nums.size() - 1; i >= 0; --i) { result[countVec[nums[i] - minNum] - 1] = nums[i]; // 特别注意索引调整 --countVec[nums[i] - minNum]; // 递减计数 } } void printVec(const vector<int>& nums) { for (int num : nums) { cout << num << ' '; } cout << endl; } int main() { vector<int> nums = {22, 22, 21, 16, 29}; printVec(nums); vector<int> result; countSort(nums, result); printVec(result); return 0; } \",\"时间复杂度：O ( N + r a n g e ) 空间复杂度：O ( r a n g e ) 。\"]},\"215\":{\"c\":[\"数据结构与算法\"]},\"216\":{\"c\":[\"排序算法\"]},\"217\":{\"h\":\"选择排序\",\"t\":[\"外循环，依次选择前N-1个位置，存放最小的数据\",\"内循环，需要指定待比较数据的位置\",\"//selectSort.h #ifndef _SELECT_SORT_H_ #define _SELECT_SORT_H_ #include <vector> using std::vector; using std::swap; void selectSort(vector<int> &nums); #endif //_SELECT_SOTR_H_ \",\"//selectSort.cc #include \\\"selectSort.h\\\" void selectSort(vector<int>& nums) { size_t len = nums.size(); for(int i = 0; i < len - 1; ++i) { size_t minPos = i; for(int j = i + 1; j < len; ++j) { //if(nums[j] < nums[j-1]) { //error if(nums[j] < nums[minPos]) { minPos = j; } } if(i != minPos) { swap(nums[i], nums[minPos]); } } } \"]},\"218\":{\"c\":[\"数据结构与算法\"]},\"219\":{\"c\":[\"排序算法\"]},\"220\":{\"h\":\"（简单）快速排序\",\"t\":[\"关键在于找一个基准（一般选第一个元素）\",\"小于基准的放左边，大于的放右边\",\"递归\",\"//quickSort.h #ifndef _QUICK_SORT_H_ #define _QUICK_SORT_H_ #include <vector> using std::vector; using std::swap; void quickSort(vector<int> &nums, int begin, int end); #endif //_QUICK_SORT_H_ \",\"//quickSort.cc #include \\\"quickSort.h\\\" void quickSort(vector<int> &nums, int begin, int end) { if(begin >= end) { //递归结束的条件 return; } int left = begin; int right = end; int key = nums[left]; while(left < right) { while(left < right && nums[right] >= key) { --right; } if( left < right) { nums[left] = nums[right]; ++left; } while(left < right && nums[left] <= key) { ++left; } if(left < right) { nums[right--] = nums[left]; } } nums[left] = key; quickSortCore(nums, begin,left - 1); quickSortCore(nums,left + 1, end); } \"]},\"221\":{\"c\":[\"数据结构与算法\"]},\"222\":{\"c\":[\"排序算法\"]},\"223\":{\"h\":\"页面配置\"},\"224\":{\"h\":\"顺序栈的实现\",\"t\":[\"#include <iostream> #include <stdexcept> #include <cstring> using std::cout; using std::endl; class SeqStack { public: SeqStack(int cap = 3) :_top(0) ,_cap(cap) { _pstack = new int[_cap](); } ~SeqStack() { delete[] _pstack;//不要用delete _pstack = nullptr; } void push(int val) { if(_top == _cap) { //栈满了 expand(2*_cap); } _pstack[_top] = val; ++_top; } void pop() { if(_top == 0){ throw \\\"Stack is empty!!!\\\"; } --_top; } int top() { if(_top == 0) { throw \\\"Stack is empty!!!\\\"; } return _pstack[_top-1]; } bool empty() { return _top == 0; } private: void expand(int size) { int* newStack = new int[size]; memcpy(newStack, _pstack, _top*sizeof(int)); delete[] _pstack; //这里也是delete[] _pstack = newStack; _cap = size; } public: int* _pstack; //指向数据域 int _top; //指向栈顶,也是栈的大小 int _cap; //栈的容量 }; int main() { SeqStack s; s.push(12); s.push(17); s.push(100); s.push(78); //cout << s.top() << endl; //s.pop(); //cout << s.top() << endl; //s.pop(); //cout << s.top() << endl; //s.pop(); //cout << s.top() << endl; //s.pop(); while(!s.empty()) { cout << s.top() << endl; s.pop(); } return 0; } \",\"$./a.out 78 100 17 12 \"]},\"225\":{\"c\":[\"使用指南\"]},\"226\":{\"c\":[\"页面配置\",\"使用指南\"]},\"227\":{\"h\":\"反汇编小结\",\"t\":[\"记录一下常用的反汇编指令方便查看\",\"objdump -M intel -d -C binary_file \",\"-M intel：指定输出为 Intel 语法。\",\"-d：反汇编二进制文件中的机器指令。\",\"-C：显示低级的反汇编，并尝试将代码中的地址转换为符号名（即函数名）。\"]},\"228\":{\"h\":\"-d 和 -S的区别\",\"t\":[\"-d或--disassemble： \",\"这个选项用于反汇编目标 ELF 文件中包含可执行指令的节区（section）中的内容。换句话说，它会将机器代码转化为汇编代码\",\"-S或--source： \",\"这个选项用于混合显示源代码和反汇编代码。，objdump -S 的效果可能与 objdump -d 类似，因为缺少源代码信息。\"]},\"229\":{\"c\":[\"c/c++\"]},\"230\":{\"c\":[\"反汇编\"]},\"231\":{\"h\":\"指令角度理解堆栈调用过程\"},\"232\":{\"h\":\"栈空间\",\"t\":[\"image-20240130155633380\",\"栈空间是从高地址向低地址扩充，堆地址是从低地址向高地址扩充。\",\"堆栈是一种具有一定规则的，我们可以按照一定的规则进行添加和删除数据。它使用的是先进后出的原则。在x86等汇编集合中堆栈与弹栈的操作指令分别为：\",\"PUSH：将目标内存推入栈顶。\",\"POP：从栈顶中移除目标。\"]},\"233\":{\"h\":\"ESP和EBP\",\"t\":[\"image-20240130155845449\",\"esp：当前函数栈顶指针；来标记栈的底部，他随着栈的变化而变化\",\"ebp：当前函数栈底指针（虚拟内存空间中）；通过固定的地址与偏移量来寻找在栈参数与变量\",\"ESP是可变的,随着栈的生产而逐渐变小（因为栈向低地址扩充，栈顶寄存器数值不断变小）,而EBP寄存器是固定的,。\",\"pop ebp;出栈 栈扩大4byte 因为ebp为32位 push ebp;入栈，栈减少4byte add esp, 0Ch；表示栈减小12byte sub esp, 0Ch；表示栈扩大12byte \"]},\"234\":{\"h\":\"🍗🍗🍗示例\",\"t\":[\"#include <iostream> int sum(int a, int b) { int temp = 0; temp = a + b; return temp; } int main() { int a = 10;// mov dword ptr[ebp - 4], 0Ah int b = 20;// mov dword ptr[ebp - 8], 14h int ret = sum(a, b);//取a，b的值，放入寄存器，压入sum函数的栈（esp从main函数栈顶，上移两个int的位（分别放形参a，b）变成sum函数的栈顶） return 0; } \",\"打断点，调试，查看反汇编：\",\"g++ main.cc -m32 -g -o main.o #-m32指定编译为32位程序 gdb main.o (gdb) b main (gdb) start (gdb) set disassembly-flavor intel #在windows下使用习惯了intel汇编，在Linux下看的难受，在gdb下使用 (gdb) disassemble /mr #/m 显示相关联的源代码；/r 显示具体值 \",\"可能会报错如下\",\"$g++ -m32 -g -o main.o main.cc In file included from main.cc:6:0: /usr/include/c++/7/iostream:38:10: fatal error: bits/c++config.h: No such file or directory #include <bits/c++config.h> ^~~~~~~~~~~~~~~~~~ compilation terminated. \",\"只需要安装缺少的库即可\",\"sudo apt-get install g++-multilib \",\"(gdb) disassemble /m sum Dump of assembler code for function sum(int, int): 9 { 0x565555dd <+0>: push ebp 0x565555de <+1>: mov ebp,esp 0x565555e0 <+3>: sub esp,0x10 0x565555e3 <+6>: call 0x565556b7 <__x86.get_pc_thunk.ax> 0x565555e8 <+11>: add eax,0x19e8 10 int temp = 0; 0x565555ed <+16>: mov DWORD PTR [ebp-0x4],0x0 11 temp = a + b; 0x565555f4 <+23>: mov edx,DWORD PTR [ebp+0x8] 0x565555f7 <+26>: mov eax,DWORD PTR [ebp+0xc] 0x565555fa <+29>: add eax,edx 0x565555fc <+31>: mov DWORD PTR [ebp-0x4],eax 12 return temp; 0x565555ff <+34>: mov eax,DWORD PTR [ebp-0x4] 13 } 0x56555602 <+37>: leave 0x56555603 <+38>: ret End of assembler dump. (gdb) disassemble /m main Dump of assembler code for function main(): 16 { 0x56555604 <+0>: push ebp 0x56555605 <+1>: mov ebp,esp 0x56555607 <+3>: sub esp,0x10 0x5655560a <+6>: call 0x565556b7 <__x86.get_pc_thunk.ax> 0x5655560f <+11>: add eax,0x19c1 17 int a = 10; => 0x56555614 <+16>: mov DWORD PTR [ebp-0xc],0xa 18 int b = 20; 0x5655561b <+23>: mov DWORD PTR [ebp-0x8],0x14 19 int ret = sum(a, b); 0x56555622 <+30>: push DWORD PTR [ebp-0x8] 0x56555625 <+33>: push DWORD PTR [ebp-0xc] 0x56555628 <+36>: call 0x565555dd <sum(int, int)> 0x5655562d <+41>: add esp,0x8 0x56555630 <+44>: mov DWORD PTR [ebp-0x4],eax 20 21 return 0; 0x56555633 <+47>: mov eax,0x0 22 } 0x56555638 <+52>: leave 0x56555639 <+53>: ret End of assembler dump. \",\"g++ -g -c main main.cc #前提编译时 加-g\",\"objdump -d main.o #反汇编\",\"objdump -M intel -S main.o #反汇编、与相关联的源代码交替并且以英特尔的框架显示🍗🍗🍗\",\"image-20240130173737985\",\"问题1.sum函数调用完，如何知道回到main函数 ?\",\"问题2.回到main函数，如何知道从哪一行开始?\",\"call：函数调用指令\",\"把下一行指令的地址（位于.text段）压栈（问题2）\",\"进入调用函数（sum)\",\"进入sum函数之后，把esp的位置压栈（问题1），然后esp从main函数，上移到ebp位置（esp=ebp），并为sum函数开辟栈帧，有的编译器(windows)会为开辟的栈帧中初始化为0xCCCCCCCC（如果此类编译器如果允许访问未初始化的值，那么打印出来可能就是此值）\",\"sum函数后ebp回到esp位置（mov ebp esp），开辟的栈空间返回给系统；把栈的值出栈，给esp（，即回到main函数栈底）再出栈（将出栈内容，call的1所存入的值，放入CPU的PC寄存器），形参的地址归还给系统\"]},\"235\":{\"h\":\"在main函数的入口和退出：{ 会进行入栈操作，}进行出栈操作\",\"t\":[\"img\",\"9 { 0x565555dd <+0>: push ebp 0x565555de <+1>: mov ebp,esp 0x565555e0 <+3>: sub esp,0x10 \",\"上面两句话的意思是将ebp推入栈中，之后让esp等于ebp\",\"为什么这么做呢？因为ebp作为一个用于寻址的固定值是有时间周期的。只有在某个函数执行过程中才是固定的，在函数调用与函数执行完毕后会发生改变。\",\"在函数调用之前，将调用者的函数（caller）的ebp存入栈，以便于在执行完毕后恢复现场是还原ebp的值。下一步，必须为它的局部变量分配空间，同时，也必须为它可能用到的一些临时变量分配空间。\",\"​ sub esp, 0E4h；\",\"之后会根据情况看是否保存某些特定的寄存器（EBX，ESI和EDI）\",\"之后ebp的值会保持固定。此后局部变量和临时存储都可以通过基准指针EBP加偏移量找到了\",\"在函数执行完毕，控制流返回到调用者的函数（caller）之前会进行下述操作\",\"img\",\"所谓有始有终，这是会还原上面保存的寄存器值（edi esi ebx），之后还原esp的值（上一个函数调用之前的esp被保存在固定的ebp中）与ebp值。这一过程被称为还原现场之后通过ret返回上一个函数\"]},\"236\":{\"h\":\"main函数内\",\"t\":[\"image-20240130182232318\",\"接下来是int ret = sum(a,b):\",\"17 int a = 10; => 0x56555614 <+16>: mov DWORD PTR [ebp-0xc],0xa 18 int b = 20; 0x5655561b <+23>: mov DWORD PTR [ebp-0x8],0x14 19 int ret = sum(a, b); 0x56555622 <+30>: push DWORD PTR [ebp-0x8] #b 0x56555625 <+33>: push DWORD PTR [ebp-0xc] #a 0x56555628 <+36>: call 0x565555dd <sum(int, int)> 0x5655562d <+41>: add esp,0x8 0x56555630 <+44>: mov DWORD PTR [ebp-0x4],eax \"]},\"237\":{\"h\":\"函数调用参数的压栈顺序:参数由右向左压入堆栈。\",\"t\":[\"先将b的值压入堆栈，再将a的值压入堆栈\",\"image-20240130182849062\"]},\"238\":{\"h\":\"执行 call sum (0F8108Ch) #执行call ：\",\"t\":[\"call函数首先会将下一行执行的地址入栈：假设下一行指令的地址位0x08124458\",\"image-20240130183016130\",\"第二步进入函数调用：sum\",\"img\",\"函数调用第一步： 将调用函数（main）函数的栈底指针ebp压栈\",\"第二步：将新的栈底ebp指向原来的栈顶esp\",\"第三步：将esp指向新的栈顶（开辟了函数的栈帧）：大小：0cch\",\"img\",\" temp = a + b;由于a,b的值之前入栈，可以通过ebp+12字节找到b的值，ebp+8字节找到a的值，最后将运算结果赋值给temp\",\"img\",\"接着运行return temp;: mov eax,dword ptr [temp]\",\"img\",\"接着是函数的右括号“}”\",\"img\",\"mov esp,ebp 回退栈帧 将栈顶指针指向栈底\",\"pop ebp 栈顶出栈,并将出栈内容赋值给ebp，也是将main的栈底重新赋值给ebp\",\"ret\",\"接着调用函数完毕，回到主函数： 利用了PC寄存器，使得程序知道退出sum后运行哪一条指令：\",\"image-20240130203609288\",\"img\",\"最后return 0，程序结束\"]},\"239\":{\"h\":\"栈空间大小\",\"t\":[\"linuxulimit -s 16384将把默认栈大小设置为16384 KB（或16MB）（以 kbytes 为单位）。 \",\"这个设置仅对，当你重新启动终端时，它会恢复为系统默认值。\",\"如果你希望更改，你可能需要编辑 /etc/security/limits.conf 文件，并添加相应的条目。\",\"zw 20:41:13 ~ $ulimit -s 8192 zw 20:41:19 ~ $ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited scheduling priority (-e) 0 file size (blocks, -f) unlimited pending signals (-i) 7558 max locked memory (kbytes, -l) 65536 max memory size (kbytes, -m) unlimited open files (-n) 1024 pipe size (512 bytes, -p) 8 POSIX message queues (bytes, -q) 819200 real-time priority (-r) 0 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 7558 virtual memory (kbytes, -v) unlimited file locks (-x) unlimited \",\"image-20240130204306887\"]},\"240\":{\"h\":\"栈溢出\",\"t\":[\"出现栈内存溢出的常见原因有2个：\",\"函数调用层次过深,每调用一次,函数的参数、局部变量等信息就压一次栈。\",\"局部静态变量体积太大\",\"第一种情况不太常见,因为,所以只要不出现无限制的调用都应该是没有问题的,起码深度几十层我想是没问题的。检查是否是此原因的方法为，在引起溢出的那个函数处设一个断点,然后执行程序使其停在断点处, 然后按下快捷键Alt+7调出call stack窗口,在窗口中可以看到函数调用的层次关系。\",\"第二种情况比较常见 在函数里定义了一个局部变量,是一个类对象,该类中有一个大数组\",\"即如果函数这样写： void test_stack_overflow() { char* chdata = new[2*1024*1024]; delete []chdata; } 是不会出现这个错误的，而这样写则不行： void test_stack_overflow() { char chdata[2*1024*1024]; } 大多数情况下都会出现内存溢出的错误, \",\"解决办法大致说来也有两种：\",\"🍗\"]},\"241\":{\"c\":[\"c/c++\"]},\"242\":{\"c\":[\"操作系统\",\"堆栈\"]},\"243\":{\"h\":\"编译器角度理解c++代码的编译和链接\",\"t\":[\"c/c++这种本地编译型语言的编译过程\",\"image-20231230103243664\"]},\"244\":{\"h\":\"重点 ：\",\"t\":[\"*.o文件的组成格式是什么样的？\",\"可执行文件的组成格式是什么样的？\",\"链接的两个步骤做的是什么事情？\",\"符号表中的符号怎么理解？\",\"符号何时分配虚拟地址？\",\"#pragma lib表示程序执行时需要连接的库，所以必须在链接阶段生效\",\"假如有个函数start，想让程序执行的时候从start开始执行而不是main，需要#pragma link修改程序的入口地址，所以也必须持续到链接阶段。\",\"(#include、#define、#ifdef、#ifndef、#endif 等)\",\"编译阶段可以gcc，也可以g++, g++ -O 0 1 2 3 ...表示优化级别\",\"编译完成后会生成相应平台的汇编代码，汇编阶段有两种架构的汇编代码x86和AT&T\",\"在gdb下使用set disassembly-flavor intel 转换为intel格式的汇编\",\"set disassembly-flavor att 转换为att格式的汇编\",\"汇编就是把汇编代码转成特定平台的二进制码\"]},\"245\":{\"h\":\"链接主要工作🍔\",\"t\":[\"⭐在编译过程中，源文件经过预编译、编译和汇编的过程，生成了二进制的可重定位的目标文件；\",\"⭐此后，在链接过程，所有.o文件对应的段进行合并，其中，符号表进行合并后，需要对符号进行解析\",\"⭐对符号进行解析：所有对符号的引用，都要找到其定义的地方\",\"⭐对符号进行解析完成后，就会给所有的符号分配虚拟地址；\",\"⭐符号重定位：就是将给符号分配后的地址写回代码段；\"]},\"246\":{\"h\":\"示例\",\"t\":[\"根据如下两段代码分析\",\"其中注释表示符号和存放在进程虚拟地址空间的位置\",\"//main.cpp // 引用sum.cpp里定义得全局变量及函数 extern int gdata; // gdata *UND* int sum(int, int); // _Z3sumii *UND* int data = 20; // data .data int main() // main .text { int a = gdata; int b = data; int ret = sum(a, b); return 0; } // sum.cpp int gdata = 20; // gdata .data int sum(int a, int b) // _Z3sumii .text { return a + b; } \"]},\"247\":{\"h\":\"编译阶段：\",\"t\":[\"g++ -c main.cpp #编译成main.o g++ -c sum.cpp #编译成sum.o \"]},\"248\":{\"h\":\"查看符号表：\",\"t\":[\"objdump -t main.o #不仅显示符号表，还显示了段的信息 nm main.o #简洁，符号表（符号名称、类型和地址等基本信息） readelf -s main.o #也可以查看符号表信息 \"]},\"249\":{\"h\":\"查看main.o符号表\",\"t\":[\"image-20240130222426316\",\"l = local\",\"g = global\",\"符号表都为0，\",\"因为引用的符号都不知道在哪里定义的，肯定无法分配虚拟地址\",\"符号的虚拟地址是在链接时分配的\"]},\"250\":{\"h\":\"查看sum.o符号表\",\"t\":[\"在这里插入图片描述\"]},\"251\":{\"h\":\"分析main.o文件头\",\"t\":[\"汇编器把汇编代码转成可重定向的文件时不仅生成了符号表，还生成了各种各样的段\",\"image-20240131004256680\",\"*.o文件的组成，需要关注的：\",\"ELF文件头\",\".text\",\".data\",\".bss\",\".symbal （符号段）\",\".section table(段表/节头部表)\",\"readelf -h main.o #查看文件头 （elf头） \",\"在这里插入图片描述\",\"这是 可重定义的文件 不是 可执行文件，所以入口地址 Enter point address = 0x0, 0x0不可以访问\"]},\"252\":{\"h\":\"打印目标文件各个段：\",\"t\":[\"readelf -S main.o #查看有哪些段以及各个段的信息 readelf -s main.o #查看符号表信息 \",\"image-20240131011722928\",\"flag标志 \",\"A 分配空间的\",\"W 可写的\",\"X 可执行的\"]},\"253\":{\"h\":\"分析main.o的.text段\",\"t\":[\"$ g++ -c main.cpp -g $ objdump -S main.o \",\"在这里插入图片描述\",\"由上图可知编译过程中，\"]},\"254\":{\"h\":\"链接阶段\"},\"255\":{\"h\":\"链接的过程🍔🍔🍔\",\"t\":[\"所有.o文件段的合并，符号表合并后，进行符号解析\",\"main.o和sum.o中各个段进行合并\",\".text <=>.text, .data<=>.data, .bss<=>.bss ...\",\"符号表属于文件段之一（.symbal）\",\"符号表合并后，进行符号解析\",\"符号解析：所有对符号的引用，都要找到该符号定义的地方\",\"在符号表中找对应的符号是否只出现于.text或.data段\",\"若一次都无，则符号未定义（报错）；\",\"若出现多次，符号重定义(报错)\",\"链接时就是在符号表中找对应的符号是否只出现于.text或.data段；若一次都无，则符号未定义（报错）；若出现多次，符号重定义(报错)\",\"(链接的核心),给所有符号分配虚拟地址，前面都是全0\",\"符号重定向：符号解析成功后，给所有的符号分配了虚拟地址，前面符号的指令值都是全0，所以需要把符号的具体地址写到符号的指令上\",\"符号什么时候分配虚拟地址：链接过程，第一步符号解析完成后\",\"手动链接：ld -e main *.o\",\"-e 参数用于指定链接后生成的可执行文件的入口点（entry point） \",\"ld -e main *.o 意味着将所有的 *.o 目标文件链接在一起，并指定 main 函数作为程序的入口点\"]},\"256\":{\"h\":\"可执行文件\"},\"257\":{\"h\":\"查看可执行文件 a.out 的符号表\",\"t\":[\"在这里插入图片描述\",\"可以看出每个符号都有其对应的虚拟地址以及所在的区域，运行时就可以将其加载到指定段中（如.data .text）\"]},\"258\":{\"h\":\"分析可执行文件的elf头\",\"t\":[\"在这里插入图片描述\"]},\"259\":{\"h\":\"再看一下 a.out 的汇编代码\"},\"260\":{\"h\":\"objdump -S查看汇编\",\"t\":[\"g++ -g -c main main.cc #前提编译时 加-g\",\"objdump -M intel -S main.o #反汇编、与相关联的源代码交替并且以英特尔的框架显示🍗🍗🍗\",\"在这里插入图片描述\",\"可以发现main函数内第一条指令地址就是前面的入口地址(entry)\"]},\"261\":{\"h\":\"gdb查看汇编\",\"t\":[\"使用 disassemble 命令，或者简写为 disas\",\"在 gdb 提示符下，设置断点或让程序运行到你想要查看汇编代码的位置\",\"break main b main \",\"在gdb下使用set disassembly-flavor intel 转换为intel格式的汇编\",\"使用 run 命令运行程序\",\"一旦程序停止在断点或你指定的位置，可以使用 disassemble 命令查看汇编代码。如果你没有指定任何参数，gdb 会显示当前函数的汇编代码\",\"image-20240310133845350\",\"如果你想要查看特定函数或地址的汇编代码，你可以将函数名或地址作为参数传递给 disassemble 命令。例如：\",\"disas main disas 0x00000000004008ee \",\"如果你想在每一步执行时都看到对应的汇编指令，你可以使用 layout asm 命令。这将打开一个新的窗口，显示当前执行点的汇编代码。然后，你可以使用 stepi 或 nexti 命令逐步执行汇编指令，并查看每步的汇编代码变化。\",\"退出q或quit\"]},\"262\":{\"h\":\"查看可执行程序的program headers段\",\"t\":[\"readelf -l a.out #从查看可执行程序的program headers \",\"a.out 比*.o多了program headers段，有两个load(加载段),告知系统，运行时把哪些内容加载到内存中（.text, .data）\",\"693e6eec33134fa488aff85e9a3c7500\"]},\"263\":{\"h\":\"物理内存和虚拟内存映射🍗🍗🍗\",\"t\":[\"运行程序时的工作大概如下图，数据加载到指定段，将进程的虚拟地址映射到物理地址空间：\",\"在这里插入图片描述\",\"a.out位于磁盘中，a.out包含很多段\",\"elf header , 告诉程序入口地址在哪里\",\"program headers, 告诉系统加载文件中.text .data段到内存中\",\"并没有直接加载到物理内存，而是做一个地址映射，把.text .data .bss映射到cpu虚拟地址（进程的虚拟地址空间）中\",\"如果发现访问的地址还没有做映射，则会产生页面异常\",\"页面异常=》执行地址映射页面异常处理程序，分配物理内存\"]},\"264\":{\"h\":\"进阶阅读\",\"t\":[\"《CSAPP》第七章\",\"《程序员的自我修养》第2、3、4、6章\"]},\"265\":{\"c\":[\"c/c++\"]},\"266\":{\"c\":[\"操作系统\",\"编译链接\"]},\"267\":{\"h\":\"进程虚拟地址空间\",\"t\":[\"任何的编程语言都会产生两种东西：指令和数据。c++代码编译链接之后产生一个可执行文件***.exe存储在磁盘上，运行时会把程序从磁盘加载到内存（虚拟）中，\",\"产生几个问题：\",\"运行时把可执行程序的哪些东西加载到内存中？\",\"加载到内存后是如何存放的？\",\"内存空间有没有区域划分？划分后是什么样的？？\",\"前提条件：\",\"虚拟如何理解？\",\"存在，能看见 是物理的\",\"存在， 看不见 是透明的\",\"不存在， 看得见 是虚拟的\",\"不存在， 看不见 被删除了\",\"linux系统会为当前进程分配一个2^32大小的空间\",\"image-20240130150034776\",\"0x00000000到0x08048000是系统预留的空间，不可访问，如访问空指针时程序会崩溃\",\".text段：代码段,存放指令\",\".rodata：只读数据段，常量就存放在此，例如const char *p = “hello”;//p在栈上，而“hello”在只读数据段上，因为这个是字符串常量\",\".data：数据段，存放已经初始化且初始化不为0的全局变量/静态变量\",\".bss：数据段，存放初始化为0和未初始化的全局变量/静态变量，内核会将此数据段都置0\",\".heap：堆区，当程序运行时，new或malloc后才会分配堆内存，由低地址向高地址增长，程序员自己管理内存\",\".dll，*so：加载共享库，也就是动态链接库，window下是.dll，linux下是so\",\".stack：函数运行或产生线程时，每一个函数或线程独有的栈空间，由高地址向低地址增长\",\"命令行参数，环境变量：命令行参数如main函数传参，环境变量如搜索头文件或库文件时默认的路径\",\"内核空间：\",\"ZONE_DMA：ZONE“区域的意思”，约16M\",\"ZONE_BORMAL：约800多M，存放进程控制块（PCB块，task_struct）、内核空间的线程、内核函数运行时所依赖的栈空间……\",\"ZONE_HIGHMEN：高地址物理内存，做内存映射用的\",\"#include<bits/stdc++.h> #include<iostream> using namespace std; int a=7; int b=0; int c; static int sa=8; static int sb=0; static int sc; int main(){ int d=10; //move dword ptr[d],0AH //move dword ptr[esp],0AH int e=0; int f; static int sd=10; static int se=0; static int sf; cout<<c<<\\\" \\\"<<sc<<\\\" \\\"<<f<<\\\" \\\"<<sf; } \",\"全局变量都是数据，放在数据段（a，sa在.data段 b，c，sb，sc在.bss段）\",\"🍊声名**，运行时会在栈上开辟空间存储变量值，**cout << f << c << endlf不为0、c为0\",\"，e在.data，f，g在.bss\",\"，匿名管道通信就是在内核空间划分一道地址空间进行通信\",\"image-20240130153420171\",\"为什么进程间通信比较困难，主要原因是用户空间是私有的，只要内核空间是共享的\"]},\"268\":{\"c\":[\"c/c++\"]},\"269\":{\"c\":[\"操作系统\",\"虚拟内存\"]},\"270\":{\"h\":\"do-while(0)\"},\"271\":{\"h\":\"为了代码 分块 ，比仅仅使用{}更直观些。例如在 cocos2d-x 代码中\",\"t\":[\"do { CCImage* pImage = new CCImage(); CC_BREAK_IF(NULL == pImage); bRet = pImage->initWithString(text, (int)dimensions.width, (int)dimensions.height, eAlign, fontName, (int)fontSize); CC_BREAK_IF(!bRet); bRet = initWithImage(pImage); CC_SAFE_RELEASE(pImage); } while (0); \"]},\"272\":{\"h\":\"宏 展开的时候不会出错\"},\"273\":{\"h\":\"不使用{}把action1()、action2()包起来\",\"t\":[\"假设你需要定义这样一个宏：\",\"#define DOSOMETHING() action1(); action2(); \",\"这个宏的本意是，当执行DOSOMETHING()时，action1(),action2()都会被调用。如果有判断，再执行这个宏的话，如下：\",\"if(NULL == pPointer) DOSOMETHING(); else ... \",\"这样宏在预处理的时候会直接被展开，放在花括号里，那么实际上写的代码如下：\",\"if(NULL == pPointer) action1(); action2(); else ... \",\"这展开存在两个问题：\",\"假设没有else分支，则DOSOMETHING中的第二个语句无论if测试是否通过，都会执行。\",\"因为if分支后面有两个语句，导致else分支没有对应的if，编译失败。\"]},\"274\":{\"h\":\"使用{}把action1()、action2()包起来\",\"t\":[\"？比如：\",\"#define DOSOMETHING() { action1(); action2(); } \",\"我们在写代码的时候都习惯在语句右面加上分号，如果在宏中使用{}，代码编译展开后宏就相当于这样写了：{...};，展开后如下：\",\"if(NULL == pPointer) { action1(); action2(); }; //大括号后多了一个分号 else ... \",\"这段代码中大括号后多了一个分号，如果有else，那么else又没有对应的if了,编译出错。\"]},\"275\":{\"h\":\"使用 do{...}while(0) 来定义宏\",\"t\":[\"#define DOSOMETHING() \\\\ do{ \\\\ action1();\\\\ action2();\\\\ }while(0)\\\\ \"]},\"276\":{\"h\":\"用到 空宏\",\"t\":[\"避免由宏引起的警告 内核中由于不同架构的限制，很多时候会用到空宏。在编译的时候，这些空宏会给出警告，为了避免这样的warning，我们可以使用do{...}while(0)来定义空宏：\",\"#define DOSOMETHING() do{}while(0) \"]},\"277\":{\"h\":\"我想跳到另外一段代码了， 剩下的不执行 了\",\"t\":[\"当你执行一段代码到一半，想跳过剩下的一半的时候，如果你正处于do{...}while(0)循环中，则能用break达到这个目的。\",\"do { 执行. 再执行… if (如果有什么条件满足) { 我想跳到另外一段代码了，剩下的不执行了，可是不建议用goto语句，怎么办呢？ break;/*搞定*/ } 我有可能被执行. }while(false) \",\"举个例子如下\",\"do { if(!a) break; //do something here if(!b) break; //do another thing here }while(0); \",\"变形的goto，有些公司不让用goto。在一些函数中，需要实现条件转移，或者构成循环，跳出循环体，使用goto总是一种简单的方法，例如：\",\"#include <stdio.h> #include <stdlib.h> int main() { char *str; /* 最初的内存分配 */ str = (char *) malloc(15); if(str != NULL) goto loop; printf(\\\"hello world\\\\n\\\"); loop: printf(\\\"malloc success\\\\n\\\"); return(0); } \",\"但由于goto不符合软件工程的结构化，而且有可能使得代码难懂，所以很多人都不倡导使用，这个时候我们可以使用do{...}while(0)来做同样的事情：\",\"#include <stdio.h> #include <stdlib.h> int main() { do{ char *str; /* 最初的内存分配 */ str = (char *) malloc(15); if(str != NULL) break; printf(\\\"hello world\\\\n\\\"); }while(0); printf(\\\"malloc success\\\\n\\\"); return(0); } \"]},\"278\":{\"c\":[\"c/c++\"]},\"279\":{\"c\":[\"do-while(0)\"]},\"280\":{\"h\":\"malloc、free的底层实现\"},\"281\":{\"h\":\"前言\",\"t\":[\"从操作系统角度来看，进程分配内存有2种方式，分别由2个系统调用完成：brk和mmap（不考虑共享内存）。\",\"brk是将数据段(.data)的最高地址指针_edata\",\"mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。\",\"这两种方式分配的都是虚拟内存，没有分配物理内存。在\"]},\"282\":{\"h\":\"malloc概述\",\"t\":[\"在C语言中只能通过malloc()和其派生的函数进行动态的申请内存，而实现的根本是通过系统调用实现的（在linux下是通过sbrk()系统调用实现）。\",\"malloc()到底从哪里得到了内存空间？答案是从堆里面获得空间。也就是说函数返回的指针是指向堆里面的一块内存。操作系统中有一个记录空闲内存地址的链表。当。\",\"malloc()在动态分配分配内存，free()释放由其分配的内存。malloc()在分配用户传入的大小的时候，还分配的一个相关的用于管理的额外内存，不过，用户是看不到的。所以，\",\"实际的大小 = 管理空间 + 用户空间 \"]},\"283\":{\"h\":\"小于128K的内存分配\",\"t\":[\"，如下图(32位系统)：\",\"进程启动的时候，其（虚拟）内存空间的初始布局如图1所示\",\"其中，mmap内存映射文件是在堆和栈的中间（例如libc-2.2.93.so，其它数据文件等），为了简单起见，省略了内存映射文件。\",\"_edata指针（glibc里面定义）指向数据段的最高地址。\",\"进程**调用A=malloc(30K)**以后，内存空间如图2\",\"malloc函数会，就完成虚拟内存分配。\",\"你可能会问：只要把_edata+30K就完成内存分配了？\",\"事实是这样的，_edata+30K只是完成虚拟地址的分配，，等到进程。也就是说，。\"]},\"284\":{\"h\":\"大于128K的内存分配\",\"t\":[\"malloc大于128k的内存，，如下图：\",\"进程**调用C=malloc(200K)**以后，内存空间如图4：\",\"默认情况下，malloc函数分配内存，如果请求内存大于128K（），那就不是去推_edata指针了，而是利用mmap系统调用，从堆和栈的中间分配一块虚拟内存。这样子做主要是因为：\"]},\"285\":{\"h\":\"分配虚拟内存的细节\",\"t\":[\"malloc()在运行期动态分配分配内存，free()释放由其分配的内存。malloc()在分配用户传入的大小的时候，还分配的一个相关的用于管理的额外内存，不过，用户是看不到的。所以\",\"实际的大小 = 管理空间 + 用户空间 \",\"在64位系统中，malloc(0)的有效内存大小为24，32位中为12，准确的说是至少是这么多，并且这些内存是可以用的\",\"此外，，并不是申请多少字节，就拿出多少个字节的内存来提供使用。（8Byte(for 32bit system)或16Byte(for 64bit system)。\",\"因此，。\",\"在linux系统下面一个程序的堆的管理是通过内存块进行管理的，也就是将堆分成了很多大小不一的内存块。这些块怎么管理呢，比如怎么查询块的大小，怎么查询块是否正在被程序使用，怎么知道这个块的地址。为了解决内存块的管理所以要设计一个管理内存块的，详细的数据结构如下：\",\"综合上面的知识，可以很容易想到malloc()实现的大体思路。。思路很简单，malloc()实现流程图如下所示：\",\"看完上面的思路，也会很容易的想到。这样下次调用malloc()函数的时候就可以将该内存块作为可分配块再次进行分配了。\",\"最后，贴上malloc()和free()实现的代码：\"]},\"286\":{\"h\":\"malloc()实现：\",\"t\":[\"/**内存控制块数据结构，用于管理所有的内存块 * is_available: 标志着该块是否可用。1表示可用，0表示不可用 * size: 该块的大小 **/ struct mem_control_block { int is_available; int size; }; /**在实现malloc时要用到linux下的全局变量 *managed_memory_start：该指针指向进程的堆底，也就是堆中的第一个内存块 *last_valid_address：该指针指向进程的堆顶，也就是堆中最后一个内存块的末地址 **/ void *managed_memory_start; void *last_valid_address; /**malloc()功能是动态的分配一块满足参数要求的内存块 *numbytes：该参数表明要申请多大的内存空间 *返回值：函数执行结束后将返回满足参数要求的内存块首地址，要是没有分配成功则返回NULL **/ void *malloc(size_t numbytes) { //游标，指向当前的内存块 void *current_location; //保存当前内存块的内存控制结构 struct mem_control_block *current_location_mcb; //保存满足条件的内存块的地址用于函数返回 void *memory_location; memory_location = NULL; //计算内存块的实际大小，也就是函数参数指定的大小+内存控制块的大小 numbytes = numbytes + sizeof(struct mem_control_block); //利用全局变量得到堆中的第一个内存块的地址 current_location = managed_memory_start; //对堆中的内存块进行遍历，找合适的内存块 while (current_location != last_valid_address) //检查是否遍历到堆顶了 { //取得当前内存块的内存控制结构 current_location_mcb = (struct mem_control_block*)current_location; //判断该块是否可用 if (current_location_mcb->is_available) //检查该块大小是否满足 if (current_location_mcb->size >= numbytes) { //满足的块将其标志为不可用 current_location_mcb->is_available = 0; //得到该块的地址，结束遍历 memory_location = current_location; break; } //取得下一个内存块 current_location = current_location + current_location_mcb->size; } //在堆中已有的内存块中没有找到满足条件的内存块时执行下面的函数 if (!memory_location) { //向操作系统申请新的内存块 if (sbrk(numbytes) == -1) return NULL;//申请失败，说明系统没有可用内存 memory_location = last_valid_address; last_valid_address = last_valid_address + numbytes; current_location_mcb = (struct mem_control_block)memory_location; current_location_mcb->is_available = 0; current_location_mcb->size = numbytes; } //到此已经得到所要的内存块，现在要做的是越过内存控制块返回内存块的首地址 memory_location = memory_location + sizeof(struct mem_control_block); return memory_location; } \"]},\"287\":{\"h\":\"free实现：\",\"t\":[\"/**free()功能是将参数指向的内存块进行释放 *firstbyte：要释放的内存块首地址 *返回值：空 **/ void free(void *firstbyte) { struct mem_control_block *mcb; //取得该块的内存控制块的首地址 mcb = firstbyte - sizeof(struct mem_control_block); //将该块标志设为可用 mcb->is_available = 1; return; } \"]},\"288\":{\"h\":\"缺页中断\"},\"289\":{\"h\":\"查看缺页中断的次数\",\"t\":[\"ps -o majflt,minflt -C program #查看缺页中断的次数 \",\"majflt代表majorfault，中文名叫大错误\",\"minflt代表minor fault，中文名叫小错误。\",\"这2个数值表示一个进程自启动以来所发生的缺页中断的次数。\"]},\"290\":{\"h\":\"发生缺页中断后，执行了哪些操作？\",\"t\":[\"当一个，执行以下操作：\",\"检查要访问的虚拟地址是否合法\",\"查找/分配一个物理页\",\"填充物理页内容（读取磁盘，或者直接置0，或者啥也不干）\",\"建立映射关系（虚拟地址到物理地址）\",\"重新执行发生缺页中断的那条指令\",\"如果第3步，需要读取磁盘，那么这次缺页中断就是majflt，否则就是minflt。\"]},\"291\":{\"c\":[\"c/c++\"]},\"292\":{\"c\":[\"c语言基础\"]},\"293\":{\"h\":\"scanf\",\"t\":[\"#define _CRT_SECURE_NO_WARNINGS //放在文件最上端；vs studio要写这个，linux不需要 #include <stdio.h> scanf(\\\"%d\\\", &i2); \",\"我们在编译老的用C语言的开源项目如lua源包的时候，可能因为一些老的.c文件使用了strcpy,scanf等不安全的函数，而报警告和错误，而导致无法编译通过。\",\"此时我们有两种解决方案：\",\"在指定的源文件的开头定义：#define _CRT_SECURE_NO_WARNINGS （只会在该文件里起作用）\",\"在项目属性里设置，这会在整个项目里生效，依次选择：属性->配置属性->C/C++ ->预处理器->预处理器定义->编辑最下面加上一行：_CRT_SECURE_NO_WARNINGS （注意不需要#define）\",\"image-20231230144015991\"]},\"294\":{\"c\":[\"c/c++\"]},\"295\":{\"c\":[\"c基础\"]},\"296\":{\"h\":\"关键字\",\"t\":[\"知道关键字有哪些，这里列出避免大家后面命名变量名时， 和我们关键字重名。\",\"auto\",\"double\",\"int\",\"struct\",\"else\",\"break\",\"long\",\"switch\",\"case\",\"enum\",\"register\",\"typedef\",\"char\",\"extern\",\"return\",\"union\",\"const\",\"float\",\"short\",\"unsigned\",\"continue\",\"for\",\"signed\",\"void\",\"default\",\"goto\",\"sizeof\",\"volatile\",\"do\",\"if\",\"while\",\"static\"]},\"297\":{\"c\":[\"c/c++\"]},\"298\":{\"c\":[\"c基础\"]},\"299\":{\"h\":\"前言\"},\"300\":{\"h\":\"为什么叫c语言\",\"t\":[\"详细请看wd_C语言\",\"其实是因为先有高级语言ALGOL 60，简称 A 语言，后来经过简化，变为 BCPL 语言，简称 B 语言，而 C 语言是在 B 语言的基础之上发展而来的，所以就称为 C 语言。所以世界上第一个 C 语言的编译器是用 B语言编写的。\"]},\"301\":{\"h\":\"UNIX和c语言的发展史\",\"t\":[\"1965年为了解决大型机连接终端数量不够用的问题(当时大型主机至多能提供 30 台终端（30 个键盘、显示器)，连接一台电脑)，贝尔实验室 加入了 麻省理工学院 以及 通用电气 合作的计划\",\"1969 年前后这个项目进度缓慢，资金短缺，贝尔实验室退出了研究\",\"1969 年从这个项目中退出的 Ken Thompson 当时在实验室无聊时，为了让一台空闲的电脑上能够运行 “星际旅行（Space Travel）” 游行，在 8 月份左右趁着其妻子探亲的时间，用了 1 个月的时间，使用汇编写出了 Unix 操作系统的原型\",\"1970 年，美国贝尔实验室的 Ken Thompson ，以 BCPL 语言为基础，设计出很简单且很接近硬件的 B 语言（取 BCPL 的首字母），并且他用 B 语言 写了第一个 UNIX 操作系统\",\"1971 年，同样酷爱 “星际旅行（Space Travel）” 的 Dennis M.Ritchie 为了能早点儿玩上游戏，加入了 Thompson 的开发项目，合作开发 UNIX，他的主要工作是改造 B语言，因为 B 语言 的跨平台性较差\",\"1972 年， Dennis M.Ritchie（丹尼斯·里奇） 在 B 语言 的基础上最终设计出了一种新的语言，他取了 CPL 的第二个字母作为这种语言的名字，这就是 C 语言\",\"1973 年初， C 语言的主体完成， Thompson 和 Ritchie 迫不及待地开始用它完全重写了现在大名鼎鼎的 Unix 操作系统\"]},\"302\":{\"h\":\"为什么说c语言移植性强\",\"t\":[\"机器语言和汇编语言都不具有移植性，为 x86 开发的程序，不可能在Alpha，SPARC 和 ARM 等机器上运行\",\"而 C 语言程序则可以使用在任意架构的处理器上，只要那种架构的处理器具有对应 的 C 语言编译器和库，然后将 C 源代码编译、链接成目标二进制文件之后即可运 行\"]},\"303\":{\"h\":\"为什么c语言不能叫跨平台\",\"t\":[\"Java编写的任何代码，无序修改即可在任何一个平台上运行，所以称之为跨平台语言\",\"我们所讲的 C 标准，当然可以通过不同的编译器编译后在任何一台平台上运行，但是 C 标准除了文件操作之外，是没有涉及到操作系统硬件资源的接口的，比如进程调度，网络通信等 ，这些接口均为每一个操作系统独有的，windows与 Linux 这些接口有差异，一旦你的 C 程序中使用了这些接口，代码放到另外一个平台就无法编译通过了\"]},\"304\":{\"h\":\"C语言的优势\",\"t\":[\"C 语言的**执行效率**一直是高级语言中的第一！另外 Java 及其他脚本语言中没有指针，无法访问物理地址，所以系统中的驱动都需要用 C或 C++进行编写。\"]},\"305\":{\"h\":\"学习c语言的目标\",\"t\":[\"理解运行的逻辑\",\"内存变化\",\"程序的调试能力\"]},\"306\":{\"h\":\"vs studio 调试方法\",\"t\":[\"打断点->F5·（启动程序）->打开监视、调用堆栈、输出、内存窗口\",\"在这里插入图片描述\",\"按钮 1 是单步执行按钮F10，点击该按钮一次，程序会向下执行一步；按钮 2 是继续执行按钮，点击后，程序会执行到最后，或者执行到下一个断点，按钮3 是停止执行按钮shift F5，点击后程序直接停止运行。（左键点击断点就可以取消断点）\",\"在断点调试状态下，我们点击菜单栏的调试，选择窗口，然后依次点击监视，调用堆栈，内存，三个调试窗口，调用堆栈，监视，内存窗口对于后面我们调试程序及理解程序执行原理都至关重要，这次调出以后，后面每次调试程序都会自动弹出\",\"程序调试方法：\",\"断点单步调试\",\"判断打印调试\",\"等等\"]},\"307\":{\"h\":\"内存地址及内存空间\",\"t\":[\"在这里插入图片描述\",\"i 的值是 0x00000001，为什么显示效果为 01 00 00 00 呢，这个是因为英特尔的 CPU 为小端存储，所以低位在前，高位在后\"]},\"308\":{\"h\":\"内存地址只是一个编号，代表一个内存空间（！容易产生误区）\",\"t\":[\"内存地址只是一个编号，代表一个内存空间，这个空间大小不会随编号的位数改变而改变（变成2个字节，4个字节），一个内存地址所代表的永远是1个字节。内存的每一个字节都有一个编号，16位操作系统、32位操作系统只是改变这个编号的长短，不会影响内存的最小单元大小，仅仅是个编号。唯一影响的是所能表示的个数（寻址能力）。\",\"image-20231230115745742\",\"所以这个16位的cpu，所有表示的地址个数是2^20 = 1048576个，一个地址所指大小1个字节 ，也就是1M；32位的cpu，所有表示的地址个数是2^32 = 4294967296个，一个地址所指大小1个字节 ，也就是4G；\",\"image-20231230120138838\"]},\"309\":{\"h\":\"显示代码行号\",\"t\":[\"工具 --> 选项 -->勾选行号\"]},\"310\":{\"h\":\"程序生成过程\",\"t\":[\"image-20231230103243664\",\"首先我们编写源代码f.c 经过编译后，我们会得到 f.obj 文件，f.obj 文件中均为0101 类型的机器码，也就是 cpu 能够识别的微指令（英特尔的机器指令）去运行，f.obj 文件并不能执行，因为我们调用的标准库函数的代码并不在 f.obj 文件中，例如上面 main.c 的printf 函数，printf 函数的代码并不在 main.obj 中，这时经过链接，就得到可执行文件 f.exe，了解这个编译过程，对于我们后面编写程序遇到编译错误后，分析编译错误，我们可以区分清楚是编译错误，还是链接错误。\"]},\"311\":{\"h\":\"预编译指令\",\"t\":[\"#include 头文件包含 #define 宏定义 \",\"右侧项目代码->属性->配置属性->c/c+±>预编译器->预处理到文件（是）\",\"image-20231230111457047\",\"预处理c和C++源文件并将预处理的输出写到文件，此选项取消编译，因此不会生成.obj文件\",\"image-20231230111622514\"]},\"312\":{\"h\":\"#include＜＞ 和 #include\\\"\\\" 的区别\",\"t\":[\"#include<>：编译器直接从系统类库目录里查找头文件\",\"比如在VS2013中，编译器会直接在<Visual studio 2013安装目录>\\\\VC\\\\include目录下查找到stdio.h这个文件，这就是编译器的类库目录；\",\"在Linux GCC编译环境下，一般为/user/include和/usr/local/include。\",\"例如，我们自定义一个头文件\\\"test.h\\\"，把它放在项目工程文件所在目录，然后用“#include <>”的形式加载头文件test.h，编译时会直接报错：No such file or directory.\",\"#include\\\"\\\"：默认从项目当前目录查找头文件，如果在项目当前目录下查找失败，再从项目配置的头文件引用目录查找头文件\",\"所谓项目配置的引用目录，就是我们在项目工程中设置的头文件引用目录，Windows VS编译环境如下图所示。在Linux GCC编译环境下，则一般通过在Makefile文件中使用参数指定引用目录。\",\"image-20231230104904001\",\"虽然#include\\\"\\\"的查找范围更广，但是这并不意味着，不论是系统头文件，还是自定义头文件，一律用#include\\\"\\\"包含。\"]},\"313\":{\"c\":[\"c/c++\"]},\"314\":{\"c\":[\"c基础\"]},\"315\":{\"h\":\"变量\",\"t\":[\"变量：有名字的内存空间\"]},\"316\":{\"h\":\"变量命名(标识符)的规定：\",\"t\":[\"由字母、 数字和下划线三种字符组成，\",\"第一个字符必须为字母或下划线\",\"不能与关键字重名\",\"注意：\",\"区分大小写，\",\" ，\",\"应注意做到“见名知意” ， 即选有含意的英文单词 （或其缩写） 作标识符。\"]},\"317\":{\"h\":\"数据类型\",\"t\":[\"内存大小\",\"解释方式\"]},\"318\":{\"c\":[\"c/c++\"]},\"319\":{\"c\":[\"c基础\"]},\"320\":{\"h\":\"字符\",\"t\":[\"字面值界定符'\",\"字符字面值的表示方法：\",\"image-20231230175915108\"]},\"321\":{\"c\":[\"c/c++\"]},\"322\":{\"c\":[\"c基础\"]},\"323\":{\"h\":\"常量\",\"t\":[\"基本数据类型有常量和变量， 首先我们先来看一下常量， 在程序运行过程中,其值不能被改变的量称为常量\",\"image-20231230130126412\",\"#include <stdio.h> //#define PI 3 #define PI 0x123 /* 1. 宏定义一般大写 2. 字面值常量 -->magic number 符号常量 */ int main() { //printf(\\\"PI = %d\\\\n\\\", 3); printf(\\\"PI = %d\\\\n\\\", PI); //3 = 4 //PI = 4 //常量不可改变值 return 0; } \",\"整型常量， 实型常量， 字符型常量在编译时直接编入代码段， 字符串常量是存在字符串常量区。\"]},\"324\":{\"c\":[\"c/c++\"]},\"325\":{\"c\":[\"c基础\"]},\"326\":{\"h\":\"数据类型\",\"t\":[\"image-20231230124538132\",\"数据类型作用：\",\"内存大小\",\"解释方式\"]},\"327\":{\"c\":[\"c/c++\"]},\"328\":{\"c\":[\"c基础\"]},\"329\":{\"h\":\"整型（integer）\",\"t\":[\"image-20231230140401166\"]},\"330\":{\"h\":\"有符号整型\",\"t\":[\"char < short < int < long < long long \",\"，大小1 byte\"]},\"331\":{\"h\":\"无符号整型\",\"t\":[\"image-20231230144838893\"]},\"332\":{\"h\":\"溢出\"},\"333\":{\"h\":\"有符号溢出： 机器数运算修改了符号位\",\"t\":[\"image-20231230144954359\"]},\"334\":{\"h\":\"无符号溢出： 机器数运算高位舍弃了\",\"t\":[\"image-20231230145335308\"]},\"335\":{\"c\":[\"c/c++\"]},\"336\":{\"c\":[\"c基础\"]},\"337\":{\"h\":\"浮点数\",\"t\":[\"使用浮点数直接使用 double 即可\"]},\"338\":{\"h\":\"浮点数字面值表示方法\",\"t\":[\"小数形式：0.123\",\"指数形式：3e-3（为3 * 10-3 ，即0.003）\",\"注意：\",\"#include <stdio.h> //#define PI 3.14 //#define PI 0.314E1 //#define PI 0.314e1 #define PI 31.4e-1 //#define PI 31.4E0.5 e后面只能写整数 int main() { printf(\\\"PI = %f\\\\n\\\",PI); } \"]},\"339\":{\"h\":\"浮点数的存储方式\",\"t\":[\"image-20231230164803584\",\"浮点型数据是按照指数形式存储的。 系统把一个浮点型数据分成小数部分和指数部分， 分别存放。指数部分采用规范化的指数形式， 指数也分正负 。\",\"float存储为例（4byte = 32bit）：\",\"1 位的符号位， 是 0 就代表正数， 1 就代表负数\",\"8位阶码，\",\"23位的小数部分， 是通过 2-1+2-2+2-3等去近似一个小数的\",\"double的阶码为11位\"]},\"340\":{\"h\":\"浮点数的精度丢失问题\",\"t\":[\"image-20231230175132311\",\"image-20231230174224741\",\"**加数 与 加数相差很大 **，会发生精度丢失\",\"image-20231230175233568\",\"我们赋给 a 的值为 1.23456789e10， 加20 后， 应该得到的值为 1.234567892e10， 但是却是 1.23456788e10， 变的更小了， 我们把这种现象称为精度丢失， 原因就是 float 能够表示的有效数字为 7 位， 最多只保证 1.234567e10 的正确性， 如果要达到正确， 我们需要把 a 和 b 均改为 double 类型。\",\"image-20231230175541124\"]},\"341\":{\"c\":[\"c/c++\"]},\"342\":{\"c\":[\"c基础\"]},\"343\":{\"h\":\"补码\"},\"344\":{\"h\":\"为什么需要补码\",\"t\":[\"计算机的 CPU 是无法做减法操作 的，只能做加法，其实 CPU 中有一个逻辑单元叫加法器，计算机所做的减法，乘法，除法，都是由科学家将其变化为加法。\"]},\"345\":{\"h\":\"补码的实现\",\"t\":[\"img\",\"在这里插入图片描述\",\"负数快速求机器数的方法\",\"-2 + 12 = 10\"]},\"346\":{\"h\":\"两个机器数比较大小\",\"t\":[\"image-20231230142228229\"]},\"347\":{\"c\":[\"c/c++\"]},\"348\":{\"c\":[\"c基础\"]},\"349\":{\"h\":\"8进制、10进制、16进制及进制转换\",\"t\":[\"八进制字面值 023 \",\"以0作为八进制数的前缀\",\"数码取值为0～7\",\"八进制数通常是无符号数。\",\"十进制字面值 456\",\"十六进制字面值 0x456\",\"image-20231230134403043\"]},\"350\":{\"c\":[\"c/c++\"]},\"351\":{\"c\":[\"c基础\"]},\"352\":{\"h\":\"STL向量容器vector简单实现\"},\"353\":{\"h\":\"什么是容器\",\"t\":[\"就是保存其他对象的对象。而且，这种“对象”还有处理“其他对象”的方法\",\"C++采用基于模版的方式处理容器，STL中的容器提供了多种数据结构。\",\"它可以像数组一样被操作，由于它的特性我们完全可以将vector 看作动态数组。\"]},\"354\":{\"h\":\"特点\",\"t\":[\"随机访问\",\"线性顺序结构。可以指定一块连续的空间，也可以不预先指定大小，空间可自动扩展，也可以像数组一样被操作，即支持[ ]操作符和vector.at()，因此可看做动态数组，通常体现在追加数据push_back()和删除末尾数据pop_back()。\",\"当分配空间不够时，vector会申请一块更大的内存块（以2的倍数增长），然后将原来的数据拷贝到新内存块中并将原内存块中的对象销毁，最后释放原来的内存空间。因此如果vector保存的数据量很大时会很消耗性能，因此在预先知道它大小时性能最优。\",\"节省空间。因为它是连续存储，在存储数据的区域是没有浪费的，但实际上大多数时候是存不满的，因此实际上未存储的区域是浪费的。\",\"在内部进行插入和删除的操作效率低。由于vector内部按顺序表结构设计，因此这样的操作基本上是**，它被设计成**。\"]},\"355\":{\"h\":\"简单版\",\"t\":[\"template <typename T> class vector//向量容器 { public: vector(int size = 10)//构造 { _first = new T[size]; _last = _first; _end = _first + size; } ~vector()//析构 { delete[]_first; _first = _last = _end = nullptr; } vector(const vector<T> &rhs)//拷贝构造 { int size = rhs._end - rhs._first;//空间大小 _first = new T[size]; int len = rhs._last - rhs._first;//有效元素 for (int i=0; i<len; ++i) { _first[i] = rhs._first[i]; } _last = _first + len; _end = _first + size; } vector<T>& operator=(const vector<T> &rhs)//赋值运算符重载 { if (this == &rhs) { return *this; } delete[]_first; int size = rhs._end - rhs._first; _first = new T[size]; int len = rhs._last - rhs._first; for (int i=0; i<len; i++) { _first[i] = rhs._fisrt[i]; } _last = _first + len; _end = _fitst = size; return *this; } void push_back(const T &val)//尾插 { if (full()) { expand(); } *_last++ = val; } void pop_back()//尾删 { if (empty()) return; --_last; } T back()const//返回容器末尾元素值 { return *(_last - 1); } bool full()const { return _last == _end; } bool empty()const { return _first == _last; } int size()const//返回容器中元素个数 { return _last - _first; } private: T *_first;//起始数组位置 T *_last;//指向最后一个有效元素后继位置 T *_end;//指向数组空间的后继位置 void expand()//扩容 { int size = _end - _first; T *ptmp = new T[2*size]; for (int i=0; i<size; ++i) { ptmp[i] = _first[i]; } delete[]_first; _first = ptmp; _last = _first + size; _end = _first + 2*size; } }; int main() { vector<int> vec; for (int i=0; i<20; ++i) { vec.push_back(rand() % 100); } while (!vec.empty()) { cout << vec.back() << \\\" \\\"; vec.pop_back(); } cout << endl; return 0; } \",\"这里只是简单实现以下vector容器，但是还少了空间配置器allocator。 库中定义的vector：\",\"template<class _Ty, class _Alloc = allocator<_Ty> > class vector : public _Vector_alloc<!is_empty<_Alloc>::value, _Vec_base_types<_Ty, _Alloc> > \"]},\"356\":{\"c\":[\"c/c++\"]},\"357\":{\"c\":[\"模板实践\",\"STL\"]},\"358\":{\"h\":\"函数模板与模板函数\"},\"359\":{\"h\":\"为什么要定义模板？\",\"t\":[\"简化程序，少写代码，维持结构的清晰，大大提高程序的效率。\",\"解决强类型语言的严格性和灵活性之间的冲突。\",\"带参数的宏定义(原样替换)\",\"函数重载(函数名字相同，参数不同)\",\"模板(将数据类型作为参数)\",\"强类型语言程序设计：C/C++/Java等，有严格的类型检查，如int a = 10，在编译时候明确变量的类型，如果有问题就可以在编译时发现错误，安全，但是不够灵活，。\",\"弱类型程序语言设计：js/python等，虽然也有类型，但是在使用的时候直接使用let/var number,不知道变量具体类型，由编译器解释变量类型，属于解释型语言。如果有错，到运行时才发现，虽然灵活，但是不安全。\"]},\"360\":{\"h\":\"模板的定义\",\"t\":[\"template <class T,...> 或者 template <typename T,...> \",\"注意：class与typename在此，完全一致。class出现的时间比较早，通用性更好一些，typename是后来才添加了，对于早期的编译器可能识别不了typename关键字。\"]},\"361\":{\"h\":\"模板的类型\",\"t\":[\"函数模板与类模板。通过参数实例化构造出具体的函数或者类，称为模板函数或者模板类。\"]},\"362\":{\"h\":\"函数模板\",\"t\":[\"template <模板参数列表> //模板参数列表，此处模板参数列表不能为空 返回类型 函数名（参数列表） { //函数体 } \",\"template <typename T>//模板参数列表 T add(T x, T y) { cout << \\\"T add(T, T)\\\" << endl; return x + y; } \",\"意义：一种特殊的函数可用，看起来和普通函数很相似，区别是类型可被参数化。\",\"语法规则：template 关键字用于，typename 关键字用于。 **模板实现原理： 。**但我们实际使用时并不用关注它\"]},\"363\":{\"h\":\"注意：\",\"t\":[\"只用写一套代码实现逻辑，，编译器会从原模版实例化出来。\",\"。\",\"一般来说，模板代码====。模板代码调用之前，一定要看到模板定义的地方，这样模板才能够正常实例化。\",\"分开可以编译，但是在的。\"]},\"364\":{\"h\":\"实例化：隐式实例化与显示实例化\",\"t\":[\"//函数的调用点 cout << \\\"add(ia, ib) = \\\" << add(ia, ib) << endl;//隐式实例化，没有明确说明类型，靠 编译器推导 cout << \\\"add(da, db) = \\\" << add<double>(da, db) << endl;//显示实例化，编译器无序 推导 \",\"image-20240411140728256\"]},\"365\":{\"h\":\"模板函数：用模板实现的函数\",\"t\":[\"template<typename T>//定义一个模板参数列表 class也可以替换typename bool compare(T a, T b)//compare 是一个函数模板 { cout << \\\"template compare\\\" << endl; return a > b; } int main() { //函数的调用点 compare<int>(10, 20); compare<double>(10.5, 20.5); return 0; } //实例化的函数模板，即模板函数 bool compare<int>(int a, int b) { return a > b; } bool compare<double>(double a, double b) { return a > b; } \"]},\"366\":{\"h\":\"函数模板、普通函数间的关系\",\"t\":[\"与是\",\"于函数模板执行\",\"与之间也是\",\"template<typename T>//定义一个模板参数列表 class也可以替换typename bool compare(T a, T b)//compare 是一个函数模板 { cout << \\\"template compare\\\" << endl; return a > b; } //针对compare函数模板,提供const char*类型的特例化版本 template<> bool compare<const char*>(const char *a, const char *b) { cout << \\\"compare<const char*>\\\" <<endl; return strcmp(a, b) > 0; } //普通函数(非模板函数) bool compare(const char *a, const char *b) { cout << \\\"normal compare\\\" <<endl; return strcmp(a,b) > 0; } \",\"优先调用普通函数，没有的话才去找函数模板，若有模板特例化，优先使用特例化\"]},\"367\":{\"h\":\"模板的特化：偏特化与全特化\",\"t\":[\"。针对某些类型，以来编译器自己针对这些类型的模板实例化已经不满足代码的逻辑要求了，我们就针对该该类型提供自己的特例化版本。不是编译器提供的，而是用户提供的。\",\"全特化：全部特化出来就是全特化\",\"偏特化：只特殊化几个参数或者一定的参数范围\"]},\"368\":{\"h\":\"全特化\",\"t\":[\"比较两个字符串的时候使用a>b，只是比较两个字符串地址谁大谁小，没有意义。我们应该比较为它们在ASCII表中的顺序大小。实际应该这样比较：\",\"template<typename T>//定义一个模板参数列表 class也可以替换typename bool compare(T a, T b)//compare 是一个函数模板 { cout << \\\"template compare\\\" << endl; return a > b; } //针对compare函数模板,提供const char*类型的特例化版本 template<> bool compare<const char*>(const char *a, const char *b) { cout << \\\"compare<const char*>\\\" <<endl; return strcmp(a, b) > 0; } int main() { //函数的调用点 compare<int>(10, 20); compare<double>(10.5, 20.5); compare(10, 20); compare<int>(30, 40.5); compare(\\\"aaa,=\\\", \\\"ccc\\\"); return 0; } \",\"template<>中为空，代表所有类型都在下面特殊化处理，其他类型依然是泛化版本。\",\"/* cout << \\\"add(ia, db) = \\\" << add(ia, db) << endl;//函数模板必须进行严格的 推导，如果没有普通函数形式，这就话就error */ \"]},\"369\":{\"h\":\"偏特化： 函数模板不能偏特化！！！！！！！！！！！！！\",\"t\":[\"image-20240411151958707\"]},\"370\":{\"h\":\"注意区分偏特化和重载\",\"t\":[\"template <typename T> void tfunc(T& a, double& b) \",\"这个叫做重载。 下面的才是偏特化\",\"template <typename T> void tfunc<T,double >(T& a, double& b) //error \"]},\"371\":{\"h\":\"函数模板的参数类型\",\"t\":[\"类型参数，class T 这种就是类型参数\",\"非类型参数,\",\"template <typename T = int, short kMin = 10> T multiply(T x, T y) { return x * y * kMin; } void test() { int ia = 3, ib = 4; double da = 3.3, db = 4.4; cout << \\\"multiply(ia, ib) = \\\" << multiply(ia, ib) << endl; cout << \\\"multiply(ia, ib) = \\\" << multiply<int, 4>(ia, ib) << endl; cout << \\\"multiply(ia, ib) = \\\" << multiply<double, 4>(da, db) << endl; } \",\"$./a.out multiply(ia, ib) = 120 multiply(ia, ib) = 48 multiply(ia, ib) = 58.08 \"]},\"372\":{\"h\":\"成员函数模板\",\"t\":[\"就是类的成员函数也可以设置为模板，可以写例子看看。\",\"class Point { public: //............. //成员函数模板,成员函数模板也是可以设置默认值 template <typename T = int> T func() { return (T)_dx; } private: double _dx; double _dy; }; void test() { Point pt(1.1, 2.2); cout << \\\"pt.func() = \\\" << pt.func<int>() << endl; cout << \\\"pt.func() = \\\" << pt.func<double>() << endl; cout << \\\"pt.func() = \\\" << pt.func() << endl; } \"]},\"373\":{\"c\":[\"c/c++\"]},\"374\":{\"c\":[\"模板\"]},\"375\":{\"h\":\"可变模板参数\",\"t\":[\"是新增的最强大的特性之一，它对参数进行了高度的泛化，它能表示**、**的参数。\"]},\"376\":{\"h\":\"模板参数包\",\"t\":[\"template<typename… Args> class tuple;//tuple是元组的意思，其模板参数就是模板参数包 \",\"Args标识符的左侧使用了省略号,在C++11中Args被称为“模板参数包”,表示可以接受任意多个参数作为模板参数,编译器将多个模板参数打包成“单个”的模板参数包.\"]},\"377\":{\"h\":\"函数参数包\",\"t\":[\"template<typename…T> void f(T… args);//args就是函数参数包 \",\"args 被称为函数参数包,表示函数可以接受多个任意类型的参数. 在C++11标准中，要求**必须唯一，且是函数的最后一个参数**; 则没有。 当使用参数包时，省略号位于参数名称的右侧，表示立即展开该参数，这个过程也被称为解包。\"]},\"378\":{\"h\":\"可变模板参数的优势\",\"t\":[\"参数个数，那么对于模板来说，在模板推导的时候，就已经知道参数的个数了，也就是说在编译的时候就确定了，这样编译器就存在可能去优化代码\",\"参数类型，推导的时候也已经确定了，模板函数就可以知道参数类型了。\",\"#include <iostream> #include <string> using std::string; using std::cout; using std::endl; template <typename... Args> void print(Args... args) { cout << \\\"sizeof...(Agrs) = \\\" << sizeof...(Args) << endl; cout << \\\"sizeof...(agrs) = \\\" << sizeof...(args) << endl; } void display() { cout << endl; } template <typename T, typename... Args> void display(T t, Args... args) { cout << t << \\\" \\\"; display(args...);//当... 位于args右边的时候叫做解包 } void test() { string s1 = \\\"hello\\\"; print(); print(1, 2.2); print('a', true, s1); print(1, 2.2, 'b', \\\"hello\\\"); } void test2() { string s1 = \\\"hello\\\"; display(); display(1, 2.2); display('a', true, s1); display(1, 2.2, 'b', \\\"hello\\\"); } template <class T> T sum(T t) { return t; } template <typename T, typename... Args> T sum(T t, Args... args) { return t + sum(args...); } void test3() { cout << \\\"sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) = \\\" << sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) << endl; } int main() { test(); test2(); test3(); return 0; } \",\"$./a.out sizeof...(Agrs) = 0 sizeof...(agrs) = 0 sizeof...(Agrs) = 2 sizeof...(agrs) = 2 sizeof...(Agrs) = 3 sizeof...(agrs) = 3 sizeof...(Agrs) = 4 sizeof...(agrs) = 4 1 2.2 a 1 hello 1 2.2 b hello sum(1, 2, 3, 4, 5, 6, 7, 8, 9, 10) = 55 \"]},\"379\":{\"c\":[\"c/c++\"]},\"380\":{\"c\":[\"模板\"]},\"381\":{\"h\":\"容器空间适配器allocator简单实现\"},\"382\":{\"h\":\"容器为什么需要空间配置器，不用空间配置器会怎么样？\",\"t\":[\"我们还是前面简单实现的vector容器，用Test来实例化：\",\"class Test { public: Test(){cout << \\\"Test()\\\" << endl;} ~Test(){cout << \\\"~Test\\\" << endl;} }; \",\"对其进行实例化：\",\"vector<Test> vec; \",\"此时什么都没有做，这是一个空容器，但是却**。**，因此构造了10个对象，使用十分不合理。\"]},\"383\":{\"h\":\"问题分析：\",\"t\":[\"①定义容器对象时，底层只是进行空间开辟，而不能去构造对象。但是如果使用new的话，它会同时完成这两件事。 ②析构时用了delete，将_first指针指向的数组每一个元素都当作有效的test对象析构了一遍。数组可能会很长，但是里面有效的元素可能只有几个，我们析构时只析构有效的元素，再将整个数组内存释放。\"]},\"384\":{\"h\":\"解决思路\",\"t\":[\"①需要我们把与分开处理了。②析构容器有有效的元素，然后释放_first指针指向的堆内存。③只需要析构对象，将对象的析构和内存分离开。 此时就需要我们的容器空间配置器了。\"]},\"385\":{\"h\":\"allocator实现\",\"t\":[\"容器的空间配置器allocator：容器底层内存开辟，内存释放，对象构造和析构，都通过allocator空间适配器来实现。\",\"//容器的空间配置器 template <typename T> struct Allocator { T* allocate(size_t size)//只负责内存开辟 { return (T*)malloc(sizeof(T) * size); } void deallocate(void *p)//只负责内存释放 { free(p); } void construct(T *p, const T &val)//已经开辟好的内存上，负责对象构造 { new (p) T(val);//定位new，指定内存上构造val，T(val)拷贝构造 } void destroy(T *p)//只负责对象析构 { p->~T();//~T()代表了T类型的析构函数 } }; template <typename T, typename Alloc = Allocator<T>> class vector//向量容器 { public: vector(int size = 10)//构造 { //_first = new T[size]; _first = _allocator.allocate(size); _last = _first; _end = _first + size; } ~vector()//析构 { //delete[]_first; for (T *p=_first; p!=_last; ++p) { _allocator.destroy(p);//把_first指针指向的数组的有效元素析构 } _allocator.deallocate(_first);//释放堆上的数组内存 _first = _last = _end = nullptr; } vector(const vector<T> &rhs)//拷贝构造 { int size = rhs._end - rhs._first;//空间大小 //_first = new T[size]; _first = _allocator.allocate(size); int len = rhs._last - rhs._first;//有效元素 for (int i=0; i<len; ++i) { //_first[i] = rhs._first[i]; _allocator.construct(_first+i, rhs._first[i]); } _last = _first + len; _end = _first + size; } vector<T>& operator=(const vector<T> &rhs)//赋值运算符重载 { if (this == &rhs) { return *this; } //delete[]_first; for (T *p=_first; p!=_last; ++p) { _allocator.destory(p);//把_first指针指向的数组的有效元素析构 } _allocator.deallocate(_first);//释放堆上的数组内存 int size = rhs._end - rhs._first;//空间大小 _first = _allocator.allocate(size); int len = rhs._last - rhs._first;//有效元素 for (int i=0; i<len; ++i) { _allocator.construct(_first+i, rhs._first[i]); } _last = _first + len; _end = _first + size; return *this; } void push_back(const T &val)//尾插 { if (full()) { expand(); } //*_last++ = val; _allocator.construct(_last, val);//_last指针指向的内存构造一个值为val的对象 _last++; } void pop_back()//尾删 { if (empty()) return; //--_last; //不仅要把_last指针--，还需要析构删除的元素 --_last; _allocator.destroy(_last); } T back()const//返回容器末尾元素值 { return *(_last - 1); } bool full()const { return _last == _end; } bool empty()const { return _first == _last; } int size()const//返回容器中元素个数 { return _last - _first; } private: T *_first;//起始数组位置 T *_last;//指向最后一个有效元素后继位置 T *_end;//指向数组空间的后继位置 Alloc _allocator;//定义容器的空间配置器对象 void expand()//扩容 { int size = _end - _first; //T *ptmp = new T[2*size]; T *ptmp = _allocator.allocate(2*size); for (int i=0; i<size; ++i) { _allocator.construct(ptmp+i, _first[i]); //ptmp[i] = _first[i]; } //delete[]_first; for (T *p=_first; p!=_last; ++p) { _allocator.destroy(p); } _allocator.deallocate(_first); _first = ptmp; _last = _first + size; _end = _first + 2*size; } }; class Test { public: Test(){cout << \\\"Test()\\\" << endl;} ~Test(){cout << \\\"~Test\\\" << endl;} Test(const Test&){cout << \\\"Test(const Test&)\\\" << endl;} }; int main() { Test t1, t2, t3; cout << \\\"-------------------------\\\" << endl; vector<Test> vec; vec.push_back(t1); vec.push_back(t2); vec.push_back(t3); cout << \\\"-------------------------\\\" << endl; vec.pop_back();//只需要析构 cout << \\\"-------------------------\\\" << endl; return 0; } \",\"在这里插入图片描述\"]},\"386\":{\"c\":[\"使用指南\"]},\"387\":{\"c\":[\"页面配置\",\"使用指南\"]},\"388\":{\"h\":\"类模板与模板类\",\"t\":[\"类模板：仅仅的类的抽象\",\"类模板的实例化就是\",\"使用与函数模板也差不多，只是要，直接使用例子看类模板。\",\"//类模板 template <typename T, size_t kSize = 10>//类型参数T与非类型参数kSize class Stack { public: Stack() : _top(-1) , _data(new T[kSize]()) { } ~Stack(); bool empty() const; bool full() const; void push(const T &t); void pop(); T top() const; private: int _top; T *_data; }; //类模板在类外面定义成员函数时候需要注意，模板是有类型的，需要使用参数加类型 template <typename T, size_t kSize> Stack<T, kSize>::~Stack() { if(_data) { delete [] _data; _data = nullptr; } } template <typename T, size_t kSize> bool Stack<T, kSize>::empty() const { return -1 == _top;//_top = -1 } template <typename T, size_t kSize> bool Stack<T, kSize>::full() const { return _top == kSize - 1; } template <typename T, size_t kSize> void Stack<T, kSize>::push(const T &t) { if(!full()) { _data[++_top] = t; } else { cout << \\\"The Stack is full, cannot push any data\\\" << endl; } } template <typename T, size_t kSize> void Stack<T, kSize>::pop() { if(!empty()) { --_top; } else { cout << \\\"The Stack is empty\\\" << endl; } } template <typename T, size_t kSize> T Stack<T, kSize>::top() const { return _data[_top]; } void test() { Stack<int, 8> st; } void test1() { Stack<string> st; } \"]},\"389\":{\"h\":\"模板的嵌套\",\"t\":[\"template<class T> class Outside { public: template <class R> class Inside { public: Inside(R x) { r = x; } void disp() {cout << \\\"Inside: \\\" << r << endl;} private: R r; }; Outside(T x) : t(x) {} void disp() { cout<<\\\"Outside:\\\"; t.disp(); } private: Inside<T> t; }; void test() { Outside<int>::Inside<double> obin(3.5); obin.disp(); Outside<int> obout(2); obout.disp(); } \",\"C++模板的特化(specialization)和偏特化(partial specialization)_模板偏特化-CSDN博客\"]},\"390\":{\"c\":[\"c/c++\"]},\"391\":{\"c\":[\"模板\"]},\"392\":{\"h\":\"this指针\",\"t\":[\"类可以实例无数的对象，每个对象都有自己的成员变量，但是共享一套成员方法代码（存储在.text）。类的成员方法一经，会给的非静态成员函数都加一个this指针，接收调用该方法的对象的地址（即this指针的作用就是区分不同对象的(接收调用该方法的对象的地址)\",\"this指针指向本身\",\"this指针隐藏在**（非静态）成员函数的第一个参数的位置**\",\"被const修饰类类型 * const this ，即指针常量\",\"void Point::print(Point *const this) { cout << \\\"(\\\" << this->_ix << \\\",\\\" << this->_iy << \\\")\\\" << endl; } \",\"对于类成员函数而言，并不是一个对象对应一个单独的成员函数体，而是此类的所有对象这个成员函数体。 当程序被编译之后，此成员函数地址即已确定。而成员函数之所以能把属于此类的各个对象的数据区别开, 就是靠这个this指针。函数体内所有对类数据成员的访问， 都会被转化为this->数据成员的方式。\",\"这就是一套方法能知道处理哪个对象的原因：因为当用对象调用这些方法的时候，他就把对象的地址当作实参传给这些函数了，这些函数在编译过程中会产生this指针来接收所传入函数的地址。\"]},\"393\":{\"c\":[\"c/c++\"]},\"394\":{\"c\":[\"类和对象\"]},\"395\":{\"h\":\"拷贝构造函数\",\"t\":[\"img\",\"C++中经常会使用一个变量初始化另一个变量，如\",\"int x = 1; int y = x; \",\"我们希望这样的操作也能作用于自定义类类型，如\",\"Point pt1(1, 2); Point pt2 = pt1; \",\"pt1对象已经存在，而pt2对象还不存在，所以也是这句创建了pt2对象，既然涉及到对象的创建，就必然需要调用构造函数，而这里会调用的就是复制构造函数，又称为拷贝构造函数。如果类中没有显式定义拷贝构造函数时，编译器会自动提供一个缺省的拷贝构造函数。其原型是:\",\"类名::类名(const 类名 &); \"]},\"396\":{\"h\":\"缺省的拷贝构造函数\",\"t\":[\"如果成员比较简单，缺省的拷贝构造函数已经可以满足需求了，所以可以不显式定义\",\"Point::Point(const Point &rhs) : _ix(rhs._ix) , _iy(rhs._iy) { } \"]},\"397\":{\"h\":\"浅拷贝和深拷贝\",\"t\":[\"只拷贝指针地址的方式，我们称为浅拷贝。\",\"在这里插入图片描述\",\"浅拷贝出错问题： 对象使用浅拷贝不一定有错，但是对象有，那么当发生浅拷贝时，两个对象不同的指针指向同一个资源。第一次析构将堆内存释放，。\",\"class Computer { public: Computer(const char *brand, double price) : _brand(new char[strlen(brand) + 1]()) , _price(price) { cout << \\\"Computer(const char *, double)\\\" << endl; } Computer(const Computer &rhs) //缺省的拷贝构造函数 : _brand(rhs._brand) //浅拷贝 , _price(rhs._price) { } Computer(const Computer &rhs) : _brand(new char[strlen(rhs._brand) + 1]()) //深拷贝 , _price(rhs._price) { } private: char *_brand; //指向堆内存的指针 double _price; }; //执行构造初始化 Computer pc1(\\\"Huawei Matebook14\\\", 5699); Computer pc2 = pc1; \",\"此时需要重新显式定义拷贝构造函数，让两个指针指向不同堆空间的方式叫深拷贝，源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响\",\"在这里插入图片描述\"]},\"398\":{\"h\":\"拷贝构造函数的调用时机\",\"t\":[\"当用一个已经存在的对象初始化另一个新对象时，会调用拷贝构造函数。\",\"当实参和形参都是对象，进行实参与形参的结合时，会调用拷贝构造函数。\",\"当函数的返回值是对象，函数调用完成返回时，会调用拷贝构造函数。(优化选项-fno-elide-constructors)\"]},\"399\":{\"h\":\"Q：拷贝构造 函数参数中的 引用符号 可以去掉吗？\",\"t\":[\"不能去掉，如果去掉引用符号，在满足拷贝构造函数的情况，会满足拷贝构造函数的用 一个已经存在的对象初始化一个新对象 的调用时机，然后进行调用拷贝构造函数，函数的参数是会入栈，这样的话栈空间肯定会溢出的，所以引用符号不能去掉\"]},\"400\":{\"h\":\"Q：拷贝构造函数 参数中的 const 可以去掉吗？\",\"t\":[\"不能去掉，当传递的是（临时对象、临时变量、匿名对象）的时候，会返回报错（非const左值引用不能绑定到右值），当传递临时对象的时候，就会报错\"]},\"401\":{\"h\":\"Q:为什么拷贝时候要使用 for循环 ，使用memcpy函数补上更简单吗？\",\"t\":[\"因为在进行数据拷贝时候，如果是整型，不会占用整型之外的资源，进行memcpy拷贝没有问题。\"]},\"402\":{\"c\":[\"c/c++\"]},\"403\":{\"c\":[\"类和对象\"]},\"404\":{\"h\":\"拷贝构造和赋值重载的实践\",\"t\":[\"这个类的对象的成员变量有占用外部资源，所以我们要重写它的拷贝构造函数和赋值函数。\"]},\"405\":{\"h\":\"实现String类型\",\"t\":[\"#include <iostream> using namespace std; class String { public: String(const char* str = nullptr)//普通构造函数 { if (str != nullptr) { m_data = new char[strlen(str) + 1];//'\\\\0'要算上 strcpy(this->m_data, str); } else//用户传进来的字符串是空的话 ，为了让其他方法不用判空 { m_data = new char[1];//new char;开辟1个字节大小的空间 *m_data = '\\\\0';//0 } } String(const String& other)//拷贝构造函数，深拷贝 { m_data = new char[strlen(other.m_data) + 1]; strcpy(m_data, other.m_data); } ~String(void)//析构函数 { delete[]m_data; m_data = nullptr;//防止野指针的出现 } //使用String&是为了支持连续的operator=赋值操作 String& operator=(const String& other)//赋值重载函数，深拷贝 { if (this == &other)//防止自赋值 { return *this;//str1 } delete[]m_data;//释放当前的外部资源 m_data = new char[strlen(other.m_data) + 1]; strcpy(m_data, other.m_data); return *this;//str1 } private: char* m_data;//用于保存字符串 }; int main() { //用带const char*参数的构造函数 String str1;//调用默认的构造，形参是nullptr String str2(\\\"hello\\\"); String str3 = \\\"world\\\";//str2 //调用拷贝构造函数 String str4 = str3; String str5(str3); //调用赋值重载函数 /* str1 = str2 str1.operator=(str2) => str1 str3 = str1 */ str3 = str1 = str2; return 0; } \"]},\"406\":{\"h\":\"实现循环队列queue\",\"t\":[\"image-20240411091801938\",\"如果是用顺序表实现队列，那么现在，不能入队了，因为已经满了，前面有元素出队，但是没办法放。\",\"rear++的时候，我们不要让他加到末尾，让他加到前面去；\",\"包括front也一样，把78出队后，回到队前面\",\"#include <iostream> using namespace std; //循环队列 memcpy realloc class Queue { public: Queue(int size = 5)//构造函数 { _pQue = new int[size]; _front = _rear = 0; _size = size; } //Queue(const Queue&) = delete; //Queue& operator=(const Queue&) = delete; Queue(const Queue& src)//拷贝构造函数 { _size = src._size; _front = src._front; _rear = src._rear; _pQue = new int[_size]; for (int i = _front; i != _rear; i = (i + 1) % _size) { _pQue[i] = src._pQue[i]; } } Queue& operator=(const Queue& src)//赋值函数 { //防止自赋值 if (this == &src) return *this; delete[]_pQue; _size = src._size; _front = src._front; _rear = src._rear; _pQue = new int[_size]; for (int i = _front; i != _rear; i = (i + 1) % _size) { _pQue[i] = src._pQue[i]; } return *this; } //析构函数 ~Queue() { delete[]_pQue; _pQue = nullptr; } //入队操作，队尾入 void push(int val) { if (full()) resize(); _pQue[_rear] = val;//队尾赋值 _rear = (_rear + 1) % _size;//因为是循环队列 } //出队操作 void pop() { if (empty()) return; _front = (_front + 1) % _size; } //获取队头元素 int front() { return _pQue[_front]; } bool full() { return (_rear + 1) % _size == _front; }//判满 bool empty() { return _front == _rear; }//判空 private: void resize()//扩容操作 { int* ptmp = new int[2 * _size]; int index = 0; for (int i = _front; i != _rear; i = (i + 1) % _size) { ptmp[index++] = _pQue[i]; } delete[]_pQue; _pQue = ptmp; _front = 0; _rear = index; _size *= 2; } int* _pQue;//申请队列的数组空间，方便扩容 int _front;//指示队头的位置 int _rear;//指示队尾的位置 int _size;//队列扩容的总大小 }; int main() { Queue queue; for (int i = 0; i < 20; ++i) { queue.push(rand() % 100); } while (!queue.empty()) { cout << queue.front() << \\\" \\\"; queue.pop(); } cout << endl; Queue queue1 = queue; queue1 = queue; return 0; } \"]},\"407\":{\"c\":[\"c/c++\"]},\"408\":{\"c\":[\"类和对象\"]},\"409\":{\"h\":\"指向类型成员的指针\"},\"410\":{\"h\":\"普通成员变量\",\"t\":[\"普通成员变量：我们定义指针指向类的成员变量，。而且。\",\"class Test { public: void func()//普通成员方法 { cout << \\\"call Test::func\\\" << endl; } static void static_func()//静态成员方法 { cout << \\\"Test::static_func\\\" << endl; } int ma;//普通成员变量 }; \",\"&Test::ma类型编译器认为是加了类的作用域，因此我们定义指针时，也需要加上类的作用域，是类作用域里的整型变量。当访问ma时必须给前面加上对象。\"]},\"411\":{\"h\":\"在栈上定义一个对象\",\"t\":[\"int main() { Test t1;//栈上 int Test::*p = &Test::ma;//普通指针指向整型成员变量 t1.*p = 20; cout << t1.*p << endl; return 0; } \"]},\"412\":{\"h\":\"在堆上定义一个对象\",\"t\":[\"int main() { Test *t2 = new Test();//堆上 int Test::*p = &Test::ma;//普通指针指向整型成员变量 t2->*p = 30; cout << t2->*p << endl; delete t2; return 0; } \"]},\"413\":{\"h\":\"静态成员变量\",\"t\":[\"静态成员变量：。\",\"class Test { public: void func()//普通成员方法 { cout << \\\"call Test::func\\\" << endl; } static void static_func()//静态成员方法 { cout << \\\"Test::static_func\\\" << endl; } int ma;//普通成员变量 static int mb;//静态成员变量 }; int Test::mb; int main() { int *p1 = &Test::mb; *p1 = 40; cout << *p1 << endl; return 0; } \"]},\"414\":{\"h\":\"指向普通成员方法的指针\",\"t\":[\"Test t1;//栈上 Test *t2 = new Test();//堆上 //指向成员方法的指针 void (Test::*pfunc)() = &Test::func; (t1.*pfunc)(); (t2->*pfunc)(); \"]},\"415\":{\"h\":\"指向静态成员方法的指针\",\"t\":[\"Test::static_func(); \"]},\"416\":{\"c\":[\"c/c++\"]},\"417\":{\"c\":[\"类和对象\"]},\"418\":{\"h\":\"构造函数、初始化列表和析构函数\",\"t\":[\"img\"]},\"419\":{\"h\":\"构造函数\"},\"420\":{\"h\":\"构造函数的特点：\",\"t\":[\"函数的名字与类名相同\",\"没有返回值\",\"没有返回类型，即使是void也不能有\",\"构造函数在对象创建时自动调用，用以完成对象及其他操作(如为指针成员等)；\",\"如果程序员没有显式定义它，系统会提供一个默认构造函数。\"]},\"421\":{\"h\":\"示例\",\"t\":[\"下面我们用一个点Point来举例:\",\"class Point { public: //即使不写，编译器也会自动提供一个 Point() { cout << \\\"Point()\\\" << endl; _ix = 0; _iy = 0; } void print() { cout << \\\"(\\\" << _ix << \\\",\\\" << _iy << \\\")\\\" << endl; } private: int _ix; int _iy; }; int main(void){ Point pt; pt.print(); return 0; } \",\"编译器自动生成的缺省(默认)构造函数是，实际上，构造函数可以接收参数\",\"Point(int ix, int iy) { cout << \\\"Point(int,int)\\\" << endl; _ix = ix; _iy = iy; } \",\"这说明了构造函数是可以****的。\",\"现在假设Point类中只显式，如果还希望通过默认构造函数创建对象，则需要。\"]},\"422\":{\"h\":\"初始化列表\",\"t\":[\"class Point { public: //... Point(int ix = 0, int iy = 0) : _ix(ix) , _iy(iy) { cout << \\\"Point(int = 0,int = 0)\\\" << endl; } //... }; \",\"如果没有在构造函数的初始化列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。如在“对象的创建”部分的两个构造函数中的_ix和_iy都是先执行默认初始化后，再在函数体中执行赋值操作。\",\"注意：\",\"每个成员在初始化列表之中，\",\"其初始化的顺序不是由成员变量在初始化列表中的顺序决定的，而是由成员变量在类中被决定的。（举例说明）\",\"class Base { public: int m_a; public: Base(int a) : m_a(a) { std::cout << \\\"Base obj constructed !\\\" << std::endl; } }; class Derived: public Base { public: int m_b; int m_c; int m_d; public: Derived (int a, int c) : m_c(c), Base(a), m_b(m_a + m_c) { std::cout << \\\"Derived obj constructed !\\\" << std::endl; } }; int main() { Derived d(1, 10); std::cout << d.m_a << std::endl; // 1 std::cout << d.m_b << std::endl; // 未初始化 std::cout << d.m_c << std::endl; // 10 std::cout << d.m_d << std::endl; // 1 std::cin.get(); } \",\"$./a.out Base obj constructed ! Derived obj constructed ! 1 1 10 0 \",\"class Test { public: Test(int data = 10):mb(data), ma(mb){} void show() { cout << \\\"ma:\\\" << ma << \\\" mb:\\\" << mb << endl; } private: int ma; int mb; }; int main() { Test t; t.show(); return 0; } \",\"结果：ma先初始化，此时mb还没有值，即0xcccccccc；mb再初始化即10。\",\"在这里插入图片描述\"]},\"423\":{\"h\":\"必须在初始化列表中进行初始化的情况有哪些\",\"t\":[\"**成员变量是 const **\",\"成员变量引用类型：\",\"如果派生类需要调用基类的构造函数\",\"如果派生类需要调用基类的有参构造函数，必须初始化列表初始化\",\"如果派生类需要调用基类的无参构造函数 \",\"基类有一个无参构造函数，那么编译器会自动调用基类的无参构造函数来初始化基类部分\",\"如果基类没有提供无参构造函数，编译器会产生编译错误\",\"（因为编译器在自动生成构造函数的过程中会尝试调用基类的构造函数，但是如果基类没有提供无参构造函数，而且编译器不会自动创建默认的基类构造函数调用，编译器就无法生成默认构造函数，这样就会导致编译错误。）\",\"初始化其他自定义类型的成员对象\",\"如果类中有其他类类型的成员对象，必须在构造函数初始化列表中对其进行初始化。\",\"class OtherClass { public: OtherClass(int val) {} }; class MyClass { public: MyClass(int val) : _other(val) {} private: OtherClass _other; }; \"]},\"424\":{\"h\":\"析构函数\",\"t\":[\"析构函数(Destructor)在对象被撤销时被自动调用，相比构造函数，析构函数要简单的多。\"]},\"425\":{\"h\":\"析构函数的特点：\",\"t\":[\"与类同名，之前冠以波浪号，以区别于构造函数。\",\"析构函数没有返回类型，也没有参数, 因此，析构函数只能有，。\",\"对象超出其作用域被销毁时，析构函数会被自动调用\",\"析构函数在对象撤销时自动调用，用以执行一些**清理任务，如**等。\",\"如果程序员没有显式的定义它，系统也会提供一个默认的析构函数。\"]},\"426\":{\"h\":\"示例\",\"t\":[\"class Point { public: //... ~Point() { } //... }; \",\"class Computer { public: Computer(const char *brand, double price) : _brand(new char[strlen(brand) + 1]()) , _price(price) { cout << \\\"Computer(const char *, double)\\\" << endl; } ~Computer() { cout << \\\"~Computer()\\\" << endl; delete [] _brand; _brand = nullptr; } double getPrice() { return _price; } private: char *_brand; double _price; }; \",\"如果某个数据成员是指针，而该指针在构造函数中初始化时已经申请了堆空间的资源，则当对象被销毁时，必须回收其资源。此时，编译器提供的默认析构函数是没有做回收操作的，因此就不再满足我们的需求，我们必须显式定义一个析构函数，在函数体内回收资源。 析构函数除了在对象被销毁时自动调用外，还可以。\",\"int main() { Computer c; c.~Computer(); //不建议手动析构 c.getPrice(); //error } \"]},\"427\":{\"h\":\"析构函数在哪些时候会被调用呢？\",\"t\":[\"对于全局定义的对象，每当程序开始运行，在主函数main接受程序控制权之前，就调用构造函数创建全局对象，整个程序结束时，自动调用全局对象的析构函数。\",\"对于局部定义的对象，每当程序流程到达该对象的定义处就调用构造函数，在程序离开局部对象的作用域时调用对象的析构函数。\",\"对于关键字static定义的静态局部变量，当程序流程第一次到达该对象定义处调用构造函数，在整个程序结束时调用析构函数。\",\"对于用new运算符创建的对象，每当创建该对象时调用构造函数，当用delete删除该对象时，调用析构函数。\"]},\"428\":{\"h\":\"注意\",\"t\":[\"先构造的后析构，后构造的先析构。（栈结构）\"]},\"429\":{\"c\":[\"c/c++\"]},\"430\":{\"c\":[\"类和对象\"]},\"431\":{\"h\":\"特殊数据成员的初始化\",\"t\":[\"在C++的类中，有4种比较特殊的数据成员，他们分别是常量成员、引用成员、类对象成员和静态成员，他们的初始化与普通数据成员有所不同。\"]},\"432\":{\"h\":\"常量数据成员\",\"t\":[\"当数据成员用const关键字进行修饰以后，就成为常量成员。一经初始化，该数据成员便具有“只读属 性”，在程序中无法对其值修改。事实上，在构造函数体内初始化const数据成员是非法的，它们只能在构造函数初始化列表中进行初始化。如：\",\"class Point { public: //错误写法 Point(int ix = 0, int iy = 0) { _ix = ix;//error, 这是赋值语句，const成员不能修改 _iy = iy;//error _iz = _ix; } //正确写法 Point(int ix = 0, int iy = 0) : _ix(ix) , _iy(iy) , _iz(_ix) { } private: const int _ix; //常量数据成员,必须在初始化列表中进行 const int _iy; int & _iz; }; \"]},\"433\":{\"h\":\"引用数据成员\",\"t\":[\"和常量成员相同，引用成员也必须在构造函数初始化列表中进行初始化，否则编译报错。\",\"#include <iostream> using std::cout; using std::endl; class Point { public: Point(int ix = 0, int iy = 0) : _ix(ix) , _iy(iy) , _ref(_ix) { cout << \\\"Point(int = 0, int = 0)\\\" << endl; /* _ix = ix;//error,赋值 */ /* _iy = iy; */ } void print() { cout << \\\"(\\\" << _ix << \\\", \\\" << _iy << \\\")\\\" << endl; } ~Point() { cout << \\\"~Point()\\\" << endl; } private: int _ix; int _iy; int &_ref; }; //成员函数不占用类的大小，成员函数存在于程序代码区，被该类的 //左右对象共享 // int main(int argc, char **argv) { cout << \\\"sizeof(Point) = \\\" << sizeof(Point) << endl; Point pt(1, 2);//栈对象 return 0; } \",\"$./a.out sizeof(Point) = 16 #有内存对齐 Point(int = 0, int = 0) ~Point() \"]},\"434\":{\"h\":\"类对象成员\",\"t\":[\"当数据成员本身也是自定义类类型对象时，比如一个直线类Line对象中包含两个Point类对象，对Point 对象的创建就必须要放在Line的构造函数的初始化列表中进行。如\",\"#include <iostream> using std::cout; using std::endl; class Point { public: /* Point(int ix = 0, int iy = 0) */ Point(int ix, int iy) : _ix(ix) , _iy(iy) { cout << \\\"Point(int = 0, int = 0)\\\" << endl; } void print() { cout << \\\"(\\\" << _ix << \\\", \\\" << _iy << \\\")\\\" << endl; } ~Point() { cout << \\\"~Point()\\\" << endl; } private: int _ix; int _iy; }; class Line { public: Line(int x1, int y1, int x2, int y2) : _pt1(x1, y1)//类对象成员需要显示进行初始化，否则就是默认值 , _pt2(x2, y2) { cout << \\\"Line(int, int, int,int)\\\" << endl; } void printLine() { _pt1.print(); _pt2.print(); } ~Line() { cout << \\\"~Line()\\\" << endl; } private: Point _pt1;//类对象成员(子对象) Point _pt2; }; int main(int argc, char **argv) { Line line(1, 2, 3, 4); line.printLine(); return 0; } \",\"当Line的构造函数没有在其初始化列表中初始化对象_pt1和_pt2时，系统也会自动调用Point类的默认构造函数，此时就会与预期的构造不一致。因此需要显式在Line的构造函数初始化列表中初始化_pt1和_pt2对象。\"]},\"435\":{\"h\":\"静态数据成员\",\"t\":[\"C++允许使用static（静态存储）修饰数据成员，这样的成员在**就被创建并初始化的（与之相比，对象是在**被创建的），且其实例只有一个，被所有该类的对象共享，就像住在同一宿舍里的同学共享一个房间号一样。静态数据成员和之前介绍的静态变量一样，当程序执行时，该成员已经存在，一直到程序结束，任何该类对象都可对其进行访问，静态数据成员存储在全局/静态区，并不占据对象的存储空间。\",\"class Computer { public: Computer(const char *brand, double price) : _brand(new char[strlen(brand) + 1]()) , _price(price) { _totalPrice += _price; } void print() { cout << \\\"品牌:\\\" << _brand << endl << \\\"价格:\\\" << _price << endl << \\\"总价:\\\" << _totalPrice << endl; } //... private: char * _brand; double _price; //4和 _brand 会有内存对齐 static double _totalPrice;//4静态的数据成员不占类的大小，被类 //创建的所有对象所共享 }; \",\"因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类对象时被定义的。这意味着它们不是由类的的构造函数初始化的，一般来说，我们不能在类的内部初始化静态数据成员，必须在类的外部定义和初始化静态数据成员，且，格式如下:\",\"类型 类名::变量名 = 初始化表达式; //普通变量 类型 类名::对象名(构造参数); //对象变量 \",\"//静态数据成员要放在全局静态位置进行初始化，特别是对于头文件与 //实现文件的形式，要放在实现文件里面，否则会有多重定义的报错 double Computer::_totalPrice = 0; \",\"注意：要放在里面，否则会有的报错\"]},\"436\":{\"c\":[\"c/c++\"]},\"437\":{\"c\":[\"类和对象\"]},\"438\":{\"h\":\"特殊的成员函数\",\"t\":[\"img\",\"除了特殊的数据成员以外，C++类中还有两种特殊的成员函数：静态成员函数和 const 成员函数。我们 先来看看静态成员函数。\"]},\"439\":{\"h\":\"静态成员函数\",\"t\":[\"成员函数也可以定义成静态的，静态成员函数的特点:\",\"静态的成员函数的第一个参数位置没有this指针\",\"静态的成员函数不能访问非静态的数据成员和非静态的成员函数\",\"非静态的成员函数静态的数据成员和静态的成员函数\",\"静态成员函数可以使用类名加作用符的形式进行调用（静态成员函数的特殊用法）\",\"如下:\",\"普通的成员方法特点：编译器会添加一个this形参变量\",\"class Computer { public: Computer(const char * brand, double price) : _brand(new char[strlen(brand) + 1]()) , _price(price) { _totalPrice += _price; } //... static void printTotalPrice() { cout << \\\"总价:\\\" << _totalPrice << endl; } //... private: char * _brand; double _price; static double _totalPrice; }; \",\"对于静态成员函数，还可以直接通过类名进行调用，这也是的方式：\",\"int main(void) { Computer pc1(\\\"Huawei MateBook14\\\", 5699); pc1.print(); Computer::printTotalPrice();//通过类名直接调用 return 0; } \",\"下面让我们再来看一个有意思的例子:\",\"#ifndef __COMPUTER_H__ #define __COMPUTER_H__ class Computer { public: Computer(const char *brand, float price); Computer(const Computer &rhs); Computer &operator=(const Computer &rhs); void setBrand(const char *brand); void setPrice(float price); static void printTotalPrice(); void print(); ~Computer(); private: char *_brand;//8 float _price;//4, 内存对齐 static float _totalPrice;//4静态的数据成员不占类的大小，被类 //创建的所有对象所共享 }; #endif \",\"void test4() { cout << \\\"sizeof(Computer) = \\\" << sizeof(Computer) << endl; cout << \\\"一台电脑都没有购买 : \\\" << endl; Computer::printTotalPrice(); cout << endl; Computer com1(\\\"huawei\\\", 6000); cout << \\\"com1 = \\\"; com1.print(); cout << \\\"购买第一台电脑总价 : \\\" << endl; com1.printTotalPrice(); Computer::printTotalPrice(); cout << endl; Computer com2(\\\"xiaomi\\\", 8000); cout << \\\"com2 = \\\"; com2.print(); cout << \\\"购买第二台电脑总价 : \\\" << endl; com2.printTotalPrice(); com1.printTotalPrice(); Computer::printTotalPrice();//可以使用类名加作用域限定符进行调用 /* Computer::print();//error */ } \"]},\"440\":{\"h\":\"const成员函数\",\"t\":[\"之前已经介绍了const在函数中的应用，实际上，const在类成员函数中还有种特殊的用法，把const关键 字放在函数的参数表和函数体之间（与之前介绍的const放在函数前修饰返回值不同），称为const成员 函数，其具有以下特点:\",\"对于非const对象，既可以调用const版本的成员函数，可以调用非const版本的成员函数，情况下，调用非const版本的成员函数\",\"const对象调用const版本的成员函数,不能调用非const版本的函数\",\"const版本的成员函数与非const版本的成员函数可以重载，一般先写const版本的\",\"const版本的成员函数具有只读特性，不能进行写操作，所以对于不修改数据成员的情况，可以将成员函数用const修饰\",\"其格式为：\",\"类型 函数名(参数列表) const { 函数体 } \",\"比如当给Computer类添加一个const的打印函数后，则其实现如下:\",\"class Computer { public: //... //const版本的成员函数可以与非const版本的成员函数进行重载（this指针是不一样） //一般建议先写出const版本的成员函数 void Computer::print(/* Computer * const this */) { /* this->_price = 10; */ /* printTotalPrice();//ok */ cout << \\\"void print()\\\" << endl; printf(\\\"brand : %p\\\\n\\\", _brand); cout << \\\"brand : \\\" << _brand << endl << \\\"price : \\\" << this->_price << endl; } void Computer::print(/* const Computer * const this */) const { /* this->_price = 10;//error */ cout << \\\"void print() const \\\" << endl; printf(\\\"brand : %p\\\\n\\\", _brand); cout << \\\"brand : \\\" << _brand << endl << \\\"price : \\\" << this->_price << endl; } }; \",\"void test5() { //非const对象既可以访问非const版本成员函数也可以访问 //const版本的成员函数，但是默认情况下访问非const版本 //的成员函数 Computer com1(\\\"huawei\\\", 6000); cout << \\\"com1 = \\\"; com1.print(); cout << endl; //const int number = 10; //const对象只能访问const版本的成员函数，不能访问非const版本的成员函数 const Computer com2(\\\"xiaomi\\\", 8000); cout << \\\"com2 = \\\"; com2.print(); } \"]},\"441\":{\"h\":\"为什么const成员无法调用普通成员方法？\",\"t\":[\"因为const成员的this指针类型为const T * const this,\",\"普通成员方法要求传入的是T * const this，相当于试图T* <= const T*, 错误\"]},\"442\":{\"c\":[\"c/c++\"]},\"443\":{\"c\":[\"类和对象\"]},\"444\":{\"h\":\"类和对象\",\"t\":[\"img\"]},\"445\":{\"h\":\"什么是OOP思想？\",\"t\":[\"面向对象的程序设计语言必须有描述对象及其相互之间关系的语言成分。这些程序设计语言可以归纳为以下几类：系统中一切事物皆为对象；对象是属性及其操作的封装体；对象可按其性质划分为类，对象成为类的实例；实例关系和继承关系是对象之间的静态关系；消息传递是对象之间动态联系的唯一形式，也是计算的唯一形式；方法是消息的序列。\"]},\"446\":{\"h\":\"oop编程方法：\",\"t\":[\"先确定有哪些实体，根据实体的属性和行为抽象出 ADT(abstract data type)\",\"类（属性->成员变量，行为->成员方法）实例化得到对象\"]},\"447\":{\"h\":\"面向对象基本概念\",\"t\":[\"c语言：各种各样的函数定义\",\"c++： 类，表示实体的抽象数据类型\",\"在这里插入图片描述\"]},\"448\":{\"h\":\"oop语言的四大特征是什么？\",\"t\":[\"抽象：忽略一个主题中与当前目标无关的东西,专注的注意与当前目标有关的方面，将其抽象。\",\"**封装/隐藏：只隐藏对象的属性和实现细节，仅对外提供公共访问方式。**通过访问限定符体现的出来的 \",\"public\",\"private\",\"protected\",\"继承：提高代码复用性；继承是多态的前提。\",\"多态：是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。\"]},\"449\":{\"h\":\"C++中类的定义\",\"t\":[\"C++用类来描述对象，类是对现实世界中相似事物的抽象，比如同是“双轮车”的摩托车和自行车，有共同点，也有许多不同点。“车”类是对摩托车、自行车、汽车等相同点的提取与抽象。\",\"类的定义分为两个部分：数据（相当于属性）和对数据的操作（相当于行为）。\",\"从程序设计的观点来说，类就是数据类型，是用户定义的数据类型，对象可以看成某个类的实例（某个类的变量）。所以说类是对象的封装，对象是类的实例\",\"class 类名 { public: //公有数据成员和成员函数 protected://面向对象用的少，继承用的多 //保护数据成员和成员函数 private: //私有数据成员和成员函数 }; // 千万不要忘了这个分号 \",\"class内部可以拥有的是数据成员(属性)和成员函数(行为)，他们可以分别用三个不同的关键字进行修饰，public、protected、private. 其中public进行修饰的成员表示的是该类可以提供的接口、功能、或者服务；protected进行修饰的成员，其访问权限是开放给其子类；private进行修饰的成员是不可以在类之外进行访问的，只能在类内部访问，可以说**就是由private关键字来体现**。\",\"下面以一台大家 熟悉的计算机来举例:\",\"class Computer { public: //成员函数 void setBrand(const char * brand) { strcpy(_brand, brand); } void setPrice(float price) { _price = price; } private: //数据成员 char _brand[20]; float _price; }; int main(int argc, char * argv[]) { Computer pc; pc.setBrand(\\\"Huawei Matebook14\\\"); pc.setPrice(5600); return 0; } \",\"在定义的成员函数，都是。除了可以在类内部实现外，成员函数还可以在类之外实现。在类的外部定义成员函数时，应使用**作用域限定符（::）**来标识函数所属的类，即有如下形式:\",\"返回类型 类名::成员函数名(参数列表) { //.... } \",\"对于Computer中的两个成员函数，我们在类之外实现，其实现如下:\",\"void Computer::setBrand(const char * brand) { strcpy(_brand, brand); } void Computer::setPrice(float price) { _price = price; } \",\"注意：\",\"如果类给外部的接口，返回的是成员属性的记得加const，\",\"class Goods{ public: //char* getName(); const char* getName; private: char* _name; }; \"]},\"450\":{\"h\":\"class与struct的区别\",\"t\":[\"在C++中，与C相比，struct的功能已经进行了扩展。class能做的事儿，struct一样能做，他们之间唯一的区别，就是默认访问权限不同。class的默认访问权限是private，struct的默认访问权限是public\",\"struct Computer { //成员函数, 其访问权限是public void setBrand(const char *brand) { strcpy(_brand, brand); } void setPrice(float price) { _price = price; } //数据成员, 其访问权限是public char _brand[20]; float _price; }; class Computer2 { //成员函数, 其访问权限是private void setBrand(const char *brand) { strcpy(_brand, brand); } void setPrice(float price) { _price = price; } //数据成员, 其访问权限是private char _brand[20]; float _price; }; \"]},\"451\":{\"c\":[\"c/c++\"]},\"452\":{\"c\":[\"类和对象\"]},\"453\":{\"h\":\"对象的组织\",\"t\":[\"有了自己定义的类，或者使用别人定义好的类创建对象，其机制与使用int等创建普通变量几乎完全一致，同样可以创建const对象、创建指向对象的指针、创建对象数组，还可使用new和delete等创建动态对象。\"]},\"454\":{\"h\":\"const对象\",\"t\":[\"类对象也可以声明为const对象，一般来说，能作用于const对象的成员函数除了和**，便只有**了，因为const对象只能被、以及，。\",\"const Point pt(1, 2); pt.print(); \"]},\"455\":{\"h\":\"指向对象的指针\",\"t\":[\"对象占据一定的内存空间，， C++ 程序中采用如下形式声明指向对象的指针：\",\"类名 *指针名 [=初始化表达式]; \",\"初始化表达式是可选的，既可以通过取地址（&对象名）给指针初始化，也可以通过申请动态内存给指针初始化，或者干脆不初始化（比如置为nullptr），在程序中再对该指针赋值。 指针中存储的是对象所占内存空间的****。针对上述定义，则下列形式都是合法的：\",\"Point pt(1, 2); Point *p1 = nullptr; Point *p2 = &pt; Point *p3 = new Point(3, 4); Point *p4 = new Point[5]; p3->print();//合法 (*p3).print();//合法 \"]},\"456\":{\"h\":\"对象数组\",\"t\":[\"对象数组，也有声明、初始化和使用3个步骤\"]},\"457\":{\"h\":\"对象数组的声明:\",\"t\":[\"类名 数组名[对象个数]; \",\"这种格式会或。\"]},\"458\":{\"h\":\"对象数组的初始化：可以在声明时进行初始化。\",\"t\":[\"Point pts[2] = {Point(1, 2), Point(3, 4)}; Point pts[] = {Point(1, 2), Point(3, 4)}; Point pts[5] = {Point(1, 2), Point(3, 4)}; //或者 Point pts[2] = {{1, 2}, {3, 4}};//这里需要注意，除了去掉Point，还换了大括号 Point pts[] = {{1, 2}, {3, 4}}; Point pts[5] = {{1, 2}, {3, 4}}; \"]},\"459\":{\"h\":\"堆对象\",\"t\":[\"，可以用new和delete表达式为对象分配动态存储区，在复制构造函数一节中已经介绍了为类内的指针成员分配动态内存的相关范例，这里主要讨论如何为对象和对象数组动态分配内存。如：\",\"void test() { Point *pt1 = new Point(11, 12); pt1->print(); delete pt1; pt1 = nullptr; Point * pt2 = new Point[5]();//注意 pt2->print(); (pt2 + 1)->print(); delete [] pt2;//可以试试使用free去进行释放会发生什么？为什么会发生这个问题？ } \",\"注意: 使用new表达式为对象数组分配动态空间时，，因此，对象要么没有定义任何形式的构造函数（由），要么显式定义了一个（且只能有一个）。\",\"#include <iostream> using std::cout; using std::endl; class Point { public: Point(int ix = 0, int iy = 0) : _ix(ix) , _iy(iy) { cout << \\\"Point(int = 0, int = 0)\\\" << endl; } void print() { cout << \\\"(\\\" << this->_ix << \\\", \\\" << this->_iy << \\\")\\\" << endl; } ~Point() { cout << \\\"~Point()\\\" << endl; } private: int _ix; int _iy; }; void test() { //int number = 10; //int *pInt = &number; Point pt(1, 2); Point *ptr = &pt; //int *pInt = new int(10); Point *pc = new Point(1, 3); } void test2() { //int arr[2] = {1, 2}; Point pt[2] = {Point(1, 2), Point(2, 3)}; pt[0].print(); cout << endl; //逗号表达式 /* Point ptemp[2] = {(1, 2), (4, 3)}; */ Point ptemp[2] = {{1, 2}, {4, 3}}; ptemp[0].print(); } void test3() { int *pInt = new int[5](); Point *pArr = new Point[5](); cout << \\\"222\\\" << endl; pArr[0] = {1, 3}; cout << \\\"333\\\" << endl; pArr[1] = Point(2, 4);//临时对象/匿名对象，生命周期只在本行,对象在本行创建，也在本行销毁 cout << \\\"111\\\" << endl; delete [] pArr;//堆对象数组 /* free(pArr);//error */ } int main(int argc, char **argv) { test3(); return 0; } \"]},\"460\":{\"c\":[\"c/c++\"]},\"461\":{\"c\":[\"类和对象\"]},\"462\":{\"h\":\"赋值运算符函数\",\"t\":[\"img\"]},\"463\":{\"h\":\"形式\",\"t\":[\"赋值运算是一种很常见的运算，比如：\",\"int x = 1, y = 2; x = y; \",\"同样地， 我们也希望该操作能作用于自定义类类型，比如：\",\"Point pt1(1, 2), pt2(3, 4); pt1 = pt2;//赋值操作 \",\"在执行pt1 = pt2;该语句时，pt1与pt2都存在，所以不存在对象的构造，这要与 Point pt2 = pt1;语句区分开，这是不同的。\",\"Point pt1(1, 2); /* Point pt4 = pt1;//拷贝构造函数 */ Point pt4(pt1);//拷贝构造函数 Point pt2(3, 4); pt2 = pt1;//赋值运算符函数 \",\"在这里，当=作用于对象时，其实是把它当成一个函数来看待的。在执行pt1 = pt2;该语句时，需要调用的是赋值运算符函数。其形式如下：\",\"返回类型 类名::operator=(参数列表) { //... } \",\"如果类中没有显式定义赋值运算符函数时，编译器会自动提供一个缺省的赋值运算符函数。\",\"Point &Point::operator=(const Point &rhs) { _ix = rhs._ix; _iy = rhs._iy; return *this; } \"]},\"464\":{\"h\":\"深拷贝和浅拷贝问题\",\"t\":[\"class Computer { public: Computer(const char *brand, double price) : _brand(new char[strlen(brand) + 1]()) , _price(price) { cout << \\\"Computer(const char *, double)\\\" << endl; } Computer &operator=(const Computer &rhs) { _brand = rhs._brand; //浅拷贝 _price = rhs._price; return *this; } Computer &Computer::operator=(const Computer &rhs) { if(this != &rhs) //1、自复制 { delete [] _brand; //2、释放左操作数 _brand = nullptr; _brand = new char[strlen(rhs._brand) + 1](); //3、深拷贝 strcpy(_brand, rhs._brand); _price = rhs._price; } return *this; //4、返回*this } private: char *_brand; //指向堆内存的指针 double _price; }; //执行构造初始化 Computer pc1(\\\"Huawei Matebook14\\\", 5699); Computer pc2 = pc1; \"]},\"465\":{\"h\":\"Q：引用符号可以去掉吗？\",\"t\":[\"如果去掉，会多执行一次拷贝构造函数，效率就会降低\"]},\"466\":{\"h\":\"Q:const可以去掉吗：\",\"t\":[\"如果右操作数是右值的时候，就会产生非const左值引用不能绑定到右值的报错\"]},\"467\":{\"h\":\"Q:赋值运算符函数的返回类型可以是void？\",\"t\":[\"考虑连等情况\"]},\"468\":{\"h\":\"空类\",\"t\":[\"#include <iostream> using std::cout; using std::endl; class Empty { //无参构造函数 //拷贝构造函数 //赋值运算符函数 //析构函数 }; int main(int argc, char **argv) { cout << \\\"sizeof(Empty) = \\\" << sizeof(Empty) << endl; Empty e1; Empty e2; Empty e3; printf(\\\"&e1 = %p\\\\n\\\", &e1); printf(\\\"&e2 = %p\\\\n\\\", &e2); printf(\\\"&e3 = %p\\\\n\\\", &e3); return 0; } \",\"$./a.out sizeof(Empty) = 1 &e1 = 0x7ffe6ef931ef &e2 = 0x7ffe6ef931ee &e3 = 0x7ffe6ef931ed \"]},\"469\":{\"h\":\"一个空的类，编译器会自动提供哪些函数\",\"t\":[\"无参构造函数\",\"拷贝构造函数\",\"赋值运算符函数\",\"析构函数\"]},\"470\":{\"h\":\"空类的大小不为0\",\"t\":[\"C++标准指出，不允许一个对象（当然包括类对象）的大小为0，。这是由于：\",\"new需要分配不同的内存地址，不能分配内存大小为0的空间\",\"避免除以 sizeof(T)时得到除以0错误\",\"故使用****来区分空类。\",\"值得注意的是，这并不代表一个空的基类也需要加一个字节到子类中去。这种情况下，空类并不是独立的，它附属于子类。子类继承空类后，子类如果有自己的数据成员，而空基类的一个字节并不会加到子类中去。例如，\",\"class Empty {}; struct D : public Empty {int a;}; //sizeof(D)为4 \",\"再来看另一种情况，一个类包含一个空类对象数据成员。\",\"class Empty {}; class HoldsAnInt { int x; Empty e; }; \",\"在大多数编译器中，你会发现 sizeof(HoldsAnInt) 输出为8。这是由于，Empty类的大小虽然为1，然而为了内存对齐，编译器会为HoldsAnInt额外加上一些字节，使得HoldsAnInt被放大到足够又可以存放一个int。\"]},\"471\":{\"c\":[\"c/c++\"]},\"472\":{\"c\":[\"类和对象\"]},\"473\":{\"h\":\"bool\",\"t\":[\"1681304077461-c2f9d32f-49d2-4aaf-9f81-1c3da4cd2450\",\"在C++中，还添加了一种基本类型，就是bool类型，用来表示true和false。true和false是字面值，可以通过转换变为int类型，true为1，false为0.\",\"int x = true;// 1 int y = false;// 0 \",\"任何数字或指针值都可以隐式转换为bool值。任何非零值都将转换为true，而零值转换为false.\",\"bool b1 = -100; bool b2 = 100; bool b3 = 0; bool b4 = 1; bool b5 = true; bool b6 = false; int x = sizeof(bool); \",\"一个bool类型的数据占据的内存空间大小为1.\"]},\"474\":{\"c\":[\"c/c++\"]},\"475\":{\"c\":[\"c++基础\"]},\"476\":{\"h\":\"c++初探\",\"t\":[\"#include <stdio.h> #include <iostream>//C++头文件没有加.h，因为C++头文件都是用模板写的， //而模板有个特点：必须要知道所有实现之后才能正常编译 using namespace std;//命名空间 //函数的声明 //函数声明可以有多次，函数定义只能有一次 void test(); void test(); void test(); void test(); void test(); void test() { } int main(int argc, char **argv) { /* &10;//error,字面值常量,右值，不能取地址 */ /* &\\\"Hello, world\\\";//ok */ //cout,标准输出 //<<,输出流运算符 //\\\"Hello world\\\",字符串常量 //endl end of line cout << \\\"Hello world\\\" << endl; operator<<(cout, \\\"Hello world\\\").operator<<(endl);//运算符重载 int number = 0; //cin，标准输入 //>>，输入流运算符 cin >> number; cout << \\\"number = \\\" << number << endl; return 0; } \",\"注意：\",\"字符串字面值可以取地址\"]},\"477\":{\"c\":[\"c/c++\"]},\"478\":{\"c\":[\"c++基础\"]},\"479\":{\"h\":\"const\",\"t\":[\"1681302938745-c100c3cc-4cb4-4f9d-a1cb-94d6bd99e2ad\"]},\"480\":{\"h\":\"const关键字修饰变量\",\"t\":[\"const int number1 = 10;//const关键字修饰的变量称为常量 int const number2 = 20; const int val;//error 常量必须要进行初始化 number1 = 30;//error 常量不能被赋值（初始化后不可修改） \",\"除了这种方式可以创建常量外，还可以使用宏定义的方式创建常量\",\"#define NUMBER 1024 \"]},\"481\":{\"h\":\"常考题：const常量与宏定义的区别是什么？\",\"t\":[\"编译器处理方式不同。宏定义是在展开，做字符串的替换；而const常量是在。\",\"类型和安全检查不同。宏定义没有类型，不做任何类型检查（有bug运行时才会报错）；const常量有具体的类型，在编译期会执行类型检查（有bug编译时报错）。\",\"在使用中，应尽量以const替换宏定义，可以减小犯错误的概率。\"]},\"482\":{\"h\":\"const和普通变量的区别\",\"t\":[\"const修饰的变量不能再作为左值，初始化后值不能被修改\",\"编译方式不一样\"]},\"483\":{\"h\":\"c和c++中const修饰变量有什么不同\",\"t\":[\"C中const修饰的量可以不初始化，但后面也不能赋值了，不叫常量，而是叫，因此不能用作数组下标：\",\"int main(void) { const int a = 20; int array[a] = {}; // error return 0; } \",\"int main(void) { const int a = 20; int *p = (int*)&a; *p = 30; // 30 30 30 printf(\\\"%d %d %d \\\\n\\\", a, *p, *(&a)); return 0; } \"]},\"484\":{\"h\":\"c++中const特性\",\"t\":[\"const修饰的变量必须初始化，可以用作数组下标\",\"int main(void) { const int a = 20; int array[a] = {}; // pass int *p = (int*)&a; *p = 30; //*p此时确实把&a的值改成了30，但是a在编译时都直接替换成20 // 20 30 20 printf(\\\"%d %d %d \\\\n\\\", a, *p, *(&a)); //printf(\\\"%d %d %d \\\\n\\\", 20, *p, 20); return 0; } \",\"C++是将a在**都直接替换**成20,这就是为什么必须初始化，不初始化怎么发生替换\",\"c++中的const初始化值为**叫，如果用给const初始化的叫**，因为只有运行时才知道变量的值是多少\",\"int main(void) { int b = 20; const int a = b; //int array[a] = {}; //常变量不能定义数组 int *p = (int*)&a; *p = 30; // 30 30 30 printf(\\\"%d %d %d \\\\n\\\", a, *p, *(&a)); //和c语言一样 return 0; } \",\"答：\",\"const的编译方式不同，c中，const就是当作一个变量编译生成指令的；在C++中，const常量则会被视为一个编译时的常数，并在。\",\"c++中const修饰的变量必须初始化；c语言的const可以不初始化叫常变量\",\"c++中const初始化值为立即数叫常量，可以当数组下标；如果用变量给const初始化的叫常变量，常变量不能当数组下标；\",\"(运行时赋值)\"]},\"485\":{\"h\":\"const修饰的量常见错误\",\"t\":[\"常量不能再作为左值（直接修改常量值）\",\"不能把常量地址泄漏给一个普通指针或者普通引用变量（间接修改常量值）\",\"int main() { const int a = 10; int *p = &a; // error: invalid conversion from ‘const int*’ to ‘int*’ //杜绝*p = 30出现 const int *p = &a; // ok， 保证*p = x;被禁止 } \"]},\"486\":{\"h\":\"const关键字修饰指针\"},\"487\":{\"h\":\"对于指针需要关注两点：\",\"t\":[\"指针指向的变量是什么\",\"指针本身是什么\",\"int value = 2; int value1 = 10; int *p1 = &value1; p1 = &value; *p1 = 20000; \"]},\"488\":{\"h\":\"常量指针和指针常量\",\"t\":[\"常量指针 (const *):不能修改指针所指内容的值，可以改变指针的指向\",\"指针常量 ( * const):可以修改指针所指内容的值， 不可以改变指针的指向\",\"int number1 = 10; int number2 = 20; const int * p1 = &number1;//常量指针，Pointer to const *p1 = 100;//error 通过p1指针无法修改其所指内容的值 p1 = &numbers;//ok 可以改变p1指针的指向 int const * p2 = &number1; //常量指针的第二种写法 int * const p3 = &number1;//指针常量，const pointer *p3 = 100;//ok 通过p3指针可以修改其所指内容的值 p3 = &number2;//error 不可以改变p1指针的指向 const int * const p4 = &number1;//两者皆不能进行修改 \"]},\"489\":{\"h\":\"顶层const和底层const\",\"t\":[\"顶层const：指的是const修饰的变量本身是⼀个常量，⽆法修改，指的是，就是 底层const：指的是const修饰的变量所指向的对象是⼀个常量，指的是，就是 \",\"int a = 10;int* const b1 = &a; //顶层const，b1本身是⼀个常量 const int* b2 = &a; //底层const，b2本身可变，所指的对象是常量 const int b3 = 20; //顶层const，b3是常量不可变 const int* const b4 = &a; //前⼀个const为底层，后⼀个为顶层，b4不可变 const int& b5 = a; //⽤于声明引⽤变量，都是底层const \",\"注意：\",\"const int b3 = 20; b3是所修饰的变量，所以是****\",\"⽤于声明引⽤变量，都是底层const\",\"区分作⽤：\",\"执⾏对象拷⻉时有限制，常量的底层const不能赋值给⾮常量的底层const\",\"使⽤命名的强制类型转换函数const_cast时，只能改变运算对象的底层const（即）\"]},\"490\":{\"h\":\"const与二级（多级）指针结合\",\"t\":[\"实际上没有多级指针，只有一级指针，const int **q => const int * *q，p和*q都指向0x100，==const int **q表示*q（ 0x100）存放的数据类型应该是常量指针类型const int *==🍗🍗🍗\",\"const int **q; // const修饰**q, **q不能被赋值，*q和q可以被赋值 int *const *q; // const修饰*q, *q不能被赋值，**q和 q可被赋值 int **const q; // const修饰q, 只有q不能被赋值 \",\"//错误的例子 int main() { int a = 10; int *p = &a; const int **q = &p; // error, const int ** <= int** // 假如有const int b; *q = &b; 由于*q和p相同，相当于通过p可以间接修改b的值 } \",\"在C++中，int* 可以隐式转换为 const int*，因为这样做增加了对数据的保护，不会改变原有数据的非const性质。但是，int**（指向int指针的指针）和const int**（指向const int指针的指针）之间并不是这种简单的类型兼容关系。\",\"当您尝试将int** p赋值给const int** q时，您实际上是在尝试将一个指向非const指针的指针赋值给一个指向const指针的指针。这两种类型并不兼容，因为q期望的是一个指向const int指针的指针，而p是一个指向可能修改其指向的int值的指针的指针。\",\"换句话说，即使*p（即p所指向的内容）可以被转换为const int*，p本身（即指向int*的指针）也不能被转换为const int**\",\"可修改为如下方可通过编译🍗\",\"int main() // 法一 { int a = 10; const int *p = &a; //p存放的是const int *类型的数据 const int **q = &p; // ok,*q是的类型是const int * } int main() // 法二 { int a = 10; int *p = &a; const int *const*q = &p; // ok，此时*q是常量，*q类型是const int *没有问题 } \"]},\"491\":{\"h\":\"const和指针的类型转换（ 没有约束的可以给有约束的赋值 ）🍗🍗🍗\",\"t\":[\"int* <= const int* // error,因为解引用会修改const的值 const int* <= int* //OK int ** <= const int ** //error const int** <= int** // error int** <= int *const* //error,const与一级指针结合，可转换成 * <= const *判断，即第一种 int *const* <= int** //ok，同第二种情况 \"]},\"492\":{\"h\":\"习题\",\"t\":[\"#include <typeinfo> int *q1 = nullptr; int *const q2 = nullptr;//const修饰的是q2，因此q2不能 cout << typeid(q1).name() << endl; //int* //Pi cout << typeid(q2).name() << endl; //int* //Pi int a = 10; int *p1 = &a; const int *p2 = &a; //const int * <= int *,OK int *const p3 = &a; //int * <= int *,OK int *p4 = p3; //int * <= int *,OK \",\"int a = 10; const int *p = &a; int *q = p; //int * <= const int * ,error \",\"注意辨析：p存放的是a的地址，p又赋值给q，a是变量值可以修改，那q可不可以修改❌\",\"q 和有没有a没有关系，不管是变量地址给p还是常量地址给p,对于编译器来说p存放的就是整型常量的地址const int *\",\"// 例一： int a = 10; const int *p = &a; // int* <= int* int *q = p; // int* <= const int*，error //例二： int a = 10; int *const p = &a; // int* <= int* int *q = p; // int* <= int* ,ok //例三： int a = 10; int *const p = &a; // int* <= int* const int *q = p; // const int* <= int*，OK //例四： int a = 10; int *p = &a; const int **q = &p; // const int ** <= int **,error, *q<=>p //例五： int a = 10; int *p = &a; int **const q = &p; // int** <= int**，OK //例六：🍔🍔🍔 int a = 10; const int *p = &a; int *const* q = &p; //int *const* <= const int**,两个const分开看 //等号左边const修饰*q,const* <= *, OK //因为qcun'cint *类型，int* <= const int * ,error \"]},\"493\":{\"h\":\"函数指针、指针函数、数组指针、指针数组\",\"t\":[\"函数指针：指向函数的指针\",\"指针函数：返回类型是指针的函数\",\"数值指针：指向数组的指针\",\"指针数组：存储类型为指针的数组\",\"//函数指针 指针函数 //int (*pf)(int) int* pf(int) // //数组指针 指针数组 //int (*pArray)[] int* pArray[] \",\"#include <pthread.h> int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg); //void *(*start_routine) (void *) 就是函数指针 \"]},\"494\":{\"h\":\"在 C 语言中，可以通过 函数指针和结构体来模拟多态性\",\"t\":[\"在传统的 C 语言中，没有直接的语言支持来实现面向对象编程中的多态性（polymorphism）。多态性是面向对象编程的一个重要特性，可以通过继承和虚函数来实现。然而，我们可以使用一些技巧来模拟多态性的概念。具体而言，可以通过定义一个包含函数指针的结构体，并使用不同的函数实现来实现多态性的效果。\",\"#include <stdio.h> typedef struct { void (*speak)(void); } Animal; typedef struct { Animal base; const char* name; } Dog; typedef struct { Animal base; const char* name; } Cat; void dogSpeak(void) { printf(\\\"The dog barks.\\\\n\\\"); } void catSpeak(void) { printf(\\\"The cat meows.\\\\n\\\"); } int main() { Dog dog; dog.base.speak = dogSpeak; dog.name = \\\"Tom\\\"; Cat cat; cat.base.speak = catSpeak; cat.name = \\\"Jerry\\\"; Animal* animals[] = { (Animal*)&dog, (Animal*)&cat }; int i; for (i = 0; i < 2; i++) { printf(\\\"%s: \\\", i == 0 ? dog.name : cat.name); animals[i]->speak(); } return 0; } \"]},\"495\":{\"h\":\"const关键字修饰成员函数\",\"t\":[\"const成员函数\"]},\"496\":{\"h\":\"const关键字修饰对象\",\"t\":[\"[对象的组织 | 张威的编程学习笔记 (gitee.io)](https://iszhwei.gitee.io/ccpp/03 类和对象/组织对象.html)\"]},\"497\":{\"h\":\"课堂代码\",\"t\":[\"#include <iostream> using std::cout; using std::endl; //宏定义发生的时机是在预处理阶段,字符串替换,有bug会到运行时才会发现 #define MAX 10 #define multiply(x, y) ((x) * (y)) void test() { //发生时机在编译阶段,会进行类型安全检查,如果有bug在编译时候就会出现 //内置类型：char/short/int/long/double/float/void * const int number = 10;//const修饰的变量称为常量，必须在定义的时候进行初始化 /* number = 20;//赋值,常量不能进行赋值 */ int const number2 = 20; } //函数指针 指针函数 //int (*pf)(int) int* pf(int) // //数组指针 指针数组 //int (*pArray)[] int* pArray[] void test2() { int value = 2; int value1 = 10; int *p1 = &value1; p1 = &value; *p1 = 20000; cout << endl; int value2 = 200; const int *p2 = &value2;//当const位于*左边的时候，常量指针(pointer to const) /* *p2 = 222;//error,不能修改指针所指变量的值 */ p2 = &value;//ok,可以改变指针本身（指向） cout << endl; int value3 = 300; int const *p3 = &value3;//当const位于*左边的时候，常量指针(pointer to const) /* *p3 = 333;//error,不能修改指针所指变量的值 */ p3 = &value;//ok,可以改变指针本身（指向） cout << endl; int value4 = 400; int * const p4 = &value4;//当const位于*右边的时候，指针常量(const pointer) *p4 = 444;//ok,可以修改指针所指变量的值 /* p4 = &value;//error,不可以改变指针本身（指向） */ cout << endl; int value5 = 500; const int * const p5 = &value5;//双const /* *p5 = 555;//error,不可以修改指针所指变量的值 */ /* p5 = &value;//error,不可以改变指针本身（指向） */ } int main(int argc, char **argv) { test2(); return 0; } \"]},\"498\":{\"c\":[\"c/c++\"]},\"499\":{\"c\":[\"c++基础\"]},\"500\":{\"h\":\"inline内联函数\",\"t\":[\"1681304109194-2447f7ce-8687-48ed-932c-a4679599e78c\",\"在C++中，通常定义以下函数来求取两个整数的最大值\",\"int max(int x, int y) { return x > y ? x : y; } \",\"为这么一个小的操作定义一个函数的好处有：\",\"阅读时好理解：阅读和理解函数 max 的调用，要比读一条等价的条件表达式并解释它的含义要容易得多;\",\"修改时好找：如果需要做任何修改，修改函数要比找出并修改每一处等价表达式容易得多;\",\"使用函数可以确保统一的行为，每个测试都保证以相同的方式实现;\",\"方便重用：函数可以重用，不必为其他应用程序重写代码。\",\"虽然有这么多好处，但是写成函数有一个潜在的：调用函数比求解等价表达式要得多。在大多数的机器上，调用函数都要做很多工作：。即对于这种简短的语句使用函数****。\",\"函数调用过程(函数调用过程也被称为函数的开销)：\",\"从右向左先压实参，然后执行call指令，call指令先把call指令的下一行指令的地址入栈，然后进入被调函数，被调函数左括号{先把调用方的栈底地址入栈，然后再给被调函数开辟栈帧，对被调函数的栈帧初始化（gcc/g++只负责开辟栈帧不进行初始化！！！汇编指令可以看到），......\",\"在C语言中，我们使用带参数的宏定义这种借助编译器的优化技术来减少程序的执行时间，那么在C++中有没有相同的技术或者更好的实现方法呢？答案是有的，那就是**内联(inline)函数**。内联函数作为编译器优化手段的一种技术，在降低运行时间上非常有用。\",\"#include <iostream> using std::cout; using std::endl; #define multiply(x, y) ((x) * (y))//带参数宏定义，x,y要看成表达式加(),否则容易出错 /* #define multiply(x, y) x * y */ //a + c * b + d = 3 + 5 * 4 + 6会出错 //普通函数会有参数入栈出栈的开销 //现代的编译器可以自动识别一个函数是不是内联函数 //特点：在函数调用的时候，用函数体去代替函数的调用 inline int add(int x, int y) { return x + y; } int main(int argc, char **argv) { int a = 3, b = 4, c = 5, d = 6; cout << \\\"multiply(a, b) = \\\" << multiply(a, b) << endl; //a + c * b + d = 3 + 5 * 4 + 6 cout << \\\"multiply(a + c, b + d) = \\\" << multiply(a + c, b + d) << endl; cout << \\\"add(a, b) = \\\" << add(a, b) << endl; return 0; } \"]},\"501\":{\"h\":\"什么是内联函数？\",\"t\":[\"内联函数是C++的增强特性之一，用来降低程序的运行时间。\",\"内联函数：在编译过程（非程序运行阶段）中，就没了函数的调用开销了，在函数的调用点直接把函数的代码进行展开处理\",\"inline函数不再生成相应的函数符号\",\"gcc -c main main.cpp -O2 objdump -t main.o \",\"所以可以通过判断有没有生成函数符号，\",\"定义函数时，在函数的最前面以关键字“inline”声明函数，即可使函数称为内联声明函数。\",\"inline int max(int x, y) { return x > y ? x : y; } \"]},\"502\":{\"h\":\"inline内联函数和普通函数的区别🍗🍗🍗\",\"t\":[\"面试中，简单问题不要只回答定义，要从原理上解释\",\"函数调用参数压栈，栈帧的开辟和回退过程，函数调用开销大\",\"inline函数在编译过程中，没有函数调用开销了，在调用点直接把函数代码展开处理了\",\"inline函数不再生成相应的函数符号\",\"inline只是对编译器建议把函数处理成内联函数， 不是所有inline都会被编译器处理成内联函数，如递归，因为不知道展开几次\",\"debug版本（-g）上inline无效，只在release版本可用\",\"普通函数调用需要标准开销，但是内联函数不需要开销；如果这个函数在短时间内大量调用并且这个函数十分简单，我们尽量将其设置为内联函数；内联函数如果内联成功，不会在符号表生成符号。内联函数并不一定能够内联，最终由编译器决定\"]},\"503\":{\"h\":\"内联函数和带参数的宏定义\",\"t\":[\"宏定义没有类型检查\",\"无论是《Effective C++》中的 “Prefer consts，enums，and inlines to #defines” 条款，还是《高质量程序设计指南——C++/C语言》中的“用函数内联取代宏”。在书《高质量程序设计指南——C++/c语言》中这样解释到： \"]},\"504\":{\"h\":\"将内联函数放入头文件\",\"t\":[\"关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。下面的foo函数：\",\"inline void foo(int x, int y);//该语句在头文件中 void foo(int x, int y)//实现在.cpp文件中 { //... } \",\"而正确的姿势如下：\",\"inline void bar(int x, in y)//该语句在头文件中 { //... } \",\"所以说，C++ inline函数是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了 inline 关键字，但我认为 inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。 内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 inline函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。 当然内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它，而且必须为每个源文件拷贝一份定义(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。\",\"//add.h #ifndef __ADD_H__ #define __ADD_H__ //对于内联函数（inline函数）而言，不要分成头文件与实现文件的形式，不能将声明与实现分开 //内联函数一般都是一些小函数，不要去写for/while这些复杂的语句 inline int add(int x, int y); #include \\\"add.cc\\\"//可以使用#include进行包含实现文件 #endif \"]},\"505\":{\"h\":\"谨慎地使用内联\",\"t\":[\"内联能提高函数的执行效率，**为什么不把所有的函数都定义成内联函数？**以下摘自《高质量程序设计指南----C/C++语言》： \"]},\"506\":{\"h\":\"课堂代码\",\"t\":[\"//#include \\\"add.h\\\" inline int add(int x, int y) { return x + y; } \",\"//#include \\\"add.h\\\" #ifndef __ADD_H__ #define __ADD_H__ //对于内联函数（inline函数）而言，不要分成头文件与实现文件的形式 //不能将声明与实现分开 //可以使用#include进行包含实现文件 //内联函数一般都是一些小函数，不要去写for/while这些复杂的语句 inline int add(int x, int y); #include \\\"add.cc\\\" #endif \",\"#include \\\"add.h\\\" #include <iostream> using std::cout; using std::endl; int main(int argc, char **argv) { int a = 3, b = 4; cout << \\\"add(a, b) = \\\" << add(a, b) << endl; return 0; } \"]},\"507\":{\"c\":[\"c/c++\"]},\"508\":{\"c\":[\"c++基础\"]},\"509\":{\"h\":\"new/delete关键字\",\"t\":[\"1681303112683-41ec0262-0bfb-46e8-a571-0e4cd626492a\",\"在C语言中，我们写程序时，总是会有动态开辟内存的需求，每到这个时候我们就会想到用malloc/free 去从堆里面动态申请出来一段内存给我们用。但对这一块申请出来的内存，往往还需要我们对它进行稍许的“加工”后即初始化 才能为我们所用，虽然C语言为我们提供了calloc来开辟一段初始化好（0)的一段内存，但，它同样束手无策。同时，为了保持良好的编程习惯，我们也都应该对申请出来的内存作手动进行初始化。于是到了C++中就有了new/delete, new []/delete[] 。用它们便可实现动态的内存管理。\"]},\"510\":{\"h\":\"开辟一个元素的空间\",\"t\":[\"int *p = new int(1); cout << *p << endl; delete p; p = nullptr; //无论是c还是c++释放内存后要把指针制空，养成好的习惯 \"]},\"511\":{\"h\":\"有几种new的方式\",\"t\":[\"情况1：最常用操作，，抛异常处理内存开辟失败\",\"int *p1 = new int(20);//最常用操作,通过抛出异常判断内存开辟失败 \",\"情况2：\",\"int *p2 = new (nothrow) int;//不抛出异常，开辟失败判断情况与malloc一样 \",\"情况3：堆上开辟常量，\",\"const int *p3 = new const int(40);//在堆上开辟了一个常量 \",\"情况4：\",\"//定位new int data = 0; // 在&data位置分配内存并初始化 int *p4 = new (&data) int(50);//在指定的内存上划分了一块初值为4字节大小的内存，初值为50 \"]},\"512\":{\"h\":\"开辟一个数组的空间\",\"t\":[\"int *p = new int[10]();//开辟数组时，要记得采用[] for(int idx = 0; idx != 10; ++idx) { p[idx] = idx; } delete []p;//回收时，也要采用[]，1.[]写在数组名前，2.[]不要写数组的大小，编译器会自动推断大小，写了反而会报错（和编译器有关） p = nullptr; \"]},\"513\":{\"h\":\"常考题： new/delete表达式与malloc/free的区别是？\",\"t\":[\"相同：1、都是用来申请堆空间的2、malloc与free，new与delete要成对出现，否则可能造成内存泄漏\",\"不同：\",\"malloc与new的区别\",\"①malloc按字节开辟内存的；new开辟内存时需要指定类型；②malloc开辟内存返回的都是void *** ，new相当于运算符重载函数，返回值自动转为指定的类型的指针。**③malloc只负责开辟内存空间，new不仅仅也有malloc功能，还可以进行数据的初始化。④malloc开辟内存失败返回nullptr指针；new抛出的是bad_alloc类型的异常。⑤malloc开辟单个元素内存与数组内存都是给字节数；new开辟时对单个元素内存后面不需要[]，而数组需要[]并给上元素个数。\",\"free和delete的区别：\",\"①free不管释放单个元素内存还是数组内存，只需要传入内存的起始地址即可。②delete释放单个元素内存，不需要加中括号，但释放数据内存时需要加中括号。③delete执行其实有两步，先调用析构，再释放；free只有一步。\"]},\"514\":{\"h\":\"既然new/delete的功能完全覆盖了malloc/free，为什么C++还保留malloc/free呢？\",\"t\":[\"：因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。\"]},\"515\":{\"h\":\"课堂代码\",\"t\":[\"#include <stdlib.h> //memset()的头文件 #include <iostream> using std::cout; using std::endl; void test2() { int number = 10; printf(\\\"sizeof(number) = %lu\\\", sizeof(number)); printf(\\\"sizeof number = %lu\\\", sizeof number);//sizeof是一个运算符，不是一个函数，因为函数不能这么写 } //面试中常问的 //内存溢出？踩内存？内存越界？野指针 // // //面试题 //malloc/free与new/delete异同点？ //1、都是用来申请堆空间的 //2、malloc与free，new与delete要成对出现，否则可能造成内存泄漏 // //不同点： //1、malloc/free是C里面的库函数，new/delete是C++中的表达式 //2、malloc申请的是未初始化的堆空间，new申请是已经初始化的堆空间 void test() { int *pInt = (int *)malloc(sizeof(int));//1、申请堆空间 memset(pInt, 0, sizeof(int));//2、初始化 *pInt = 10;//3、赋值 free(pInt);//4、释放堆空间 /* pInt = NULL;//0 */ pInt = nullptr;//void * int *pArray = (int *)(malloc(sizeof(int) * 10)); memset(pArray, 0, sizeof(int) * 10); free(pArray); pArray = nullptr; } void test3() { int *pInt = new int(10);//1、申请堆空间，并初始化，还可以进行赋值 cout << \\\"*pInt = \\\" << *pInt << endl; delete pInt;//2、释放堆空间 pInt = nullptr; int *pArray = new int[10](); pArray[0] = 120; delete [] pArray; } int main(int argc, char **argv) { cout << \\\"Hello world\\\" << endl; return 0; } \"]},\"516\":{\"h\":\"new和deletea原理\",\"t\":[\" class T{ public: T(){ cout << \\\"构造函数。\\\" << endl; } ~T(){ cout << \\\"析构函数。\\\" << endl; } void * operator new(size_t sz){ T * t = (T*)malloc(sizeof(T)); //operator new就是简单的分配内存即可 cout << \\\"内存分配。\\\" << endl; return t; } void operator delete(void *p){ free(p); cout << \\\"内存释放。\\\" << endl; return; } }; int main() { T * t = new T(); // 先 内存分配 ，再 构造函数 delete t; // 先 析构函数， 再 内存释放 return 0; } \",\"error: ‘nullptr’ was not declared in this scope 解决办法 编译语句中添加-std=c++11，在链接语句不需要添加\",\"g++ -g main.cc -std=c++11 objdump -M intel -S -C a.out #-C 选项用于进行名称修饰 \",\"image-20240202222822996\"]},\"517\":{\"h\":\"new[] 和delete 或者说new和delete[]能混用吗？C++如何区分单个元素和数组内存分配和释放\",\"t\":[\"不能混用，数组new[]时，编译器会在开头多分配4B空间记录new对象的数量\",\"class Test { public: Test(int data = 10) { cout << \\\"Test()\\\" << endl; } ~Test() { cout << \\\"~Test()\\\" << endl; } private: int ma; }; int main() { Test* p1 = new Test[5]; delete[] p1; // 从operator delete(p1-4),即从最顶上存储对象的数量的内存起始地址开始释放 } \",\"在这里插入图片描述\",\"注意返回的地址不是最顶上的地址！！\",\"若混用new[]和delete：\",\"Test* p1 = new Test[5]; // 输出operator new[] addr:0157F6C0 cout << \\\"p1:\\\" << p1 << endl; // p1:0157F6C4 delete p1; \",\"可以看出返回的是p1[0]对象的地址，调用delete p1也只是析构p1[0]对象，不合法，抛出异常\",\"若混用new 和delete[]更好理解，delete[]会传入【new返回的地址-4】来调用析构，这块空间根本就没分配，必然就出错\",\"可以通过重载new和delete来解决内存泄漏\"]},\"518\":{\"h\":\"[深入理解C++ new/delete, new ]/delete[]动态内存管理\",\"t\":[\"在C++ Primer书中有提到说： new/delete的表达式与标准库函数同名了，所以系统并没有重载new或delete表达式。new/delete真正的实现其实是依赖下面这几个内存管理接口的。c++中称之为“placement版”内存管理接口。接口原型：\",\"void * operator new (size_t size); void operator delete (size_t size); void * operator new [](size_t size); void operator delete[] (size_t size); \",\"探究它，不妨从这样一个类AA开始\",\"class AA { public: AA(size_t count = 1) { _a = new int[count]; cout<<\\\"AA()\\\"<<endl; } ~AA() { delete[] _a; cout<<\\\"~AA()\\\"<<endl; } private: int* _a; }; \",\"用AA* pA = new AA[10]创建对象,VS下通过调试进入new表达式内部系统函数,得到下面两个图：\",\"img\",\"img\",\"通过上面两个图，大致可以看出来new表达式并不直接开辟内存出来，而是通过调用operator new来获得的内存，而operator new获得的内存实质上还是用malloc开辟出来的。这便证实了前面所述的：开空间出来还是得 malloc来。\",\"同样的道理，delete表达式也不是直接去释放掉内存。比如对上面的对象数组进行delete\",\"AA* pA = new AA[10]; delete[] pa; \"]},\"519\":{\"h\":\"delete[]实际做了这样几件事情：\",\"t\":[\"依次调用pA指向对象数组中每个对象的析构函数，共10次\",\"调用operator delete[]()，它将再调用operator delete\",\"底层用free执行operator delete表达式，依次释放内存\",\"小结operator new/ operator delete：\",\"operator new/operator delete operator new[]/operator delete[] 和 malloc/free用法一样。\",\"他们只负责分配空间/释放空间，不会调用对象构造函数/析构函数来初始化/清理对象。\",\"实际operator new和operator delete只是malloc和free的一层封装\"]},\"520\":{\"h\":\"new最后将开辟好内存用指针p返回，pA接收它。可为什么p 和pA 会差上4字节？\",\"t\":[\"这其实是因为编译器用相差的这4个字节用来保存一个东西——对象个数，即AA* p = new AA[10] 中的‘10’。这也就不难解释 为什么在delete[] 的时候，不用传给它对象个数。\",\"​ \",\"delete[] 删除时，将new[] 返回的地址再往前移4个字节便可以拿到要析构的对象个数了。\",\"但是注意：new type[] ,只有type显示定义析构函数时，编译器才会多开4字节来保存对象个数。所以像new int、char这样的内置类型编译器不会多开这4字节，编译器自行优化。\",\"它们之间可用下面的图展示：\",\"img\"]},\"521\":{\"h\":\"new/delete, new []/delete[], malloc/free配套使用！\",\"t\":[\"class AA { public: AA(size_t count = 1) { _a = new int[count]; cout<<\\\"AA()\\\"<<endl; } ~AA() { delete[] _a; cout<<\\\"~AA()\\\"<<endl; } private: int* _a; }; \"]},\"522\":{\"h\":\"malloc/delete的组合\",\"t\":[\"void Test1() { AA* p1 = (AA*)malloc(sizeof(AA)); //没有报错，但不建议采用，容易引起混淆 delete p1; AA* p2 = (AA*)malloc(sizeof(AA)); //报错，同上，释放位置也不对 delete[] p2; } \"]},\"523\":{\"h\":\"delete, delete[] 之间误用（值得注意）\",\"t\":[\"void Test2() { AA* p3 = new AA; //不报错，但未清理干净。p3的构造函数开辟的空间没有被释放 free(p3); AA* p4 = new AA[10]; //崩溃卡死，存在问题，释放位置被后移了4字节。同时只调用了一次析构函数 delete p4; ， AA* p5 = new AA; //报错 非法访问内存 delete[] p5; } \",\"①delete p4错误在于释放位置不对（和编译器实现new []的机制有关），导致内存泄漏\",\"img\",\"②delete[] p5 直接就崩了，这次new AA的时候并未多开4字节保存对象个数，编译器便无法知道要调用多少次析构函数（这里仅仅调用一次析构函数就好了）但编译器内部还是试图去访问p5前4字节的内存，以此获得对象个数;这便非法内存访问了，所以程序就挂了。\"]},\"524\":{\"h\":\"针对内置类型\",\"t\":[\"void Test3() { int* p6 = new int[10]; //没问题 delete[] p6; int* p7 = new int[10]; //没问题 delete p7; int* p8 = new int[10]; //没问题 free(p8); } \",\"内存管理内置类型，它们的析构函数其实上是可调可不调的，所以它的实现机制不像前面的new []/delete[]，编译器会自行对处理的数据做记录，然后处理;所以即便是不匹配的使用，它们也没出现什么问题。不仅仅这种内置类型如此，那种无自定义类型析构函数的类对象，这样的用法同样不会表现出什么问题。但即便如此，\"]},\"525\":{\"h\":\"NULL、0、nullptr 区别分析\"},\"526\":{\"h\":\"C的NULL\",\"t\":[\"在C语言中，我们使用NULL表示\",\"int *i = NULL; foo_t *f = NULL; \",\"实际上在C语言中，NULL通常被定义为如下：\",\"#define NULL ((void *)0) //void *指针赋值给int *和foo_t *的指针的时候，隐式转换成相应的类型 \",\"，所以通常情况下，编译器提供的头文件会这样定义NULL：\",\"#ifdef __cplusplus ---简称：cpp c++ 文件 #define NULL 0 #else #define NULL ((void *)0) #endif \"]},\"527\":{\"h\":\"C++的0\",\"t\":[\"因为C++中不能将void *类型的指针隐式转换成其他指针类型，而又为了解决空指针的问题，所以C++中引入0来表示空指针（注：0表示，还是有缺陷不完美），这样就有了类似上面的代码来定义NULL。实际上C++的书都会推荐说C++中更习惯使用0来表示空指针而不是NULL，尽管NULL在C++编译器下就是0。\"]},\"528\":{\"h\":\"为什么C++的书都推荐使用0而不是NULL来表示空指针呢？\",\"t\":[\"我们看一个例子：\",\"在foo.h文件中声明了一个函数：\",\"void bar(sometype1 a, sometype2 *b); \",\"这个函数在a.cpp、b.cpp中调用了，分别是：\",\"a.cpp:\",\"bar(a, b); \",\"b.cpp:\",\"bar(a, 0); \",\"都是正常完美的编译运行。但是突然在某个时候我们功能扩展，需要对bar函数进行扩展，我们使用了，现在foo.h的声明如下：\",\"void bar(sometype1 a, sometype2 *b); void bar(sometype1 a, int i); \",\"这个时候危险了，a.cpp和b.cpp中的调用代码这个时候就不能按照期望的运行了。但是我们很快就会发现b.cpp中的0是整数，也就是在overload resolution的时候，我们知道它调用的是void bar(sometype1 a, int i)这个重载函数，于是我们可以做出如下修改让代码按照期望运行：\",\"bar(a, static_cast<sometype2 *>(0)); --- 我们的游戏项目就遇到这个问题，这样用开起来别扭 \",\"我知道，如果我们一开始就有bar的这两个重载函数的话，我们会在一开始就想办法避免这个问题（不使用重载）或者我们写出正确的调用代码，然而后面的这个重载函数或许是我们几个月或者很长一段时间后加上的话，那我们出错的可能性就会加大了不少。貌似我们现在说道的这些跟C++通常使用0来表示空指针没什么关系，好吧，假设我们的调用代码是这样的：\",\"foo.h\",\"void bar(sometype1 a, sometype2 *b); \",\"a.cpp\",\"bar(a, b); \",\"b.cpp\",\"bar(a, NULL); \",\"当bar的重载函数在后面加上来了之后，我们会发现出错了，但是出错的时候，我们找到b.cpp中的调用代码也很快可能忽略过去了，因为我们用的是NULL空指针啊，应该是调用的void bar(sometype1 a, sometype2 *b)这个重载函数啊。实际上NULL在C++中就是0，写NULL这个反而会让你没那么警觉，因为NULL不够“明显”，而这里如果是使用0来表示空指针，那就会够“明显”，因为0是空指针，它更是一个整形常量。\",\"在C++中，使用0来做为空指针会比使用NULL来做空指针会让你更加警觉。\"]},\"529\":{\"h\":\"C++ 11的nullptr\",\"t\":[\"虽然上面我们说明了0比NULL可以让我们更加警觉，但是我们并没有避免这个问题。这个时候C++ 11的nullptr就很好的解决了这个问题，我们在C++ 11中使用nullptr来表示空指针，这样最早的代码是这样的，\",\"foo.h\",\"void bar(sometype1 a, sometype2 *b); \",\"a.cpp\",\"bar(a, b); \",\"b.cpp\",\"bar(a, nullptr); \",\"在我们后来把bar的重载加上了之后，代码是这样：\",\"foo.h\",\"void bar(sometype1 a, sometype2 *b); void bar(sometype1 a, int i); \",\"a.cpp\",\"bar(a, b); \",\"b.cpp\",\"bar(a, nullptr); \",\"这时候，我们的代码还是能够如预期的一样正确运行。\"]},\"530\":{\"h\":\"在没有C++ 11的nullptr的时候，我们怎么解决避免这个问题呢？\",\"t\":[\"// 定义一个名为 nullptr_t 的类，用于模拟 C++11 中的空指针常量 nullptr class nullptr_t { public: // 转换操作符，将 nullptr_t 转换为任意指针类型 T* template<class T> inline operator T*() const { return 0; } // 转换操作符，将 nullptr_t 转换为类 C 中成员指针类型 T C::* template<class C, class T> inline operator T C::*() const { return 0; } private: // 私有成员函数，禁止取地址操作符&的使用,以避免与普通指针混淆。 void operator&() const; } nullptr = {}; // 创建一个名为 nullptr 的 nullptr_t 类型的实例并初始化为一个匿名对象 \",\"结论：。 cocos2d-x3.0 采用 c++11的新特性了... c++ 二春来了...\"]},\"531\":{\"h\":\"内存溢出、踩内存、内存越界、野指针、悬空指针\",\"t\":[\"\\\"内存溢出\\\"（Memory Overflow）是指程序尝试写入超出其所分配的内存范围的区域，导致数据覆盖或程序崩溃。也可以是指系统中可用内存不足，无法满足程序的内存需求，导致程序运行异常或崩溃。\",\"\\\"踩内存\\\"（Memory Leak）指的是程序在动态分配内存时，没有正确释放已经不需要的内存，导致内存占用不断增加，最终导致程序崩溃或系统资源不足。\",\"\\\"内存越界\\\"（Array Out of Bounds）指的是程序试图访问数组的越界元素（即访问数组中不存在的元素），导致程序异常或崩溃。\",\"野指针：指针定义时未被初始化，它的默认值是随机的。（因为任何指针变量（除了static修饰的指针变量）在被定义的时候是不会被置空的）\",\"悬空指针：指针指向的内存空间已被释放或不再有效，没有及时置空\"]},\"532\":{\"c\":[\"c/c++\"]},\"533\":{\"c\":[\"c++基础\"]},\"534\":{\"h\":\"string\"},\"535\":{\"h\":\"c风格字符串\",\"t\":[\"两种定义字符串方式：\",\"//1.数组定义 char str1[] = {'h', 'e', 'l', 'l', 'o', '\\\\0'};//局部变量，栈空间 char str2[] = \\\"hello\\\"; //结尾自动包含\\\\0,等价于str1 //2.指针定义 char* str3 = \\\"world\\\"; //文字常量区 \",\"数组名char str1[]实际上是char * const str1，只能修改数组值，不能修改指针指向\",\"str2[0] = 'H'; //str2 = nullptr; //error str3[0] = 'W'; //error,说明str3的内容是不可以被修改的， //所以c++写c风格字符串最好写为const char* ,如果在修改内容编译器会报错提示 const char *str3 = \\\"world\\\"; size_t len1 = sizeof(str3); //表示指针地址大小64位为8，32位为4 size_t len2 = strlen(str3); //表示存储字符的个数 //如何测试系统是32位还是64位？ //sizeof(指针) //size_t与int区别 //1. size_t 实际上是unsigned int //2. size_t 具有跨平台的作用 \",\"字符串处理在程序中应用广泛，C风格字符串是以'\\\\0'（空字符）来结尾的字符数组。对字符串进行操作的C函数定义在头文件<string.h>或中。常用的库函数如下：\",\"//字符检查函数(非修改式操作) size_t strlen( const char *str );//返回str的长度，不包括null结束符 //比较lhs和rhs是否相同。lhs等于rhs,返回0; lhs大于rhs，返回正数; lhs小于rhs，返回负数 int strcmp( const char *lhs, const char *rhs ); int strncmp( const char *lhs, const char *rhs, size_t count ); //在str中查找首次出现ch字符的位置；查找不到，返回空指针 char *strchr( const char *str, int ch ); //在str中查找首次出现子串substr的位置；查找不到，返回空指针 char *strstr( const char* str, const char* substr ); //字符控制函数(修改式操作) char *strcpy(char *dest, const char *src);//将src复制给dest，返回dest char *strncpy(char *dest, const char *src, size_t count); char *strcat( char *dest, const char *src );//concatenates two strings char *strncat( char *dest, const char *src, size_t count ); \",\"在使用时，程序员需要考虑字符数组大小的开辟，结尾空字符的处理，使用起来有诸多不便。\",\"void test0() { char str[] = \\\"hello\\\"; char * pstr = \\\"world\\\"; //求取字符串长度 printf(\\\"%d\\\\n\\\", strlen(str)); //字符串拼接 char * ptmp = (char*)malloc(strlen(str) + strlen(pstr) + 1); strcpy(ptmp, str); strcat(ptmp, pstr); printf(\\\"%s\\\\n\\\", ptmp); //查找子串 char * p1 = strstr(ptmp, \\\"world\\\"); free(ptmp); } \",\"注意：c/c++字符串使用的是双引号，数据库中字符串使用的是单引号\"]},\"536\":{\"h\":\"C++风格字符串\",\"t\":[\"C++提供了std::string（后面简写为string）类用于字符串的处理。string类定义在C++头文件中，注意和头文件区分，其实是对C标准库中的<string.h>的封装，其定义的是一些对C风格字符串的处理函数。\",\"尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们。这是因为C风格字符串不仅使用起来不太方便，而且极易引发程序漏洞，是诸多安全问题的根本原因。**与C风格字符串相比，string不必担心内存是否足够、字符串长度，结尾的空白符等等。**string作为一个类出现，其集成的成员操作函数功能强大，几乎能满足所有的需求。从另一个角度上说，完全可以string当成是C++的内置数据类型，放在和int、double等内置类型同等位置上。string类本质上其实是basic_string类模板关于char型的实例化。\",\"#include<string> //包含头文件 using std::string; //使用实体 \",\"我们先来看一个简单的例子：\",\"void test1() { //C风格字符串转换为C++风格字符串 std::string s1 = \\\"hello\\\"; std::string s2(\\\"world\\\"); //求取字符串长度 cout << s1.size() << endl; cout << s1.length() << endl; //字符串的遍历 for(size_t idx = 0; idx != s1.size(); ++idx) { cout << s1[idx] << \\\" \\\"; } cout << endl; //字符串拼接 std::string s3 = s1 + s2; //两个C++字符串拼接 std::string s4 = s1 + \\\"hahaha\\\";//与C字符串拼接 std::string s5 = s1 + 'A';//与字符拼接 s1.append(s2); //s1 = helloworld cout << \\\"s3 = \\\" << s3 << endl; cout << \\\"s4 = \\\" << s4 << endl; cout << \\\"s5 = \\\" << s5 << endl; //查找子串 size_t pos = s1.find(\\\"wor\\\"); //5 //截取子串 std::string substr = s1.substr(pos); cout << \\\"substr = \\\" << substr << endl; //world } \",\"std::string提供了很多方便字符串操作的方法。\"]},\"537\":{\"h\":\"string对象的构造\",\"t\":[\"首先来看一下string类型常用的构造函数\",\"string();//默认构造函数，生成一个空字符串 string(const char * rhs);//通过c风格字符串构造一个string对象 string(const char * rhs, size_type count);//通过rhs的前count个字符构造一个string对象 string(const string & rhs);//复制拷贝构造函数 string(size_type count, char ch);//生成一个string对象，该对象包含count个ch字符 string(InputIt first, InputIt last);//以区间[first, last)内的字符创建一个string对象 \"]},\"538\":{\"h\":\"string与C风格字符串的转换\",\"t\":[\"C风格字符串转换为string字符串相对来说比较简单，通过构造函数即可实现。但由于string字符串实际上是类对象，其并不以空字符'\\\\0'结尾，因此，string字符串向C风格字符串的转化是通过3个成员函数完成的，分别为:\",\"const char *c_str() const;// 返回一个C风格字符串 const char *data() const;// c++11之后与c_str()效果一致 //字符串的内容复制或写入既有的C风格字符串或字符数组内 size_type copy(char* dest, size_type count, size_type pos = 0) const; \"]},\"539\":{\"h\":\"元素遍历和存取\",\"t\":[\"string对象可以使用下标操作符[]和函数at()对字符串中包含的字符进行访问。需要注意的是操作符[]并不检查索引是否有效，如果索引超出范围，会引起未定义的行为。而at()会检查，如果使用at()的时候索引无效，会抛出out_of_range异常。\",\"reference operator[]( size_type pos );// 返回下标为pos的元素 const_reference operator[]( size_type pos ) const;// reference at( size_type pos );// 返回下标为pos的元素 const_reference at( size_type pos ) const;// \",\"除此以外，还可以使用迭代器进行遍历访问\",\"iterator begin(); const_iterator begin() const; iterator end(); const_iterator end() const; reverse_iterator rbegin(); const_reverse_iterator rbegin() const; reverse_iterator rend(); const_reverse_iterator rend() const; \",\"其示意图如下:\",\"img\"]},\"540\":{\"h\":\"字符串的长度和容量相关\",\"t\":[\"bool empty() const; size_type size() const; size_type length() const; size_type capacity() const; size_type max_size() const; \"]},\"541\":{\"h\":\"元素追加和相加\",\"t\":[\"string &operator+=(const string & tr); string &operator+=(CharT ch); string &operator+=(const CharT* s); string &append(size_type count, CharT ch); string &append(const basic_string & str); string &append(const CharT* s); string &append(InputIt first, InputIt last); //以下为非成员函数 string operator+(const string & lhs, const string & rhs); string operator+(const string & lhs, const char* rhs); string operator+(const char* lhs, const string & rhs); string operator+(const string & lhs, char rhs); string operator+(char lhs, const string & rhs); \"]},\"542\":{\"h\":\"提取子串\",\"t\":[\"string substr(size_type pos = 0, size_type count = npos) const; \"]},\"543\":{\"h\":\"元素删除\",\"t\":[\"iterator erase(iterator position); iterator erase(const_iterator position); iterator erase(iterator first, iterator last); \"]},\"544\":{\"h\":\"元素清空\",\"t\":[\"void clear(); \"]},\"545\":{\"h\":\"字符串比较\",\"t\":[\"//非成员函数 bool operator==(const string & lhs, const string & rhs); bool operator!=(const string & lhs, const string & rhs); bool operator>(const string & lhs, const string & rhs); bool operator<(const string & lhs, const string & rhs); bool operator>=(const string & lhs, const string & rhs); bool operator<=(const string & lhs, const string & rhs); \"]},\"546\":{\"h\":\"搜索与查找\",\"t\":[\"//find系列： size_type find(const basic_string & str, size_type pos = 0) const; size_type find(const CharT* s, size_type pos = 0) const; size_type find(const CharT* s, size_type pos, size_type count) const; size_type find(char ch, size_type pos = npos ) const; //rfind系列： size_type rfind(const basic_string & str, size_type pos = 0) const; size_type rfind(const CharT* s, size_type pos = 0) const; size_type rfind(const CharT* s, size_type pos, size_type count) const; size_type rfind(char ch, size_type pos = npos) const; \"]},\"547\":{\"h\":\"课堂代码\",\"t\":[\"#include <string.h>//C的头文件 #include <iostream> #include <string>//C++头文件 using std::cout; using std::endl; using std::string; void test() { //C风格字符串两种定义方式 //1.用数组定义 //char str1[] = {'h', 'e', 'l', 'l', 'o'}; //C风格字符串默认以'\\\\0'结尾 char str1[] = \\\"hello\\\"; char str2[] = \\\"world\\\"; str1[0] = 'H';//const *p1 /* str1 = nullptr;//error, * const */ printf(\\\"str1 = %s\\\\n\\\", str1); //2.用指针定义 const char *pstr = \\\"hello, world\\\"; //debug定位小技巧,多使用printf打印信息 /* printf(\\\"111\\\\n\\\"); */ /* pstr[0] = 'H';//error */ /* printf(\\\"222\\\\n\\\"); */ pstr = nullptr; /* printf(\\\"333\\\\n\\\"); */ /* size_t len2 = sizeof(pstr);//8，指针的大小 */ /* size_t len3 = strlen(pstr);//13，以\\\\0结尾 */ size_t len1 = sizeof(str1); size_t len2 = sizeof(str2); printf(\\\"len1 = %lu\\\\n\\\", len1); printf(\\\"len2 = %lu\\\\n\\\", len2); size_t len = len1 + len2 - 1; char *pstr2 = static_cast<char *>(malloc(len)); memset(pstr2, 0, sizeof(len)); strcpy(pstr2, str1); strcat(pstr2, str2); printf(\\\"pstr2 = %s\\\\n\\\", pstr2); free(pstr2); pstr2 = nullptr; } #if 0 typedef struct A { int ia; char cb; }structAA; structAA a; a.ia = 10; a.cb = 'c'; #endif void test2() { //C++ C string s1 = \\\"hello\\\";//C风格字符串可以转换为C++风格字符串 string s2 = \\\"world\\\"; string s3 = s1 + s2; cout << \\\"s1 = \\\" << s1 << endl << \\\"s2 = \\\" << s2 << endl << \\\"s3 = \\\" << s3 << endl; //从C++风格字符串转换为C风格字符串 cout << endl; const char *pstr = s3.c_str(); cout << \\\"pstr = \\\" << pstr << endl; //C++风格字符串的长度 cout << endl; /* size_t len1 = sizeof(s3);//32，与string的底层实现有关，不同系统不同模型值不同 */ size_t len2 = s3.size(); size_t len3 = s3.length(); /* cout << \\\"len1 = \\\" << len1 << endl; */ cout << \\\"len2 = \\\" << len2 << endl;//10 cout << \\\"len3 = \\\" << len3 << endl;//10 //遍历C++风格字符串 cout << endl; for(size_t idx = 0; idx != len2; ++idx) { cout << s3[idx] << \\\" \\\"; } cout << endl; //C++风格字符串的拼接 cout << endl; string s4 = s3 + \\\"wuhan\\\"; cout << \\\"s4 = \\\" << s4 << endl; cout << endl; string s5 = s4 + 'A'; cout << \\\"s5 = \\\" << s5 << endl; cout << endl; s5.append(s1); cout << \\\"s5 = \\\" << s5 << endl; } int main(int argc, char **argv) { test2(); return 0; } \"]},\"548\":{\"h\":\"实现一个String类\",\"t\":[\"#include <string.h> #include <iostream> using std::cout; using std::endl; class String { public: String() : _pstr(nullptr) /* : _pstr(new char[1]())//ok */ { cout << \\\"String()\\\" << endl; } //pstr = nullptr String(const char *pstr) : _pstr(new char[strlen(pstr) + 1]()) { cout << \\\"String(const char *)\\\" << endl; strcpy(_pstr, pstr); } String(const String & rhs) : _pstr(new char[strlen(rhs._pstr) + 1]()) { cout << \\\"String(const char *)\\\" << endl; strcpy(_pstr, rhs._pstr); } //str1 = str2; String & operator=(const String & rhs) { cout << \\\"String &operator=(const String &)\\\" << endl; if(this != &rhs)//1、自复制 { if(_pstr) { delete [] _pstr;//2、释放左操作数 _pstr = nullptr; } _pstr = new char[strlen(rhs._pstr) + 1]();//3、深拷贝 strcpy(_pstr, rhs._pstr); } return *this;//4、返回*this } ~String() { cout << \\\"~String()\\\" << endl; if(_pstr) { delete [] _pstr; _pstr = nullptr; } } void print() const { if(_pstr) { cout << _pstr << endl; } } private: char * _pstr; }; int main(void) { String str1; str1.print(); #if 1 String str2 = \\\"Hello,world\\\"; String str3(\\\"wangdao\\\"); str2.print(); str3.print(); String str4 = str3; str4.print(); str4 = str2; str4.print(); #endif return 0; } \"]},\"549\":{\"c\":[\"c/c++\"]},\"550\":{\"c\":[\"c++基础\"]},\"551\":{\"h\":\"内存对齐\"},\"552\":{\"h\":\"对齐规则\",\"t\":[\"对齐规则是按照成员的，依次安排内存，其为大小的整数倍，，最后的大小为的整数倍\"]},\"553\":{\"h\":\"为什么要内存对齐？\",\"t\":[\"1.平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 2.性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。 解释二 原因有这么几点： 1、的读取不是连续的，而是的，块的大小只能是1、2、4、8、16 ... 字节；2、总线周期来，因此；3、，否则会。\"]},\"554\":{\"h\":\"内存对齐的三大规则\"},\"555\":{\"h\":\"数据成员对齐规则\",\"t\":[\"结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset(偏移)为0的地方，以后每个数据成员的对齐按照 #pragma pack 指定的数值和这个数据成员自身长度中，比较小的那个进行\"]},\"556\":{\"h\":\"结构(或联合)的整体对齐规则\",\"t\":[\"在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照 #pragma pack 指定的数 值和结构(或联合)最大数据成员长度中，比较小的那个进行。\"]},\"557\":{\"h\":\"结构体作为成员\",\"t\":[\"如果一个结构里有某些结构体成员，则内部结构体成员要从成员最大元素大小的整数倍和 #pragma pack指定的数值中最小的一个的整数倍的地址开始存储。 #pragma pack(n) 对齐系数\",\"#include <iostream> //#pragma pack(8) using std::cout; using std::endl; struct xx { int a1; char b1; short c1; char d1; } MyStructxx; struct y { int b; char a; char d; short c; }MyStruct2; struct EE { int a; char b; short c; struct FF { int a1; char b1; short c1; char d1; }MyStructFF; char d; }MyStructEE; struct DD { int a; char b; short c; int d; struct FF { double a1; char b1; short c1; char d1; }MyStructFF; char e; }MyStructDD;//40 struct GG { char e[2]; short h; struct A { int a; double b; float c; }MyStructA; }MyStructGG;//32 struct SS { int a; char b; short c; int d; struct FF { int a1; char b1; short c1; char d1;//24[20]//21-23空出来,到这里21字节，不是struct里面最大的4的整数倍 }MyStructFF; #if 1 char e;//[24],要4的整数倍,所以25-27为空 //int e; //double ww; #endif }MyStructSS;//28 int main(int argc, char **argv) { cout <<\\\"sizeof(MyStructxx) = \\\" << sizeof(MyStructxx) << endl; cout <<\\\"sizeof(MyStruct1) = \\\" << sizeof(MyStruct1) << endl; cout <<\\\"sizeof(MyStruct2) = \\\" << sizeof(MyStruct2) << endl; cout <<\\\"sizeof(MyStructEE) = \\\" << sizeof(MyStructEE) << endl; cout <<\\\"sizeof(MyStructDD) = \\\" << sizeof(MyStructDD) << endl; //cout <<\\\"sizeof(GG) = \\\" << sizeof(GG) << endl; cout <<\\\"sizeof(MyStructGG) = \\\" << sizeof(MyStructGG) << endl; cout <<\\\"sizeof(MyStructSS) = \\\" << sizeof(MyStructSS) << endl; return 0; } \"]},\"558\":{\"c\":[\"c/c++\"]},\"559\":{\"c\":[\"c++基础\",\"内存对齐\"]},\"560\":{\"h\":\"函数重载\",\"t\":[\"在实际开发中，有时候需要实现几个功能类似的函数，只是细节有所不同。如交换两个变量的值，但这两种变量可以有多种类型，short, int, float等。在C语言中，必须要设计出不同名的函数，其原型类似于：\",\"void swap1(short *, short *); void swap2(int *, int *); void swap3(float *, float *); \",\"但在C++中，这完全没有必要。C++ 允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数重载（Function Overloading）。借助重载，一个函数名可以有多种用途。 函数重载是指在，可以有一组，的函数，这组函数被称为重载函数。重载函数通常用来命名一组功能相似的函数，这样做减少了函数名的数量，避免了名字空间的污染，对于程序的可读性有很大的好处。 C++进行叫名字改编（name mangling），具体的规则是：\",\"函数名称必须相同 。\",\"参数列表必须不同（参数的类型不同、个数不同、顺序不同）。\",\"函数的****。\",\"仅仅返回类型不同不足以成为函数的重载。\"]},\"561\":{\"h\":\"关注重点🍖🍖🍖\"},\"562\":{\"h\":\"c++为什么支持函数重载，c语言不支持函数重载？\",\"t\":[\"c++代码在产生函数符号的时候，是由组成的\",\"c代码产生函数符号的时候，仅由决定！\",\"由于编译产生符号的规则不同，因此c语言不支持函数重载 \",\"c++代码用c语言编译器编译会出现链接错误\",\"其最主要原因是编译器产生代码的规则不同。C++下我们可以编译通过它，但是C下面却不行。主要原因是C++代码在产生函数符号时候，由函数名 + 参数列表类型组成的，参数列表不同，编译时产生不同的符号；C代码在产生函数符号时，符号只由函数名决定，链接时会产生链接错误，。\"]},\"563\":{\"h\":\"函数重载需要注意什么？\",\"t\":[\"函数重载一定要先处于同一作用域中\",\"bool compare(int a, int b) // compare_int_int { cout << \\\"compare_int_int\\\" << endl; return a > b; } bool compare(double a, double b) // compare_double_double { cout << \\\"compare_double_double\\\" << endl; return a > b; } bool compare(const char *a, const char *b) // compare_const char*_const char* { cout << \\\"compare_char*_char*\\\" << endl; return strcmp(a, b) > 0; } int main() { bool compare(int a, int b); // 函数的声明,导致编译器不会去外面找别的compare定义， compare(10, 20); // call compare_int_int compare(10.0, 20.0); // double -> int compare(\\\"aaa\\\", \\\"bbb\\\"); // const char* => int，error！！！ return 0; } \",\"函数名称必须相同 ，参数列表必须不同（参数的类型不同、个数不同、顺序不同）\",\"const 和volatile 的情况会影响形参类型(后面会涉及 )\",\"#include <typeinfo> //typeid() //虽然第二个函数的参数中包含了const修饰符，但是在函数参数中const修饰符并不影响函数的签名，因此两个函数的参数列表是相同的，会被视为重定义 void func(int *a) {} // int void func(int *const a) {} // 错误，重定义 //下面的是函数重载，因为参数列表不同 //虽然都是指向int类型的指针，但第二个函数的参数是指向常量int的指针，因此参数列表不同 void func(int *a); //_Z4funcPi void func(const int *a); //_Z4funcPKi int main() { int a = 10; const int b = 10; cout << typeid(a).name() << endl; // int cout << typeid(b).name() << endl; // int return 0; } \",\"仅仅返回类型不同不是函数重载\",\"因为函数符号的生成与返回值没有关系\"]},\"564\":{\"h\":\"什么是多态（一个东西有多种多样的形态）/怎么理解多态？\",\"t\":[\"静态多态（编译时）：函数重载、模板\",\"动态多态（运行时）\"]},\"565\":{\"h\":\"c++和c语言代码之间如何相互调用？\",\"t\":[\"在linux上测试时，c文件链接用gcc,c++文件用g++，不然没效果\"]},\"566\":{\"h\":\"C++调用C函数\"},\"567\":{\"h\":\"如果c代码明确表示用c方式编译\",\"t\":[\"// main.cpp extern \\\"C\\\"{ int sum(int a, int b); } int main() { int ret = sum(10, 20); cout << \\\"ret = \\\" << ret << endl; return 0; } // test.c extern \\\"C\\\" { int sum(int a, int b) { return a + b; } } \",\"g++ test.c main.cc -o main \"]},\"568\":{\"h\":\"已经使用c编译方式编译成了可重定向的文件\",\"t\":[\"因为C++中函数声明生成符号带参数类型，而C文件中函数生成符号不带参数类型，两者不匹配，故在函数声明处加extern \\\"C \\\"：\",\"// main.cpp extern \\\"C\\\"{ int sum(int a, int b); } int main() { int ret = sum(10, 20); cout << \\\"ret = \\\" << ret << endl; return 0; } // test.c int sum(int a, int b) { return a + b; } \",\"可看出此时以C方式生成符号。再对test.c 编译得到目标文件并查看目标文件符号表\",\"g++ -c main.cpp #main.o gcc -c test.c #test.o g++ mian.o test.o -o main #使用g++链接 \",\"注意：\",\"g++ -c main.cpp test.c #这样写会导致test.c会按照c++方式编译成test.o \"]},\"569\":{\"h\":\"直接使用c++兼容c\",\"t\":[\"// main.cc #include <iostream> using std::cout; using std::endl; int sum(int a, int b); // 去掉extern \\\"C\\\"声明 int main() { int ret = sum(10, 20); cout << \\\"ret = \\\" << ret << endl; return 0; } // test.c int sum(int a, int b) { return a + b; } \",\"g++ test.c main.cc -o main \"]},\"570\":{\"h\":\"C调用C++的函数代码\",\"t\":[\"即函数定义写在cpp文件中\",\"// main.cpp extern \\\"C\\\" { int sum(int a, int b) { return a + b; } } // test.c #include <stdio.h> int sum(int, int); int main() { int ret = sum(10, 20); printf(\\\"ret = %d\\\\n\\\", ret); return 0; } \",\"编译执行成功：\",\"gcc -o main main.cpp test.c \",\"如果不把定义放在extern \\\"C\\\"中则提示：\",\"image-20240201150931334\",\"注意：这个extern \\\"C\\\"是写在cpp文件中的！！！！\",\"补充：\",\"#ifdef __cplusplus extern \\\"C\\\" { #endif int sum(int a, int b) // sum .text { return a + b; } #ifdef __cplusplus } #endif \",\"C++编译器都内置了__cplusplus宏名，保证了若是以C++编译该该代码，可以保证以C方式生成符号，使得不管是在C还是C++文件中定义该函数，都能够在C文件中使用该函数。\"]},\"571\":{\"h\":\"课堂代码\",\"t\":[\"#include <stdlib.h> #include <string.h> #include <iostream> using std::cout; using std::endl; //C++支持函数重载，C语言不支持函数重载 //函数重载原理：对函数名字做了改编(name mangling) //函数重载步骤：在同一个作用域中，当函数名字相同的时候，根据参数的 //个数、顺序、类型对函数名字进行改编 #ifdef __cplusplus//C和C++的混合编程 extern \\\"C\\\" { #endif int add(int x, int y) { return x + y; } #ifdef __cplusplus }//end of extern \\\"C\\\" #endif int add(int x, int y, int z) { return x + y + z; } float add(float x, float y) { return x + y; } float add(float x, float y, float z) { return x + y + z; } float add(float x, int y, float z) { return x + y + z; } int main(int argc, char **argv) { int *pInt = static_cast<int *>(malloc(sizeof(int))); memset(pInt, 0, sizeof(int)); free(pInt); pInt = nullptr; return 0; } \"]},\"572\":{\"h\":\"nm 查看二进制文件\",\"t\":[\"$gcc -c add.cc #生成add.o的二进制文件 $file add.o#查看文件信息 add.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped#ELF 二进制文件 $file add.cc add.cc: C++ source, UTF-8 Unicode text #对于二进制文件不能用vi看（看不懂），需要用nm查看 $nm add.o 0000000000000000 T add #以c语言的方式编译的int add(int x, int y) U __cxa_atexit U __dso_handle U free U _GLOBAL_OFFSET_TABLE_ 0000000000000127 t _GLOBAL__sub_I_add 0000000000000090 T main U malloc U memset 0000000000000030 T _Z3addff #c++,根据参数的个数、顺序、类型对函数名字进行改编 000000000000004a T _Z3addfff 000000000000006e T _Z3addfif 0000000000000014 T _Z3addiii 00000000000000de t _Z41__static_initialization_and_destruction_0ii U _ZNSt8ios_base4InitC1Ev U _ZNSt8ios_base4InitD1Ev 0000000000000000 r _ZStL19piecewise_construct 0000000000000000 b _ZStL8__ioinit \"]},\"573\":{\"h\":\"extern 和extern\\\"C\\\"关键字\"},\"574\":{\"h\":\"extern关键字\",\"t\":[\"外部变量（全局变量）extern----全局静态存储区\",\"extern 可以声明一个变量，作用是用来说明“此变量/函数是在别处定义的，要在此处引用”\",\"定义：表示创建变量或分配存储单元\",\"声明：说明变量的性质，但并不分配存储单元\",\"头文件中只存放“”，而不存放“定义”\",\"int a = 10;如果这个头文件被多次引用的话，a会被重复定义\",\"也不要在头文件中定义函数，只写函数声明；\",\"extern int i; //用于变量的声明，没有分配内存 int i; //注意，这是定义 \"]},\"575\":{\"h\":\"extern 的使用场景1\",\"t\":[\"比如：创建两个文件 test.c 和 main.c文件；在test.c文件中定义一个全局变量：\",\"//test.c int i = 20; //定义一个全局变量 \",\"//main.c文件 #include<stdio.h> extern int i; //声明变量i，当编译链接时候，main.c文件就可以访问到test.c文件的i的值了； int main() { printf(\\\"%d\\\",i); return 0; } \"]},\"576\":{\"h\":\"extern 的使用场景2\",\"t\":[\"但是上述的使用方式并不好，假如我一个大工程，多个文件都要访问test.c文件的变量 i，只能在这些文件的都声明变量 i，有好多其他变量呢？这会使得书写难度很繁琐，并且维护成本也大；\",\"所以一般，我们都把声明语句放到头文件使用，即我定义一个test.h的头文件；\",\"//test.h extern int i; extern int j; extern int k; //... //声明很多很多变量 \",\"然后，假如你在其他文件要使用改变量i，直接包含该头文件即可，\",\"# include<stdio.h> # include\\\"test.h\\\" //extern int i; 不用写了 //extern int j;不用写了 //extern int k;不用写了 //... //声明很多很多变量,都不用写了，因为包含了头文件，声明都在头文件中 int main() { printf(\\\"%d %d %d\\\",i,j,k); return 0; } \"]},\"577\":{\"h\":\"extern “C” 的理解和用法\",\"t\":[\"加上extern \\\"C\\\"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中；而C语言并不支持函数重载，因此。\",\"这个功能主要用在下面的情况：\",\"C++代码调用C语言代码\",\"在C++的头文件中使用\",\"在多个人协同开发时，可能有的人比较擅长C语言，而有的人擅长C++，这样的情况下也会有用到\",\"#ifndef __INCvxWorksh /*防止该头文件被重复引用*/ #define __INCvxWorksh #ifdef __cplusplus //告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的 extern \\\"C\\\"{ //C要大写 #endif #include\\\"test.h\\\"//c编写的代码 /*…*/ //被extern \\\"C\\\"限定的函数或变量是extern类型的 #ifdef __cplusplus } #endif #endif /*end of __INCvxWorksh*/ \",\"注意：\"]},\"578\":{\"h\":\"未加extern \\\"C\\\"声明\",\"t\":[\"//模块A头文件 moduleA.h #idndef _MODULE_A_H #define _MODULE_A_H int foo(int x, int y); #endif \",\"//模块B实现文件 moduleB.cpp #include\\\"moduleA.h\\\" foo(2,3); \",\"实际上，，因此会出现链接错误（g++不会报错）。\",\"在C++代码中，包含纯C的头文件而没有显式使用 extern \\\"C\\\" 并不一定会导致编译错误。这是因为C++编译器通常能够正确处理C语言的函数声明，即便缺少 extern \\\"C\\\" 包装。\",\"C++编译器在处理纯C头文件时，会默认按照C的链接规范进行处理。这是因为C++的链接规范与C的规范在很多方面是相似的。因此，对于纯C的函数声明，通常不需要显式使用 extern \\\"C\\\"。\",\"然而，显式地使用 extern \\\"C\\\" 是为了确保在更多情况下的兼容性。特别是在一些复杂的场景或者涉及到C++和C混合编程的时候，最好添加 extern \\\"C\\\" 来确保正确的链接规范。\",\"总的来说，虽然未加 extern \\\"C\\\" 声明不会导致编译错误，但在混合使用C和C++的情况下，最好使用 extern \\\"C\\\" 来确保正确的链接规范，以避免潜在的问题。\"]},\"579\":{\"c\":[\"c/c++\"]},\"580\":{\"c\":[\"c++基础\"]},\"581\":{\"h\":\"命名空间\",\"t\":[\"image-20240101150131801\"]},\"582\":{\"h\":\"为什么要使用命名空间？\",\"t\":[\"一个大型的工程往往是由若干个人独立完成的，不同的人分别完成不同的部分，最后再组合成一个完整的程序。由于各个头文件是由不同的人设计的，有可能在不同的头文件中用了相同的名字来命名所定义的类或函数，这样在程序中就会出现名字冲突。不仅如此，有可能我们自己定义的名字会与C++库中的名字发生冲突。\",\"名字冲突就是在同一个作用域中有两个或多个同名的实体，为了解决 ，C++中引入了命名空间，所谓命名空间就是一个可以由用户自己定义的作用域，在不同的作用域中可以定义相同名字的变量，互不干扰，系统能够区分它们。\"]},\"583\":{\"h\":\"什么是命名空间\",\"t\":[\"命名空间又称为名字空间，是程序员命名的，程序员根据需要指定一些有名字的空间域，把一些全局实体分别存放到各个命名空间中，从而与其他全局实体分隔开。通俗的说，每个名字空间都是一个名字空间域，存放在名字空间域中的全局实体只在本空间域内有效。名字空间对全局实体加以域的限制，从而合理的解决命名冲突。\"]},\"584\":{\"h\":\"基本格式\",\"t\":[\"C++中定义命名空间的基本格式如下：\",\"namespace wd { int val1 = 0; //不需要table,直接正常顶格写 char val2; }// end of namespace wd //不需要写; \",\"不需要写;,写了相当于执行一句空语句\"]},\"585\":{\"h\":\"存放的类型\",\"t\":[\"在声明一个命名空间时，大括号内不仅可以存放变量，还可以存放以下类型：\",\"常量\",\"变量\",\"函数，可以是定义或声明\",\"结构体\",\"类\",\"模板\",\"命名空间，可以嵌套定义\",\" namespace wd { int number = 0; struct Foo { char ch; int val; }; void display(); }// end of namespace wd \"]},\"586\":{\"h\":\"可见域\",\"t\":[\"定义在名称空间中的变量或者函数都称为实体，名称空间中的实体作用域是全局的, 并不意味着其可见域是全局的。\",\"如果不使用作用域限定符和using机制，抛开名称空间嵌套和内部屏蔽的情况，实体的可见域是从实体创建到该名称空间结束。在名称空间外，该实体是不可见的。\"]},\"587\":{\"h\":\"命名空间的使用方式\",\"t\":[\"命名空间一共有三种使用方式，分别是using编译指令、作用域限定符、using声明机制\"]},\"588\":{\"h\":\"using编译指令\",\"t\":[\"我们接触的第一个C++程序基本上都是这样的，其中std代表的是标准命名空间。\",\"#include <iostream> using namespace std; //using编译指令 int main(int argc, char *argv[]) { cout << \\\"hell,world\\\" << endl; return 0; } \",\"其中第二行就使用了using编译指令。如果一个名称空间中有多个实体，使用using编译指令，就会把该空间中的所有实体一次性引入到程序之中；对于初学者来说，如果对一个命名空间中的实体并不熟悉时，直接使用这种方式，有可能还是会造成名字冲突的问题，而且出现错误之后，还不好查找错误的原因，比如下面的程序就会报错，当然该错误是人为造成的。\",\"#include <iostream> using namespace std; double cout() //error 代码二义性 { return 1.1; } int main(void) { cout(); //error 代码二义性 return 0; } \"]},\"589\":{\"h\":\"作用域限定符\",\"t\":[\"第二种方式就是直接使用作用域限定符::啦。每次要使用某个名称空间中的实体时，都直接加上，例如：\",\"namespace wd { int number = 10; void display() { //cout,endl都是std空间中的实体，所以都加上'std::'命名空间 std::cout << \\\"wd::display()\\\" << std::endl; } }//end of namespace wd int main(void) { std::cout << \\\"wd::number = \\\" << wd::number << endl; wd::display(); } \",\"这种方式会显得比较冗余，所以还可以采用第三种使用方式。\"]},\"590\":{\"h\":\"using声明机制👍\",\"t\":[\"using声明机制的作用域是从using语句开始，到using所在的作用域结束。。\",\"#include <iostream> using std::cout; //using声明机制 using std::endl; namespace wd { int number = 10; void display() { cout << \\\"wd::display()\\\" << endl; } }//end of namespace wd using wd::number; using wd::display; int main(void) { cout << \\\"wd::number = \\\" << number << endl; \",\"创建全局变量和全局函数的时候:\",\"将自己的全局变量和全局函数放到\"]},\"591\":{\"h\":\"匿名命名空间\",\"t\":[\"命名空间还可以不定义名字，不定义名字的命名空间称为匿名命名空间。由于，该空间中的实体，，它只能在本文件的作用域内有效，它的作用域是从匿名命名空间声明开始到本文件结束。在本文件使用无名命名空间成员时不必用命名空间限定。其实匿名命名空间和static是同样的道理，都是只在本文件内有效，无法被其它文件引用。\",\"namespace { int val1 = 10; void func(); }//end of anonymous namespace \",\"在匿名空间中创建的全局变量，具有全局生存期，却只能被本文件空间内的函数等访问，。\",\"匿名命名空间的本质是什么？就是将命名空间的名字符号给去掉，让其他文件找不到。\",\"C++ 新的标准中提倡使用匿名命名空间，而不推荐使用static，因为static用在不同的地方，涵义不同，容易造成混淆。另外，static不能修饰class。\"]},\"592\":{\"h\":\"命名空间的嵌套及覆盖\",\"t\":[\"int number = 1; namespace wd { int number = 10; namespace wh //嵌套 { int number = 100; void display() { cout << \\\"wd::wh::display()\\\" << endl; } }//end of namespace wh void display(int number) { cout << \\\"形参number = \\\" << number << endl; //20 cout << \\\"wd命名空间中的number = \\\" << wd::number << endl; //10 cout << \\\"wh命名空间中的number = \\\" << wd::wh::number << endl; //100 cout << \\\"全局number = \\\" << ::number << endl; //1 } }//end of namespace wd int main(void) { using wd::display; display(20); return 0; } \"]},\"593\":{\"h\":\"对命名空间的思考和总结\",\"t\":[\"下面引用当前流行的名称空间使用指导原则：\",\"提倡已命名的，而不是直接定义外部全局变量或者静态全局变量。\",\"如果开发了一个或者，提倡将其放在一个名称空间中。\",\"对于using 声明，首先将其作用域设置为局部而不是全局(临近使用的地方声明)\",\"不要在头文件中使用using编译指令，这样，使得可用名称变得模糊，容易出现二义性，\",\"包含头文件的顺序可能会影响程序的行为，如果非要使用using编译指令，建议放在所有#include预编译指令后。\"]},\"594\":{\"h\":\"课内代码\",\"t\":[\"#include <iostream> using namespace std; #if 0 //注释方法 void HWprint() { } void HFCPPProjectPrint() { } #endif namespace wd { //命名空间中可以定义变量、函数、结构体、命名空间，统称为实体 int number = 10; void print() { cout << \\\"void print()\\\" << endl; } }//end of namespace wd /* ; */ int main(int argc, char **argv) { cout << \\\"number = \\\" << wd::number << endl;//作用域限定符 wd::print(); return 0; } \",\"#include <iostream> using namespace std;//1、using编译指令,可以将命名空间中的实体全部引出来 //自定义的实体与命名空间中的实体冲突 int cout() { return 10; } int main(int argc, char **argv) { cout(); return 0; } \",\"#include <iostream> /* using namespace std;//1、using编译指令,可以将命名空间中的实体全部引出来 */ namespace wd { //命名空间中可以定义变量、函数、结构体、命名空间，统称为实体 int number = 10; void print() { std::cout << \\\"void print()\\\" << std::endl; } }//end of namespace //2、命名空间+作用域限定符的形式，即使自定义的实体命名空间中的 //实体冲突，一样没有影响 void cout(int x, int y) { std::cout << \\\"x = \\\" << x << \\\", y = \\\" << y << std::endl; } int main(int argc, char **argv) { std::cout << \\\"number = \\\" << wd::number << std::endl;//作用域限定符 wd::print(); cout(3, 5); return 0; } \",\"/*using 声明机制*/ #include <iostream> using std::cout;//3、using声明机制,一次只引出一个实体 using std::endl;//推荐使用这种 namespace wd { //命名空间中可以定义变量、函数、结构体、命名空间，统称为实体 int number = 10; void print() { cout << \\\"void print()\\\" << endl; } }//end of namespace int main(int argc, char **argv) { cout << \\\"number = \\\" << wd::number << endl;//作用域限定符 wd::print(); return 0; } \",\"/*命名空间是可以进行扩展的,结构体是不能进行扩展的*/ #include <iostream> using std::cout; using std::endl; //标准命名空间可以进行扩展 //有可能会与std中的实体冲突，一般不建议进行扩展(标准命名空间中的实体一般都是小写) namespace std { struct MyStruct { int ia = 0; }; }//end of namespace std #if 0 //结构体是不能进行扩展的 struct A { int ia; }; struct A { int ib; }; #endif //命名空间是可以进行扩展的 //带命名空间的函数声明 namespace wd { void print(); } namespace hb { int number = 20; void show() { cout << \\\"void show()\\\" << endl; } void display() { cout << \\\"void display()\\\" << endl; wd::print(); } }//end of namespace hb namespace wd { int number = 10; void print() { cout << \\\"void print()\\\" << endl; hb::show(); } }//end of namespace int main(int argc, char **argv) { cout << \\\"number = \\\" << wd::number << endl;//作用域限定符 wd::print(); return 0; } \",\"#include <stdio.h> #include <iostream> using std::cout; using std::endl; int number = 1; namespace wd { int number = 10; void print(int number) { cout << \\\"形参number = \\\" << number << endl; cout << \\\"命名空间中number = \\\" << wd::number << endl; cout << \\\"全局number = \\\" << ::number << endl;//匿名命名空间 printf(\\\"helloworld\\\\n\\\"); //没有重名,可以直接写,不需要加匿名空间作用域限定符 ::printf(\\\"helloworld\\\\n\\\"); } //命名空间是可以嵌套的 namespace wh { int number = 200; } }//end of namespace int main(int argc, char **argv) { wd::print(20); cout << \\\"wh::number = \\\" << wd::wh::number << endl; return 0; } \"]},\"595\":{\"c\":[\"c/c++\"]},\"596\":{\"c\":[\"c++基础\"]},\"597\":{\"h\":\"异常安全--当出现异常时，要保证程序是安全的(预判错误)\",\"t\":[\"1681304184845-87c43f84-fc0b-472f-ac86-2c5c6dfa9716\",\"程序的错误大致可以分为三种，分别是语法错误、逻辑错误和运行时错误：\",\"语法错误在编译和链接阶段就能发现，只有 100% 符合语法规则的代码才能生成可执行程序。语法错误是最容易发现、最容易定位、最容易排除的错误，程序员最不需要担心的就是这种错误。\",\"逻辑错误是说我们编写的代码思路有问题，不能够达到最终的目标，这种错误可以通过调试来解决。\",\"运行时错误是指程序在运行期间发生的错误，例如除数为 0、内存分配失败、数组越界、文件不存在等。。\",\"运行时错误如果放任不管，系统就会执行默认的操作，终止程序运行，也就是我们常说的程序崩溃（Crash）。C++ 提供了异常（Exception）机制，让我们能够捕获运行时错误，给程序一次“起死回生”的机会，或者至少告诉用户发生了什么再终止程序。\",\"#include <iostream> #include <string> using namespace std; int main(){ string str = \\\"http://c.biancheng.net\\\"; char ch1 = str[100]; //下标越界，ch1为垃圾值 cout<<ch1<<endl; char ch2 = str.at(100); //下标越界，抛出异常 cout<<ch2<<endl; return 0; } \",\"运行代码，在控制台输出 ch1 的值后程序崩溃。下面我们来分析一下原因。 at() 是 string 类的一个成员函数，它会根据下标来返回字符串的一个字符。与[ ]不同，at() 会检查下标是否越界，如果越界就抛出一个异常；而[ ]不做检查，不管下标是多少都会照常访问。\",\"所谓抛出异常，就是报告一个运行时错误，程序员可以根据错误信息来进一步处理。\",\"上面的代码中，下标 100 显然超出了字符串 str 的长度。由于str[100]不会检查下标越界，虽然有逻辑错误，但是程序能够正常运行。而str.at(100)则不同，at() 函数检测到下标越界会抛出一个异常，这个异常可以由程序员处理，但是我们在代码中并没有处理，所以系统只能执行默认的操作，也即终止程序执行。\"]},\"598\":{\"h\":\"异常出现之前/c语言 处理错误的方式\",\"t\":[\"在C语言的世界中，对错误的处理总是围绕着两种方法：一是使用整型的返回值标识错误；二是使用errno宏（可以简单的理解为一个全局整型变量）去记录错误。当然C++中仍然是可以用这两种方法的。\",\"这两种方法最大的就是会出现不一致问题。例如有些函数返回1表示成功，返回0表示出错；而有些函数返回0表示成功，返回非0表示出错。 还有一个缺点就是函数的返回值只有一个，你通过函数的返回值表示错误代码，那么函数就不能返回其他的值。当然，你也可以通过指针或者C++的引用来返回另外的值，但是这样可能会令你的程序略微晦涩难懂。\"]},\"599\":{\"h\":\"捕获异常\",\"t\":[\"我们可以借助 C++ 异常机制来捕获上面的异常，避免程序崩溃。捕获异常的语法为：try...catch语句块的catch可以有多个，但至少要有一个。\",\"try{ // 可能抛出异常的语句 }catch(异常类型){ //int double …… // 处理异常的语句 }catch(exceptionType variable1){ // 处理异常的语句 }catch(exceptionType variable2){ // 处理异常的语句 } //类比switch case \",\"try和catch都是 C++ 中的关键字，后跟语句块，不能省略{ }。try 中包含可能会抛出异常的语句，一旦有异常抛出就会被后面的 catch 捕获。从 try 的意思可以看出，它只是“检测”语句块有没有异常，如果没有发生异常，它就“检测”不到。catch 是“抓住”的意思，用来捕获并处理 try 检测到的异常；如果 try 语句块没有检测到异常（没有异常抛出），那么就不会执行 catch 中的语句。\",\"catch 关键字后面的exceptionType variable指明了当前 catch 可以处理的异常类型，以及具体的出错信息。\",\"#include <iostream> #include <string> #include <exception> using namespace std; int main(){ string str = \\\"http://c.biancheng.net\\\"; try{ char ch1 = str[100]; cout<<ch1<<endl; }catch(exception e){ cout<<\\\"[1]out of bound!\\\"<<endl; } try{ char ch2 = str.at(100); cout<<ch2<<endl; }catch(exception &e){ //exception类位于<exception>头文件中 cout<<\\\"[2]out of bound!\\\"<<endl; } return 0; } \",\"运行结果： 可以看出，第一个 try 没有捕获到异常，输出了一个没有意义的字符（垃圾值）。因为[ ]不会检查下标越界，不会抛出异常，所以即使有错误，try 也检测不到。换句话说，发生异常时必须将异常明确地抛出，try 才能检测到；如果不抛出来，即使有异常 try 也检测不到。所谓抛出异常，就是明确地告诉程序发生了什么错误。 第二个 try 检测到了异常，并交给 catch 处理，执行 catch 中的语句。需要说明的是，异常一旦抛出，会立刻被 try 检测到，并且不会再执行异常点（异常发生位置）后面的语句。本例中抛出异常的位置是第 17 行的 at() 函数，它后面的 cout 语句就不会再被执行，所以看不到它的输出。 说得直接一点，检测到异常后程序的执行流会发生跳转，从异常点跳转到 catch 所在的位置，位于异常点之后的、并且在当前 try 块内的语句就都不会再执行了；即使 catch 语句成功地处理了错误，程序的执行流也不会再回退到异常点，所以这些语句永远都没有执行的机会了。本例中，第 18 行代码就是被跳过的代码。\",\"执行完 catch 块所包含的代码后，程序会继续执行 catch 块后面的代码，就恢复了正常的执行流。\",\"关于「如何抛出异常」异常的处理流程：\",\"抛出（Throw）--> 检测（Try） --> 捕获（Catch） \",\"try...catch语句块的catch可以有多个，但至少要有一个。\"]},\"600\":{\"h\":\"发生异常的位置--throw表达式\",\"t\":[\"异常可以发生在当前的 try 块中，也可以发生在 try 块所调用的某个函数中，或者是所调用的函数又调用了另外的一个函数，这个另外的函数中发生了异常。这些异常，都可以被 try 检测到。\",\"throw+表达式, 如:\",\"throw “the input is error.”;//抛出const char* 的异常类型 throw 1;//抛出int型的异常类型 throw runtime_error(“Data must refer to ISBN”);//抛出runtime_error类类型的异常类型，其中runtime_error是一个标准的异常处理 \"]},\"601\":{\"h\":\"发生异常的位置\",\"t\":[\"try 块中直接发生的异常：\",\"#include <iostream> #include <string> #include <exception> using namespace std; int main(){ try{ throw \\\"Unknown Exception\\\"; //抛出const char*类型的异常 cout<<\\\"This statement will not be executed.\\\"<<endl; }catch(const char* &e){//抓取 异常类型 ，获取异常信息 cout<<e<<endl; } return 0; } \",\"Unknown Exception \",\"#include <iostream> using namespace std; void test() { double x, y; cin >> x >> y; try { if(0 == y) { throw y; //double } else { cout << (x / y) << endl; } } catch(double d) { cout << \\\"catch(double)\\\" << endl; } catch(int e) { cout << \\\"catch(int)\\\" << endl; } } int main() { test(); return 0; } \",\"1681217280598-bdb7d4b4-bd17-4ebd-b18c-d2f8037978a4\",\"下面的例子演示了 try 块中调用的某个函数中发生了异常：\",\"#include <iostream> #include <string> #include <exception> using namespace std; void func(){ throw \\\"Unknown Exception\\\"; //抛出const char*异常 cout<<\\\"[1]This statement will not be executed.\\\"<<endl; } int main(){ try{ func(); cout<<\\\"[2]This statement will not be executed.\\\"<<endl; }catch(const char* &e){ cout<<e<<endl; } return 0; } \",\"运行结果：\",\"Unknown Exception \",\"func() 在 try 块中被调用，它抛出的异常会被 try 检测到，进而被 catch 捕获。从运行结果可以看出，func() 中的 cout 和 try 中的 cout 都没有被执行。\",\"try 块中调用了某个函数，该函数又调用了另外的一个函数，这个另外的函数抛出了异常：\",\"#include <iostream> #include <string> #include <exception> using namespace std; void func(){ throw \\\"Unknown Exception\\\"; //抛出异常 cout<<\\\"[1]This statement will not be executed.\\\"<<endl; } int main(){ try{ func(); cout<<\\\"[2]This statement will not be executed.\\\"<<endl; }catch(const char* &e){ cout<<e<<endl; } return 0; } \",\"运行结果：\",\"Unknown Exception \"]},\"602\":{\"h\":\"课堂代码\",\"t\":[\"#include <iostream> using std::cout; using std::endl; using std::cin; void test() { double x, y; cin >> x >> y; try { if(0 == y) /* if( y = 1 ) */ { throw y; } else { cout << \\\"(x/y) = \\\" << x/y << endl; } } catch(int e) { cout << \\\"catch(int)\\\" << endl; } catch(double d) { cout << \\\"catch(double)\\\" << endl; } } int main(int argc, char **argv) { test(); return 0; } \"]},\"603\":{\"h\":\"寻找处理代码的过程(匹配catch的过程)\",\"t\":[\"如果try语句块有嵌套。那么，在throw抛出异常后，寻找catch异常处理的代码是怎样的一个过程呢？答案就是逐层向外寻找。即本层throw出的异常，若在本层没找到对应的catch异常处理，则在调用它的层里继续匹配寻找。\",\"注意： 当上述的匹配过程中最后都没能匹配到任何catch字句，程序会转到terminate的标准库函数，程序非正常退出。\"]},\"604\":{\"h\":\"C++定义的标准异常类\",\"t\":[\"C++ 提供了一系列标准的异常，它们是以父子类层次结构组织起来的，如下所示：\",\"下面是对异常类的说明：\",\"异常\",\"描述\",\"std::exception\",\"该异常是所有标准 C++ 异常的父类。\",\"std::bad_alloc\",\"该异常可以通过 new 抛出。\",\"std::bad_cast\",\"该异常可以通过 dynamic_cast 抛出。\",\"std::bad_typeid\",\"该异常可以通过 typeid 抛出。\",\"std::bad_exception\",\"这在处理 C++ 程序中无法预期的异常时非常有用。\",\"std::logic_error\",\"理论上可以通过读取代码来检测到的异常。\",\"std::domain_error\",\"当使用了一个无效的数学域时，会抛出该异常。\",\"std::invalid_argument\",\"当使用了无效的参数时，会抛出该异常。\",\"std::length_error\",\"当创建了太长的 std::string 时，会抛出该异常。\",\"std::out_of_range\",\"该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator。\",\"std::runtime_error\",\"理论上不可以通过读取代码来检测到的异常。\",\"std::overflow_error\",\"当发生数学上溢时，会抛出该异常。\",\"std::range_error\",\"当尝试存储超出范围的值时，会抛出该异常。\",\"std::underflow_error\",\"当发生数学下溢时，会抛出该异常。\"]},\"605\":{\"h\":\"使用C++的标准异常类实例\",\"t\":[\"例子:\",\"将if (_b == 0) throw \\\"输入的分母是0。\\\";修改为 if (_b == 0) throw runtime_error(\\\"输入的分母是0。\\\");\",\"将catch(const char* s)修改为catch(runtime_error err) 将std::cout << s修改为std::cout << err.what()\",\"最后的结果和修改前一样，只不过使用的异常类。\",\"注意：。该字符串的目的是提供有关异常的一些文本信息。就如\\\"输入的分母是0。\\\"提示一样。对于那些无初始值的异常类型来说，what返回的内容由编译器决定。\",\"#include <iostream> #include <stdexcept> using namespace std; int main() { //bad_alloc异常类实例 try { char * p = new char[0x7fffffff]; //无法分配这么多空间，会抛出异常 } catch (bad_alloc e) { cerr << e.what() << endl; } //out_of_range异常类实例 string s = \\\"I love China\\\"; try { char c = s.at(100); //拋出 out_of_range 异常 } catch (out_of_range & e) { cerr << e.what() << endl; } return 0; } \",\"$./a.out basic_string::at \",\"从这个例子可以看出，有些异常是系统自动抛出，并不需要我们自己写抛出异常。\"]},\"606\":{\"h\":\"如何定义和使用自己的异常类\",\"t\":[\"我们可以通过继承C++标准异常类的方法来定义自己的异常类。\",\"#include <iostream> #include <exception> #include <stdexcept> using namespace std; class MyException :public exception { public: MyException() :c(nullptr){} MyException(const char* _c):c(_c){} virtual ~MyException(){} //覆写what成员函数 const char* what() throw() { if (c == nullptr) return \\\"MyException() error catch!\\\"; return c; } private: const char * c; }; int main() { //默认参数-构造一个MyException类 try{ throw MyException(); } catch (MyException & myexp){ cerr << myexp.what() << endl; } //实际传参-构造一个MyException类 try{ throw MyException(\\\"Error have been found.\\\"); } catch(MyException & myexp){ cerr << myexp.what() << endl; } return 0; } \",\"$./a.out MyException() error catch! Error have been found. \"]},\"607\":{\"h\":\"异常规范（C++11标例子准中已经被废弃）\",\"t\":[\"异常规范可以分为两类：\",\"动态异常规范（Dynamic Exception Specification）：使用关键字 throw() 或 noexcept 来指定函数不会抛出任何异常或只会抛出特定类型的异常。例如：\",\"void myFunction() throw(); // myFunction 不会抛出任何异常 void myFunction() noexcept; // myFunction 不会抛出任何异常 void myFunction() throw(std::bad_alloc); // myFunction 只会抛出 std::bad_alloc 异常 \",\"静态异常规范（Static Exception Specification）：使用关键字 throw(...) 来指定函数可能会抛出任何类型的异常。例如：\",\"void myFunction() throw(...); // myFunction 可能会抛出任何类型的异常 \",\"（异常安全有时间再看，先知道怎么用）\"]},\"608\":{\"h\":\"C++中使用异常时应注意的问题/总结\",\"t\":[\"指针和动态分配导致的内存回收问题：在C++中，不会自动回收动态分配的内存，如果遇到异常就需要考虑是否正确的回收了内存。\",\"try块中如果抛出异常，会立即跳转到与异常相匹配的catch块中（throw后的语句不执行），执行完会再跳转到最后一个catch的下一条语句。\",\"try和catch必须成对出现。catch通过()中的异常声明来匹配throw抛出的异常类型(也就是throw后接的表达式类型)\",\"catch的匹配是逐层向外匹配。即当前函数没有catch，则在调用它的函数里找catch\",\"若throw抛出的异常最终没有匹配到catch或则根本就没有catch，系统调用terminate后退出程序\",\"。\",\"函数的异常抛出列表：在C++中是如果你没有在函数的异常抛出列表指定要抛出的异常，意味着你可以抛出任何异常。\",\"C++中编译时不会检查函数的异常抛出列表。这意味着你在编写C++程序时，如果在函数中抛出了没有在异常抛出列表中声明的异常，编译时是不会报错的。\",\"catch的匹配过程中，对类型的要求比较严格。不允许标准算术转换和类类型的转换。（类类型的转化包括两种：通过构造函数的隐式类型转化和通过转化操作符的类型转化）\"]},\"609\":{\"c\":[\"c/c++\"]},\"610\":{\"c\":[\"c++基础\"]},\"611\":{\"h\":\"引用\"},\"612\":{\"h\":\"什么是引用？\",\"t\":[\"在理解引用概念前，先回顾一下变量名。 变量名实质就是一段连续内存空间的别名。那一段连续的内存空间只能取一个别名吗？ 显然不是，引用的概念油然而生。在C++中，引用是一个已定义变量的别名。其语法是：\",\"类型 &引用名 = 目标变量名； void test0() { int a = 1; int &ref1 = a; int &ref2; } \",\"在使用引用的过程中，要注意以下几点：\",\"&在这里不再是取地址符号，而是引用符号，相当于&有了第二种用法\",\"引用的类型必须和其绑定的变量的类型相同\",\"声明引用的同时，必须对引用进行初始化；否则编译时报错\",\"一旦绑定到某个变量之后，就不会再改变其指向 (类型 * const)\"]},\"613\":{\"h\":\"引用和取地址的区别\",\"t\":[\"的为引用，不带的是取地址\",\"int &b = a; &c; \"]},\"614\":{\"h\":\"引用的本质\",\"t\":[\"C++中的引用本质上是一种被限制的指针(类型 * const)。类似于线性表和栈的关系，栈是被限制的线性表，底层实现相同，只不过逻辑上的用法不同而已，(获取地址，然后赋值)。\",\"#include <iostream> //#include <typeinfo.h> 编译提示typeinfo.h找不到 #include <typeinfo> int main() { int a = 10; int * p = &a; int &b = a; *p = 20; b= 30; return 0; } \",\"编译提示typeinfo.h找不到 解决方法：typeinfo.h 改为typeinfo\",\"$g++ -g main.cc $objdump -M intel -S a.out \",\"image-20240202155647969\",\"由于引用是被限制的指针，所以引用是占据内存的，占据的大小就是一个指针的大小。有很多的说法，都说引用不会占据存储空间，其只是一个变量的别名，但这种说法并不准确。引用变量会占据存储空间，存放的是一个地址，但是编译器阻止对它本身的任何访问，从一而终总是指向初始的目标单元。在汇编里， 引用的本质就是“间接寻址”。在后面学习了类之后，我们也能看到相关的用法。\"]},\"615\":{\"h\":\"引用作为函数参数\",\"t\":[\"在没有引用之前，如果我们想通过形参改变实参的值，只有使用指针才能到达目的。但使用指针的过程中，不好操作，很容易犯错。 而引用既然可以作为其他变量的别名而存在，那在很多场合下就可以用引用代替指针，因而也具有更好的可读性和实用性。这就是引用存在的意义。 一个经典的例子就是交换两个变量的值。\",\"//用指针作为参数 void swap(int *pa, int *pb) { int temp = *pa; *pa = *pb; *pb = temp; } //引用作为参数 void swap(int &x, int &y) { int temp = x; x = y; y = temp; } \",\"参数传递的方式除了上面的指针传递和引用传递两种外，还有值传递。采用值传递时，系统会在内存中开辟空间用来存储形参变量，并将实参变量的值拷贝给形参变量，即形参变量只是实参变量的副本而已；如果函数传递的是类对象，系统还会调用类中的拷贝构造函数来构造形参对象，假如对象占据的存储空间比较大，那就很不划算了。这种情况下，强烈建议使用引用作为函数的形参，这样会大大提高函数的时空效率。 当用引用作为函数的参数时，其效果和用指针作为函数参数的效果相当。当调用函数时，函数中的形参就会被当成实参变量或对象的一个别名来使用，也就是说此时函数中对形参的各种操作实际上是对实参本身进行操作，而非简单的将实参变量或对象的值拷贝给形参。 使用指针作为函数的形参虽然达到的效果和使用引用一样，但，而引用则不需要这样，故在C++中推荐使用引用而非指针作为函数的参数\"]},\"616\":{\"h\":\"引用作为函数的返回值\",\"t\":[\"//语法： 类型 &函数名(形参列表) { //函数体 } \",\"当以引用作为函数的返回值时，返回的变量其生命周期一定是要大于函数的生命周期的，即当函数执行完毕时，。\",\"int gNumber;//全局变量 int func1() // 当函数返回时，会对temp进行复制 { temp = 100; return temp;//此处会进行复制操作 } int &func2()//当函数返回时，不会对temp进行复制，因为返回的是引用 { temp = 1000; return temp; } \",\"当引用作为函数的返回值时，必须遵守以下规则：\",\"不能返回局部变量的引用。主要原因是。\",\"不能在函数内部返回new分配的堆空间变量的引用。。\",\"int &func3() { int number = 1; return number; } int &func4() { int *pInt = new int(1); return *pInt; } void test() { int a = 3, b = 4; int c = a + func4() + b;//内存泄漏 } \"]},\"617\":{\"h\":\"引用总结：\",\"t\":[\"在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。\",\"用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。\",\"引用与指针的区别是，指针后，对它所指向的变量。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作()。\"]},\"618\":{\"h\":\"课堂代码\",\"t\":[\"#include <iostream> using std::cout; using std::endl; //指针与引用的异同点？ void test() { int number = 10; int &ref = number;//引用是变量的别名,引用的提出就是为了减少指针的使用 &ref; cout << \\\"number = \\\" << number << endl; cout << \\\"ref = \\\" << ref << endl; printf(\\\"number = %p\\\\n\\\", &number); //打印地址常用printf %p更方便 printf(\\\"ref = %p\\\\n\\\", &ref); cout << endl; int number2 = 200; ref = number2;//操作引用与操作变量本身是一样的 cout << \\\"number2 = \\\" << number2 << endl; cout << \\\"number = \\\" << number << endl; cout << \\\"ref = \\\" << ref << endl; printf(\\\"number2 = %p\\\\n\\\", &number2); printf(\\\"number = %p\\\\n\\\", &number); printf(\\\"ref = %p\\\\n\\\", &ref); cout << endl; //引用的实质：指针常量 * const /* int &ref2;//引用不能独立存在，在定义的时候必须要进行初始化,在定义的 */ //的时候绑定到变量上面，跟变量绑定到一起，不会改变引用的指向 } //1、引用作为函数参数 #if 0 //值传递====副本 //没有触及a b本身 void swap(int x, int y)//int x = a, int y = b { int temp = x; x = y; y = temp; } #endif #if 0 //值传递====地址值 void swap(int *px, int *py)//int *px = &a, int *py = &b; { int temp = *px; *px = *py; *py = temp; } #endif //引用传递====变量本身 void swap(int &x, int &y)//int &x = a, int &y = b { int temp = x; x = y; y = temp; } void test2() { int a = 3, b = 4; cout << \\\"在交换之前 a = \\\" << a << \\\", b = \\\" << b << endl; swap(a, b); cout << \\\"在交换之后 a = \\\" << a << \\\", b = \\\" << b << endl; } //2、引用作为函数返回类型 int func1() { int number = 10; return number;//执行一个拷贝操作 } int &func2() { int number = 10;//局部变量 return number;//不能返回一个局部变量的引用 } //不要去返回堆空间的引用,必须要有内存回收的机制 int &getHeapData() { int *pInt = new int(100); return *pInt; } void test4() { int a = 3, b = 5; int temp = a + getHeapData() + b; cout << \\\"temp = \\\" << temp << endl; int &ref = getHeapData(); delete &ref; //虽然没问题，但这种写法很怪，而且别人不知道分装了new } //函数返回类型是引用的前提:实体的生命周期一定要大于函数的生命周期 int arr[10] = {1, 3, 5, 7, 9, 10}; int &getIndex(int idx) { return arr[idx];//先不去考虑越界 } void test3() { cout << \\\"getIndex(0) = \\\" << getIndex(0) << endl; getIndex(0) = 200; cout << \\\"getIndex(0) = \\\" << getIndex(0) << endl; cout << \\\"arr[0] = \\\" << arr[0] << endl; /* func1() = 200; */ } int main(int argc, char **argv) { test4(); return 0; } \"]},\"619\":{\"h\":\"引用和指针的区别\",\"t\":[\"引用是变量的别名，是对目标对象的直接操作；指针是通过某个指针变量指向一个对象，对所指的对象进行间接操作\",\"引用必须初始化，不能初始化空对象，初始化后不能改变；指针可以不初始化，但最好初始化（野指针）\",\"引用的本质是指针常量，在汇编上引用和指针生成的指令一样，通过引用变量修改所引用内存的值，和通过指针解引用修改指针指向的内存的值，其底层指令也是一模一样的\",\"引用只有一级引用，没有多级引用；指针可以有一级指针，也可以有多级指针\",\"在参数传递时，引用不会产生副本，指针会将实参地址拷贝给形参\"]},\"620\":{\"h\":\"左值引用\",\"t\":[\"左值：有内存地址，有名字，值可以修改；\",\"int a = 10; //左值：有内存地址，有名字，值可以修改； int &b =a; int &c =10;//错误 20 是右值，20=40是错误的，其值不能修改，没内存，没名字，是一个立即数； \",\"上述代码是无法编译通过的，因为10无法进行取地址操作，无法对一个立即数取地址，因为立即数并没有在内存中存储，而是存储在寄存器中，可以通过下述方法解决：\",\"const int &var = 10; \",\"使用常引用来引用常量数字10，因为此刻内存上产生了临时变量保存了10，这个临时变量是可以进行取地址操作的，因此var引用的其实是这个临时变量，相当于下面的操作：\",\"const int temp = 10; const int &var = temp; \",\"根据上述分析，得出如下结论：\",\"； 但使用常引用后，我们只能通过引用来读取数据，无法去修改数据，因为其被const修饰成常量引用了\",\"那么C++11 引入了右值引用的概念，使用右值引用能够很好的解决这个问题。\"]},\"621\":{\"h\":\"右值引用\",\"t\":[\"C++对于左值和右值没有标准定义，但是有一个被广泛认同的说法：\",\"可以取地址的，有名字的，非临时的就是左值；\",\"不能取地址的，没有名字的，临时的就是右值；\",\"可见立即数，函数返回的值等都是右值；而非匿名对象(包括变量)，函数返回的引用，const对象等都是左值。\",\"从本质上理解，\",\"创建和销毁由编译器幕后控制，程序员只能确保在本行代码有效的，就是右值(包括立即数)；\",\"而用户创建的，通过作用域规则可知其生存期的，就是左值(包括函数返回的局部变量的引用以及const对象)。\",\"#include <iostream> #include <typeinfo> int main() { int a = 10; int &b = a; int &&c = 20; //C++11提供了右值引用 std::cout << typeid(b).name() << std::endl; //i std::cout << typeid(c).name() << std::endl; //i const int *d = &a; std::cout << typeid(d).name() << std::endl; //PKi return 0; } \",\"$g++ -g -std = c++11 main.cc $objdump -M intel -S a.out \",\"image-20240202162644415\",\"const int &var = 10; //var = 20; //error,被const修饰不可以修改 int &&c = 20; //右值引用 c = 30; //OK，没有const修饰，右值引用可以修改值 int &e = c; //一个右值引用变量本身是一个左值（c本身有内存有名字） //int &&e = c; //error,右值引用只能引用右值，因为右值引用会产生一个临时量，而左值本身就有内存，所有代码有冲突 \"]},\"622\":{\"h\":\"总结：\",\"t\":[\"右值引用只能用来引用右值类型int &&c = 20；指令上，可以自动产生临时量，然后直接引用临时量；可以修改临时量的内存c = 30\",\"右值引用本身是一个左值，只能用左值引用来引用它\",\"不能用一个右值引用变量来引用左值\"]},\"623\":{\"h\":\"例题\"},\"624\":{\"h\":\"写一句代码在内存的0x0018ff44处写一个4字节的10\",\"t\":[\"int* p = (int*)0x0018ff44; //0x0018ff44是一个整数需要强转 *p = 10; int *&&p = (int*)0x0018ff44; //右值引用，引用对象是int * 类型 int *const &p = (int*)0x0018ff44; //引用对象是个常量 \"]},\"625\":{\"h\":\"判断对错 🍗🍗🍗\",\"t\":[\"// 例1 int a = 10; int *p = &a; const int *&q = p; // 等价于const int** <= int**,error //不要被表象迷住了,看成const int* <= int*,要转成指针看 //-> const int **q = &p //-> const int ** = int** // 例2 int a = 10; int *const p = &a; int *&q = p; //因为p是一个指针常量，即指针的值（即地址）是不可变的，但是q却是一个指向指针的引用，它允许改变指针的值 // 等价于int **q = &p; //即 int** <= int* const * //-> int* <= const int *,error \"]},\"626\":{\"c\":[\"c/c++\"]},\"627\":{\"c\":[\"c++基础\"]},\"628\":{\"h\":\"强制转换\",\"t\":[\"类型转换有c风格的，当然还有c++风格的。c风格的转换的格式很简单\",\"TYPE a = （TYPE）EXPRESSION; \",\"但是c风格的类型转换有不少的缺点，有的时候用c风格的转换是不合适的，因为它可以在任意类型之间转换，比如你可以把一个指向const对象的指针转换成指向非const对象的指针，把一个指向基类对象的指针转换成指向一个派生类对象的指针，这两种转换之间的差别是巨大的，但是传统的c语言风格的类型转换没有区分这些。 另一个缺点就是，c风格的转换不容易查找，它由一个括号加上一个标识符组成，而这样的东西在c++程 序里一大堆。 c++为了克服这些缺点，引进了4个新的类型转换操作符（非函数），他们是static_cast，const_cast，dynamic_cast，reinterpret_cast\"]},\"629\":{\"h\":\"static_cast\",\"t\":[\"的类型转换，最常用的类型转换符，在正常状况下的类型转换, 用于将一种基本数据类型转换成另一种基本数据类型，如把int转换为float\",\"int iNumber = 100； float fNumber = 0； fNumber = (float) iNumber；//C风格 fNumber = static_cast<float>(iNumber); \",\"也可以完成指针之间的转换，例如可以将void*指针转换成其他类型的指针\",\"void *pVoid = malloc(sizeof(int)); int *pInt = static_cast<int*>(pVoid); *pInt = 1; \",\"但\",\"int iNumber = 1; int *pInt = &iNumber; float *pFloat = static_cast<float *>(pInt);//error \",\"总结，static_cast的用法主要有以下几种：\",\"用于基本数据类型之间的转换，如把int转成char，把int转成enum。这种转换的安全性也要开发人员来保证。\",\"把void指针转换成目标类型的指针，但。\",\"把任何类型的表达式转换成void类型。\",\"用于类层次结构中基类和派生类之间指针或引用的转换。进行上行转换（把；进行下行转换（把。\"]},\"630\":{\"h\":\"const_cast\",\"t\":[\"该运算符。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。\",\"const int number = 100; int *pInt = &number; //error int *pInt1 = (int*)&number; //C中类型转换 int *pInt2 = const_cast<int *>(&number); //C++中类型转换const_cast \",\"注意：\",\"不考虑const或valatile，才可以进行合理的类型转换。\",\"转换为相同类型的时候，我们通过反汇编查看时候，发现**与所生成的的**。\",\"但是在转换成汇编指令之前，即编译阶段，就有所不同。\",\"注意1：不考虑const或valatile后，类型保持一致才可以进行合理的类型转换\",\"const int a = 10; char *p1 = (char*)&a;//C中类型转换，可以 char *p2 = const_cast<char*>(&a);//C++中类型转换const_cast，不可以 \",\"在这里插入图片描述\",\"如果通过C中类型转换可以将int * 转换为多种不同的类型，没有任何问题；这里为整型常量的地址，但是如果通过const_cast将整型常量地址转换为另一个指针类型不匹配的指针，是不可以的。。防止了C中低级别的类型强转任意的转换指针的类型导致一些不确定的错误。\",\"注意2：const_cast<里面必须是指针或引用类型>，否则出错，例如：\",\"const int a = 10; int b = const_cast<int>(a); \"]},\"631\":{\"h\":\"dynamic_cast\",\"t\":[\"该运算符主要用于基类和派生类间的转换，尤其是向下转型的用法中。\",\"，用于继承结构中，可以支持RTTI类型识别的上下转换及识别。将一个基类对象指针（或引用）转换到继承类指针，\",\"class Base { public: virtual void func() = 0; }; class Derive1 : public Base { public: void func() { cout << \\\"call Derive1::func\\\" << endl; } }; class Derive2 : public Base { public: void func() { cout << \\\"call Derive2::func\\\" << endl; } }; void showFunc(Base* p) { p->func();//动态绑定 } int main() { Derive1 d1; Derive1 d2; showFunc(&d1); showFunc(&d2); return 0; } \",\"但是，我们的需求改变了。Derive实现了一个新功能的API接口函数\",\"class Derive2 : public Base { public: void func() { cout << \\\"call Derive2::func\\\" << endl; } //需求更改 Derive2实现新功能的API接口函数 void derive02func() { cout << \\\"call derive02func()::func\\\" << endl; } }; \",\"我们的void show()应该区分判断一下，如果Base* p指向了其他的派生类对象，调用p->func()方法就好。但如果指向Derive2对象，不调用func()方法，而**** 这里就要识别*p的类型，看它指向哪个对象。此时就需要我们的dynamic_cast()了。dynamic会检查p指针是否指向的是一个Derive2类型的对象；p->vfptr->vftable RTTI信息 如果是dynamic_cast，转换类型成功，返回Derive2对象地址；否则，返回nullptr。\",\"void showFunc(Base* p) { //dynamic会检查p指针是否指向的是一个Derive2类型的对象 //p->vfptr->vftable RTTI信息 如果是dynamic_cast， //转换类型成功，返回Derive2对象地址；否则，返回nullptr Derive2 *pd2 = dynamic_cast<Derive2*>(p); if (pd2 != nullptr) { pd2->derive02func(); } else { p->func();//动态绑定 } } \"]},\"632\":{\"h\":\"reinterpret_cast\",\"t\":[\"类似于C风格的强制类型转换，是。\",\"该运算符可以用来处理无关类型之间的转换，即用在任意指针（或引用）类型之间的转换，以及指针与足够大的整数类型之间的转换。由此可以看出，reinterpret_cast的效果很强大，但错误的使用reinterpret_cast很容易导致程序的不安全，只有将转换后的类型值转换回到其原始类型，这样才是正确使用reinterpret_cast方式。\",\"int *p = nullptr; double* b = reinterpret_cast<double*>(p); \"]},\"633\":{\"h\":\"课堂代码\",\"t\":[\"#include <iostream> using std::cout; using std::endl; void test() { int iNumber = 10; float fNumber = 12.345; /* iNumber = (int)fNumber; */ iNumber = int(fNumber); } void test2() { int iNumber = 10; float fNumber = 12.345; iNumber = static_cast<int>(fNumber); cout << \\\"inumber = \\\" << iNumber << endl; void *pret = malloc(sizeof(int)); int *pInt = static_cast<int *>(pret); free(pInt); pInt = nullptr; } void test3() { const int number = 100; /* int *p1 = &number;//error */ int *p1 = const_cast<int *>(&number); cout << \\\"*p1 = \\\" << *p1 << endl; //100 printf(\\\"p1's address : %p\\\\n\\\", p1);//0x7ffc1abeae5c printf(\\\"number's address : %p\\\\n\\\", &number);//0x7ffc1abeae5c,地址相同（指向原对象） //下面这个种行为C++已经不支持了,不要这样写，了解后不要纠结这里了 //地址相同，值不同 cout << endl; *p1 = 200;//未定义行为 cout << \\\"*p1 = \\\" << *p1 << endl; //200 cout << \\\"number = \\\" << number << endl;//100 printf(\\\"p1's address : %p\\\\n\\\", p1); //0x7ffc1abeae5c printf(\\\"number's address : %p\\\\n\\\", &number);//0x7ffc1abeae5c } int main(int argc, char **argv) { test3(); return 0; } \"]},\"634\":{\"c\":[\"c/c++\"]},\"635\":{\"c\":[\"c++基础\"]},\"636\":{\"h\":\"默认参数\",\"t\":[\"1681304023862-96f676ac-4269-4aa5-bf35-9cf222f1743c\"]},\"637\":{\"h\":\"默认参数的目的\",\"t\":[\"C++可以给函数定义默认参数值。通常，调用函数时，要为函数的每个参数给定对应的实参\",\"void func1(int x, int y); void func1(int x, int y) { cout << \\\"x = \\\" << x << endl; cout << \\\"y = \\\" << y << endl; } \",\"无论何时调用func1函数，都必须要给其传递两个参数。但C++可以给参数定义默认值，如果将func1函数参数中的x定义成默认值0， y定义成默认值0，只需简单的将函数声明改成\",\"void func1(int x = 0, int y = 0); \",\"这样调用时，若不给参数传递实参，则func1函数会按指定的默认值进行工作。允许函数设置默认参数值，是为了让编程简单，让编译器做更多的检查错误工作。\"]},\"638\":{\"h\":\"调用效率问题（汇编）\",\"t\":[\"若两个函数都传入，会提高效率，形参带默认值的函数；若传入，则效率不变。\",\"int main() { int a = 10; int b = 20; int ret = sum(a, b); /* mov eax, dword ptr[ebp-8] push eax mov ecx, dword ptr[ebp-4] push ecx call sum */ ret = sum(a); /* push 14H // 这里直接push省去mov mov ecx, dword ptr[ebp-4] push ecx call sum */ //如果实参是立即数，则效率和默认参数是一样的 ret = sum(); ret = sum(30, 40); /* push 28H //40 push 1EH //30 call sum */ return 0; } int sum(int a = 10, int b = 20) { return a + b; } \",\"当调用次数大的时候开销差别还是很可观\"]},\"639\":{\"h\":\"默认参数的声明\",\"t\":[\"。，。若在定义时而不是在声明时置默认值，那么函数定义一定要在函数的调用之前。因为声明时已经给编译器一个该函数的向导，所以只在定义时设默认值时，编译器只有检查到定义时才知道函数使用了默认值。若先调用后定义，在调用时编译器并不知道哪个参数设了默认值。所以我们通常是将默认值的设置放在声明中而不是定义中。\",\"默认值只能给一次\",\"/*error int sum(int a = 10, int b); //error,默认值顺序从右往左赋值 int sum(int a, int b = 20); */ //下面的这种情况编译正常，原因：执行2的时已经知道了1给b赋了默认值（声明可以多次） int sum(int a, int b = 20); //1 int sum(int a = 10, int b); //2 \"]},\"640\":{\"h\":\"默认参数的顺序规定\",\"t\":[\"如果一个函数中有多个默认参数，则形参分布中，默认参数应从右至左逐渐定义，因为涉及到参数的入栈出栈。当调用函数时，只能向左匹配参数。如：\",\"void func2(int a = 1, int b, int c = 0, int d);//error void func2(int a, int b, int c = 0, int d = 0);//ok \",\"若给某一参数设置了默认值，那么在参数表中其后所有的参数都必须也设置默认值，否则，由于函数调用时可不列出已设置默认值的参数，编译器无法判断在调用时是否有参数遗漏。\"]},\"641\":{\"h\":\"默认参数与函数重载\",\"t\":[\"默认参数可将一系列简单的重载函数合成为一个。例如：\",\"void func3(); void func3(int x); void func3(int x, int y); //上面三个函数可以合成下面这一个 void func3(int x = 0, int y = 0); \",\"如果一组重载函数（可能带有默认参数）都允许相同实参个数的调用，将会引起调用的二义性。\",\"void func4(int); void func4(int x, int y = 0); void func4(int x = 0, int y = 0); \",\"所以在。\"]},\"642\":{\"h\":\"课堂代码\",\"t\":[\"#include <iostream> using std::cout; using std::endl; #if 0 int add(){ return 1; } int add(int x) { return x + 0 + 1; } int add(int x,int y) { return x + y + 1; } int add(int x,int y, int z) { return x + y + z; } #endif #if 0 //二义性 int add(int x, int y) { return x + y; } #endif //默认参数要从右往左进行连续的赋初值 int add(int x = 0, int y = 0, int z = 0) { return x + y + z; } int main(int argc, char **argv) { int a = 3, b = 4, c = 5; cout << \\\"add(a, b, c) = \\\" << add(a, b, c) << endl; cout << \\\"add(a, b) = \\\" << add(a, b) << endl;//二义性 cout << \\\"add(a) = \\\" << add(a) << endl; cout << \\\"add() = \\\" << add() << endl; return 0; } \"]},\"643\":{\"c\":[\"c/c++\"]},\"644\":{\"c\":[\"c++基础\"]},\"645\":{\"h\":\"多基继承\"},\"646\":{\"h\":\"形式\",\"t\":[\"class 派生类 : public/protected/private 基类1 , ... , public/protected/private 基类N { }; \"]},\"647\":{\"h\":\"class不写出来就是私有继承\",\"t\":[\"class D : public A, B, C { }; \",\"注意上面的写法中B和C属于私有继承，D的实例化的对象是无法访问B、C的成员方法的\",\"class D : public A , public B , public C { }; \"]},\"648\":{\"h\":\"构造和析构顺序\"},\"649\":{\"h\":\"派生类构造函数初始化列表不写时，构造和析构顺序\",\"t\":[\"class D : public A , public B , public C { public: D(){ cout << \\\"D()\\\" << endl; } ~D(){ cout << \\\"~D()\\\" << endl; } }; \",\"构造函数调用顺序和派生列表一致\"]},\"650\":{\"h\":\"派生类初始化列表顺序和派生列表顺序不一致时\",\"t\":[\"class D : public A , public B , public C { public: D() : A() , C() , B() { cout << \\\"D()\\\" << endl; } ~D(){ cout << \\\"~D()\\\" << endl; } }; \",\"顺序依然没变\"]},\"651\":{\"h\":\"小结\",\"t\":[\"多基继承和单基继承的派生类构造函数完成的任务和执行顺序并没有本质不同，唯一一点区别在于：首先要执行所有基类的构造函数，再执行派生类构造函数中初始化表达式的其他内容和构造函数体。各基类构造函数的执行顺序与其在初始化表中的顺序无关，而是由定义派生类时指定的基类顺序（派生列表）决定的。\"]},\"652\":{\"h\":\"成员名冲突的二义性\",\"t\":[\"一般来说，在派生类中对基类成员的访问应当具有唯一性，但在多基继承时，\",\"如下面的例子，我们先定义3个不同的类A、B、C，这3个类中都有一个同名成员函数print，然后让类D继承自A、B、C，则当创建D的对象d，用d调用成员函数print时，发生编译错误。\",\"class A { public: void print() { cout << \\\"A::print()\\\" << endl; } }; class B { public: void print() { cout << \\\"B::print()\\\" << endl; } }; class C { public: void print() { cout << \\\"C::print()\\\" << endl; } }; class D : public A , public B , public C { }; void test() { D d; d.print();//error d.A::print();//ok d.B::print();//ok d.C::print();//ok } \",\"解决该问题的方式比较简单，只需要在调用时，指明要调用的是某个基类的成员函数即可，即使用就可以解决该问题。\"]},\"653\":{\"h\":\"菱形继承的二义性问题\",\"t\":[\"多基派生中，如果在多条继承路径上，如下图所示，不难看出，在D类对象中，会有来自两条不同路径的共同基类（类A）的双重拷贝。\",\"class A { public: void setNumber(long number) { _number = number; } private: long _number; }; class B : public A { }; class C : public A { }; class D : public B , public C { }; \",\"D不能直接调用A的成员\",\"D d; d.A::print(); //error \",\"可以加作用域访问B或C中的成员\",\"d.B::print(); d.C::print(); \",\"D实例化对象会调用A的构造函数和析构函数，因此A的成员在D实例化的对象的内存中存在两份，会产生二义性\",\"出现这种问题时，我们的解决方案是采用****，。中间的类B、C虚拟继承自A，就可以解决了。至于背后到底发生了什么，待我们学了多态的知识后一起做讲解。\",\"class A { public: void setNumber(long number) { _number = number; } private: long _number; }; class B : virtual public A { }; class C : virtual public A { }; class D : public B , public C { }; int main(void) { D d; d.setNumber(10); return 0; } \",\"D实例化对象会调用A的构造函数和析构函数\",\"D继承B、C的虚基指针，只有A类的成员\"]},\"654\":{\"c\":[\"c/c++\"]},\"655\":{\"c\":[\"继承\"]},\"656\":{\"h\":\"派生方式对基类成员的访问权限\"},\"657\":{\"h\":\"访问限定表\",\"t\":[\"派生（继承）方式有3种，分别是\",\"public（公有）继承\",\"protected（保护型）继承\",\"private（私有）继承\",\"image-20240413153213559\"]},\"658\":{\"h\":\"总结：派生类的访问权限规则如下：\",\"t\":[\"1．不管以什么继承方式，都不能访问基类的私有成员。 2．不管以什么继承方式，除了基类的私有成员不可以访问外，其他的都可以访问。 3．不管以什么继承方式，除了公有继承基类中的公有成员可以访问外，其他的一律不能访问\",\"私有成员只能自己内部访问或者友元访问\",\"基类的私有成员只能继承，但是无法访问\"]},\"659\":{\"h\":\"如果我们不写继承方式的话，那么它会以什么方式继承呢？\",\"t\":[\"class B : A//未写继承方式 \",\"具体情况具体研究：要看派生类是用class定义的还是struct定义的。class定义派生类，默认继承方式是private私有的；struct定义派生类，默认继承方式是public共有的。\"]},\"660\":{\"c\":[\"c/c++\"]},\"661\":{\"c\":[\"继承\"]},\"662\":{\"h\":\"派生类对象间的复制控制\",\"t\":[\"从前面的知识，我们知道，基类的拷贝构造函数和operator=运算符函数不能被派生类继承，那么在执行派生类对象间的复制操作时，就需要注意以下几种情况:\",\"如果用户定义了基类的拷贝构造函数，而的拷贝构造函数，那么在用一个派生类对象初始化新的派生类对象时，两对象间的**执行缺省的行为**（只拷贝值），而两对象间的**执行用户定义的基类拷贝构造函数**。\",\"#include <string.h> #include <iostream> using std::cout; using std::endl; class Base { public: Base() : _pbase(nullptr) { cout << \\\"Base()\\\" << endl; } Base(const char *pbase) : _pbase(new char[strlen(pbase) + 1]()) { cout << \\\"Base(const char *)\\\" << endl; strcpy(_pbase, pbase); } Base(const Base &rhs) : _pbase(new char[strlen(rhs._pbase) + 1]()) { cout << \\\"Base(const Base &)\\\" << endl; strcpy(_pbase, rhs._pbase); } Base &operator=(const Base &rhs) { cout << \\\"Base &operator=(const Base &)\\\" << endl; if(this != &rhs) { delete [] _pbase; _pbase = nullptr; _pbase = new char[strlen(rhs._pbase) + 1](); strcpy(_pbase, rhs._pbase); } return *this; } ~Base() { cout << \\\"~Base()\\\" << endl; if(_pbase) { delete [] _pbase; _pbase = nullptr;; } } friend std::ostream &operator<<(std::ostream &os, const Base &rhs); private: char *_pbase; }; std::ostream &operator<<(std::ostream &os, const Base &rhs) { if(rhs._pbase) { os << rhs._pbase; } return os; } class Derived : public Base { public: Derived(const char *pbase) : Base(pbase) { cout << \\\"Derived(const char *)\\\" << endl; } ~Derived() { cout << \\\"~Derived()\\\" << endl; } friend std::ostream &operator<<(std::ostream &os, const Derived &rhs); }; std::ostream &operator<<(std::ostream &os, const Derived &rhs) { const Base &ref = rhs; os << ref; return os; } int main(int argc, char **argv) { Derived d1(\\\"hello\\\"); cout << \\\"d1 = \\\" << d1 << endl; cout <<endl << endl; Derived d2 = d1; cout << \\\"d1 = \\\" << d1 << endl; cout << \\\"d2 = \\\" << d2 << endl; cout <<endl << endl; Derived d3(\\\"world\\\"); cout << \\\"d3 = \\\" << d3 << endl; cout << endl << endl; d3 = d1; cout << \\\"d1 = \\\" << d1 << endl; cout << \\\"d3 = \\\" << d3 << endl; return 0; } \",\"调用的是基类的拷贝构造和拷贝赋值\",\"如果用户定义了派生类的拷贝构造函数或者重载了派生类的对象赋值运算符=，则在用已有派生类对象初始化新的派生类对象时，或者在派生类对象间赋值时，将会执行用户定义的派生类的拷贝构造函数或者重载赋值函数，而不会再自动调用基类的拷贝构造函数和基类的重载对象赋值运算符，这时，通常用户在派生类的拷贝构造函数或者派生类的赋值函数中基类的拷贝构造或赋值运算符函数。\",\"//派生类的拷贝构造函数或者派生类的赋值函数中 没有显式调用 基类的拷贝构造或赋值运算符函数 #include <string.h> #include <iostream> using std::cout; using std::endl; class Base { public: Base() : _pbase(nullptr) { cout << \\\"Base()\\\" << endl; } Base(const char *pbase) : _pbase(new char[strlen(pbase) + 1]()) { cout << \\\"Base(const char *)\\\" << endl; strcpy(_pbase, pbase); } Base(const Base &rhs) : _pbase(new char[strlen(rhs._pbase) + 1]()) { cout << \\\"Base(const Base &)\\\" << endl; strcpy(_pbase, rhs._pbase); } Base &operator=(const Base &rhs) { cout << \\\"Base &operator=(const Base &)\\\" << endl; if(this != &rhs) { delete [] _pbase; _pbase = nullptr; _pbase = new char[strlen(rhs._pbase) + 1](); strcpy(_pbase, rhs._pbase); } return *this; } ~Base() { cout << \\\"~Base()\\\" << endl; if(_pbase) { delete [] _pbase; _pbase = nullptr;; } } friend std::ostream &operator<<(std::ostream &os, const Base &rhs); private: char *_pbase; }; std::ostream &operator<<(std::ostream &os, const Base &rhs) { if(rhs._pbase) { os << rhs._pbase; } return os; } class Derived : public Base { public: Derived(const char *pbase, const char *pderived) : Base(pbase) , _pderived(new char[strlen(pderived) + 1]()) { cout << \\\"Derived(const char *)\\\" << endl; strcpy(_pderived, pderived); } Derived(const Derived &rhs) //拷贝构造 : _pderived(new char[strlen(rhs._pderived) + 1]()) { cout << \\\"Derived(const Derived &)\\\" << endl; strcpy(_pderived, rhs._pderived); } Derived &operator=(const Derived &rhs) //拷贝赋值 { cout << \\\"Derived &operator=(const Derived &)\\\" << endl; if(this != &rhs) { delete [] _pderived; _pderived = nullptr; _pderived = new char[strlen(rhs._pderived) + 1](); strcpy(_pderived, rhs._pderived); } return *this; } ~Derived() { cout << \\\"~Derived()\\\" << endl; if(_pderived) { delete [] _pderived; _pderived = nullptr;; } } friend std::ostream &operator<<(std::ostream &os, const Derived &rhs); private: char *_pderived; //派生类的数据部分 }; std::ostream &operator<<(std::ostream &os, const Derived &rhs) { const Base &ref = rhs; os << ref << \\\" , \\\" << rhs._pderived; return os; } int main(int argc, char **argv) { Derived d1(\\\"hello\\\", \\\"world\\\"); cout << \\\"d1 = \\\" << d1 << endl; cout <<endl << endl; Derived d2 = d1; cout << \\\"d1 = \\\" << d1 << endl; cout << \\\"d2 = \\\" << d2 << endl; cout <<endl << endl; Derived d3(\\\"hubei\\\", \\\"wuhan\\\"); cout << \\\"d3 = \\\" << d3 << endl; cout << endl << endl; d3 = d1; cout << \\\"d1 = \\\" << d1 << endl; cout << \\\"d3 = \\\" << d3 << endl; return 0; } \",\"派生类定义了后，就不会再调用基类的\",\"没有显示调用的结果\",\"//派生类的拷贝构造函数或者派生类的赋值函数中 显式调用 基类的拷贝构造或赋值运算符函数 class Derived : public Base { public: //... Derived(const Derived &rhs) : Bas e(rhs)//显示调用基类的拷贝构造函数 , _pderived(new char[strlen(rhs._pderived) + 1]()) { cout << \\\"Derived(const Derived &)\\\" << endl; strcpy(_pderived, rhs._pderived); } Derived &operator=(const Derived &rhs) { cout << \\\"Derived &operator=(const Derived &)\\\" << endl; if(this != &rhs) { Base::operator=(rhs);//显示的调用基类的赋值运算符函数 delete [] _pderived; _pderived = nullptr; _pderived = new char[strlen(rhs._pderived) + 1](); strcpy(_pderived, rhs._pderived); } return *this; } }; \"]},\"663\":{\"c\":[\"c/c++\"]},\"664\":{\"c\":[\"继承\"]},\"665\":{\"h\":\"派生类的构造和销毁过程\",\"t\":[\"构造函数和析构函数是不能继承的，为了对数据成员进行初始化，派生类必须。\",\"由于派生类对象通过继承而包含了基类数据成员，因此，创建派生类对象时，系统首先通过派生类的构造函数来调用\",\"而后对。\"]},\"666\":{\"h\":\"形式\",\"t\":[\"派生类名(总参数表): 基类构造函数(参数表) { //函数体 }; \"]},\"667\":{\"h\":\"如何初始化基类的成员变量\",\"t\":[\"答：通过调用基类相应的构造函数\",\"class Base { public: Base(int data) :ma(data) { cout << \\\"Base()\\\" << endl; } ~Base() { cout << \\\"~Base()\\\" << endl; } protected: int ma; }; class Derive : public Base { public: Derive(int data):ma(data), mb(data) { cout << \\\"Derive()\\\" << endl; } ~Derive() { cout << \\\"~Derive() \\\" << endl; } private: int mb; }; int main() { Derive d(20); return 0; } \",\"程序出错：不允许我们派生类这样对从基类继承的ma进行初始化。在初始化列表中使用基类的构造来初始化ma；\",\"class Derive : public Base { public: Derive(int data):Base(data), mb(data) { cout << \\\"Derive()\\\" << endl; } ~Derive() { cout << \\\"~Derive() \\\" << endl; } private: int mb; }; \",\"派生类的构造函数和析构函数,负责初始化和清理派生类部分\",\"派生类从基类继承来的成员的初始化和清理由基类的构造函数和析构函数负责\"]},\"668\":{\"h\":\"派生类构造调用基类构造\"},\"669\":{\"h\":\"派生类有显式定义构造函数，而基类没有显示定义构造函数\",\"t\":[\"如果派生类有显式定义构造函数，而基类没有显示定义构造函数，则创建派生类的对象时，派生类相应的构造函数会被自动调用，此时都自动调用了基类缺省的无参构造函数。\",\"class Base { pulbic: Base() { cout << \\\"Base()\\\" << endl; } }; class Derived : public Base { public: Derived(long derived) : _derived(derived) { cout << \\\"Derived(long)\\\" << endl; } long _derived; }; void test() { Derived d(1); } \"]},\"670\":{\"h\":\"如果派生类没有显式定义构造函数，而基类有显示定义构造函数\",\"t\":[\"如果派生类没有显式定义构造函数而基类有显示定义构造函数，则****。\",\"class Base { pulbic: Base(long base) { cout << \\\"Base(long)\\\" << endl; } private: long _base; }; class Derived : public Base { public: //没有显示定义那就是编译器合成 }; void test() { Derived d;//error } \"]},\"671\":{\"h\":\"派生类有构造函数，基类有默认构造函数\",\"t\":[\"如果派生类有构造函数，基类有默认构造函数，则创建派生类的对象时，基类的默认构造函数会自动调用，如果你想调用基类的有参构造函数，必须要在派生类构造函数的初始化列表中显示调用基类的有参构造函数。\"]},\"672\":{\"h\":\"派生类和基类都有构造函数，但基类没有默认的无参构造函数\",\"t\":[\"如果派生类和基类都有构造函数，但基类没有默认的无参构造函数，即基类的构造函数均带有参数，则派生类的每一个构造函数必须在其初始化列表中显示的去调用基类的某个带参的构造函数。 如果派生类的初始化列表中没有显示调用则会出错，因为基类中没有默认的构造函数。\",\"class Base { pulbic: Base(long base) { cout << \\\"Base(long)\\\" << endl; } private: long _base; }; class Derived : public Base { public: Derived(long base, long derived) : Base(base) , _derived(derived) { cout << \\\"Derived(long, long)\\\" << endl; } long _derived; }; void test() { Derived d(1, 2); } \"]},\"673\":{\"h\":\"结论\",\"t\":[\"必须将基类构造函数放在派生类构造函数的，以调用基类构造函数完成基类数据成员的初始化。\",\"[必须在初始化列表中进行初始化的情况有哪些](https://iszhwei.gitee.io/ccpp/03 类和对象/构造函数和析构函数.html#必须在初始化列表中进行初始化的情况有哪些)\"]},\"674\":{\"h\":\"派生类构造函数调用顺序\",\"t\":[\"完成对象所占整块内存的开辟，由系统在调用构造函数时自动完成。\",\"调用基类的构造函数完成基类成员的初始化。\",\"若派生类中含**，则必须在初始化表中完成其初始化**。\",\"派生类构造函数体执行。\"]},\"675\":{\"h\":\"派生类对象的销毁\",\"t\":[\"当派生类对象被删除时，派生类的析构函数被执行。析构函数同样不能继承，因此，在执行派生类析构函数时，基类析构函数会被。执行顺序是先执行派生类的析构函数，再执行基类的析构函数，这和执行构造函数时的顺序正好。当考虑对象成员时，继承机制下析构函数的调用顺序：\",\",释放派生类成员可能占用的外部资源(堆内存 文件)\",\"再调用派生类中****\",\"最后调用****,释放派生类内存中从基类继承来的成员可能占用的外部资源\"]},\"676\":{\"c\":[\"c/c++\"]},\"677\":{\"c\":[\"继承\"]},\"678\":{\"h\":\"继承中的类型转换\",\"t\":[\"image-20240414114736980\",\"派生类适应于基类，派生类的对象适应于基类对象，派生类对象的指针和引用也适应于基类对象的指针和引用\",\"可以把给基类的对象\",\"可以把绑定到派生类的对象（只能访问基类的部分）\",\"可以声明指向派生类的对象 (向上转型)（解引用只能访问基类的部分）\",\"也就是说如果函数的对象或者基类对象的引用或者基类对象的指针类型，在进行函数调用时，相应的。\",\"class Base { public: Base(long base) { cout << \\\"Base(long)\\\" << endl; } private: long _base; }; class Derived : public Base { public: Derived(long base, long derived) : Base(base) , _derived(derived) { cout << \\\"Derived(long,long)\\\" << endl; } private: long _derived; }; void test() { Base base(1); Derived derived(10, 11); base = derived;//ok Base &refBase = derived;//ok Base *pBase = &derived;//ok derived = base;//error Derived &refDerived = base;//error Derived *pDerived = &base;//error cout << endl << endl; Base base2(10); Derived derived2(20, 30); Derived *pderived2 = static_cast<Derived *>(&base2);//不安全的向下转型 pderived2->print(); cout << endl; Base *pbase3 = &derived2; Derived *pderived3 = static_cast<Derived *>(pbase3);//安全的向下转型 pderived3->print(); } \",\"在继承结构中进行上下的类型转换，默认只支持从下到上的类型的转换。除非进行强转，但强转会涉及内存的。\",\"[类型转换函数 | 张威的编程学习笔记 (gitee.io)](https://iszhwei.gitee.io/ccpp/02 c__基础/强制转换.html#static-cast)\"]},\"679\":{\"c\":[\"c/c++\"]},\"680\":{\"c\":[\"继承\"]},\"681\":{\"h\":\"继承的本质和原理\"},\"682\":{\"h\":\"继承的本质\",\"t\":[\"：\",\"代码复用\",\"类和类的关系：\",\"组合： a part of ... ... 一部分的关系\",\"继承： a kind of ... ... 一种的关系\"]},\"683\":{\"h\":\"形式\",\"t\":[\"class 派生类 : public/protected/private 基类 { }; \"]},\"684\":{\"h\":\"派生类的生成过程包含3个步骤:\",\"t\":[\"吸收基类的成员\",\"改造基类的成员\",\"添加自己新的成员\",\"class A { public: int ma; protected: int mb; private: int mc; }; class B : public A//继承:A 基类/父类 B派生类/子类 { public: int md; protected: int me; private: int mf; }; \",\"继承之后：继承基类的成员，基类是12字节，派生类为24字节。\",\"继承之后，还附带了： 若在派生类中加一个ma，成员名字****，内存是28字节。\"]},\"685\":{\"h\":\"不能从基类继承下来的\",\"t\":[\"不论何种继承方式，下面这些基类的特征是不能从基类继承下来的：\",\"构造函数（包括拷贝构造）\",\"析构函数\",\"用户重载的operator new/delete运算符\",\"用户重载的operator=运算符\",\"友元关系\"]},\"686\":{\"c\":[\"c/c++\"]},\"687\":{\"c\":[\"继承\"]},\"688\":{\"h\":\"菱形继承问题\",\"t\":[\"多重继承：可以复用多个基类的代码到派生类中。\",\"但是多重继承中也会出现问题：我们来看一个经典的问题： A为B、C的基类，B从A单继承而来，C从A也是单继承而来；D是B和C多继承而来，D有两个基类分别为B和C。A称为D的间接基类，D也有A的数据。\",\" 假设A中有ma变量，B从A继承来并且有自己的mb，C从A继承来并且有自己的mc，D从B与C多继承而来，从B继承来了ma与mb，从C继承来了ma与mc，D也有自己的属性md；那么就出现了问题，<font color='red'>我们的**间接基类D有多份ma属性**，这就是菱形继承问题</font>。 \",\"当然，我们多重继承还会出现别的问题： 半圆形继承问题： B从A单一继承而来，C有一个基类B而且同时还从A继承而来。A到B为单继承，C为多继承。 假设ma为类A的属性，B从A继承而来，B有自己的mb；C从B与A继承而来，C有自己的mc，又从A继承来了ma，从B继承来了mb与mc；产生了菱形继承同样的问题，C中出现了两个ma属性。\",\"我们用代码来实现一下菱形继承问题：\",\"class A { public: A(int data):ma(data) { cout << \\\"A()\\\" << endl; } ~A() { cout << \\\"~A()\\\" << endl; } protected: int ma; }; class B : public A { public: B(int data):A(data), mb(data) { cout << \\\"B()\\\" << endl; } ~B() { cout << \\\"~B()\\\" << endl; } protected: int mb; }; class C : public A { public: C(int data):A(data), mc(data) { cout << \\\"C()\\\" << endl; } ~C() { cout << \\\"~C()\\\" << endl; } protected: int mc; }; class D : public B , public C { public: D(int data):B(data), C(data), md(data) { cout << \\\"D()\\\" << endl; } ~D() { cout << \\\"~D()\\\" << endl; } protected: int md; }; int main() { D d(10); return 0; } \",\"我们画一下d对象的内存布局。\",\"D能看见B，C与md，所以D在构造时调用B,C的构造及ma的初始化。ma的初始化在B与C的构造函数中进行，因此D内存为20个字节。打印一下：\",\"，最后是D的构造；析构顺序与其相反。我们发现，D这个派生类中调用了两次A的构造，\",\"那么如何处理这种问题呢？就需要虚继承来处理了。所有从A继承而来的地方都采用虚继承，A就为虚基类。 此时：。虚继承就可以解决多重继承中的菱形继承与半圆形继承出现的问题了。\",\"代码修改为如下：\",\"class A { public: A(int data):ma(data) { cout << \\\"A()\\\" << endl; } ~A() { cout << \\\"~A()\\\" << endl; } protected: int ma; }; class B : virtual public A { public: B(int data):A(data), mb(data) { cout << \\\"B()\\\" << endl; } ~B() { cout << \\\"~B()\\\" << endl; } protected: int mb; }; class C : virtual public A { public: C(int data):A(data), mc(data) { cout << \\\"C()\\\" << endl; } ~C() { cout << \\\"~C()\\\" << endl; } protected: int mc; }; class D : public B , public C { public: D(int data):A(data), B(data), C(data), md(data) { cout << \\\"D()\\\" << endl; } ~D() { cout << \\\"~D()\\\" << endl; } protected: int md; }; int main() { D d(10); return 0; } \",\"打印结果：修改成功；A、B、C、D各初始化与析构一次。\"]},\"689\":{\"c\":[\"c/c++\"]},\"690\":{\"c\":[\"继承\"]},\"691\":{\"h\":\"重载，隐藏，重写（覆盖）\"},\"692\":{\"h\":\"（1）重载（overload）\",\"t\":[\"[函数重载 | 张威的编程学习笔记 (gitee.io)](https://iszhwei.gitee.io/ccpp/02 c__基础/函数重载.html)\",\"在同⼀作用域当中的同名成员函数才存在重载关系\",\"函数名相同，参数列表不同（类型、数目、顺序）\",\"返回值不同不能区分函数。。\",\"class A{ ... virtual int fun(); void fun(int); void fun(double, double); static int fun(char); ... } \"]},\"693\":{\"h\":\"重写（覆盖）（override）\",\"t\":[\"重写指的是在派⽣类中覆盖基类中的同名函数，重写就是重写函数体，\",\"要求基类函数****\",\"参数列表和返回值与基类虚函数相同\",\"//⽗类 class A{ public: virtual int fun(int a){} } //⼦类 class B : public A{ public: //重写,⼀般加override可以确保是重写⽗类的函数 virtual int fun(int a) override{} } \"]},\"694\":{\"h\":\"重载与重写的区别：\",\"t\":[\"重写是⽗类和⼦类之间的垂直关系；重载是不同函数之间的⽔平关系\",\"重写要求参数列表和返回值相同；重载则要求参数列表不同，返回值不要求\",\"重写关系中，调⽤⽅法根据决定；重载根据调⽤来选择函数体\"]},\"695\":{\"h\":\"（3）隐藏（hide）\",\"t\":[\"隐藏：某些情况下，派⽣类中的函数屏蔽了基类中的。\",\"隐藏是指的把**作用域隐藏**了，因此可以加作用域进行访问；优先找的是派生类自己作用域的成员，没有才去基类里面去找\",\"两个函数参数，但是****。\",\"和重写的区别在于。\",\"//⽗类 class A{ public: void fun(int a){ cout << \\\"A中的fun函数\\\" << endl; } }; //⼦类 class B : public A{ public: //两个函数参数相同，但是基类函数不是虚函数。 //隐藏⽗类的fun函数 void fun(int a){ cout << \\\"B中的fun函数\\\" << endl; } }; int main(){ B b; b.fun(2); //调⽤的是B中的fun函数 b.A::fun(2); //调⽤A中fun函数 return 0; } \",\"两个函数参数，。\",\"和重载的区别在于。\",\"//⽗类 class A{ public: virtual void fun(int a){ cout << \\\"A中的fun函数\\\" << endl; } }; //⼦类 class B : public A{ public: //两个函数参数不同，⽆论基类函数是不是虚函数，都会被隐藏。 //隐藏⽗类的fun函数 virtual void fun(char* a){ cout << \\\"A中的fun函数\\\" << endl; } }; int main(){ B b; b.fun(2); //报错，调⽤的是B中的fun函数，参数类型不对 b.A::fun(2); //调⽤A中fun函数 return 0; } \",\"b.A::fun(2); //调⽤A中fun函数\",\"// ⽗类 class A { public: virtual void fun(int a) { // 虚函数 cout << \\\"This is A fun \\\" << a << endl; } void add(int a, int b) { cout << \\\"This is A add \\\" << a + b << endl; } }; // ⼦类 class B: public A { public: void fun(int a) override { // 覆盖 cout << \\\"this is B fun \\\" << a << endl; } void add(int a) { // 隐藏 cout << \\\"This is B add \\\" << a + a << endl; } }; int main() { // 基类指针指向派⽣类对象时，基类指针可以直接调用到派⽣类的覆盖函数，也可以通过 :: 调⽤到基类被覆盖 // 的虚函数；⽽基类指针只能调⽤基类的被隐藏函数，⽆法识别派⽣类中的隐藏函数。 A *p = new B(); p->fun(1); // 调⽤⼦类 fun 覆盖函数 p->A::fun(1); // 调⽤⽗类 fun p->add(1, 2); // p->add(1); // 错误，识别的是 A 类中的 add 函数，参数不匹配 // p->B::add(1); // 错误，⽆法识别⼦类 add 函数 return 0; } \",\"，基类指针可以直接调用到派⽣类的，也可以通过 :: 调⽤到基类被覆盖的虚函数；⽽\"]},\"696\":{\"c\":[\"c/c++\"]},\"697\":{\"c\":[\"继承\"]},\"698\":{\"h\":\"string迭代器的实现\",\"t\":[\"string str1 = \\\"hello world!\\\";//str1叫容器吗？ \",\"叫容器，其底层放了一组的字符，也是容器。 若想用指针遍历其底层字符串数组，我们并不清楚它的数组名，那如何指向它的数组名？此时就需要我们的容器的迭代器了。\",\"。迭代器是一个变量，相当于容器和操纵容器的算法之间的中介。迭代器可以指向容器中的某个元素，通过迭代器就可以读写它指向的元素。从这一点上看，迭代器和指针类似。\",\"不同容器底层数据结构不一样，每一种容器都有自己的迭代器，迭代器按照定义方式分成以下四种：\",\"正向迭代器\",\"容器类名::iterator 迭代器名; \",\"常量正向迭代器\",\"容器类名::const_iterator 迭代器名; \",\"反向迭代器\",\"容器类名::reverse_iterator 迭代器名; \",\"常量反向迭代器\",\"容器类名::const_reverse_iterator 迭代器名; \",\"string str1 = \\\"hello world!\\\";//str1叫容器吗？ //iterator即容器的迭代器 string::iterator it = str1.begin(); for (; it!=str1.end(); ++it) { cout << *it << \\\" \\\"; } cout << endl; \",\"image-20240410165523682\",\"str1对象中存入了各种各样的字符，字符串类型底层的成员变量为私有的，我们无法看见。\",\"容器有一个begin()方法，begin()返回它底层的迭代器的表示，it迭代器指向容器的首元素。\",\"容器中还有一个end()方法，end()表示容器中最后一个元素的后继位置，循环中it!=end()，++it，将其遍历一遍。\",\"底层无论是数组还是链表什么的，如何从当前元素遍历到下一个元素，我们不需要操心；容器底层元素真真正正从一个元素跑到下一个元素，不同数据结构，不同差异都封装在迭代器++运算符重载函数中。\",\"迭代器还需要提供 * 运算符重载，访问迭代器所迭代元素的值，迭代器解引用访问的就是容器底层数据。\"]},\"699\":{\"h\":\"实现迭代器iterator：\",\"t\":[\"class String { public: String(const char *p = nullptr) { if (p != nullptr) { _pstr = new char[strlen(p) + 1]; strcpy(_pstr, p); } else { _pstr = new char[1]; *_pstr = '0'; } } ~String() { delete[]_pstr; _pstr = nullptr; } String(const String &str) { _pstr = new char[strlen(str._pstr) + 1]; strcpy(_pstr, str._pstr); } String& operator=(const String &str) { if (this == &str) { return *this; } delete[]_pstr; _pstr = new char[strlen(_pstr) + 1]; strcpy(_pstr, str._pstr); return *this; } bool operator>(const String &str)const { return strcmp(_pstr, str._pstr) > 0; } bool operator<(const String &str)const { return strcmp(_pstr, str._pstr) < 0; } bool operator==(const String &str)const { return strcmp(_pstr, str._pstr) == 0; } int length()const { return strlen(_pstr); } char& operator[](int index) { return _pstr[index]; } const char& operator[](int index)const { return _pstr[index]; } const char* c_str()const//返回字符串底层管理的char*，返回为const char* { return _pstr; } //给String字符串类型提供迭代器iterator的实现 class iterator { public: iterator(char *p = nullptr):_p(p){} bool operator!=(const iterator &it) { return _p != it._p; } void operator++()//迭代器前置++；后置++效率低 { ++_p; } char& operator*() { return *_p; } private: char *_p; }; iterator begin()//返回容器底层首元素迭代器的表示 { return iterator(_pstr); } iterator end()//返沪容器末尾元素后继位置的迭代器的表示 { return iterator(_pstr + length()); } private: char *_pstr; friend ostream& operator<<(ostream &out, const String &str); friend String operator+(const String &lhs, const String &rhs); }; String operator+(const String &lhs, const String &rhs) { String tmp; tmp._pstr = new char[strlen(lhs._pstr) + strlen(rhs._pstr) + 1]; strcpy(tmp._pstr, lhs._pstr); strcat(tmp._pstr, rhs._pstr); return tmp; } ostream& operator<<(ostream &out, const String &str) { out << str._pstr; return out; } int main() { String str1 = \\\"hello world!\\\";//str1叫容器吗？ //iterator即容器的迭代器 String::iterator it = str1.begin(); //auto it = str1.begin();//自动推导类型 for (; it!=str1.end(); ++it) { cout << *it << \\\" \\\"; } cout << endl; } \"]},\"700\":{\"h\":\"auto\",\"t\":[\"//String::iterator it = str1.begin(); auto it = str1.begin();//自动推导类型 \",\"auto不是一个类型的“声明”，而是一个“占位符”，编译器在会将auto为变量实际的类型。 使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类型。它自动推导变量类型是根据“=”右侧的变量类型决定的。\"]},\"701\":{\"h\":\"foreach\",\"t\":[\"C++11标准中的foreach方式来遍历容器内部元素的值：其底层还是通过进行遍历的\",\"如果自定义类型没有迭代器的实现，则不能用foreach方法遍历\",\"//C++11 foreach方式来遍历容器内部元素的值 for (char ch : str1) { cout << ch << \\\" \\\"; } cout << endl; \"]},\"702\":{\"c\":[\"c/c++\"]},\"703\":{\"c\":[\"运算符重载\",\"迭代器\"]},\"704\":{\"h\":\"vector迭代器的实现\",\"t\":[\"泛型算法：给所有容器都可以使用，参数接受的都是容器的迭代器。\",\"//容器的空间配置器 template <typename T> struct Allocator { T* allocate(size_t size)//只负责内存开辟 { return (T*)malloc(sizeof(T) * size); } void deallocate(void *p)//只负责内存释放 { free(p); } void construct(T *p, const T &val)//已经开辟好的内存上，负责对象构造 { new (p) T(val);//定位new，指定内存上构造val，T(val)拷贝构造 } void destroy(T *p)//只负责对象析构 { p->~T();//~T()代表了T类型的析构函数 } }; template <typename T, typename Alloc = Allocator<T>> class vector//向量容器 { public: vector(int size = 10)//构造 { //_first = new T[size]; _first = _allocator.allocate(size); _last = _first; _end = _first + size; } ~vector()//析构 { //delete[]_first; for (T *p=_first; p!=_last; ++p) { _allocator.destroy(p);//把_first指针指向的数组的有效元素析构 } _allocator.deallocate(_first);//释放堆上的数组内存 _first = _last = _end = nullptr; } vector(const vector<T> &rhs)//拷贝构造 { int size = rhs._end - rhs._first;//空间大小 //_first = new T[size]; _first = _allocator.allocate(size); int len = rhs._last - rhs._first;//有效元素 for (int i=0; i<len; ++i) { //_first[i] = rhs._first[i]; _allocator.construct(_first+i, rhs._first[i]); } _last = _first + len; _end = _first + size; } vector<T>& operator=(const vector<T> &rhs)//赋值运算符重载 { if (this == &rhs) { return *this; } //delete[]_first; for (T *p=_first; p!=_last; ++p) { _allocator.destory(p);//把_first指针指向的数组的有效元素析构 } _allocator.deallocate(_first);//释放堆上的数组内存 int size = rhs._end - rhs._first;//空间大小 _first = _allocator.allocate(size); int len = rhs._last - rhs._first;//有效元素 for (int i=0; i<len; ++i) { _allocator.construct(_first+i, rhs._first[i]); } _last = _first + len; _end = _first + size; return *this; } void push_back(const T &val)//尾插 { if (full()) { expand(); } //*_last++ = val; _allocator.construct(_last, val);//_last指针指向的内存构造一个值为val的对象 _last++; } void pop_back()//尾删 { if (empty()) return; //--_last; //不仅要把_last指针--，还需要析构删除的元素 --_last; _allocator.destroy(_last); } T back()const//返回容器末尾元素值 { return *(_last - 1); } bool full()const { return _last == _end; } bool empty()const { return _first == _last; } int size()const//返回容器中元素个数 { return _last - _first; } T& operator[](int index) { if (index < 0 || index >= size()) { throw \\\"OutOfRangeException\\\"; } return _first[index]; } //迭代器一般实现成容器的嵌套类型 class iterator { public: iterator(T *ptr = nullptr) :_ptr(ptr){} bool operator!=(const iterator &it)const { return _ptr != it._ptr; } void operator++() { _ptr++; } T& operator*() { return *_ptr; } const T& operator*()const { return *_ptr; } private: T *_ptr; }; iterator begin() { return iterator(_first); } iterator end() { return iterator(_last); } private: T *_first;//起始数组位置 T *_last;//指向最后一个有效元素后继位置 T *_end;//指向数组空间的后继位置 Alloc _allocator;//定义容器的空间配置器对象 void expand()//扩容 { int size = _end - _first; //T *ptmp = new T[2*size]; T *ptmp = _allocator.allocate(2*size); for (int i=0; i<size; ++i) { _allocator.construct(ptmp+i, _first[i]); //ptmp[i] = _first[i]; } //delete[]_first; for (T *p=_first; p!=_last; ++p) { _allocator.destroy(p); } _allocator.deallocate(_first); _first = ptmp; _last = _first + size; _end = _first + 2*size; } }; int main() { vector<int> vec; for (int i=0; i<20; ++i) { vec.push_back(rand()%100); } int size = vec.size();//[]重载针对vector有意义 for (int i=0; i<size; ++i) { cout << vec[i] << \\\" \\\";//底层是数组，O(1) } cout << endl; vector<int>::iterator it = vec.begin(); //auto it = vec.begin(); for (; it!=vec.end(); ++it) { cout << *it << \\\" \\\"; } cout << endl; for(int val : vec)//底层还是通过容器的迭代器来实现遍历的 { cout << val << \\\" \\\"; } cout << endl; return 0; } \"]},\"705\":{\"c\":[\"c/c++\"]},\"706\":{\"c\":[\"运算符重载\",\"迭代器\"]},\"707\":{\"h\":\"剖析new和delete实现原理\",\"t\":[\"[new/delete关键字 | 张威的编程学习笔记 (gitee.io)](https://iszhwei.gitee.io/ccpp/02 c__基础/new、delete.html)\"]},\"708\":{\"h\":\"我们先来看一下：malloc与new、delete与free区别\",\"t\":[\"malloc与new的区别：\",\"①malloc按字节开辟内存的；new开辟内存时需要指定类型； ②malloc开辟内存返回的都是void *** ，new相当于运算符重载函数，返回值自动转为指定的类型的指针。** ③malloc只负责开辟内存空间，new不仅仅也有malloc功能，还可以进行数据的初始化。 ④malloc开辟内存失败返回nullptr指针；new抛出的是bad_alloc类型的异常。 ⑤malloc开辟单个元素内存与数组内存是一样的，都是给字节数；new开辟时对单个元素内存后面不需要[]，而数组需要[]并给上元素个数。\",\"free和delete的区别：\",\"①free不管释放单个元素内存还是数组内存，只需要传入内存的即可。 ②delete释放单个元素内存，不需要加中括号，但释放数据内存时需要加。 ③delete执行其实有两步，先调用析构，再释放；free只有一步。\"]},\"709\":{\"h\":\"new与delete实现原理进行剖析\",\"t\":[\"int* p = new int; delete p; \",\"将其转为反汇编后：\",\"我们发现，也是。\",\"new -> operator new delete -> operator delete \",\"那么我们自己实现一下它：\"]},\"710\":{\"h\":\"operator new的实现：\",\"t\":[\"//new:先调用operator开辟内存空间，然后调用对象的构造函数 void* operator new(size_t size) { void *p = malloc(size); if (p == nullptr) { throw bad_alloc(); } cout << \\\"operator new addr:\\\" << p <<endl; return p; } //operator new[]实现 void* operator new[](size_t size) { void *p = malloc(size); if (p == nullptr) { throw bad_alloc(); } cout << \\\"operator new[] addr:\\\" << p <<endl; return p; } \"]},\"711\":{\"h\":\"operator delete的实现：\",\"t\":[\"//delete p:调用p指向对象的析构函数，再调用operator delete释放内存空间 void operator delete(void *ptr) { cout << \\\"operator delete addr:\\\" << ptr <<endl; free(ptr); } //operator delete[]实现 void operator delete[](void *ptr) { cout << \\\"operator delete[] addr:\\\" << ptr <<endl; free(ptr); } \"]},\"712\":{\"h\":\"问题一：平常我们new与delete都是正常使用的，但是new与delete能混用吗？C++为什么区分单个元素和数组的内存分配和释放呢？\"},\"713\":{\"h\":\"情况1：int类型下将其混用\",\"t\":[\"int *p = new int; delete[]p; int *q = new int[10]; delete q; \",\"测试一下：能够混用。对于整型来说，没有构造函数与析构函数，针对于int类型，new与delete功能只剩下malloc与free功能，可以将其混用\"]},\"714\":{\"h\":\"情况2：类类型下将其混用\",\"t\":[\"class Test { public: Test(int data = 10):ptr(new int(data)) { cout << \\\"Test()\\\" << endl; } ~Test() { delete ptr; cout << \\\"~Test()\\\" << endl; } private: int *ptr; }; \",\"先来看一下对单个元素正常使用：\",\"Test *p1 = new Test(); delete p1; \",\"但是如果我们将单个元素与delete[]混用：\",\"Test *p1 = new Test(); delete[]p1; \",\"测试结果：。new与delete不能再混用了。\",\"再对数组类型正常使用：\",\"Test *p2 = new Test[5]; delete[]p2; \",\"最后将数组与delete进行混用：\",\"Test *p2 = new Test[5]; delete p2; \",\"测试结果：\"]},\"715\":{\"h\":\"分析\",\"t\":[\"正常情况下，每一个test对象有一个整型成员变量，我们这里分配了5个test对象。delete时先调用析构函数，this指针将正确的对象的地址传入析构函数中，加了[]表示有好几个对象，有一个数组其中每一个对象都要进行析构。但delete真正执行指令时，底层是malloc按字节开辟，并不知道是否开辟了5个test对象的数组，因此还要再多开辟一个4字节来存储对象的个数，假设它的地址是0x100；但是new完之后p2返回的地址是0x104地址，当我们执行delete[]时，会到4字节来取一下对象的个数，将知道了是5个并将这块内存平均分为5份，将其每一份对象起始地址传给相应的析构函数，正常析构，最后将0x100开始的4字节也释放。 而我们p2出错是给用户返回的存对象开始的起始地址，delete p2认为p2只是指向了一个对象，只将Test[0]对象析构，直接从0x104 free(p2)，但底层实际是从0x100开辟的，因此崩溃；而p1出错：p1只是单个元素，从0x104开始开辟内存，但是delete[]p1，里面并没有那么多元素，最后还释放了4个字节的存储对象个数的内存(即从0x100释放)因此崩溃。\",\"image-20240413175814411\",\"结论：自定义的类类型，有析构函数，为了调用正确的析构函数，那么开辟对象数组时会多开辟4个字节记录对象的个数，不能混用。\"]},\"716\":{\"h\":\"问题二：C++中如何设计一个程序 检查内训泄露 问题？\",\"t\":[\"核心是用new与delete运算符重载接管整个应用的内存管理，对。 检查内存泄露，new操作没有对应的delete，\"]},\"717\":{\"h\":\"要求一个类 只能创建栈对象\",\"t\":[\"意思是不能创建堆对象，栈上可以正常创建对象\",\"void test0() { //思考：栈对象的创建需要哪些条件?是不是只要构造函数不为私有就ok？ Student s1(101, \\\"John\\\");//ok Student *pstu = new Student(101, \\\"Mark\\\");//error } \",\"要达到以上的效果，咱们只需要\",\"构造函数不为私有\"]},\"718\":{\"h\":\"要求一个类只能创建堆对象\",\"t\":[\"创建出堆对象的同时，不能创建栈对象。\",\"void test1() { Student s1(101, \\\"John\\\");//error Student *pstu = new Student(101, \\\"Mark\\\");//ok } \",\"operator new不私有\"]},\"719\":{\"c\":[\"使用指南\"]},\"720\":{\"c\":[\"运算符重载\",\"new/delete\"]},\"721\":{\"h\":\"友元\",\"t\":[\"作用：访问类中的私有成员\",\"友元的形式可以分为友元函数和友元类。\",\"class 类名 { //... friend 函数原型; friend class 类名; //... } \",\"形式：\",\"1、友元之普通函数\",\"2、友元之成员函数\",\"3、友元之友元类\"]},\"722\":{\"h\":\"友元函数\",\"t\":[\"分为全局函数友元和成员函数友元\",\"float distance(const Point &lhs, const Point &rhs)//全局函数 { return hypot(lhs._ix - rhs._ix, lhs._iy - rhs._iy); } class Line { public: float distance(const Point &lhs, const Point &rhs)//成员函数 { return hypot(lhs._ix - rhs._ix, lhs._iy - rhs._iy); } }; class Point { public: Point(int ix = 0, int iy = 0) : _ix(ix) , _iy(iy) { } void print() const { cout << \\\"(\\\" << _ix << \\\",\\\" << _iy << \\\")\\\"; } friend float distance(const Point &lhs, const Point &rhs);//全局函数 friend float Line::distance(const Point &lhs, const Point &rhs);//成员函数 private: int _ix; int _iy; }; \"]},\"723\":{\"h\":\"友元类\",\"t\":[\"多个函数访问类的私有成员，一个个写成友元函数麻烦，可以封装一个友元类\",\"class Point { //... friend class Line; //... }; \"]},\"724\":{\"h\":\"友元的性质\",\"t\":[\"友元关系是单向的、没有传递性（A->B->C）、不能被继承\",\"友元的声明是不受public/protected/private访问关键字限制的。\"]},\"725\":{\"c\":[\"c/c++\"]},\"726\":{\"c\":[\"类和对象\"]},\"727\":{\"h\":\"复数类CComplex\",\"t\":[\"运算符重载：运算符不仅能实现原有的功能，而且能实现在函数中指定的新的功能。本质还是函数重载或函数多态\",\"//格式 函数类型 operator 运算符名称(形参表) { 对运算符的重载处理 } \",\"operator是关键字，是专门用于定义重载运算符的函数的，运算符名就是C++已有的运算符。\"]},\"728\":{\"h\":\"运算符重载的规则\",\"t\":[\"C++用户，只能对已有的C++运算符进行重载。\",\"只有5个：\",\". 成员访问运算符\",\".* 成员指针访问运算符\",\":: 域运算符\",\"sizeof 长度运算符\",\"?: 条件运算符\",\"重载运算符运算对象(即操作数)的\",\"重载不能改变运算符的别\",\"重载不能改变运算符的\",\"重载不能改变\",\"重载的运算符必须，其参数至少有一个是类对象(或类对象的引用)\",\"用于类对象的运算符一般必须重载，但有两个例外，“=”和“&”不必用户重载\"]},\"729\":{\"h\":\"测试sizeof是运算符\",\"t\":[\"//测试sizeof是运算符 int number = 10; sizeof(number) sizeof number//ok \"]},\"730\":{\"h\":\"究竟把运算符重载作为类的成员函数好，还是友元函数好？\",\"t\":[\"(1)C++规定，。 (2)和、不能定义为类的成员函数，。 (3)一般将单目运算符和复合运算符( += , -= , /= , = , &= , != , ^= , %= , >>= , <<= )重载为成员函数 。 (4）一般将*重载为友元**函数。\"]},\"731\":{\"h\":\"代码实现\",\"t\":[\"#include <iostream> using namespace std; class CComplex { public: CComplex(int r = 0, int i = 0) :_mreal(r) ,_mimage(i) { } void operator=(const CComplex&obj) { this->_mreal = obj._mreal; this->_mimage = obj._mimage; } //指导编译器怎么做CComplex类对象的加法操作 /*CComplex operator+(const CComplex&com) { return CComplex(this->_mreal + com._mreal, this->_mimage + com._mimage); }*/ CComplex operator++(int) { return CComplex(this->_mreal++, this->_mimage++); /*CComplex comp = *this; this->_mimage++; this->_mreal++; return comp;*/ } CComplex& operator++() { _mreal += 1; _mimage += 1; return *this; } void operator+=(const CComplex&rhs) { this->_mreal += rhs._mreal; this->_mimage += rhs._mimage; } void show() { cout << \\\"real:\\\" << _mreal << \\\"image:\\\" << _mimage << endl; } private: int _mreal; int _mimage; friend CComplex operator+(const CComplex &lhs, const CComplex &rhs); friend ostream& operator<<(ostream&out, const CComplex&src); friend istream& operator>>(istream&in, CComplex&src); }; istream& operator>>(istream&in, CComplex&src) { int a, b; in >> a >> b; src._mreal = a; src._mimage = b; return in; } ostream& operator<<(ostream&out, const CComplex&src) { out << \\\"real:\\\" << src._mreal << \\\"image:\\\" << src._mimage << endl; return out; } CComplex operator+(const CComplex &lhs, const CComplex &rhs) { return CComplex(lhs._mreal + rhs._mreal, lhs._mimage + rhs._mimage); } int main() { CComplex c1(1, 2); CComplex c2(2, 3); CComplex c4; c4 = c1+c2; c4.show(); c4 = c1 + 20; c4.show(); c4 = 30 + c2; c4.show(); CComplex c5; c5 = c4++; c5.show(); c5 = ++c4; c5.show(); c5 += c4; c5.show(); cout << \\\"++++++++++++++++++++++++++++++\\\" << endl; cout << c5; CComplex c6; cin >> c6; cout << c6; return 0; } \"]},\"732\":{\"c\":[\"c/c++\"]},\"733\":{\"c\":[\"运算符重载\"]},\"734\":{\"h\":\"运算符重载实现string类\"},\"735\":{\"h\":\"注意事项\",\"t\":[\"等号赋值的四步走\",\"防止自己给自己赋值\",\"释放之前所占的外部资源\",\"申请新的空间然后将数据拷贝进去\",\"返回*this\",\"析构函数执行后记得要把指针变量指向nullptr，避免野指针的出现。\",\"String str1; str.~String(); str.~String(); \",\"str在第二次调用析构函数后。\"]},\"736\":{\"h\":\"实现代码\",\"t\":[\"#include<iostream> using namespace std; enum error_num {OUTOFRANDGE}; //1，保证string没有空(不然每次操作的时候都需要判断是否为空，很麻烦) //2，不要出现野指针 class String { public: String(const char*ptr=nullptr) { //保证String类中_ptr不为空指针 if (ptr != nullptr) { _ptr = new char[strlen(ptr) + 1]; strcpy(_ptr, ptr); } else { _ptr = new char[1]; _ptr = '\\\\0'; } } ~String() { delete[]_ptr; _ptr = nullptr; } String(const String &src) { _ptr = new char[strlen(src._ptr) + 1]; strcpy(_ptr, src._ptr); } String(String &&src) { _ptr = src._ptr; src._ptr = nullptr;//++++++++++++++很重要很重要很重要很重要 } //返回值为String目的是为了可以连等于操作 String& operator=(const String &src) { if (&src == this) return *this; delete[]this->_ptr; _ptr = new char[strlen(src._ptr) + 1]; strcpy(_ptr, src._ptr); return *this; } String operator=(String &&src) { delete[]this->_ptr;//首先释放自己占有的外部资源，不然容易引起内存泄漏 _ptr = src._ptr; src._ptr = nullptr; } //等号右边的操作数为const char*不存在连等赋值，所以返回值为void void operator=(const char*_str) { delete[]this->_ptr; if (_str == nullptr) { _ptr = new char[1]; _ptr = '\\\\0'; } else { _ptr = new char[strlen(_str) + 1]; strcpy(_ptr, _str); } } bool operator>(const String&str)const { return strcmp(_ptr, str._ptr) > 0; } bool operator<(const String &str)const { return strcmp(_ptr, str._ptr) < 0; } bool operator==(const String &str)const { return strcmp(_ptr, str._ptr) == 0; } int length()const { return strlen(_ptr); } const char*c_str()const { return _ptr; } char &operator[](int index) { if (index > length() - 1 || index < 0) throw OUTOFRANDGE; return _ptr[index]; } private: char *_ptr; friend String operator + (const String &lhs, const String &rhs); friend ostream& operator<<(ostream &out, const String &str); friend istream& operator>>(istream &in, String &str); }; String operator+ (const String &lhs, const String &rhs) { String tmp; tmp._ptr = new char[strlen(lhs._ptr) + strlen(rhs._ptr) + 1]; strcpy(tmp._ptr, lhs._ptr); strcat(tmp._ptr, rhs._ptr); return tmp; } ostream& operator<<(ostream &out, const String &str) { out << str._ptr; return out; } istream& operator>>(istream &in, String &str) { /*delete[]str._ptr; str._ptr = nullptr; char tmp[1024] = { 0 }; in >> tmp; str = tmp; return in;*/ delete[] str._ptr; str._ptr = new char[1024]; in >> str._ptr; return in; } \"]},\"737\":{\"c\":[\"c/c++\"]},\"738\":{\"c\":[\"运算符重载\"]},\"739\":{\"h\":\"迭代器失效的底层核心原理\"},\"740\":{\"h\":\"迭代器失效问题\",\"t\":[\"对容器的操作，称为。\"]},\"741\":{\"h\":\"迭代器失效情况\",\"t\":[\"当容器调用**erase()方法后，到**的所有迭代器全部失效。\",\"当容器调用**insert()方法后，到**的所有迭代器全部失效。\",\"如果容器**，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器**了。\",\"不同容器的迭代器，是不能进行比较运算的。\"]},\"742\":{\"h\":\"失效问题1：把vec容器中所有的偶数全部 删除\",\"t\":[\"先使用库中的vector来看看什么是失效问题\",\"int main() { vector<int>vec; for (int i=0; i<20; ++i) { vec.push_back(rand()%100 + 1); } //把vec容器中所有的偶数全部删除 auto it = vec.begin(); for (; it!=vec.end(); ++it) { if (*it % 2 == 0) { vec.erase(it);//insert(it,val) erase(it) break;//只删除第一个偶数 } } return 0; } \",\"当我们调用vec.erase时加上break时候，程序执行成功。\",\"但如果我们去掉break时候：，第一次调用erase后，迭代器it就失效了，再对其进行++运算符重载函数调用就崩溃了。\"]},\"743\":{\"h\":\"失效问题2：给vec容器中所有的偶数前面 添加 一个小于偶数值1的数字\",\"t\":[\"int main() { vector<int>vec; for (int i=0; i<20; ++i) { vec.push_back(rand()%100 + 1); } //给vec容器中所有的偶数前面添加一个小于偶数值1的数字 auto it = vec.begin(); for (; it!=vec.end(); ++it) { if (*it % 2 == 0) { vec.insert(it, *it-1); break; } } } \",\"当我们调用vec.insert时加上break时候，程序执行成功。\",\"但如果我们去掉break时候：。这里的迭代器在第一次insert之后，iterator就失效了，再执行运算符重载函数调用就崩溃了。\"]},\"744\":{\"h\":\"如何解决迭代器失效问题\",\"t\":[\"解决方案：对插入/删除点的迭代器进行更新操作。\",\"在这里插入图片描述\"]},\"745\":{\"h\":\"解决失效问题1：解决删除问题\",\"t\":[\"vector<int>vec; for (int i=0; i<20; ++i) { vec.push_back(rand()%100 + 1); } for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; //把vec容器中所有的偶数全部删除 auto it = vec.begin(); while (it!=vec.end()) { if (*it % 2 == 0) { it = vec.erase(it);//insert(it,val) erase(it) //更新当前删除位置迭代器 } else { ++it; } } for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; \"]},\"746\":{\"h\":\"解决失效问题2：解决增加问题\",\"t\":[\"vector<int>vec; for (int i=0; i<20; ++i) { vec.push_back(rand()%100 + 1); } for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; //给vec容器中所有的偶数前面添加一个小于偶数值1的数字 auto it = vec.begin(); for (; it!=vec.end(); ++it) { if (*it % 2 == 0) { it = vec.insert(it, *it-1);//更新当前增加位置迭代器 ++it; //在当期遍历前一个位置插入，插入后要返回下一个位置 } } for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; return 0; \"]},\"747\":{\"h\":\"解决迭代器失效底层原理\",\"t\":[\"主要功能实现： 1.在iterator私有成员下添加一个指向当前对象的指针，让迭代器知道当前迭代的容器对象，不同容器之间不能相互比较。\",\"vector<T, Alloc> *_pVec;//指向当前对象容器的指针 \",\"2.容器迭代器失效增加代码，它是一个结构体维护了一个链表。cur是指向某一个结构体的指针，又定义了一个指向下一个Iterator_Base节点的地址，还定义了一个头节点。记录了用户从中获取的哪一个元素的迭代器，记录在Iterator_Base链表中，哪一个迭代器增加或删除要让其失效并重新更新。\",\"在这里插入图片描述\",\"//容器迭代器失效增加代码 struct Iterator_Base { Iterator_Base(iterator *c = nullptr, Iterator_Base *n =nullptr) :_cur(c), _next(n){} iterator *_cur; Iterator_Base *_next; }; Iterator_Base _head; \",\"3.构造函数中添加了接收外面传进容器对象的地址，将迭代器成员变量初始化。构造函数即新生成当前元素某一个位置的迭代器。\",\"//新生成当前容器某一个位置元素的迭代器 iterator(vector<T, Alloc> *pvec , T *ptr = nullptr) :_ptr(ptr), _pVec(pvec) { // 下面这两行相当于头插法 Iterator_Base *itb = new Iterator_Base(this, _pVec->_head._next); _pVec->_head._next = itb; } \",\"4.!=运算符号重载前要检查迭代器的有效性，即两个迭代器比较之前检查是否失效，或者是否是同一类型容器的迭代器。\",\"bool operator!=(const iterator &it)const { //检查迭代器的有效性 if (_pVec == nullptr || _pVec != it._pVec)//迭代器为空或迭代两个不同容器 { throw \\\"iterator incompatable!\\\"; } return _ptr != it._ptr; } \",\"5.++运算符重载前检查有效性。\",\"void operator++() { if (_pVec == nullptr) { throw \\\"iterator incalid!\\\"; } _ptr++; } \",\"6.* 运算符重载前检查有效性。\",\"T& operator*() { //检查迭代器有效性 if (_pVec == nullptr) { throw \\\"iterator invalid!\\\"; } return *_ptr; } const T& operator*()const { if (_pVec == nullptr) { throw \\\"iterator invalid!\\\"; } return *_ptr; } \",\"7.pop_back中加入了verfiy，pop_back从当前末尾删除，verify检查有效性。在我们增加或删除后，把我们当前节点的地址到末尾的地址，全部进行检查，在存储的迭代器链表上进行遍历，哪一个迭代器指针指向的迭代器迭代元素的指针在检查范围内，就将相应迭代器指向容器的指针置为空，即为失效的迭代器。\",\"void pop_back()//尾删 { if (empty()) return; verify(_last - 1, _last); //不仅要把_last指针--，还需要析构删除的元素 --_last; _allocator.destroy(_last); } void verify(T *first, T *last) { Iterator_Base *pre = &this->_head; Iterator_Base *it = this->_head._next; while (it != nullptr) { if (it->_cur->_ptr > first && it->_cur->_ptr <= last) { //迭代器失效，把iterator持有的容器指针置nullptr it->_cur->_pVec = nullptr; //删除当前迭代器节点，继续判断后面的迭代器节点是否失效 pre->_next = it->_next; delete it; it = pre->_next; } else { pre = it; it = it->_next; } } } \",\"8.自定义insert实现(未考虑扩容与ptr合法性)。\",\"//自定义vector容器insert方法实现 iterator insert(iterator it, const T &val) { //1.这里我们未考虑扩容 //2.还未考虑it._ptr指针合法性，假设它合法 verify(it._ptr - 1, _last); T *p = _last; while (p > it._ptr) { _allocator.construct(p, *(p-1)); _allocator.destroy(p - 1); p--; } _allocator.construct(p, val); _last++; return iterator(this, p); } \",\"9.自定义erase实现。\",\"//自定义vector容器erase方法实现 iterator erase(iterator it) { verify(it._ptr - 1, _last); T *p = it._ptr; while (p < _last-1) { _allocator.destroy(p); _allocator.construct(p, *(p+1)); p++; } _allocator.destroy(p); _last--; return iterator(this, it._ptr); } \",\"测试1:比较it1与it2\",\"vector<int> vec; for (int i=0; i<20; ++i) { vec.push_back(rand()%100 + 1); } auto it1 = vec.end(); auto it2 = vec.end(); cout << (it1 != it2) << endl; \",\"测试结果：测试成功，它们都在vec.end。\",\"测试2：加上pop_back\",\"vector<int> vec; for (int i=0; i<20; ++i) { vec.push_back(rand()%100 + 1); } auto it1 = vec.end(); vec.pop_back();//verify(_last-1, _last) auto it2 = vec.end(); cout << (it1 != it2) << endl; \",\"测试结果：测试成功，此时迭代器失效。\",\"测试3：使用insert并对迭代器更新\",\"vector<int> vec(200); for (int i=0; i<20; ++i) { vec.push_back(rand()%100 + 1); } //给vec容器中所有的偶数前面添加一个小于偶数值1的数字 auto it = vec.begin(); for (; it!=vec.end(); ++it) { if (*it % 2 == 0) { it = vec.insert(it, *it-1);//更新当前增加位置迭代器 ++it; } } for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; \",\"测试4：使用insert未对迭代器更新\",\"vector<int> vec(200); for (int i=0; i<20; ++i) { vec.push_back(rand()%100 + 1); } //给vec容器中所有的偶数前面添加一个小于偶数值1的数字 auto it = vec.begin(); for (; it!=vec.end(); ++it) { if (*it % 2 == 0) { vec.insert(it, *it-1);//更新当前增加位置迭代器 ++it; } } for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; \",\"测试结果：测试成功，迭代器失效\",\"测试5.使用erase并对迭代器更新\",\"vector<int> vec(200); for (int i=0; i<20; ++i) { vec.push_back(rand()%100 + 1); } //把vec容器中所有的偶数全部删除 auto it = vec.begin(); while (it!=vec.end()) { if (*it % 2 == 0) { it = vec.erase(it);//insert(it,val) erase(it) //break;//只删除第一个偶数 } else { ++it; } } for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; \",\"测试结果：删除成功。\",\"测试6.使用erase未对源代码进行更新\",\"vector<int> vec(200); for (int i=0; i<20; ++i) { vec.push_back(rand()%100 + 1); } //把vec容器中所有的偶数全部删除 auto it = vec.begin(); while (it!=vec.end()) { if (*it % 2 == 0) { vec.erase(it);//insert(it,val) erase(it) //break;//只删除第一个偶数 } else { ++it; } } for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; \",\"测试结果：测试成功，迭代器失效。\"]},\"748\":{\"c\":[\"c/c++\"]},\"749\":{\"c\":[\"运算符重载\",\"迭代器\"]},\"750\":{\"h\":\"重载new和delete运算符实现一个对象池\",\"t\":[\"[new/delete关键字 | 张威的编程学习笔记 (github.io)](https://iszhwei.github.io/ccpp/02 c__基础/new、delete.html)\",\"当我们需要，会使得我们的程序进程的。\",\"通过****一个对象池，提高程序的效率和减少不必要的开销。\"]},\"751\":{\"h\":\"使用队列的push和pop入队和出队操作模拟一个简单对象池的实现的例子\",\"t\":[\"image-20240410192158623\",\"#include <iostream> #include <ctime> using namespace std; template<typename T> class Queue { public: Queue() { _front = _rear = new QueueItem(); } ~Queue() { QueueItem* cur = _front; while (cur != nullptr) { _front = _front->_next; delete cur; cur = _front; } } void push(const T& val) { // 有了对象池后，这个操作在多数情况下只需要构造而没有分配内存的操作 QueueItem* item = new QueueItem(val); _rear->_next = item; _rear = item; } void pop() { if (empty()) { return; } // _front指向队首元素前一个位置 QueueItem* first = _front->_next;; _front->_next = first->_next; if (_front->_next == nullptr) { _rear = _front; // 置空 } delete first; } T front() const { return _front->_next->_data; } bool empty()const { return _front == _rear; } private: // 内部类，队列的元素抽象 struct QueueItem { QueueItem(T data = T()) : _data(data), _next(nullptr) {} // 给QueueItem提供自定义内存管理 void* operator new(size_t size) { // 提前开辟POOL_ITEM_SIZE个对象的空间，不构造 if (_itemPool == nullptr) { // 分配字节，如果用new QueueItem会陷入递归调用 _itemPool = (QueueItem*)new char[POOL_ITEM_SIZE * sizeof(QueueItem)]; QueueItem* p = _itemPool; // 将每个对象空间组织成链表 // 每次循环跳跃空间大小为sizeof(QueueItem) for (; p < _itemPool + POOL_ITEM_SIZE - 1; ++p) { p->_next = p + 1; } p->_next = nullptr; } // 已经有对象池，则从头取出一块对象空间来 QueueItem* p = _itemPool; _itemPool = _itemPool->_next; return p; } void operator delete(void* ptr) { // 头插法归还空间 QueueItem* p = (QueueItem*)ptr; p->_next = _itemPool; _itemPool = p; } T _data; QueueItem* _next; static QueueItem* _itemPool; // 指向对象池首个元素的指针 static const int POOL_ITEM_SIZE = 100000; // 对象池大小 }; QueueItem* _front; // 队头不指向具体元素 QueueItem* _rear; }; // typename Queue<T>::QueueItem是告知编译器 Queue<T>::QueueItem是类型而不是成员变量，从而把后面*当乘号 template<typename T> typename Queue<T>::QueueItem *Queue<T>::QueueItem::_itemPool = nullptr; int main() { clock_t startTime, endTime; startTime = clock();//计时开始 Queue<int> que; for (int i = 0; i < 1000000; ++i) { que.push(i); que.pop(); } endTime = clock(); cout << \\\"The run time is:\\\" << (double)(endTime - startTime) / CLOCKS_PER_SEC * 1000 << \\\"ms\\\" << endl; return 0; } \"]},\"752\":{\"c\":[\"c/c++\"]},\"753\":{\"c\":[\"运算符重载\",\"对象池\",\"new/delete\"]},\"754\":{\"h\":\"Leetcode 234. 回文链表\",\"t\":[\"Leetcode 234. 回文链表\",\"题目描述：给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。\"]},\"755\":{\"h\":\"方法一：数组+双指针\",\"t\":[\"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: bool isPalindrome(ListNode* head) { vector<int> vec; for(ListNode* p = head; p != nullptr; p = p->next) {//O(n) vec.push_back(p->val); //空间复杂度O(n) } for(int i = 0, j = vec.size() - 1; i < j; ++i, --j) { //O(n/2) if(vec[i] != vec[j]) { return false; } } return true; } }; \"]},\"756\":{\"h\":\"方法二：反转后半部链表（空间复杂度O(1))\",\"t\":[\"避免使用 O(n) 额外空间的方法就是改变输入。\",\"我们可以将链表的后半部分反转（修改链表结构），然后将前半部分和后半部分进行比较。比较完成后我们应该将链表恢复原样。虽然不需要恢复也能通过测试用例，但是使用该函数的人通常不希望链表结构被更改。\",\"步骤：\",\"找到前半部分链表的尾节点。(快慢指针)\",\"反转后半部分链表。\",\"判断是否回文。\",\"恢复链表。\",\"返回结果。\",\"Leetcode876.链表的中间结点 (该链表有两个中间结点，返回第二个结点。)\",\"leetcode206.反转链表\",\"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: bool isPalindrome(ListNode* head) { if(head == nullptr) { return true; } //1.找到前半部分链表的尾节点(找中间结点) ListNode* fistHalfEnd = endOfFirstHalf(head); cout << fistHalfEnd->val << endl; //2.反转后半部分链表。 ListNode* secondHalfStart = reverseList(fistHalfEnd->next); //3.判断是否回文 ListNode* p1 = head; ListNode* p2 = secondHalfStart; while (p2) { //链表长度若为偶数，则p1链长度 == p2链；若为奇数，则p1链长度 = p2链 + 1 if(p1->val != p2->val) { return false; } p1 = p1->next; p2 = p2->next; } //4.还原链表并返回结果 fistHalfEnd->next = reverseList(secondHalfStart); return true; } ListNode* reverseList(ListNode* head) { ListNode* temp = nullptr; ListNode* pre = nullptr; ListNode* cur = head; while(cur) { temp = cur->next; cur->next = pre; pre = cur; cur = temp; } return pre; } ListNode* endOfFirstHalf(ListNode* head) { ListNode* slow = head; ListNode* fast = head; while(fast->next && fast->next->next) {//该链表有两个中间结点，返回第一个结点。 fast = fast->next->next; slow = slow->next; } return slow; } }; \"]},\"757\":{\"c\":[\"数据结构与算法\"]},\"758\":{\"c\":[\"链表\",\"数组\",\"双指针\"]},\"759\":{\"h\":\"LeetCode 203.移除链表元素\",\"t\":[\"LeetCode 203.移除链表元素\",\"题目描述：给定链表头节点head和整数val，删除所有值为val的节点 ，返回新的头节点\",\"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeElements(ListNode* head, int val) { ListNode* dummyHead = new ListNode(0, head); ListNode* cur = dummyHead; while(cur->next) { if(cur->next->val == val) { //cur->next->val不是cur->next.val ListNode* temp = cur->next; cur->next = cur->next->next; delete temp; temp = nullptr; } else { cur = cur->next; } } head = dummyHead->next; delete dummyHead; dummyHead = nullptr; return head; } }; \",\"删除结点后记得释放结点，然后将指针置空\"]},\"760\":{\"c\":[\"数据结构与算法\"]},\"761\":{\"c\":[\"链表\",\"虚拟头结点\"]},\"762\":{\"h\":\"leetcode 21. 合并两个有序链表\",\"t\":[\"21. 合并两个有序链表\",\"**题目表述：**将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。\",\"注意：读清题意，不是用新的链表\",\"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) { ListNode *dummyHead = new ListNode(-1); ListNode *res = dummyHead; ListNode *p1 = list1; ListNode *p2 = list2; while(p1 != nullptr && p2 != nullptr) { // ListNode* newNode = nullptr; if(p1->val < p2->val) { //newNode = new ListNode(p1->val,nullptr); res->next = p1; p1 = p1->next; //记得让p1往前走一位 } else { // newNode = new ListNode(p2->val, nullptr); res->next = p2; p2 = p2->next; } res = res->next;//让新链表的指针往前走一位 // res->next = newNode; // res = res->next; } if(p1 != nullptr) { //if判断哪个还有剩，不需要while遍历后面的所有的结点 // ListNode* newNode = new ListNode(p1->val); // res->next = newNode; // res = res->next; res->next = p1; } if(p2 != nullptr) { // ListNode* newNode = new ListNode(p2->val); // res->next = newNode; // res = res->next; res->next = p2; } ListNode* head = dummyHead->next; delete dummyHead; dummyHead = nullptr; return head; } }; \"]},\"763\":{\"c\":[\"数据结构与算法\"]},\"764\":{\"c\":[\"链表\",\"虚拟头结点\",\"双指针\"]},\"765\":{\"h\":\"leetcode 141. 环形链表 (判断链表是否有环)\",\"t\":[\"leetcode 141. 环形链表 (判断链表是否有环)\",\"判断链表是否包含环属于经典问题了，解决方案也是用：\",\"每当慢指针 slow 前进一步，快指针 fast 就前进两步。如果 fast 最终遇到空指针，说明链表中没有环；如果 fast 最终和 slow 相遇，那肯定是 fast 超过了 slow 一圈（相对静止），说明链表中含有环。\",\"bool hasCycle(ListNode* head) { // 初始化快慢指针，指向头结点 ListNode* fast = head; ListNode* slow = head; // 快指针到尾部时停止 while(fast && fast->next) { // 慢指针走一步，快指针走两步 fast = fast->next->next; slow = slow->next; // 快慢指针相遇，说明含有环 if(fast == slow) { return ture; } } // 不包含环 return false; } \"]},\"766\":{\"c\":[\"数据结构与算法\"]},\"767\":{\"c\":[\"链表\",\"双指针\"]},\"768\":{\"h\":\"Leetcode 142. 环形链表 II (查找环的入口地址)\",\"t\":[\"Leetcode 142. 环形链表 II (查找环的入口地址)\",\"**题目描述：**给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\",\"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; // 快指针到尾部时停止 while(fast && fast->next) { // 慢指针走一步，快指针走两步 fast = fast->next->next; slow = slow->next; // 快慢指针相遇，说明含有环 if(fast == slow) { slow = head; while(fast != slow) { fast = fast->next; slow = slow->next; } return slow; } } // 不包含环 return nullptr; } }; \"]},\"769\":{\"c\":[\"数据结构与算法\"]},\"770\":{\"c\":[\"链表\",\"双指针\"]},\"771\":{\"h\":\"leetcode 160. 相交链表 (判断链表是否相交)\",\"t\":[\"leetcode 160. 相交链表 (判断链表是否相交)\",\"**题目描述：**给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。\",\"img\",\"方法一：计算两个链表的差，让长的先走m-n步，然后一起走，如果后面相交则p1 == p2，否则各自走到链尾\",\"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode* p1 = headA; ListNode* p2 =headB; int lenA = 0; int lenB = 0; while(p1) { ++lenA; p1 = p1->next; } while(p2) { ++lenB; p2 = p2->next; } p1 = headA; //注意重置指针，要不就是操控空指针 p2 = headB; int num = abs(lenA-lenB); if(lenA > lenB) { while(num--) { p1 = p1->next; } } else { while(num--) { p2 = p2->next; } } while(p1 != p2) { p1 = p1->next; p2 = p2->next; } return p1; } }; \",\"方法二：走位自己的链表后返回走另一个，第二圈时如果相遇则p1==p2,否则两个两个一起走到链尾p1=nullptr,p2 = nullptr\",\"class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { ListNode* p1 = headA; ListNode* p2 = headB; while(p1 != p2) {//找不到p1走n+m,p2走m+n，同时为nullptr;找到则p1==p2 if(p1) { p1 = p1->next; } else { // p1 走一步，如果走到 A 链表末尾，转到 B 链表 p1 = headB; } if(p2) { p2 = p2->next; } else { // p2 走一步，如果走到 B 链表末尾，转到 A 链表 p2 = headA; } } return p1; } }; \",\"时间复杂度：O(m+n)，其中m 和 n是分别是链表 headA 和 headB 的长度。两个指针同时遍历两个链表，每个指针遍历两个链表各一次。\",\"空间复杂度：O(1)。\"]},\"772\":{\"c\":[\"数据结构与算法\"]},\"773\":{\"c\":[\"链表\",\"双指针\"]},\"774\":{\"h\":\"Leetcode 19. 删除链表的倒数第 N 个结点\",\"t\":[\"Leetcode 19. 删除链表的倒数第 N 个结点\",\"**题目描述：**给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\",\"**关键：**fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作）\",\"image-20240113171317370\",\"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { if(head == nullptr) { return nullptr; } ListNode* dummyHead = new ListNode(-1, head); ListNode* fast = dummyHead; ListNode* slow = dummyHead; ++n; while(n--) { //这里不要写成--n fast = fast->next; } while(fast) { fast = fast->next; slow = slow->next; } ListNode* temp = slow->next; slow->next = slow->next->next; delete temp; temp = dummyHead->next; delete dummyHead; dummyHead = nullptr; return temp; } }; \",\"while()中--n和n--不一样\",\"//借用2.6的代码 class Solution { public: ListNode* findFromEnd(ListNode* list, int n) { ListNode* fast = list; ListNode* slow = list; while(fast && n--) { //先走N步 fast = fast->next; } while(fast) { //当fast为空时 slow刚好指在目标元素上 fast = fast->next; slow = slow->next; } return slow; } ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* cur = findFromEnd(head, n + 1); //因为删除元素需要知道前一个元素的位置 ListNode* temp = cur->next; cur->next = cur->next->next; delete temp; temp = nullptr; return head; } }; \"]},\"775\":{\"c\":[\"数据结构与算法\"]},\"776\":{\"c\":[\"链表\",\"双指针\"]},\"777\":{\"h\":\"leetcode 206. 反转链表\",\"t\":[\"leetcode 206. 反转链表\",\"**题目描述：**给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\",\"方法一：虚拟头结点+头插法\",\"class Solution { public: ListNode* reverseList(ListNode* head) { if(head == nullptr) { return nullptr; } ListNode* dummyHead = new ListNode(-1, head); ListNode* p1 = dummyHead; while( p1 && p1->next) { //头插 ListNode* temp = p1->next; p1->next = dummyHead->next; dummyHead->next = p1; p1 = temp; } if(p1 != nullptr) {//最后一个结点 p1->next = dummyHead->next; } head->next = nullptr; return p1; } }; \",\"**方法二：**类似 int temp = a; a =b; b =temp;\",\"class Solution { public: ListNode* reverseList(ListNode* head) { ListNode* p1 = head; ListNode* p2 = nullptr; //记录反转后链表的头结点 ListNode* temp = nullptr; //暂存p1的下一个结点的位置 while(p1) { temp = p1->next; p1->next = p2; //翻转 p2 = p1; p1 = temp; } return p2; } }; \"]},\"778\":{\"c\":[\"数据结构与算法\"]},\"779\":{\"c\":[\"链表\"]},\"780\":{\"h\":\"Leetcode 23. 合并 K 个升序链表\",\"t\":[\"Leetcode 23. 合并 K 个升序链表\",\"**题目描述：**给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。\"]},\"781\":{\"h\":\"分治思想\"},\"782\":{\"h\":\"方法一：顺序合并\",\"t\":[\"两两合并，用一个变量res 来维护以及合并的链表，第 i 次循环把第 i 个链表和res合并，答案保存到 res 中。\",\"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(!l1) { return l2; } if(!l2) { return l1; } ListNode* dummyHead = new ListNode(); ListNode* cur = dummyHead; while(l1 && l2) { if(l1->val < l2->val) { cur->next = l1; l1 = l1->next; } else { cur->next = l2; l2 = l2->next; } cur = cur->next; } if(l1) { cur->next = l1; } if(l2) { cur->next = l2; } ListNode* head = dummyHead->next; delete dummyHead; dummyHead = nullptr; return head; } ListNode* mergeKLists(vector<ListNode*>& lists) { size_t len = lists.size(); if(!len) { return nullptr; } ListNode* res = nullptr; for(size_t i = 0; i < len; ++i) { res = mergeTwoLists(res, lists[i]); } return res; } }; \"]},\"783\":{\"h\":\"方法二：分治合并\",\"t\":[\"![img](Leetcode23. 合并 K 个升序链表.assets/6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662-image.png)\",\"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(!l1) { return l2; } if(!l2) { return l1; } ListNode* dummyHead = new ListNode(); ListNode* cur = dummyHead; while(l1 && l2) { if(l1->val < l2->val) { cur->next = l1; l1 = l1->next; } else { cur->next = l2; l2 = l2->next; } cur = cur->next; } if(l1) { cur->next = l1; } if(l2) { cur->next = l2; } ListNode* head = dummyHead->next; delete dummyHead; dummyHead = nullptr; return head; } ListNode* mergeList(vector<ListNode*>& lists, int left, int right) { if(left == right) { //切记不要写= return lists[left]; } if(left > right) { return nullptr; } size_t middle = left + (right - left) / 2; ListNode* list1 = mergeList(lists, left, middle); ListNode* list2 = mergeList(lists, middle + 1, right); return mergeTwoLists(list1, list2); } ListNode* mergeKLists(vector<ListNode*>& lists) { size_t len = lists.size(); if(!len) { return nullptr; } ListNode* res = nullptr; for(size_t i = 0; i < len; ++i) { res = mergeTwoLists(res, lists[i]); } return res; } }; \"]},\"784\":{\"h\":\"优先队列\",\"t\":[\"合并 k 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 k 个节点中的最小节点，接到结果链表上？\",\"这里我们就要用到 优先级队列（二叉堆） 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 k 个节点中的最小节点\",\"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* mergeKLists(vector<ListNode*>& lists) { if(lists.empty()) { return nullptr; } ListNode* dummyHead = new ListNode(); ListNode* cur = dummyHead; auto cmp = [](ListNode* l1, ListNode* l2) { return l1->val > l2->val; //使用小根堆 }; //记得这里有`;` priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp); for(auto head : lists) { if(head != nullptr) { //注意：这里要判断是否遍历完成 pq.push(head); //将头结点压入队列 } } while(!pq.empty()) { ListNode* minNode = pq.top(); pq.pop(); cur->next = minNode; if(minNode->next) { //所在list还有元素，将下一个结点做这个list的head压入队列 pq.push(minNode->next); } cur = cur->next; } return dummyHead->next; } }; \",\"C++ priority_queue 与 lambda的结合使用\",\"class student{ public: int age; string name; /**重载小于操作符， *这里必须是非成员函数才可以 */ friend bool operator<(const student& a, const student & b){ return a.age < b.age; } }; /**可调用的函数操作符的对象*/ struct mycmp{ bool operator()(const student & a,const student & b){ return a.age < b.age; } }; /**函数指针*/ bool cmpfunc(const student& a, const student& b){ return a.age < b.age; } /**默认使用student的oprator<来进行比较*/ priority_queue<student> que1; /**使用重载函数操作符的类对象*/ priority_queue<student,vector<student>,mycmp> que2; /**定义一下比较函数*/ auto cmp = [](const student & a,const student & b){return a.age < b.age;}; /** * 需要把lambda表达式作为优先队列参数进行初始化 * 并且指定priority_queue的模板实参，decltype(cmp)，c++11 declare type，声明类型 * 可以认为是确定函数的类型 * bool (const student & a,const student & b) **/ priority_queue<student,vector<student>,decltype(cmp)> que4(cmp); /*使用函数对象来定义这个比较函数原型*/ //lambda 函数来初始化函数对象 priority_queue<student,vector<student>,function<bool(const student&,const student&)>> que5(cmp); //函数指针来初始化函数对象 priority_queue<student,vector<student>,function<bool(const student&,const student&)>> que6(cmpfunc); /**函数对象*/ function<bool(const student&,const student &)> func(cmpfunc); priority_queue<student,vector<student>,function<bool(const student&,const student&)>> que7(func); \"]},\"785\":{\"c\":[\"数据结构与算法\"]},\"786\":{\"c\":[\"链表\",\"分治思想\",\"双指针\",\"优先队列\"]},\"787\":{\"h\":\"Leetcode 61.旋转链表.md\",\"t\":[\"Leetcode 61. 旋转链表\",\"给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。\",\"img\",\"思路：\",\"计算链表长度\",\"找到 k取模链表长度 (k % length) 开始的子链表\",\"拼接子链表和原链表(被截取后的部分)\",\"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { if(k == 0 || head == nullptr || head->next == nullptr) { return head; } int len = 0; ListNode* p1 = head; ListNode* tail = head; while(p1) { ++len; tail = p1; p1 = p1->next; } k = k % len; ListNode* pre = findFromEnd(head, k + 1);//倒数第K+1 tail->next = head; head = pre->next; pre->next = nullptr; return head; } ListNode* findFromEnd(ListNode* head, int N) { ListNode* fast = head; ListNode* slow = head; while(N--) { fast = fast->next; } while(fast) { fast = fast->next; slow = slow->next; } return slow; } }; \"]},\"788\":{\"c\":[\"数据结构与算法\"]},\"789\":{\"c\":[\"链表\",\"双指针\"]},\"790\":{\"h\":\"LeetCode 707.设计链表\",\"t\":[\"LeetCode 707.设计链表\",\"题目描述：在链表类中实现这些功能：\",\"get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。\",\"addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。\",\"addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。\",\"addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。\",\"deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。\",\"index是从0开始的\",\"可创建虚拟头节点简化操作\"]},\"791\":{\"h\":\"单链表\",\"t\":[\"img\",\"//单向链表 class MyLinkedList { public: struct ListNode{ int val; ListNode* next; ListNode(int val = 0, ListNode* next = nullptr) : val(val), next(next) {} }; MyLinkedList() { _dummyHead = new ListNode(0, nullptr); _size = 0; } int get(int index) { if(index < 0||index >= _size) { return -1; } ListNode* pcur = _dummyHead->next; //第一个数据结点 while(index--) { pcur = pcur->next; } return pcur->val; } void addAtHead(int val) { ListNode* ptemp = new ListNode(val, _dummyHead->next); _dummyHead->next = ptemp; ++_size; } void addAtTail(int val) { ListNode* pcur = _dummyHead;//需要前驱结点，真正要插入位置pcur->next while(pcur->next) { pcur = pcur->next; } ListNode*ptemp = new ListNode(val, nullptr); pcur->next = ptemp; ++_size; } void addAtIndex(int index, int val) { if(index < 0 || index > _size) { return; } ListNode* pcur = _dummyHead; while(index--) { pcur = pcur->next; } ListNode* ptemp = new ListNode(val, pcur->next); pcur->next = ptemp; ++_size; } void deleteAtIndex(int index) { if(index < 0 || index >= _size) { return; } ListNode* pcur = _dummyHead; while(index--) { pcur = pcur->next; } ListNode* ptemp = pcur->next; pcur->next = pcur->next->next; delete ptemp; ptemp = nullptr; --_size; } private: ListNode* _dummyHead; size_t _size; }; /** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj->get(index); * obj->addAtHead(val); * obj->addAtTail(val); * obj->addAtIndex(index,val); * obj->deleteAtIndex(index); */ \",\"实现 addAtHead(val)和 addAtTail(val)时，可以借助 addAtIndex(index, val)来实现。\",\"void addAtHead(int val) { addAtIndex(0, val); } void addAtTail(int val) { addAtIndex(_size, val); } \"]},\"792\":{\"h\":\"双向链表\",\"t\":[\"img\",\"//双向链表 struct DLinkedListNode { int val; DLinkedListNode *pre, *next; //注意同时定义两个指针的方法 DLinkedListNode(int val = 0, DLinkedListNode* pre = nullptr,DLinkedListNode* next = nullptr) : val(val), pre(pre), next(next) {} }; class MyLinkedList { private: DLinkedListNode* findElement(int index,DLinkedListNode* pcur = nullptr) { //先定义游标，在判断是靠近_phead还是_ptail if(index <= _size/2) { //前-半 pcur = _phead;//指向第一个结点 for(int i = 0; i < index + 1; ++i) { pcur = pcur->next; } } else {//后一半 pcur = _ptail; for(int i = 0; i < _size - index; ++i) { //_size - index正好pcur = 目标 pcur = pcur->pre; } } return pcur; } public: MyLinkedList() { _size = 0; _phead = new DLinkedListNode(); _ptail = new DLinkedListNode(); _phead->next = _ptail; _ptail->pre = _phead; } int get(int index) { if(index < 0 || index >= _size) { return -1; } DLinkedListNode* res = findElement(index); return res->val; } void addAtHead(int val) { //addAtIndex(0, val); DLinkedListNode* newNode = new DLinkedListNode(val,_phead,_phead->next); _phead->next->pre = newNode; _phead->next = newNode; ++_size; } void addAtTail(int val) { //addAtTail(_size, val); DLinkedListNode* newNode = new DLinkedListNode(val, _ptail->pre, _ptail); _ptail->pre->next = newNode; _ptail->pre = newNode; ++_size; } void addAtIndex(int index, int val) { if(index < 0||index > _size) { return; } DLinkedListNode* pcur = findElement(index); DLinkedListNode* newNode = new DLinkedListNode(val, pcur->pre, pcur); pcur->pre->next = newNode; pcur->pre = newNode; ++_size; } void deleteAtIndex(int index) { if(index < 0||index >= _size) { return; } DLinkedListNode* pcur = findElement(index); pcur->next->pre = pcur->pre; pcur->pre->next = pcur->next; delete pcur; pcur = nullptr; --_size; } private: int _size; DLinkedListNode* _phead; DLinkedListNode* _ptail; }; /** * Your MyLinkedList object will be instantiated and called as such: * MyLinkedList* obj = new MyLinkedList(); * int param_1 = obj->get(index); * obj->addAtHead(val); * obj->addAtTail(val); * obj->addAtIndex(index,val); * obj->deleteAtIndex(index); */ \",\"单链表：关键找到前驱，真正插入或者删除的元素是pcur->next\",\"双向链表：关键是找到目标元素，借助pre和next指针完成插入和删除\"]},\"793\":{\"c\":[\"数据结构与算法\"]},\"794\":{\"c\":[\"链表\"]},\"795\":{\"h\":\"leetcode 86. 分隔链表（链表的分解）\",\"t\":[\"leetcode 86. 分隔链表（链表的分解）\",\"给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于x 的节点都出现在 大于或等于x 的节点之前。\",\"你应当 保留 两个分区中每个节点的初始相对位置。\",\"解这道题两个关键点： 1. 先分成两个链表，一个链表存放小，另一个存放大的（创建链表用虚拟头结点） 2. 原链表结点给新链表后记得断开与原链表的结点的连接（next = nullptr） !!! \",\"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* partition(ListNode* head, int x) { ListNode *dummyHead1 = new ListNode(-1); //小于x ListNode *dummyHead2 = new ListNode(-1); //大于或等于x ListNode *p1 = dummyHead1; ListNode *p2 = dummyHead2; ListNode *pcur = head; while(pcur) { if(pcur->val < x) { p1->next = pcur; p1 = p1->next; } else { p2->next = pcur; p2 = p2->next; } //如果你不断开原链表中的每个节点的 next 指针 ListNode* temp = pcur; pcur = pcur->next; temp->next = nullptr; } p1->next = dummyHead2->next; head = dummyHead1->next; delete dummyHead1; delete dummyHead2; dummyHead1 = nullptr; dummyHead2 = nullptr; return head; } }; \",\"如果你不断开原链表中的每个节点的 next 指针，结果链表中会包含一个环。总的来说，如果我们需要把原链表的节点接到新链表上，而不是 new 新节点来组成新链表的话，。那其实我们可以养成一个好习惯，但凡遇到这种情况，就把原链表的节点断开，这样就不会出错了。\"]},\"796\":{\"c\":[\"数据结构与算法\"]},\"797\":{\"c\":[\"链表\",\"双指针\"]},\"798\":{\"h\":\"Leetcode 876. 链表的中间结点\",\"t\":[\"Leetcode 876. 链表的中间结点\",\"**题目描述：**给你单链表的头结点 head ，请你找出并返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。\",\"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* middleNode(ListNode* head) { ListNode* dummyHead = new ListNode(-1, head); ListNode* fast = dummyHead; ListNode* slow = dummyHead; while(fast&& fast->next) { fast = fast->next->next; slow = slow->next; } if(fast && fast->next == nullptr) { slow = slow->next; } return slow; } }; \",\"实际上不需要虚拟头结点即可\",\"class Solution { public: ListNode* middleNode(ListNode* head) { ListNode* fast = head; ListNode* slow = head; while(fast&& fast->next) {//如果有两个中间结点，则返回第二个中间结点。 fast = fast->next->next; slow = slow->next; } return slow; } }; \"]},\"799\":{\"c\":[\"数据结构与算法\"]},\"800\":{\"c\":[\"双指针\",\"链表\"]},\"801\":{\"h\":\"leetcode 92. 反转链表 II\",\"t\":[\"leetcode 92. 反转链表 II\",\"给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。\"]},\"802\":{\"h\":\"方法一：穿针引线\",\"t\":[\"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { private: void reverseLinkList(ListNode* head) { ListNode* p1 = head; ListNode* p2 = nullptr; ListNode* temp = nullptr; while(p1) { temp = p1->next; p1->next = p2; p2 = p1; p1 = temp; } } public: ListNode* reverseBetween(ListNode* head, int left, int right) { //注意，由示例可知，left、right是编号不是下标 // 因为头节点有可能发生变化，使用虚拟头节点可以避免复杂的分类讨论 ListNode* dummyHead = new ListNode(-1,head); ListNode* p1 = dummyHead; size_t count = 0; // 第 1 步：从虚拟头节点走 left - 1 步，来到 left 节点的前一个节点 // 建议写在 for 循环里，语义清晰 while(p1 && count < left - 1) { p1 = p1->next; ++count; } ListNode* preLeftNode = p1; // 第 2 步：从 pre 再走 right - left + 1 步，来到 right 节点 while(p1 && count < right) { ++count; p1 = p1->next; } // 第 3 步：切断出一个子链表（截取链表） ListNode* leftNode = preLeftNode->next; ListNode* rightNext = p1->next; preLeftNode->next = nullptr; p1->next = nullptr; //第 4 步：反转链表的子区间 reverseLinkList(leftNode); // 第 5 步：接回到原来的链表中 preLeftNode->next = p1; leftNode->next = rightNext; head = dummyHead->next; delete dummyHead; dummyHead = nullptr; return head; } }; \",\"方法一的缺点是：如果 left 和 right 的区域很大，恰好是链表的头节点和尾节点时，找到 left 和 right 需要遍历一次，反转它们之间的链表还需要遍历一次，虽然总的时间复杂度为 O(N)，但遍历了链表 2 次，可不可以只遍历一次呢？答案是可以的。\"]},\"803\":{\"h\":\"方法二：一次遍历「穿针引线」反转链表（头插法）\",\"t\":[\"image.png\"]},\"804\":{\"c\":[\"数据结构与算法\"]},\"805\":{\"c\":[\"链表\",\"双指针\"]},\"806\":{\"h\":\"查找链表中倒数第N个结点\",\"t\":[\"ListNode* findFromEnd(ListNode* list, int n) { ListNode* fast = list; ListNode* slow = list; while(fast && n--) { //先走N步 fast = fast->next; } while(fast) { //当fast为空时 slow刚好指在目标元素上 fast = fast->next; slow = slow->next; } return slow; } \"]},\"807\":{\"c\":[\"数据结构与算法\"]},\"808\":{\"c\":[\"链表\",\"双指针\"]},\"809\":{\"h\":\"约瑟夫环问题\"},\"810\":{\"h\":\"情景一\",\"t\":[\"约瑟夫环是一个数学的应用问题：已知n个人（以编号1，2，3...n分别表示）围坐在一张圆桌周围，从 编号为k的人开始报数，数到m的那个人出列，它的下一个人又从1开始报数，数到m的那个人又出列， 依此规律重复下去，直到圆桌周围的人全部出列，输出人的出列顺序。\",\"#include <iostream> using std::cout; using std::endl; struct Node { int _data; Node* _next; Node(int data = 0, Node* next = nullptr) : _data(data), _next(next) {} }; void josephRing(int n, int k, int m) { //创建循环链表 Node* head = new Node(1); Node* p = head; for(int i = 2; i <= n; ++i) { Node* newNode = new Node(i); p->_next = newNode; p = p->_next; } p->_next = head; //p指向尾结点 //先走k步 Node* q = head; for(int i = 1; i < k; ++i) { p = q; q = q->_next; } //结束后q指向第K个人 while(1) { for(int i = 1; i < m; ++i) { p = q; q = q->_next; }//q指向第m人 cout << q->_data << \\\" \\\"; if( p == q) {//只剩最后一个结点 delete q; cout << endl; return; } else { p->_next = q->_next; delete q; q = p->_next; } } } int main(void) { josephRing(8, 1, 3); josephRing(8, 1, 1); } \",\"$./main 3 6 1 5 2 8 4 7 1 2 3 4 5 6 7 8 \"]},\"811\":{\"h\":\"情景二\",\"t\":[\"15个教徒和15 个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了一个办法：30个人围成一圆圈，从第一个人开始依次报数，每数到第九个人就将他扔入大海，如此循环进行直到仅余15个人为止。问怎样排法，才能使每次投入大海的都是非教徒。\",\"“约瑟夫环”问题的四种方法及详解注释（c++实现）_约瑟夫环c++-CSDN博客\"]},\"812\":{\"h\":\"情景三\",\"t\":[\"LCR 187. 破冰游戏\",\"社团共有 num 为成员参与破冰游戏，编号为 0 ~ num-1。成员们按照编号顺序围绕圆桌而坐。社长抽取一个数字 target，从 0 号成员起开始计数，排在第 target 位的成员离开圆桌，且成员离开后从下一个成员开始计数。请返回游戏结束时最后一位成员的编号。\"]},\"813\":{\"c\":[\"数据结构与算法\"]},\"814\":{\"c\":[\"链表\",\"循环链表\"]},\"815\":{\"h\":\"链表基础知识\",\"t\":[\"特点：每一个节点都是在堆内存上独立new出来的，节点内存不连续\",\"优点 \",\"内存利用率高，不需要大块连续内存\",\"插入和删除节点不需要移动其它节点，时间复杂度O(1)\",\"不需要专门进行扩容操作\",\"缺点 \",\"内存占用量大，每一个节点多出存放地址的空间\",\"节点内存不连续，无法进行内存随机访问\",\"链表搜索效率不高，只能从头节点开始逐节点遍历\"]},\"816\":{\"h\":\"单向链表\",\"t\":[\"特点：\",\"每一个节点除了数据域，还有一个next指针域指向下一个节点(存储了下一个节点的地址)，但是无法回退到前一个节点\",\"末尾节点的指针域是NULL\"]},\"817\":{\"h\":\"单向链表的实现\",\"t\":[\"//LinkedList.h #ifndef _LINKEDLIST_H_ #define _LINKEDLIST_H_ #include <iostream> using std::cout; using std::endl; class LinkedList { public: LinkedList(); ~LinkedList(); void push_back(int val); void pop_back(); void push_front(int val); void pop_front(); void remove(int val); void removeAll(int val); bool find(int val); void show(); private: struct Node{ int _data; Node* _next; Node(int data = 0, Node* next = nullptr) : _data(data), _next(next) {} }; Node* head; }; #endif // _LINKEDLIST_H_ \",\"//LinkedList.cc #include \\\"LinkedList.h\\\" LinkedList::LinkedList() { head = new Node(); } LinkedList::~LinkedList() { Node* p = head; while(p != nullptr) { head = head->_next; delete p; p = head; } } void LinkedList::push_back(int val) { Node* newNode = new Node(val); Node* p = head; while(p->_next != nullptr) { p = p->_next; } p->_next = newNode; } void LinkedList::pop_back() { Node* cur = head->_next; Node* pre = head; while(cur->_next != nullptr) { pre = cur; cur = cur->_next; } delete cur; pre->_next = nullptr; } void LinkedList::push_front(int val) { Node* newNode = new Node(val, head->_next); head->_next = newNode; } void LinkedList::pop_front() { Node* p = head->_next; if(p != nullptr) { head->_next = p->_next; delete p; } } void LinkedList::remove(int val) { Node* cur = head->_next; Node* pre = head; while(cur != nullptr) { if(cur->_data == val) { pre->_next = cur->_next; delete cur; return; } else { pre = cur; cur = cur->_next; } } } void LinkedList::removeAll(int val) { Node* cur = head->_next; Node* pre = head; while(cur != nullptr) { if(cur->_data == val) { pre->_next = cur->_next; delete cur; cur = pre->_next;//注意需要重置cur } else { pre = cur; cur = cur->_next; } } } bool LinkedList::find(int val) { Node* cur = head->_next; while(cur->_next != nullptr) { if(cur->_data == val) { return true; } else { cur = cur->_next; } } return false; } void LinkedList::show() { Node* cur = head->_next; while(cur) { cout << cur->_data << \\\" \\\"; cur = cur->_next; } cout << endl; } \",\"//main.cc #include \\\"LinkedList.h\\\" #include <iostream> #include <time.h> #include <stdlib.h> using std::cout; using std::endl; int main(void) { LinkedList list; srand(time(nullptr)); for(int i = 0; i < 10; ++i) { list.push_back(rand()%100); } list.show(); list.pop_back(); list.pop_front(); list.show(); list.push_front(100); cout << list.find(100) << endl; list.remove(100); cout << list.find(100) << endl; list.push_back(100); list.push_back(100); list.push_back(100); list.show(); list.removeAll(100); list.show(); } \",\"$./main 73 69 66 82 7 66 21 6 88 77 69 66 82 7 66 21 6 88 1 0 69 66 82 7 66 21 6 88 100 100 100 69 66 82 7 66 21 6 88 \"]},\"818\":{\"h\":\"单向循环链表\",\"t\":[\"特点：\",\"每一个节点除了数据域，还有一个next指针域指向下一个节点(存储了下一个节点的地址)\",\"末尾节点的指针域指向了头节点\"]},\"819\":{\"h\":\"单向循环链表的实现\",\"t\":[\"#include <iostream> using std::cout; using std::endl; class CircleList { public: CircleList() { _head = new Node(); _head->_next = _head; _tail = _head; } ~CircleList(){ Node* p = _head->_next; while(p != _head) { //循环链表结束条件 _head = p->_next; delete p; p = _head; } delete _head; //最后记得释放头结点 } void insertTail(int val) { Node* newNode = new Node(val, _head); _tail->_next = newNode; _tail = newNode; } void insertHead(int val) { Node* newNode = new Node(val, _head->_next); _head->_next = newNode; if(newNode->_next == _head) { //如果只有一个结点的情况 _tail = newNode; } } void remove(int val) { Node* p = _head; Node* temp = nullptr; while (p->_next != _head) { if(p->_next->_data == val) { temp = p->_next; p->_next = p->_next->_next; delete temp; if(p->_next == _head) { _tail = p; } return; } else{ p = p->_next; } } } bool find(int val) const { Node* p = _head->_next; while(p != _head) { if(p->_data == val) { return true; } } return false; } void show() { Node* p = _head->_next; while(p != _head) { cout << p->_data << \\\" \\\"; p = p->_next; //记得重置p } cout << endl; } private: struct Node { int _data; Node* _next; Node(int data = 0, Node* next = nullptr) : _data(data), _next(next) {}; }; Node* _head; Node* _tail; }; int main(void) { CircleList clist; srand(time(nullptr)); for(int i = 0; i < 10; ++i) { clist.insertTail(rand()%100); } clist.show(); clist.insertHead(200); cout << clist.find(200) << endl; clist.remove(200); clist.show(); } \",\"$./main 98 13 13 33 99 6 2 35 15 18 1 98 13 13 33 99 6 2 35 15 18 \"]},\"820\":{\"h\":\"双向链表\",\"t\":[\"特点：\",\"每一个节点除了数据域，还有next指针域指向下一个节点，pre指针域指向前一个节点\",\"头节点的pre是NULL，末尾节点的next是NULL\"]},\"821\":{\"h\":\"基础版\",\"t\":[\"#include <iostream> using std::cout; using std::endl; class DoubleLink{ public: DoubleLink() { _head = new Node(); } ~DoubleLink() { Node* p = _head; while(p->_next) { _head = p->_next; delete p; p = _head; } _head = nullptr; } void insertTail(int val) { Node* newNode = new Node(val); Node* p = _head; while(p->_next) { p = p->_next; } p->_next = newNode; newNode->_pre = p; } void insertHead(int val) { Node* newNode = new Node(val); newNode->_next = _head->_next; newNode->_pre = _head; if(_head->_next != nullptr) { _head->_next->_pre = newNode; } _head->_next = newNode; } void remove(int val) { Node* p = _head; while(p) { if(p->_data == val) { p->_pre->_next = p->_next; if(p->_next) { //注意加一个判断 p->_next->_pre = p->_pre; } delete p; return; } p = p->_next; } } bool find(int val) { Node* p = _head->_next; //有头结点的注意一下 while(p) { if(p->_data == val) { return true; } p = p->_next; } return false; } void show() { Node* p = _head->_next; while(p) { cout << p->_data << \\\" \\\"; p = p->_next; } cout << endl; } private: struct Node { int _data; Node* _pre; Node* _next; Node(int data = 0, Node* pre = nullptr, Node* next = nullptr) : _data(data), _pre(pre), _next(next) {} }; Node* _head; }; int main(void) { DoubleLink dlink; dlink.insertHead(100); dlink.insertHead(10); dlink.insertHead(20); dlink.insertTail(30); dlink.insertTail(40); dlink.show(); dlink.remove(100); dlink.remove(20); dlink.remove(40); dlink.show(); cout << dlink.find(10); } \"]},\"822\":{\"h\":\"升级版\",\"t\":[\"LeetCode707 链表设计\"]},\"823\":{\"h\":\"双向循环链表\",\"t\":[\"特点：\",\"每一个节点除了数据域，还有next指针域指向下一个节点，pre指针域指向前一个节点\",\"头节点的pre指向末尾节点，末尾节点的next指向头节点\"]},\"824\":{\"c\":[\"数据结构与算法\"]},\"825\":{\"c\":[\"基础知识\",\"链表\"]},\"826\":{\"h\":\"Pimpl\",\"t\":[\"PIMPL（Private Implementation 或Pointer to Implementation）是通过一个，将指针所指向的类的内部。PIMPL又称作“编译防火墙”，它的实现中就用到了嵌套类。PIMPL设计模式有如下优点：\",\"提高编译速度；\",\"数据成员只有一个指针，使得每个对象占用内存较小\",\"可以将实现文件编译成库文件\",\"实现信息隐藏；\",\"头文件只有接口和一个数据指针，无法推断出底层的实现\",\"减小编译依赖，可以用最小的代价平滑的升级库文件；\",\"不需要重新编译就可以替换库文件，便于软件升级\",\"如果用户代码需要使用这个类，它就需要 include 这个头文件，根据 C++ 的头文件展开原则，其他的代码也需要 include 这个头文件里面涉及到的所有的头文件。因此，一旦这里面相关的代码有变动，不止变动的代码需要重新编译，用户代码也需要重新编译，这会使编译速度变得很慢。\",\"接口与实现进行解耦；\",\"移动语义友好。\",\"//Line.h class Line { public: Line(int,int,int,int); ~Line(); void printLine() const; private: class LineImpl;//类的前向声明 LineImple *_pimpl; }; \",\"//Line.cc #include \\\"Line.h\\\" //功能实现由嵌套类实现 class Line::LineImpl { public: LineImpl(int x1, int y1, int x2, int y2); void printLineImpl() const; private: class Point { public: Point(int x = 0, int y = 0) : _x(x), _y(y) { } void print() const; private: int _x; int _y; }; Point _pt1; Point _pt2; }; Line::LineImpl::LineImpl(int x1, int y1, int x2, int y2) : _pt1(x1, y1) , _pt2(x2, y2) { } void Line::LineImpl::printLineImpl() const { _pt1.print(); cout << \\\" ---> \\\"; _pt2.print(); cout << endl; } //外部接口 Line::Line(int x1, int y1, int x2, int y2) : _pimpl(new LineImpl(x1, y1, x2, y2)) { } Line::~Line() { delete _pimpl; _pimpl = nullpter; } void Line::printLine() const { _pimpl->printLineImpl(); } \"]},\"827\":{\"c\":[\"c/c++\"]},\"828\":{\"c\":[\"设计模式\"]},\"829\":{\"h\":\"代理模式、适配器模式、装饰器模式\",\"t\":[\"代理模式、适配器模式、装饰器模式属于结构型设计模式，这些模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式\"]},\"830\":{\"h\":\"1、代理模式\",\"t\":[\"不是所有的客户都能访问到老板，老板的助理，即通过代理类，来控制实际对象的访问权限。\",\"代理类和委托类是组合关系！！！\",\"客户是不能直接使用委托类的，因为委托类是包含所有功能的！（）\",\"代理类也是从基类派生的（）！客户是直接访问代理类的，代理类中有个抽象类的指针，指向为委托类的对象！（）\",\"因为代理类和委托类都继承重写了基类的所有方法，因此代理类在成员方法中可以控制委托类的成员方法访问权限！\",\"#include <iostream> #include <memory> using namespace std; /* 代理Proxy模式 : 通过代理类，来控制实际对象的访问权限 客户 助理Proxy 老板 委托类 */ class VideoSite // #1 抽象类 { public: virtual void freeMovie() = 0; // 免费电影 virtual void vipMovie() = 0; // vip电影 virtual void ticketMovie() = 0; // 用券观看电影 }; // 委托类 #2 class FixBugVideoSite : public VideoSite { public: virtual void freeMovie() // 免费电影 { cout << \\\"观看免费电影\\\" << endl; } virtual void vipMovie() // vip电影 { cout << \\\"观看VIP电影\\\" << endl; } virtual void ticketMovie() // 用券观看电影 { cout << \\\"用券观看电影\\\" << endl; } }; // 代理类 #3 代理FixBugVideoSite class FreeVideoSiteProxy : public VideoSite { public: FreeVideoSiteProxy() { Video = new FixBugVideoSite(); } ~FreeVideoSiteProxy() { delete Video; } virtual void freeMovie() // 免费电影 { Video->freeMovie(); // 通过代理对象的freeMovie，来访问真正委托类对象的freeMovie方法 } virtual void vipMovie() // vip电影 { cout << \\\"您目前只是普通游客，需要升级成VIP，才能观看VIP电影\\\" << endl; } virtual void ticketMovie() // 用券观看电影 { cout << \\\"您目前没有券，需要购买电影券，才能观看电影\\\" << endl; } private: VideoSite* Video; // # 4 组合的方式 }; // 代理类 代理FixBugVideoSite class VipVideoSiteProxy : public VideoSite { public: VipVideoSiteProxy() { pVideo = new FixBugVideoSite(); } ~VipVideoSiteProxy() { delete pVideo; } virtual void freeMovie() // 免费电影 { pVideo->freeMovie(); // 通过代理对象的freeMovie，来访问真正委托类对象的freeMovie方法 } virtual void vipMovie() // vip电影 { pVideo->vipMovie(); } virtual void ticketMovie() // 用券观看电影 { cout << \\\"您目前没有券，需要购买电影券，才能观看电影\\\" << endl; } private: VideoSite* pVideo; //组合的方式 }; // 这些都是通用的API接口，使用的都是基类的指针或者引用 void watchMovice(unique_ptr<VideoSite>& ptr) { ptr->freeMovie(); ptr->vipMovie(); ptr->ticketMovie(); } int main() { unique_ptr<VideoSite> p1(new FreeVideoSiteProxy()); // #5 客户直接访问代理对象 unique_ptr<VideoSite> p2(new VipVideoSiteProxy()); watchMovice(p1); cout << \\\"=============================\\\" << endl; watchMovice(p2); return 0; } \",\"为都提供了！\"]},\"831\":{\"h\":\"2、装饰器模式\",\"t\":[\"目的： 为了增强现有类的功能。\",\"增加类的功能，还可以增加一个子类！（太麻烦）\",\"给每个车增加两个功能，需要增加6个类！\",\"为了增强现有类的功能，通过实现子类的方式，重写接口，是可以完成功能扩展的，但是代码中有太多的子类添加进来了\",\"因此我们使用装饰器模式！\",\"和代理模式很像，只不过装饰器会对装饰的对象进行功能的扩展！\",\"#include <iostream> #include <memory> using namespace std; /* 装饰器模式 Decorator 通过子类实现功能增强的问题：为了增强现有类的功能，通过实现子类的方式， 重写接口，是可以完成功能扩展的，但是代码中有太多的子类添加进来了 */ class Car // 抽象基类 { public: virtual void show() = 0; }; // 三个实体的汽车类 class Bmw : public Car { public: void show() { cout << \\\"这是一辆宝马汽车，配置有：基类配置\\\"; } }; class Audi : public Car { public: void show() { cout << \\\"这是一辆奥迪汽车，配置有：基类配置\\\"; } }; class Benz : public Car { public: void show() { cout << \\\"这是一辆奔驰汽车，配置有：基类配置\\\"; } }; // 装饰器1 定速巡航 class ConcreteDecorator01 : public Car { public: ConcreteDecorator01(Car* p) :pCar(p) {} void show() { pCar->show();//原来的方法 cout << \\\",定速巡航\\\";//新添加的功能 } private: Car* pCar; }; class ConcreteDecorator02 : public Car { public: ConcreteDecorator02(Car* p) :pCar(p) {} void show() { pCar->show(); cout << \\\",自动刹车\\\"; } private: Car* pCar; }; class ConcreteDecorator03 : public Car { public: ConcreteDecorator03(Car* p) :pCar(p) {} void show() { pCar->show(); cout << \\\",车道偏离\\\"; } private: Car* pCar; }; int main() { Car* p1 = new ConcreteDecorator01(new Bmw()); p1 = new ConcreteDecorator02(p1); p1 = new ConcreteDecorator03(p1); p1->show(); cout << endl; Car* p2 = new ConcreteDecorator02(new Audi()); p2->show(); cout << endl; Car* p3 = new ConcreteDecorator03(new Benz()); p3->show(); cout << endl; return 0; } \"]},\"832\":{\"h\":\"3、适配器模式\",\"t\":[\"适配器模式： 让不兼容的接口可以在一起工作\",\"举个例子：\",\"电脑 =》 投影到 =》 投影仪上\",\"常用的投影接口的类型有：VGA HDMI TypeC\",\"假如我们有VGA接口的电脑， 刚好(TV)投影仪也是VGA接口（此时电脑上的视频可以直接投到投影仪上）\",\"#include <iostream> #include <string> using namespace std; /* 适配器模式：让不兼容的接口可以在一起工作 电脑 =》 投影到 =》 投影仪上 VGA HDMI TypeC VGA接口的电脑， (TV)投影仪也是VGA接口 */ class VGA // VGA接口类 { public: virtual void play() = 0; }; // TV01表示支持VGA接口的投影仪 class TV01 : public VGA { public: void play() { cout << \\\"通过VGA接口连接投影仪，进行视频播放\\\" << endl; } }; // 实现一个电脑类(只支持VGA接口) class Computer { public: // 由于电脑只支持VGA接口，所以该方法的参数也只能支持VGA接口的指针/引用 void playVideo(VGA* pVGA) { pVGA->play(); } }; /* 方法1：换一个支持HDMI接口的电脑，这个就叫代码重构 方法2：买一个转换头（适配器），能够把VGA信号转成HDMI信号，这个叫添加适配器类 */ // 进了一批新的投影仪，但是新的投影仪都是只支持HDMI接口 class HDMI { public: virtual void play() = 0; }; class TV02 : public HDMI { public: void play() { cout << \\\"通过HDMI接口连接投影仪，进行视频播放\\\" << endl; } }; // 由于电脑（VGA接口）和投影仪（HDMI接口）无法直接相连，所以需要添加适配器类 class VGAToHDMIAdapter : public VGA { public: VGAToHDMIAdapter(HDMI* p) :pHdmi(p) {} void play() // 该方法继承于VGA,实现中调用hdmi的play，相当于就是转换头，做不同接口的信号转换的 { pHdmi->play(); } private: HDMI* pHdmi; }; int main() { Computer computer; //computer.playVideo(new TV01()); computer.playVideo(new VGAToHDMIAdapter(new TV02())); return 0; } \"]},\"833\":{\"c\":[\"c/c++\"]},\"834\":{\"c\":[\"设计模式\"]},\"835\":{\"h\":\"单例模式\"},\"836\":{\"h\":\"什么是单例模式\",\"t\":[\"单例模式是指在整个系统生命周期内，保证一个类只能产生一个实例，确保该类的唯一性。\"]},\"837\":{\"h\":\"为什么需要单例模式\",\"t\":[\"节省资源。一个类只有一个实例，不存在多份实例，节省资源。\",\"方便控制。在一些操作公共资源的场景时，避免了多个对象引起的复杂操作。\"]},\"838\":{\"h\":\"线程安全\"},\"839\":{\"h\":\"什么是线程安全？\",\"t\":[\"在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。\"]},\"840\":{\"h\":\"如何保证线程安全？\",\"t\":[\"给共享的资源，保证每个资源变量每时每刻至多被一个线程占用。\",\"让线程也拥有资源，不用去共享进程中的资源。如：使用threadlocal可以为每个线程维护一个私有的本地变量。\"]},\"841\":{\"h\":\"单例类的特点\",\"t\":[\"构造函数和析构函数为私有类型，目的是禁止外部构造和析构。\",\"拷贝构造函数和赋值构造函数是私有类型，目的是禁止外部拷贝和赋值，确保实例的唯一性。\",\"类中有一个获取实例的静态方法，可以全局访问。\"]},\"842\":{\"h\":\"单例模式分类\",\"t\":[\"单例模式可以分为 懒汉式 和 饿汉式 ，两者之间的区别在于创建实例的时间不同。\"]},\"843\":{\"h\":\"懒汉式\",\"t\":[\"系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。这种方式\"]},\"844\":{\"h\":\"饿汉式\",\"t\":[\"在编译期就初始化创建实例，当需要时，直接调用即可。这种方式本身就线程安全，没有多线程的问题。\",\"优点：线程安全\",\"缺点： \",\"浪费内存，即使对象没有使用也会被创建\",\"不能加载一些运行时的资源\"]},\"845\":{\"h\":\"单例模式实现\",\"t\":[\"单例的经典实现方式是「」，推荐使用这种方式。\"]},\"846\":{\"h\":\"普通懒汉式单例（线程不安全）\",\"t\":[\"这种情况是线程不安全的，不作详细介绍。\"]},\"847\":{\"h\":\"加锁的懒汉式单例（线程安全）\",\"t\":[\"使用互斥锁保证线程安全。\"]},\"848\":{\"h\":\"方法1：返回普通指针\",\"t\":[\"/// 加锁的懒汉式实现 // class SingleInstance { public: // 获取单实例对象 static SingleInstance *GetInstance(); //释放单实例，进程退出时调用 static void deleteInstance(); // 打印实例地址 void Print(); private: // 将其构造和析构成为私有的, 禁止外部构造和析构 SingleInstance(); ~SingleInstance(); // 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值 SingleInstance(const SingleInstance &signal); const SingleInstance &operator=(const SingleInstance &signal); private: // 唯一单实例对象指针 static SingleInstance *m_SingleInstance; static std::mutex m_Mutex; }; \",\"源文件：\",\"//初始化静态成员变量 SingleInstance *SingleInstance::m_SingleInstance = nullptr; std::mutex SingleInstance::m_Mutex; // 注意：不能返回指针的引用，否则存在外部被修改的风险！ SingleInstance * SingleInstance::GetInstance() { // 这里使用了两个 if 判断语句的技术称为双检锁；好处是，只有判断指针为空的时候才加锁， // 避免每次调用 GetInstance的方法都加锁，锁的开销毕竟还是有点大的。 if (m_SingleInstance == nullptr) { std::unique_lock<std::mutex> lock(m_Mutex); // 加锁 if (m_SingleInstance == nullptr) { volatile auto temp = new (std::nothrow) SingleInstance(); m_SingleInstance = temp; } } return m_SingleInstance; } void SingleInstance::deleteInstance() { std::unique_lock<std::mutex> lock(m_Mutex); // 加锁 if (m_SingleInstance) { delete m_SingleInstance; m_SingleInstance = nullptr; } } void SingleInstance::Print() { std::cout << \\\"我的实例内存地址是:\\\" << this << std::endl; } SingleInstance::SingleInstance() { std::cout << \\\"构造函数\\\" << std::endl; } SingleInstance::~SingleInstance() { std::cout << \\\"析构函数\\\" << std::endl; } \"]},\"849\":{\"h\":\"方法2：返回智能指针\",\"t\":[\"#include <iostream> #include <memory> #include <mutex> class Singleton { public: static std::shared_ptr<Singleton> getSingleton(); void print() { std::cout << \\\"Hello World.\\\" << std::endl; } ~Singleton() { std::cout << __PRETTY_FUNCTION__ << std::endl; } private: Singleton() { std::cout << __PRETTY_FUNCTION__ << std::endl; } }; static std::shared_ptr<Singleton> singleton = nullptr; static std::mutex singletonMutex; std::shared_ptr<Singleton> Singleton::getSingleton() { if (singleton == nullptr) { std::unique_lock<std::mutex> lock(singletonMutex); if (singleton == nullptr) { volatile auto temp = std::shared_ptr<Singleton>(new Singleton()); singleton = temp; } } return singleton; } \"]},\"850\":{\"h\":\"静态局部变量的懒汉单例（C++11线程安全）\",\"t\":[\"头文件：\",\"/// 内部静态变量的懒汉实现 // class Single { public: // 获取单实例对象 static Single& GetInstance(); // 打印实例地址 void Print(); private: // 禁止外部构造 Single(); // 禁止外部析构 ~Single() // 禁止外部拷贝构造 Single(const Single &single) = delete; // 禁止外部赋值操作 const Single &operator=(const Single &single) = delete; }; \",\"源文件：\",\"Single& Single::GetInstance() { /** * 局部静态特性的方式实现单实例。 * 静态局部变量只在当前函数内有效，其他函数无法访问。 * 静态局部变量只在第一次被调用的时候初始化，也存储在静态存储区，生命周期从第一次被初始化起至程序结束止。 */ static Single single; return single; } void Single::Print() { std::cout << \\\"我的实例内存地址是:\\\" << this << std::endl; } Single::Single() { std::cout << \\\"构造函数\\\" << std::endl; } Single::~Single() { std::cout << \\\"析构函数\\\" << std::endl; } \"]},\"851\":{\"h\":\"饿汉式单例（线程安全）\",\"t\":[\"头文件：\",\"// 饿汉实现 / class Singleton { public: // 获取单实例 static Singleton* GetInstance(); // 释放单实例，进程退出时调用 static void deleteInstance(); // 打印实例地址 void Print(); private: // 将其构造和析构成为私有的, 禁止外部构造和析构 Singleton(); ~Singleton(); // 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值 Singleton(const Singleton &signal); const Singleton &operator=(const Singleton &signal); private: // 唯一单实例对象指针 static Singleton *g_pSingleton; }; \",\"源文件：\",\"// 代码一运行就初始化创建实例 ，本身就线程安全 Singleton* Singleton::g_pSingleton = new (std::nothrow) Singleton(); Singleton* Singleton::GetInstance() { return g_pSingleton; } void Singleton::deleteInstance() { if (g_pSingleton) { delete g_pSingleton; g_pSingleton = nullptr; } } void Singleton::Print() { std::cout << \\\"我的实例内存地址是:\\\" << this << std::endl; } Singleton::Singleton() { std::cout << \\\"构造函数\\\" << std::endl; } Singleton::~Singleton() { std::cout << \\\"析构函数\\\" << std::endl; } \"]},\"852\":{\"h\":\"使用 C++11 std::call_once 实现单例（C++11线程安全）\",\"t\":[\"#include <iostream> #include <memory> #include <mutex> class Singleton { public: static std::shared_ptr<Singleton> getSingleton(); void print() { std::cout << \\\"Hello World.\\\" << std::endl; } ~Singleton() { std::cout << __PRETTY_FUNCTION__ << std::endl; } private: Singleton() { std::cout << __PRETTY_FUNCTION__ << std::endl; } }; static std::shared_ptr<Singleton> singleton = nullptr; static std::once_flag singletonFlag; std::shared_ptr<Singleton> Singleton::getSingleton() { std::call_once(singletonFlag, [&] { singleton = std::shared_ptr<Singleton>(new Singleton()); }); return singleton; } \"]},\"853\":{\"h\":\"单例模式的自动释放\",\"t\":[\"使用单例设计模式的过程中，也难免会遇到内存泄漏的问题。那么是否有一个方法，可以让对象自动释放，而不需要程序员自己手动去释放呢？在学习了嵌套类之后，我们就可以完美的解决这一问题。 在涉及到自动的问题时，我们很自然的可以想到：当对象被销毁时，会自动调用其析构函数。利用这一特性，我们可以解决这一问题。\"]},\"854\":{\"h\":\"可以使用友元形式进行设计\",\"t\":[\"//1、友元实现单例对象的自动释放 class AutoRelease; class Singleton { friend AutoRelease; public: static Singleton *getInstance() { if(nullptr == _pInstance) { _pInstance = new Singleton(); } return _pInstance; } static void destroy() { if(_pInstance) { delete _pInstance; //1、调用析构函数 2、operator delete _pInstance = nullptr; } } private: Singleton() { cout << \\\"Singleton()\\\" << endl; } ~Singleton() { cout << \\\"~Singleton()\\\" << endl; } private: static Singleton *_pInstance; }; Singleton *Singleton::_pInstance = nullptr; class AutoRelease { public: AutoRelease() { cout << \\\"AutoRelease()\\\" << endl; } ~AutoRelease() { cout << \\\"~AutoRelease()\\\" << endl; if(Singleton::_pInstance) { delete Singleton::_pInstance;//1、调用析构函数 2、operator delete Singleton::_pInstance = nullptr; } } }; \"]},\"855\":{\"h\":\"内部类加静态数据成员形式\",\"t\":[\"class Singleton { public: static Singleton * getInstance() { if(_pInstance == nullptr) { _pInstance = new Singleton(); } return _pInstance; } private: class AutoRelease { public: AutoRelease() { cout << \\\"AutoRelease()\\\" << endl; } ~AutoReleas() { cout << \\\"~AutoRelease()\\\" << endl; if(_pInstance) { delete _pInstance; _pInstance = nullptr; } } }; private: Singleton() { cout << \\\"Singleton()\\\" << endl; } ~Singleton() { cout << \\\"~Singleton()\\\" << endl; } private: static Singleton *_pInstance; static AutoRelease _auto; }; \"]},\"856\":{\"h\":\"atexit方式进行\",\"t\":[\"class Singleton { public: static Singleton *getInstance() { //对于多线程环境，不安全 if(nullptr == _pInstance) { _pInstance = new Singleton(); atexit(destroy); } return _pInstance; } static void destroy() { if(_pInstance) { delete _pInstance;//1、调用析构函数 2、operator delete _pInstance = nullptr; } } private: Singleton() { cout << \\\"Singleton()\\\" << endl; } ~Singleton() { cout << \\\"~Singleton()\\\" << endl; } private: static Singleton *_pInstance; }; /* Singleton *Singleton::_pInstance = nullptr; //饱汉模式(懒汉模式)*/ Singleton *Singleton::_pInstance = getInstance();//饿汉模式 \"]},\"857\":{\"h\":\"pthread_once形式\",\"t\":[\"//4、pthread_once,平台相关性的函数 class Singleton { public: static Singleton *getInstance() { pthread_once(&_once, init); return _pInstance; } static void init() { _pInstance = new Singleton(); atexit(destroy); } static void destroy() { if(_pInstance) { delete _pInstance;//1、调用析构函数 2、operator delete _pInstance = nullptr; } } private: Singleton() { cout << \\\"Singleton()\\\" << endl; } ~Singleton() { cout << \\\"~Singleton()\\\" << endl; } private: static Singleton *_pInstance; static pthread_once_t _once; }; Singleton *Singleton::_pInstance = nullptr; //饱汉模式(懒汉模式) /* Singleton *Singleton::_pInstance = getInstance();//饿汉模式 */ pthread_once_t Singleton::_once = PTHREAD_ONCE_INIT; \"]},\"858\":{\"c\":[\"c/c++\"]},\"859\":{\"c\":[\"设计模式\"]},\"860\":{\"h\":\"简单工厂、工厂方法、抽象工厂\",\"t\":[\"属于创建型设计模式\"]},\"861\":{\"h\":\"简单工厂（Simple Factory）\",\"t\":[\"简单工厂（Simple Factory） 不属于标准的OOP设计模式中的一项，工厂方法和抽象工厂是属于标准的23种设计模式的；\",\"在编写大型C++软件的时候，代码里面会出现，每次创建对象的时候，都需要通过new 类名称的方式来生成对象，这样一来，用户，暂且不管记不记得住，这样的设计使得代码很难维护，，不符合我们软件设计的思想，Simple Factory就是在这样的需求下诞生的。\",\"工厂方法主要是封装了对象的创建！\"]},\"862\":{\"h\":\"1.1、采用new的方式创建对象\",\"t\":[\"class Car { public: Car(string name) : _name(name) {} virtual void show() = 0; protected: string _name; }; class Bmw : public Car { public: Bmw(string name) : Car(name) {} void show() { cout << \\\"获取了一辆宝马汽车：\\\" << _name << endl; } }; class Audi : public Car { public: Audi(string name) : Car(name) {} void show() { cout << \\\"获取了一辆奥迪汽车：\\\" << _name << endl; } }; int main() { Car *p1 = new Bmw(\\\"X1\\\"); Car *p2 = new Audi(\\\"A6\\\"); } \",\"缺点：\"]},\"863\":{\"h\":\"1.2、采用简单工厂\",\"t\":[\"从上面的UML类图可以看出，所有对象的创建不再通过new 类名称的方式进行了，而是把对象的创建都封装在了SimpleFactory类的createProduct方法当中；\",\"通过传入一个事先设计好的枚举类型，然后返回一个对应的对象，既解耦了对象的创建，还不用再记忆那么多的类名。\"]},\"864\":{\"h\":\"实现\",\"t\":[\"将类名设为首字母大写：（防止和枚举的名称重复）\",\"class Bmw : public Car { public: Bmw(string name) : Car(name) {} void show() { cout << \\\"获取了一辆宝马汽车：\\\" << _name << endl; } }; class Audi : public Car { public: Audi(string name) : Car(name) {} void show() { cout << \\\"获取了一辆奥迪汽车：\\\" << _name << endl; } }; enum CarType { BMW, AUDI }; class SimpleFactory { public: Car* createCar(CarType ct) { switch(ct) { case BMW: return new Bmw(\\\"X1\\\"); case AUDI: return new Audi(\\\"A6\\\"); default: cerr << \\\"传入工厂的参数不正确\\\" << ct << endkl; break; } return nullptr; } }; int main() { //Car* p1 = new Bmw(\\\"X1\\\"); //Car* p2 = new Audi(\\\"A6\\\"); SimpleFactory * factory = new SimpleFactory(); Car* p1 = factory->createCar(BMW); Car* p2 = factory->createCar(AUDI); p1->show(); p2->show(); delete p1; delete p2; delete p3; return 0; } \",\"也可以在工厂方法中使用管理：\",\"#include <memory> int main() { unique_ptr<SimpleFactory> factory(new SimpleFactory()); unique_ptr<Car> p1(factory->createCar(BMW)); unique_ptr<Car> p2(factory->createCar(AUDI)); p1->show(); p2->show(); return 0; } \",\"缺点：把所有对象的创建都封装在了一个SimpleFactory类的createCar函数中，根据传入的参数，选择产生不同的对象，很明显，，所以这样的设计不能算完美。\"]},\"865\":{\"h\":\"2、工厂方法（Factory Method）\"},\"866\":{\"h\":\"2.1、类图\",\"t\":[\"Factory Method工厂方法是标准的OOP设计模式之一，主要解决了上面使用简单工厂遇到的问题。\",\"工厂方法为每一种产品提供相应的实例工厂进行对象创建，更符合实际的面向对象设计，比如说不同厂家的汽车，肯定都有自己的汽车生产工厂，BMW和Audi两种汽车都有自己的工厂在生产。\",\"先看看工厂方法的UML类设计图如下：\",\"class Factory { public: virtual Car* createCar(string name) = 0; }; class BMWFactory : public Factory { public: Car* createCar(string name) { return new Bmw(name); } }; class AudiFactory : public Factory { public: car* createCar(string name) { return new Audi(name); } }; int main() { unique_ptr<Facory> bmwfty(new BMWFactroy()); unique_ptr<Facory> audifty(new AudiFactroy()); unique_ptr<Car> p1(bmwfty->createCar(\\\"X6\\\")); unique_ptr<Car> p2(audifty->createCar(\\\"A8\\\")); p1->show(); p2->show(); return 0; } \",\"优点：符合软件设计的开-闭原则；\",\"缺点：\",\"就是每一个实例工厂负责生产一个实例产品，也就是，那么小米不仅仅生产手机，还生产耳机，智能手环，智能插座等等相关的小米产品簇；\",\"，而且也不符合实际情况。\",\"实际上小米或者华为的工厂里面，有相关联的产品簇都是在一个工厂完成创建的；BMW或者Audi汽车制造工厂除了生产汽车，生产线上也有可能生产轮胎，或者其它的汽车附属产品。\",\"所以对于包含产品簇这么一类实体关系的设计，就需要使用Abstract Factory抽象工厂了，你也可以把上面的工厂方法看作只生产一种产品的抽象工厂，本质是相同的。\"]},\"867\":{\"h\":\"抽象工厂（Abstract Factory）\",\"t\":[\"抽象工厂其实就是解决设计的\",\"看上面抽象工厂的UML类设计图，ProductA和ProductB就是一个产品簇。\",\"//系列产品1 class Car { public: Car(string name) : _name(name) {} virtual void show() = 0; protected: string _name; }; class Bmw : public Car { public: Bmw(string name) _name(name) {} void show() { cout << \\\"获取了一辆宝马汽车：\\\" << _name << endl; } }; class Audi : public Car { public: Audi(string name) : Car(name) {} void show() { cout << \\\"获取了一辆奥迪汽车：\\\" << _name << endl; } }; //系列产品2 class Light { public: virtual void show() = 0; }; class BmwLight : public Light { public: void show() { cout << \\\"BMW Light!\\\" << endl; } }; class AudiLight : public Light { void show() { cout << \\\"Audi Light!\\\" << endl; } }; \",\"此时创建宝马对象时，因为有产品簇，不可能说又来一个宝马灯工厂，来创建宝马灯，这样的话各种配件，导致工厂类太多了！\",\"将工厂方法写成抽象工厂！\",\"//工厂方法 =》抽象工厂（对有一组关联关系的产品簇提供产品对象的同一创建） class AbstractFactory { public: virtual Car* createCar(string name) = 0;//工厂方法 创建汽车 virtual Light* createCarLight() = 0;//工厂方法 创建汽车关联的产品 } //把有关联的产品放在一个工厂中，提供多个产品创建的抽象接口！ class BMWFactory : public AbstractFactory { public: Car* createCar(string name) { return new Bmw(name); } Light* createCarLight() { return new BmwLight(); } }; class AudiFactory : public AbstractFactory { public: Car* createCar(string name) { return new Audi(name); } Light* createCarLight() { return new AudiCarLight(); } }; int main() { //现在考虑产品 一类产品（有关联关系的系列产品） unique_ptr<AbstractFactory> bmwfty(new BMWFactory()); unique_ptr<AbstractFactory> audifty(new AudiFactory()); unique_ptr<Car> p1(bmwfty->createCar(\\\"X6\\\")); unique_ptr<Car> p2(audifty->createCar(\\\"A8\\\")); unique_ptr<Light> l1(bmdfty->createCarLight()); unique_ptr<light> l2(auditfy->createCarLight()); p1->show(); l1->show(); p2->show(); l2->show(); return 0; } \",\"优点：使得，不用每个产品类建一个工厂\",\"缺点：（抽象类必须重写！）！！！\"]},\"868\":{\"h\":\"简单工厂，工厂方法，抽象工厂对比\",\"t\":[\"image-20240428143246759\"]},\"869\":{\"c\":[\"c/c++\"]},\"870\":{\"c\":[\"设计模式\"]},\"871\":{\"h\":\"观察者Observer模式\",\"t\":[\"观察者模式是行为型模式；\",\"行为型模式： 主要关注的是对象之间的通信\",\"观察者模式又叫做观察者(Observer)监听者(Listener)模式，也叫发布(Publish)订阅(Subscribe)模式\",\"主要关注的是对象的一对多的关系，也就是多个对象都依赖一个对象，当该对象的状态发生改变时，其它对象都能够接收到相应的通知\",\"#include <iostream> #include <string> #include <unordered_map> #include <list> using namespace std; /* 行为型模式：主要关注的是对象之间的通信 观察者模式Observer Pattern（发布-订阅模式）设计模式:主要关注的是对象的一对多的关系，也就是多个对象 都依赖一个对象，当该对象的状态发生改变时，其它对象都能够接收到相应的通知。 一组数据（数据对象） => 通过这一组数据 =》 曲线图(对象1)/柱状图(对象2)/圆饼图(对象3) 当数据对象改变时，对象1、对象2、对象3应该及时的收到相应的通知！ Observer1 Observer2 Observer3 Subject（主题）主题有更改，应该及时通知相应的观察者，去处理相应的事件 */ // 观察者抽象类 class Observer { public: // 处理消息的接口 virtual void handle(int msgid) = 0; }; // 第一个观察者实例：12感兴趣 class Observer1 : public Observer { public: void handle(int msgid) { switch (msgid) { case 1: cout << \\\"Observer1 recv 1 msg!\\\" << endl; break; case 2: cout << \\\"Observer1 recv 2 msg!\\\" << endl; break; default: cout << \\\"Observer1 recv unknow msg!\\\" << endl; break; } } }; // 第二个观察者实例：2感兴趣 class Observer2 : public Observer { public: void handle(int msgid) { switch (msgid) { case 2: cout << \\\"Observer2 recv 2 msg!\\\" << endl; break; default: cout << \\\"Observer2 recv unknow msg!\\\" << endl; break; } } }; // 第三个观察者实例：13感兴趣 class Observer3 : public Observer { public: void handle(int msgid) { switch (msgid) { case 1: cout << \\\"Observer3 recv 1 msg!\\\" << endl; break; case 3: cout << \\\"Observer3 recv 3 msg!\\\" << endl; break; default: cout << \\\"Observer3 recv unknow msg!\\\" << endl; break; } } }; // 主题类 class Subject { public: // 给主题增加观察者对象 void addObserver(Observer* obser, int msgid) { //map添加数据的方法1： _subMap[msgid].push_back(obser); //map添加数据的方法2： /*auto it = _subMap.find(msgid); if (it != _subMap.end()) { it->second.push_back(obser); } else { list<Observer*> lis; lis.push_back(obser); _subMap.insert({ msgid, lis }); }*/ } // 主题检测发生改变，通知相应的观察者对象处理事件 void dispatch(int msgid) { auto it = _subMap.find(msgid); if (it != _subMap.end()) { for (Observer* pObser : it->second) { pObser->handle(msgid); } } } private: unordered_map<int, list<Observer*>> _subMap; }; int main() { Subject subject; Observer* p1 = new Observer1(); Observer* p2 = new Observer2(); Observer* p3 = new Observer3(); subject.addObserver(p1, 1); subject.addObserver(p1, 2); subject.addObserver(p2, 2); subject.addObserver(p3, 1); subject.addObserver(p3, 3); int msgid = 0; for (;;) { cout << \\\"输入消息id:\\\"; cin >> msgid; if (msgid == -1) break; subject.dispatch(msgid); } return 0; } \"]},\"872\":{\"c\":[\"c/c++\"]},\"873\":{\"c\":[\"设计模式\"]},\"874\":{\"h\":\"哪些函数不能被设置为虚函数？\"},\"875\":{\"h\":\"成为虚函数的条件\",\"t\":[\"1.要成为虚函数，函数地址就要记录在虚函数表中，即虚函数能产生函数地址，存储在vftable中。2.vfptr指针需要依赖对象，对象必须存在。（vfptr->vftable->虚函数地址 ）\"]},\"876\":{\"h\":\"哪些函数不能被设置为虚函数？\",\"t\":[\"普通函数（非成员函数）：定义虚函数的主要目的是为了重写达到多态，所以普通函数声明为虚函数没有意义，因此编译器在****就绑定了它。\",\"静态成员函数：静态成员函数对于每个类都只有一份代码，所有对象都可以共享这份代码，他**，所以它也没有动态绑定的必要。(静态函数发生在**，虚函数体现多态发生在运行时) \",\"不可能出现 static + virtual 或 virtual + static\",\"内联成员函数：内联函数本就是为了减少函数调用的代价，所以在代码中直接展开。但虚函数一定要创建虚函数表，这两者不可能统一。另外，内联函数在****，而虚函数在运行时才动态绑定。\",\"构造函数：这个原因很简单，主要从语义上考虑。因为构造函数本来是为了初始化对象成员才产生的，然而虚函数的目的是为了在完全不了解细节的情况下也能正确处理对象，两者根本不能“ 好好相处 ”。因为****\",\"友元函数：当我们把一个函数声明为一个类的友元函数时，它只是一个可以访问类内成员的普通函数，并不是这个类的成员函数，自然也不能在自己的类内将它声明为虚函数。(，比如在自己类里面设置为虚函数，但是作为另一个类的友元)\"]},\"877\":{\"h\":\"为什么析构函数可以成为虚函数\",\"t\":[\"因为析构函数调用的时候，对象是存在的！\"]},\"878\":{\"c\":[\"c/c++\"]},\"879\":{\"c\":[\"多态\"]},\"880\":{\"h\":\"多态的定义和原理\"},\"881\":{\"h\":\"多态的定义\",\"t\":[\"多态性（polymorphism）是面向对象设计语言的基本特征之一。仅仅是将数据和函数捆绑在一起，进行类的封装，使用一些简单的继承，还不能算是真正应用了面向对象的设计思想。多态性是面向对象的精髓。多态性可以简单地概括为“一个接口，多种方法”。\",\"通常是指对于。\"]},\"882\":{\"h\":\"为什么用多态\",\"t\":[\"封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）。它们的目的都是为了代码重用。而多态除了代码的复用性外，还可以解决项目中紧偶合的问题，提高程序的可扩展性。\",\"如果项目耦合度很高的情况下，维护代码时修改一个地方会牵连到很多地方，会无休止的增加开发成本。而降低耦合度，可以保证程序的扩展性。而多态对代码具有很好的可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。\"]},\"883\":{\"h\":\"多态的分类\",\"t\":[\"编译时多态：也称为静态多态，我们之前学习过的函数重载、运算符重载、模板(函数模板、类模板)（模板的实例化发生在编译阶段）就是采用的静态多态，C++编译器根据传递给函数的参数和函数名决定具体要使用哪一个函数，又称为先期联编（early binding）。\",\"运行时多态：在继承结构中，基类指针(引用)指向派生类对象，通过该指针(引用)调用同名覆盖方法(虚函数)，基类指针指向哪个派生类对象，就会调用哪个派生类对象的同名覆盖方法，称为动态多态。 \",\"必须在程序运行时完成选择，因此编译器必须提供这么一套称为“动态联编”（dynamic binding）的机制，也叫晚期联编（late binding）。多态底层是通过来实现的，C++通过来实现动态绑定/动态联编。\",\"基类中给所有派生类，让派生类进行重写，然后就可以使用多态了\"]},\"884\":{\"h\":\"案例1.静多态：函数重载\",\"t\":[\"bool compare(int, int){} bool compare(double, double){} compare(10, 20); //call compare_int_int，在编译阶段就确定好调用的函数版本 compare(10.5, 20.5);//call compare_double_double \"]},\"885\":{\"h\":\"案例2.静多态：模板，模板的实例化发生在编译阶段\",\"t\":[\"template<typename T> bool compare(T a, Tb){} compare(10, 20); //=>int 实例化一个compare<int> compare(10.5, 20.5); //=>double 实例化一个compare<double> \"]},\"886\":{\"h\":\"案例3.动多态：实现一个动物类\",\"t\":[\"//动物基类 class Animal { public: Animal(string name):_name(name){} virtual void bark(){} protected: string _name; }; //动物实体类 class Cat : public Animal { public: Cat(string name):Animal(name){} void bark() { cout << _name << \\\"bark:miao miao!\\\" << endl; } }; class Dog : public Animal { public: Dog(string name):Animal(name){} void bark() { cout << _name << \\\"bark:wang wang!\\\" << endl; } }; class Pig : public Animal { public: Pig(string name):Animal(name){} void bark() { cout << _name << \\\"bark:heng heng!\\\" << endl; } }; void bark(Cat &cat) { cat.bark(); } void bark(Dog &dog) { dog.bark(); } void bark(Pig &pig) { pig.bark(); } int main() { Cat cat(\\\"小猫\\\"); Dog dog(\\\"小狗\\\"); Pig pig(\\\"小猪\\\"); bark(cat); bark(dog); bark(pig); return 0; } \",\"此时发生动态绑定，但是这个bark()接口不太好，我们若添加更多的新的动物，派生类对象越多，bark()方法还需要继续增加。相应的实体类若删除，其对应接口也要删除，达不到高内聚低耦合。\",\"那么用什么类型能将上面的对象都能接受呢？ 我们使用统一的基类类型来接受派生类的对象。\",\"void bark(Animal *p) { p->bark(); } \",\"Cat，Dog，Pig是从Animla继承而来，基类指针就可以指向派生类对象，都可以调用。由于Animal::bark()执行动态绑定，先访问指针指向的对象的前四个字节，基类指针指向了三个不同的对象，每一次访问的就是这三个不同对象的虚函数表，取用它们重写的bark()。\",\"p->cat cat vftable &Cat::bark(); p->dog dog vftable &Dog::bark(); p->Pig pig vftable &Pig::bark(); \",\"此时再增加新的派生类型，API接口不用修改，方便许多\"]},\"887\":{\"c\":[\"c/c++\"]},\"888\":{\"c\":[\"多态\"]},\"889\":{\"h\":\"带虚函数的多基派生\",\"t\":[\"#include <iostream> using std::cout; using std::endl; class Base1 { public: Base1() : _iBase1(10) { } virtual void f() { cout << \\\"Base1::f()\\\" << endl; } virtual void g() { cout << \\\"Base1::g()\\\" << endl; } virtual void h() { cout << \\\"Base1::h()\\\" << endl; } private: int _iBase1; }; class Base2 { public: Base2() : _iBase2(100) { } virtual void f() { cout << \\\"Base2::f()\\\" << endl; } virtual void g() { cout << \\\"Base2::g()\\\" << endl; } virtual void h() { cout << \\\"Base2::h()\\\" << endl; } private: int _iBase2; }; class Base3 { public: Base3() : _iBase3(1000) { } virtual void f() { cout << \\\"Base3::f()\\\" << endl; } virtual void g() { cout << \\\"Base3::g()\\\" << endl; } virtual void h() { cout << \\\"Base3::h()\\\" << endl; } private: int _iBase3; }; class Derived : public Base1 , public Base2 , public Base3 { public: Derived() : _iDerived(10000) { } void f() { cout << \\\"Derived::f()\\\" << endl; } virtual void g1() { cout << \\\"Derived::g1()\\\" << endl; } private: int _iDerived; }; int main() { Derived d; Base2 *pBase2 = &d; Base3 *pBase3 = &d; Derived *pDerived = &d; pBase2->f(); cout << \\\"sizeof(d) = \\\" << sizeof(d) << endl; cout << \\\"&Derived = \\\" << &d << endl; cout << \\\"pBase2 = \\\" << pBase2 << endl; cout << \\\"pBase3 = \\\" << pBase3 << endl; return 0; } //结论：多重继承（带虚函数） //1. 每个基类都有自己的虚函数表 //2. 派生类如果有自己的虚函数，会被加入到第一个虚函数表之中 //3. 内存布局中，其基类的布局按照基类被声明时的顺序进行排列 //4. 派生类会覆盖基类的虚函数，只有第一个虚函数表中存放的是 // 真实的被覆盖的函数的地址；其它的虚函数表中存放的并不是真实的 // 对应的虚函数的地址，而只是一条跳转指令 \"]},\"890\":{\"h\":\"多基派生的二义性\",\"t\":[\"class A { public: virtual void a() { cout << \\\"a() in A\\\" << endl; } virtual void b() { cout << \\\"b() in A\\\" << endl; } virtual void c() { cout << \\\"c() in A\\\" << endl; } }; class B { public: virtual void a() { cout << \\\"a() in B\\\" << endl; } virtual void b() { cout << \\\"b() in B\\\" << endl; } void c() { cout << \\\"c() in B\\\" << endl; } void d() { cout << \\\"d() in B\\\" << endl; } }; class C : public A , public B { public: virtual void a() { cout << \\\"a() in C\\\" << endl; } void c() { cout << \\\"c() in C\\\" << endl; } void d() { cout << \\\"d() in C\\\" << endl; } }; void test() { C c; printf(\\\"&c: %p\\\\n\\\", &c); c.b(); cout << endl; A *pA = &c; printf(\\\"pA: %p\\\\n\\\", pA); pA->a(); pA->b(); pA->c(); cout << endl; B *pB = &c; printf(\\\"pB: %p\\\\n\\\", pB); pB->a(); pB->b(); pB->c(); pB->d(); cout << endl; C *pC = &c; printf(\\\"pC: %p\\\\n\\\", pC); pC->a(); pC->b();//此处就是二义性 pC->c();//此处的c()走的是虚函数机制还是非虚函数机制，如何判别？ pC->d();//此处是隐藏，不是重写 return 0; } \"]},\"891\":{\"h\":\"菱形继承\",\"t\":[\"#include <iostream> using std::cout; using std::endl; class B { public: B() : _ib(10) , _cb('B') { cout << \\\"B()\\\" << endl; } B(int ib, char cb) : _ib(ib) , _cb(cb) { cout << \\\"B(int,char)\\\" << endl; } virtual void f() { cout << \\\"B::f()\\\" << endl; } virtual void Bf() { cout << \\\"B::Bf()\\\" << endl; } private: int _ib; char _cb; }; class B1 : virtual public B { public: B1() : _ib1(100) , _cb1('1') { } B1(int ib, char ic, int ib1, char cb1) : B(ib, ic) , _ib1(ib1) , _cb1(cb1) { cout << \\\"B1(int,char,int,char)\\\" << endl; } virtual void f() { cout << \\\"B1::f()\\\" << endl; } virtual void f1() { cout << \\\"B1::f1()\\\" << endl; } virtual void Bf1() { cout << \\\"B1::Bf1()\\\" << endl; } private: int _ib1; char _cb1; }; class B2 : virtual public B { public: B2() : _ib2(1000) , _cb2('2') { } B2(int ib, char ic, int ib2, char cb2) : B(ib, ic) , _ib2(ib2) , _cb2(cb2) { cout << \\\"B2(int,char,int,char)\\\" << endl; } //virtual void f() { cout << \\\"B2::f()\\\" << endl; } //virtual void f2() { cout << \\\"B2::f2()\\\" << endl; } //virtual void Bf2() { cout << \\\"B2::Bf2()\\\" << endl; } private: int _ib2; char _cb2; }; class D : public B1 , public B2 { public: D() : _id(10000) , _cd('3') { } D(int ib, char cb , int ib1, char ib , int ib2, char cb2 , int id, char cd) : B1(ib1, ib1) , B2(ib2, cb2) , B(ib, cb) , _id(id) , _cd(cd) { cout << \\\"D(...)\\\" << endl; } virtual void f() { cout << \\\"D::f()\\\" << endl; } virtual void f1() { cout << \\\"D::f1()\\\" << endl; } virtual void f2() { cout << \\\"D::f2()\\\" << endl; } virtual void Df() { cout << \\\"D::Df()\\\" << endl; } private: int _id; char _cd; }; void test(void) { D d; cout << sizeof(d) << endl; B1 *pb1 = &d; pb1->f(); B2 *pb2 = &d; pb2->f(); d.f(); return 0; } //结论：虚基指针所指向的虚基表的内容 // 1. 虚基指针的第一条内容表示的是该虚基指针距离所在的子对象的首地址的偏移 // 2. 虚基指针的第二条内容表示的是该虚基指针距离虚基类子对象的首地址的偏移 \",\"如果是在若干类层次中，从虚基类直接或间接派生出来的派生类的构造函数初始化列表均有对该虚基类构造函数的调用，那么创建一个派生类对象的时候只有该派生类列出的虚基类的构造函数被调用，其他类列出的将被忽略，这样就保证虚基类的唯一副本只被初始化一次。即虚基类的构造函数只被执行一次。\",\"对于虚继承的派生类对象的析构，析构函数的调用顺序为：\",\"先调用派生类的析构函数；\",\"然后调用派生类中成员对象的析构函数；\",\"再调用普通基类的析构函数；\",\"最后调用虚基类 的析构函数。\"]},\"892\":{\"c\":[\"c/c++\"]},\"893\":{\"c\":[\"多态\"]},\"894\":{\"h\":\"测试虚表的存在\",\"t\":[\"#include <iostream> using std::cout; using std::endl; class Base { public: Base(long base = 0) : _base(base) { cout << \\\"Base(long = 0)\\\" << endl; } virtual void f() { cout << \\\"virtual void Base::f()\\\" << endl; } virtual void g() { cout << \\\"virtual void Base::g()\\\" << endl; } virtual void h() { cout << \\\"virtual void Base::h()\\\" << endl; } ~Base() { cout << \\\"~Base()\\\" << endl; } private: long _base; }; class Derived : public Base { public: Derived(long base = 0, long derived = 0) : Base(base) , _derived(derived) { cout << \\\"Derived(long = 0)\\\" << endl; } virtual void f() { cout << \\\"virtual void Derived::f()\\\" << endl; } virtual void g() { cout << \\\"virtual void Derived::g()\\\" << endl; } virtual void h() { cout << \\\"virtual void Derived::h()\\\" << endl; } ~Derived() { cout << \\\"~Derived()\\\" << endl; } private: long _derived; }; int main(int argc, char **argv) { //虚表是存在的，虚表存在于只读段,对于普通的单继承而言，一个类 //只有一张虚表 Derived derived(10, 20); printf(\\\"对象derived的地址 : %p\\\\n\\\", &derived); printf(\\\"对象derived的地址 : %p\\\\n\\\", (long *)&derived); /* printf(\\\"虚表的地址 : %p\\\\n\\\", *(long *)&derived);//ok */ printf(\\\"虚表的地址 : %p\\\\n\\\", (long *)*(long *)&derived); printf(\\\"虚函数的地址 : %p\\\\n\\\", (long *)*(long *)*(long *)&derived); cout << endl << endl; typedef void (*Function)(); Function pf; pf = (Function)*((long *)*(long *)&derived); pf(); printf(\\\"第一个虚函数的地址 : %p\\\\n\\\", pf); cout << endl; pf = (Function)*((long *)*(long *)&derived + 1); pf(); printf(\\\"第二个虚函数的地址 : %p\\\\n\\\", pf); cout << endl; pf = (Function)*((long *)*(long *)&derived + 2); pf(); printf(\\\"第三个虚函数的地址 : %p\\\\n\\\", pf); cout << endl; Derived derived2(100, 200); printf(\\\"对象derived2的地址 : %p\\\\n\\\", &derived2); printf(\\\"对象derived2的地址 : %p\\\\n\\\", (long *)&derived2); /* printf(\\\"虚表的地址 : %p\\\\n\\\", *(long *)&derived2);//ok */ printf(\\\"虚表的地址 : %p\\\\n\\\", (long *)*(long *)&derived2); printf(\\\"虚函数的地址 : %p\\\\n\\\", (long *)*(long *)*(long *)&derived2); cout << endl; cout << \\\"打印数据成员_base = \\\" << (long)*((long *)&derived + 1) << endl; cout << \\\"打印数据成员_derived = \\\" << (long)*((long *)&derived + 2) << endl; return 0; } \"]},\"895\":{\"c\":[\"c/c++\"]},\"896\":{\"c\":[\"多态\"]},\"897\":{\"h\":\"纯虚函数和抽象类\"},\"898\":{\"h\":\"纯虚函数\",\"t\":[\"纯虚函数是一种特殊的虚函数，。这就是纯虚函数的作用。纯虚函数的格式如下：\",\"class 类名 { public: virtual 返回类型 函数名(参数包) = 0; }; \",\"设置纯虚函数的意义，就是让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，“你提供一个纯虚函数的实现，但我不知道你会怎样实现它”。\",\"class Base { public: virtual void display() = 0; }; class Derived : public Base { public: virtual void display() { cout << \\\"Derived::display()\\\" << endl; } }; \",\"声明纯虚函数的目的在于，提供一个与派生类。\",\"class Figure { public: virtual void display() const = 0; virtual double area() const = 0; }; class Circle : public Figure { public: explicit Circle(double radius) : _radius(radius) { } void display() const { cout << \\\"Circle\\\"; } double area() const { return 3.14159 * _radius * _radius; } private: double _radius; }; class Rectangle : public Figure { public: Rectangle(double length, double width) : _length(length) , _width(width) { } void display() const { cout << \\\"Rectangle\\\"; } double area() const { return _length * _width; } private: double _length; double _width; }; class Triangle : public Figure { public: Triangle(double a, double b, double c) : _a(a) , _b(b) , _c(c) { } void display() const { cout << \\\"Triangle\\\"; } //海伦公式计算三角形的面积 double area() const { double p = (_a + _b + _c) / 2; return sqrt(p * (p - _a) * (p - _b) * (p - _c)); } private: double _a; double _b; double _c; }; \"]},\"899\":{\"h\":\"抽象类\"},\"900\":{\"h\":\"抽象类的形式\",\"t\":[\"类中包含纯虚函数\",\"一个类可以包含纯虚函数。只要类中含有一个纯虚函数，该类便为抽象类。。\",\"//汽车的基类,抽象类 class Car { public: Car(string name, double oil):_name(name),_oil(oil){} //获取汽车剩余油量还能跑的公里数 double getLeftMiles() { //不同汽车1L油跑的公里不一样 return _oil * this->getMilesPerGallon();//动态绑定， //基类指针指向不同派生类对象访问不同派生类重写的getMilesPerGallon() } string getName()const { return _name; } protected: string _name; double _oil; virtual double getMilesPerGallon() = 0;//纯虚函数，根据具体的汽车而定1L油跑的公里数 }; class Bnze : public Car { public: Bnze(string name, double oil):Car(name, oil){} double getMilesPerGallon() { return 20.0;//具体的车跑到公里不一样 } }; class Audi : public Car { public: Audi(string name, double oil):Car(name, oil){} double getMilesPerGallon() { return 18.0;//具体的车跑到公里不一样 } }; class BMW : public Car { public: BMW(string name, double oil):Car(name, oil){} double getMilesPerGallon() { return 19.0;//具体的车跑到公里不一样 } }; //给外部提供一个统一的获取汽车剩余路程数的API void showCarleftMiles(Car &car) { cout << car.getName() << \\\"left miles:\\\" << car.getLeftMiles() << \\\"公里\\\" << endl; } int main() { Bnze b1(\\\"奔驰\\\",20.0); Audi a(\\\"奥迪\\\",20.0); BMW b2(\\\"宝马\\\",20.0); showCarleftMiles(b1); showCarleftMiles(a); showCarleftMiles(b2); return 0; } \",\"继承纯虚函数，但没有重写\",\"和普通的虚函数不同，在派生类中一般要对基类中纯虚函数进行重定义。如果该派生类没有对所有的纯虚函数进行重定义，则该派生类也会成为抽象类。这说明\",\"只有protect构造没有public构造的类\",\"除此以外，还有另外一种形式的抽象类。对一个类来说，如果只定义了protected型的构造函数而没有提供public构造函数，无论是在外部还是在派生类中作为其对象成员，但可以由其派生出新的类，这种能派生新类，却不能创建自己对象的类是另一种形式的抽象类。\",\"class Base { protected: Base(long base) : _base(base) { cout << \\\"Base()\\\" << endl; } protected: long _base; }; class Derived : public Base { public: Derived(long base, long derived) : Base(base) , _derived(derived) { cout << \\\"Derived(long, long)\\\" << endl; } void print() const { cout << \\\"_base:\\\" << _base << \\\", _derived:\\\" << _derived << endl; } private: long _derived; }; void test() { Base base(1);//error Derived derived(1, 2); } \"]},\"901\":{\"h\":\"为什么定义抽象类？抽象类和普通类的区别\",\"t\":[\"抽象类的目的不是为了抽象一个实体的类型，主要目的：\",\"让所有的派生类类通过继承基类直接复用该属性。（猫具有动物属性）\",\"给所有的派生类保留统一的覆盖/重写接口；\",\"语法上\",\"拥有纯虚函数的类称为抽象类\",\"抽象类不能实例化对象，但是可以定义指针和引用变量（指向派生类对象）\",\"普通类定义指针，引用变量都可以，实例化对象也可以\"]},\"902\":{\"c\":[\"使用指南\"]},\"903\":{\"c\":[\"页面配置\",\"使用指南\"]},\"904\":{\"h\":\"继承多态与虚函数案例分析\"},\"905\":{\"h\":\"题目一：猫狗叫声问题\",\"t\":[\"//动物基类 泛指 类-》抽象一个实体的类型 class Animal { public: Animal(string name):_name(name){} //纯虚函数 virtual void bark() = 0; protected: string _name; }; //动物实体类 class Cat : public Animal { public: Cat(string name):Animal(name){} void bark() { cout << _name << \\\"bark:miao miao!\\\" << endl; } }; class Dog : public Animal { public: Dog(string name):Animal(name){} void bark() { cout << _name << \\\"bark:wang wang!\\\" << endl; } }; class Pig : public Animal { public: Pig(string name):Animal(name){} void bark() { cout << _name << \\\"bark:heng heng!\\\" << endl; } }; int main() { Animal *p1 = new Cat(\\\"加菲猫\\\"); Animal *p2 = new Dog(\\\"二哈\\\"); int *p11 = (int*)p1; int *p22 = (int*)p2; int tmp = p11[0]; p11[0] = p22[0]; p22[0] = tmp; p1->bark(); p2->bark(); delete p1; delete p2; return 0; } \",\"分析一下：\",\"int *p11 = (int*)p1; int *p22 = (int*)p2; int tmp = p11[0];//p11[0]访问的Cat的前4个字节 p11[0] = p22[0];//p22[0]访问的Dog的前4个字节 p22[0] = tmp; \",\"主要原因是Cat的vfptr存放Dog的vftable地址，Dog的vfptr存放Cat的vftable地址。因此发生动态绑定时，输出的结果被交换\"]},\"906\":{\"h\":\"题目二：继承结构中基类派生类同名覆盖方法不同默认值问题\",\"t\":[\"class Base { public: virtual void show(int i = 10) { cout << \\\"call Base::show i:\\\" << i << endl; } }; class Derive : public Base { public: virtual void show(int i = 20) { cout << \\\"call Derive::show i:\\\" << i << endl; } }; int main() { Base *p = new Derive(); p->show(); delete p; return 0; } \",\"分析一下：\",\"我们简单看一下，有virtual，是动态绑定，指向派生类对象。会调用派生类的show，但是为什么调用的派生类的方法，函数的却使用了基类的参数的值？\",\"push 0Ah =》函数调用，参数压栈在编译时期确定好的 mov eax, dword ptr[p] mov ecx, dword ptr[eax] call ecx \",\"我们来看一下函数调用过程，调用一个函数时要先压参数，若没有传入实参，会将形参默认值压栈。运行时候才发生动态绑定调用派生类的show方法。\",\"p是基类指针调用的show()，编译器只能看见基类的show，将基类的10压栈，参数压栈在编译时期确定好的。真正调用时不管是静态还是动态绑定，只要是是show()方法，形参压栈的值都是固定的10。\"]},\"907\":{\"h\":\"题目三：派生类的方法写成私有的可以正常调用吗\",\"t\":[\"class Base { public: virtual void show() { cout << \\\"call Base::show\\\" << endl; } }; class Derive : public Base { private: virtual void show() { cout << \\\"call Derive::show\\\" << endl; } }; int main() { Base *p = new Derive(); p->show(); delete p; return 0; } \",\"输出结果：成功调用 \",\"分析一下：p->show()最终能够调用Derive的show，是在运行时期才确定的。但是是不是public，是在就需要确定好的。编译阶段编译器只能看见Base中的show为public，编译器可以调用；但最终调用的是基类的方法还是派生类的方法取决于形成的汇编指令是静态绑定还是动态绑定，因为为动态绑定最后成功调用派生类的show。\",\"但是如果我们交换一下基类与派生类的访问限定符：\",\"class Base { private: virtual void show() { cout << \\\"call Base::show\\\" << endl; } }; class Derive : public Base { public: virtual void show() { cout << \\\"call Derive::show\\\" << endl; } }; \",\"输出结果：编译出错。\",\"只有使用派生类指针此时才可以调用：道理与前面相同。\",\"Derive *p = new Derive(); p->show(); delete p; \"]},\"908\":{\"h\":\"题目四：下面两段代码是否正确\",\"t\":[\"class Base { public: Base() { cout << \\\"call Base()\\\" << endl; clear(); } void clear() { memset(this, 0, sizeof(*this));//Base大小赋为0 } virtual void show() { cout << \\\"call Base::show() \\\" << endl; } }; class Derive : public Base { public: Derive() { cout << \\\"call Derive() \\\" << endl; } void show() { cout << \\\"call Derive::show() \\\" << endl; } }; int main() { //1 Base *pb1 = new Base(); pb1->show();//动态绑定 delete pb1; //2 Base *pb2 = new Derive()；; pb2->show();//动态绑定 delete pb2; return 0; } \",\"1输出结果： 执行失败\",\"分析一下1： 基类的对象内存如图，vfptr指向Base vftable，当调用clear()时，将基类的对象内存清为0，虚函数指针也变为0地址，进行动态绑定时，访问不到，调用时出错，程序崩溃。\",\"2输出结果：执行成功\",\"分析一下2： 派生类中也有一个vfptr，首先调用基类的构造，构造基类部分，然后调用派生类构造，构造派生类部分。我们vfptr里面存储的是vftable的地址，底层来看指令一定有一个地方将vfptr写入vftable中。\",\"push ebp mov ebp,esp sub esp,4Ch #rep stos esp<->ebp #0xCCCCCCCC #windows会将esp和ebp初始化为0xCCCCCCCC；而gcc/g++只做前3步，没有这个 \",\"先了解一下这个：每一个函数进来首先push ebp，将调用方函数站点地址压进来，调用方函数站点地址放入当前函数栈底。再将esp赋给ebp，ebp指向当前函数栈底，sub esp 4Ch为当前函数开辟栈帧，rep sots esp<->ebp当前函数栈帧初始化为0；准备工作做完之后，指向当前函数第一行指令。。vfptr <—>&Base::vftable，每次层构造函数都会执行刚才的步骤，派生类中会将vfptr<—>&Derive::vftable。当我们new一个Derive对象时，首先调用基类构造，基类构造首先会将基类的vftable写入vfptr，再调用clear会将虚函数的值清为0；再调用派生类的构造函数，==派生类构造函数压完栈初始化后会将&Derive::vftable的地址写入到虚函数指针中。==当我们用指针调用show()vfptr是有效的，能够从虚函数表中取出来派生类重写的show()，因此执行成功。\"]},\"909\":{\"c\":[\"c/c++\"]},\"910\":{\"c\":[\"多态\"]},\"911\":{\"h\":\"虚函数\"},\"912\":{\"h\":\"虚函数的定义\",\"t\":[\"虚函数就是在基类中被声明为virtual，并在一个或多个派生类中被重新定义的成员函数。\",\"// 类内部 class 类名 { virtual 返回类型 函数名(参数表) { //... } }; //类之外 virtual 返回类型 类名::函数名(参数表) { //... } \"]},\"913\":{\"h\":\"派生类对虚函数的重定义\",\"t\":[\"如果一个基类的成员函数定义为虚函数，那么它在所有派生类中也保持为虚函数，即使在派生类中省略了virtual关键字，也仍然是虚函数。\",\"当一个基类中设有虚函数，而一个派生类继承了该基类，并对虚函数进行了重定义(重写函数体)，我们称之为覆盖(override). 这里的覆盖指的是中相应被覆盖。\",\"重定义的格式要求：\",\"与基类的虚函数有相同的参数列表和返回类型\",\"class Base { public: virtual void display() { cout << \\\"Base::display()\\\" << endl; } virtual void print() { cout << \\\"Base::print()\\\" << endl; } }; class Derived : public Base { public: virtual void display() { cout << \\\"Derived::display()\\\" << endl; } }; void test(Base *pbase) { pbase->display(); } int main() { Base base; Derived derived; test(&base); test(&derived); return 0; } \",\"上面的例子中，对于test()函数，如果不管测试的结果，从其实现来看，通过类Base的指针pbase只能调用到Base类型的display函数；但最终的结果是25行的test调用，最终会调用到Derived类的display函数，这里就体现出虚函数的作用了，这是怎么做到的呢，或者说虚函数底层是的怎么实现的呢？\"]},\"914\":{\"h\":\"虚函数的实现机制🍗🍗🍗\",\"t\":[\"虚函数的实现是怎样的呢？简单来说，就是通过一张虚函数表（Virtual Fucntion Table）实现的。\",\"具体地讲，当类中定义了一个虚函数后，编译器会在该类创建的对象的存储布局的开始位置产生一个虚函数指针（vfptr），该虚函数指针指向了一张虚函数表，而该虚函数表就像一个数组，表中存放的就是各虚函数的入口地址。如下图\"]},\"915\":{\"h\":\"虚函数描述、特点：\",\"t\":[\"一个类里面定义了虚函数，那么，编译器需类型产生一个vftable虚函数表。虚函数表中主要存储的内容就是和。当程序运行时，每一张虚函数表都会加载到内存的\",\"在编译时，一个类的虚函数表就确定了，这也是为什么它放在了只读数据段中\",\"一个类里面定义了虚函数，那么这个类定义的对象，其，内存中开始部分，多存储一个vfptr虚函数指针，指向相应类型的虚函数表vftable。一个类型定义的。\",\"一个类里面。\",\"如果派生类中的方法和基类继承来的某个方法，返回值、函数名、参数列表都相同，而且基类的方法是virtual虚函数，那么派生类的这个方法自动处理成虚函数，即覆盖关系。\"]},\"916\":{\"h\":\"虚函数机制是如何被激活的呢，或者说动态多态是怎么表现出来的呢？\",\"t\":[\"从上面的例子，可以得出结论：\",\"基类定义虚函数\",\"派生类重定义（覆盖、重写）虚函数\",\"创建派生类对象\",\"基类的指针指向派生类对象\",\"基类指针调用虚函数\"]},\"917\":{\"c\":[\"c/c++\"]},\"918\":{\"c\":[\"多态\"]},\"919\":{\"h\":\"虚函数的访问\",\"t\":[\"class Base { public: Base(int data = 0):ma(data){} virtual void show() { cout << \\\"Base::show()\\\" << endl; } protected: int ma; }; class Derive : public Base { public: Derive(int data = 0):Base(data), mb(data){} void show() { cout << \\\"Derive::show()\\\" << endl; } private: int mb; }; \"]},\"920\":{\"h\":\"指针访问\",\"t\":[\"使用指针访问非虚函数时，编译器根据决定要调用哪个函数，而不是根据指针指向的对象类型；\",\"使用指针访问虚函数时，编译器根据决定要调用哪个函数(动态联编)，而与指针本身的类型无关。\",\"Base b; Derive d; Base *pb1 = &b;//基类指针指向基类对象 pb1->show(); \",\"Base b; Derive d; Base *pb2 = &d;//基类指针指向派生类对象 pb2->show(); \",\"//派生类指针调用派生类对象，派生类引用调用派生类对象 Derive *pd1 = &d; pd1->show(); Derive &rd1 = d; rd1.show(); \"]},\"921\":{\"h\":\"向下强转（不安全）\",\"t\":[\"指针指向的是虚函数，属于动态绑定，但是此时派生类的虚函数表里只有基类的虚函数地址，所以最终访问到是基类的虚函数\"]},\"922\":{\"h\":\"引用访问\",\"t\":[\"使用引用访问虚函数，与使用指针访问虚函数类似，表现出动态多态特性。不同的是，引用一经声明后，。因此在使用上有一定限制，但这在一定程度上提高了代码的安全性，特别体现在函数参数传递等场合中，可以将引用理解成一种“受限制的指针”。\",\"Base &rb1 = b; rb1.show(); Base &rb2 = d; rb2.show(); \"]},\"923\":{\"h\":\"对象访问\",\"t\":[\"和普通函数一样，虚函数一样可以通过对象名来调用，此时编译器采用的是。通过对象名访问虚函数时, 调用哪个类的函数取决于定义对象名的类型。对象类型是基类时，就调用基类的函数；对象类型是子类时，就调用子类的函数。\",\" Base b; Derive d; //静态绑定 b.show();//虚函数 call Base::show(); d.show();//虚函数 call Derive::show(); \"]},\"924\":{\"h\":\"成员函数中访问\",\"t\":[\"在类内的成员函数中访问该类层次中的虚函数，采用动态联编，要使用this指针。\",\"例如：汽车类中获取汽车剩余油量还能跑的公里数\"]},\"925\":{\"h\":\"构造函数和析构函数中访问\",\"t\":[\"构造函数和析构函数是特殊的成员函数，在其中访问虚函数时，C++采用，即在构造函数或析构函数内，即使是使用“this->虚函数名”的形式来调用，编译器仍将其解释为静态联编的“本类名::虚函数名”。即**它们所调用的虚函数是自己类中定义的函数，如果在自己的类中实现该函数，。但绝不会调用任何在派生类中重定义的虚函数。 **\"]},\"926\":{\"h\":\"注意\"},\"927\":{\"h\":\"虚函数的调用一定就是动态绑定吗？\",\"t\":[\"在类的构造函数当中，调用虚函数，也是静态绑定。构造函数中调用其他函数，包括虚函数，不会发生动态绑定。\",\"注意：\",\"用对象本身调用虚函数，是静态绑定。\",\"动态绑定：\",\"如果不是通过指针或者引用来调用虚函数，那就是静态绑定。\"]},\"928\":{\"c\":[\"c/c++\"]},\"929\":{\"c\":[\"多态\"]},\"930\":{\"h\":\"虚基类和虚继承\"},\"931\":{\"h\":\"定义\",\"t\":[\"虚基类:被虚继承的类，就称为虚基类。\"]},\"932\":{\"h\":\"virtual作用：\",\"t\":[\"virtual修饰了成员方法是虚函数。\",\"可以修饰继承方式，是虚继承。被虚继承的类就称为虚基类。\"]},\"933\":{\"h\":\"语法\",\"t\":[\"class Baseclass; class Subclass : public/private/protected virtual Baseclass { public: //... private: //... protected: //... }; //其中Baseclass称之为Subclass的虚基类, 而不是说Baseclass就是虚基类 \",\"vfptr：一个类有虚函数，这个类生成的对象就有vfptr，指向vftable。 vbptr：在派生类中。 vftable：第一行为向上偏移量，第二行为离的偏移量。 vbtable:存放的RTTI指针，指向运行时RTTI信息与虚函数地址。\"]},\"934\":{\"h\":\"示例\",\"t\":[\"class A { public: private: int ma; }; class B : public A { public: private: int mb; }; //A a; 4个字节 //B b; 8个字节 \",\"这里我们的对象a占4个字节，对象b占8个字节。但如果我们给B的继承方式访问限定符前面加了一个virtual关键字。\"]},\"935\":{\"h\":\"内存分布\"},\"936\":{\"h\":\"查看方法\",\"t\":[\"使用命令：cl –d1reportSingleClassLayout[classname] xxx.cpp查看此时的内存布局。\",\"或者使用vs先配置项目属性，然后生成解决方案：\",\"/d1 reportSingleClassLayout类名 /d1 reportAllClassLayout \"]},\"937\":{\"h\":\"简单虚继承内存分布\",\"t\":[\"类A被虚继承了，但内存布局没有变化。\",\"我们再看一下类B，不是之前的8个字节，变为12个字节，多了一个vbptr指针。原来最上面应该为ma与mb，但是现在多了一个vbptr(虚基类指针)，ma跑到派生类最后面去了。vbptr指向的是vbtable，vbtable第一行为0，第二行为虚基类指针到虚基类数据的偏移量。\",\"当我们遇到虚继承时候。要考虑派生类B的内存布局时，首先我们先不考虑虚继承。类B继承了基类的ma，还有自己的mb；当我们基类被虚继承后，基类变为虚基类，虚基类的数据一定要在派生类数据最后面，再在最上面添加一个vbptr。派生类的内存就由这几部分来构成。\",\"虚基类指针(vbptr)指向虚基类表(vbtable)，vbtable第一行为向上的偏移量，因为vbptr在该派生类内存起始部分，因此向上的偏移量为0；第二行为向下的偏移量(vbptr离虚基类数据的偏移量)，原来基类的数据放到最后，找ma的时候还是在最开始找，但ma被移动，根据偏移的字节就可以找到。\"]},\"938\":{\"h\":\"含虚函数的内存分布\",\"t\":[\"image-20240415111605527\",\"B类有两个虚函数表，一个是继承基类的，另一个是自己有虚函数创建的\"]},\"939\":{\"h\":\"菱形继承内存分布\",\"t\":[\"// 基类A class A { public: int dataA; }; class B : virtual public A { public: int dataB; }; class C : virtual public A { public: int dataC; }; class D : public B, public C { public: int dataD; }; \"]},\"940\":{\"h\":\"小结\",\"t\":[\"结论一：单个虚继承，不带虚函数 虚继承与继承的区别\",\"多了一个虚基指针\",\"虚基类位于派生类存储空间的最末尾\",\"结论二：单个虚继承，带虚函数\",\"如果派生类没有自己的虚函数，此时派生类对象不会产生虚函数指针\",\"如果派生类拥有自己的虚函数，此时派生类对象就会产生自己本身的虚函数指针，并且该虚函数指针位于派生类对象存储空间的****\"]},\"941\":{\"c\":[\"c/c++\"]},\"942\":{\"c\":[\"继承\"]},\"943\":{\"h\":\"虚拟继承时派生类对象的构造和析构\",\"t\":[\"在普通的继承体系中，比如A派生出B，B派生出C，则创建C对象时，在C类构造函数的初始化列表中 用B类构造函数，然后在B类构造函数初始化列表中调用A类的构造函数，即可完成对象的创建操作。但。\",\"class A { public: A() { cout << \\\"A()\\\" << endl; } A(int ia) : _ia(ia) { cout << \\\"A(int)\\\" << endl; } void f() { cout << \\\"A::f()\\\" << endl; } protected: int _ia; }; class B : virtual public A { public: B() { cout << \\\"B()\\\" << endl; } B(int ia, int ib) : A(ia) , _ib(ib) { cout << \\\"B(int,int)\\\" << endl; } protected: int _ib; }; class C : public B { public: C(int ia, int ib, int ic) : B(ia, ib) , _ic(ic) { cout << \\\"C(int,int,int)\\\" << endl; } void show() const { cout << \\\"_ia: \\\" << _ia << endl << \\\"_ib: \\\" << _ib << endl << \\\"_ic: \\\" << _ic << endl; } private: int _ic; }; void test() { C c(10, 20, 30); c.show(); } \",\"从最终的打印结果来看，在创建对象c的过程中，我们看到C带三个参数的构造函数执行了，同时B带两个参数的构造函数也执行了，但A带一个参数的构造函数，而是执行了函数。这与我们的预期是有差别的。如果想要得到预期的结果，我们还需要在C的构造函数初始化列表最后，显式调用A的相应构造函数。那为什么需要这样做呢？\",\"在 C++ 中，如果继承链上存在虚继承的基类，则最底层的子类要负责完成该虚基类部分成员的构造。即我们需要显式调用虚基类的构造函数来完成初始化，如果不显式调用，则编译器会调用虚基类的缺省构造函数，不管初始化列表中次序如何，对虚基类构造函数的调用总是先于普通基类的构造函数。如果虚基类中没有定义的缺省构造函数，则会编译错误。因为如果不这样做，虚基类部分会在存在的多个继承链上被多次初始化。很多时候，对于继承链上的中间类，我们也会在其构造函数中显式调用虚基类的构造函数，因为一旦有人要创建这些中间类的对象，我们要保证它们能够得到正确的初始化。这种情况在菱形继承中非常明显， 我们接下来看看这种情况\"]},\"944\":{\"c\":[\"c/c++\"]},\"945\":{\"c\":[\"多态\"]},\"946\":{\"h\":\"虚析构\",\"t\":[\"虽然构造函数不能被定义成虚函数，但析构函数可以定义为虚函数，一般来说，如果类中定义了虚函数，析构函数也应被定义为虚析构函数，尤其是类内有申请的动态内存，需要清理和释放的时候。\"]},\"947\":{\"h\":\"什么时候需要把基类的析构函数必须实现成虚函数？\"},\"948\":{\"h\":\"示例一：基类的指针(引用)指向 堆上new出来的派生类对象 的时候\",\"t\":[\"基类的指针(引用)指向的时候，delete调用析构函数的时候，必须发生动态绑定，否则会导致派生类的析构函数无法调用。\",\"class Base { public: Base(int data) :ma(data) { cout << \\\"Base()\\\" << endl; } ~Base() { cout << \\\"~Base()\\\" << endl; } virtual void show() { cout << \\\"call Base::show()\\\" << endl; } protected: int ma; }; class Derive : public Base { public: Derive(int data):Base(data), mb(data),ptr(new int(data)) { cout << \\\"Derive()\\\" << endl; } ~Derive() { delete ptr; cout << \\\"~Derive() \\\" << endl; } private: int mb; int *ptr; }; int main() { Base *pb = new Derive(10); pb->show();//动态绑定pb Base* *pb Derive delete pb; return 0; } \",\"执行出现问题：。\",\"pb的类型是Base类型，因此delete调用析构函数先去Base中找Base::~Base()，此时对于析构函数的调用就是，没有机会调用派生类的析构函数，最后发生内存泄露。\",\"解决方案： 将基类的析构函数定义为虚析构函数，派生类的析构函数自动成为虚函数。 pb的类型是Base类型，调用析构时去Base中找Base::~Base发现它为虚函数，发生动态绑定。派生类的虚函数表中：&Derive:: ~derive，用派生类析构函数将自己部分进行析构，再调用基类的析构函数将基类部分析构。\",\"class Base { public: Base(int data) :ma(data) { cout << \\\"Base()\\\" << endl; } virtual~Base() { cout << \\\"~Base()\\\" << endl; } virtual void show() { cout << \\\"call Base::show()\\\" << endl; } protected: int ma; }; class Derive : public Base { public: Derive(int data):Base(data), mb(data),ptr(new int(data)) { cout << \\\"Derive()\\\" << endl; } ~Derive() { delete ptr; cout << \\\"~Derive() \\\" << endl; } private: int mb; int *ptr; }; \"]},\"949\":{\"h\":\"示例二：类内有申请的 动态内存 ，需要清理和释放的时候\",\"t\":[\"class Base { public: Base(const char *pbase) : _pbase(new char[strlen(pbase) + 1]()) { cout << \\\"Base(const char *)\\\" << endl; strcpy(_pbase, pbase); } /*virtual*/ ~Base() { if(_pbase) { delete [] _pbase; _pbase = nullptr; } cout << \\\"~Base()\\\" << endl; } private: char *_pbase; }; class Derived : public Base { public: Derived(const char *pbase, const char *pderived) : Base(pbase) , _pderived(new char[strlen(pderived) + 1]()) { cout << \\\"Derived(const char *, const char *)\\\" << endl; strcpy(_pderived, pderived); } ~Derived() { cout << \\\"~Derived()\\\" << endl; if(_pderived) { delete [] _pderived; _pderived = nullptr; } } private: char *_pderived; }; void test() { Base *pbase = new Derived(\\\"hello\\\", \\\"wuhan\\\"); pbase->print(); delete pbase; } \",\"如果基类Base的析构函数没有设置为虚函数， 则在执行delete pbase;语句时，不会调用派生类Derived的析构函数，这样就会造成。此时，将基类Base的析构函数设置为虚函数，就可以解决该问题。。，此时，系统将先执行派生类对象的析构函数，然后再执行基类的析构函数。\",\"如果基类的析构函数声明为虚的，派生类的析构函数也将自动成为虚析构函数，无论派生类析构函数声明中是否加virtual关键字。\"]},\"950\":{\"c\":[\"c/c++\"]},\"951\":{\"c\":[\"多态\"]},\"952\":{\"h\":\"静态绑定和🍔动态绑定\"},\"953\":{\"h\":\"静态绑定\",\"t\":[\"静态指的是编译时期\",\"绑定即函数调用\",\"#include <iostream> #include <typeinfo> using namespace std; class Base { public: Base(int data = 10): ma(data){} void show() { cout << \\\"Base::show()\\\" << endl; } void show(int) { cout << \\\"Base::show(int)\\\" << endl; } protected: int ma; }; class Derive : public Base { public: Derive(int data = 20):Base(data),mb(data){} void show() { cout << \\\"Derive::show()\\\" << endl; } private: int mb; }; int main() { Derive d(50); Base *pb = &d; pb->show(); pb->show(10); cout << sizeof(Base) << endl;//4 cout << sizeof(Derive) << endl;//8 cout << typeid(pb).name() << endl;//class Base * //该指针的类型，定义的是Base*,所以打印也是Base* cout << typeid(*pb).name() << endl;//class Base //解引用，表示指针指向的类型 return 0; } \",\"pb是基类类型， 调用的是派生类从基类继承来的方法\",\"pb->show();//静态绑定 call Base::show(01612DAh) pb->show(10);//静态绑定 call Base::show(01612B2h) \",\"编译期间将高级源代码编译为汇编码，指定了call Base::show(01612DAh)与call Base::show(01612B2h)，即编译期间指定了函数的调用，这就是是静态绑定。\"]},\"954\":{\"h\":\"动态绑定\",\"t\":[\"class Base { public: Base(int data = 10): ma(data){} virtual void show()//虚函数 { cout << \\\"Base::show()\\\" << endl; } virtual void show(int)//虚函数 { cout << \\\"Base::show(int)\\\" << endl; } protected: int ma; }; class Derive : public Base { public: Derive(int data = 20):Base(data),mb(data){} void show() { cout << \\\"Derive::show()\\\" << endl; } private: int mb; }; \",\"虚函数表里的“0”，表示的是虚函数指针vfptr在虚函数表里的偏移量\",\" Derive d(50); Base *pb = &d; pb->show(); pb->show(10); \",\"🍗🍗🍗pb依然是Base类型的指针，指向的是派生类对象，编译阶段编译器先去Base作用域看一下Base::show()\",\"若是普通函数，则进行静态绑定，call Base::show()\",\"若是虚函数，则进行动态绑定，\",\"mov eax,dword ptr[pb] #将派生类对象的前4个字节（虚函数表的地址vfptr）放入eax寄存器 mov ecx,dword ptr[eax] #将vfptr存的地址（派生类虚函数表）的前4字节内存&Derive::show()地址放入ecx call ecx #调用ecx，取虚函数地址 \",\"最终call 一个寄存器，只有在运行时候才知道寄存器的地址，找到哪个地址调用哪个函数，这就是动态绑定\"]},\"955\":{\"h\":\"sizeof变化的原因：\",\"t\":[\"多了virtual，即虚函数会多vfptr指针，因此sizeof()大小也会变。\"]},\"956\":{\"h\":\"*pb 的类型： typeid()\",\"t\":[\"如果Base没有虚函数，pb是*Class Base;*pb识别的就是编译时期的类型, *pb就是Class Base\",\"如果Base有虚函数，pb是*Class Base；*pb识别的就是运行时期的类型：RTTI类型，即 Class Derive\"]},\"957\":{\"h\":\"RTTI运行时的类型信息\",\"t\":[\"存储的时候字符串类型，表示该虚函数表是由什么类类型产生的\",\"RTTI应用：可以通过typeid()判断两个类是否属于同一个类\",\"C++ RTTI介绍及使用示例（run-time type Identification）_rtti 使用-CSDN博客\"]},\"958\":{\"h\":\"vs 查看内存分布\",\"t\":[\"cmd找到源文件所在目录\",\"输入下面命令\",\"cl -d1reportSingleClassLayout(输出对象内存布局信息，类的名字) \",\"注意：在虚函数表中，派生类重写的函数的入口地址应该在基类的函数入口地址的下面，基类被重写的函数的入口地址应该是直接不用了，派生类的放在基类后\"]},\"959\":{\"h\":\"总结\",\"t\":[\"静态指的是编译时期\",\"动态是运行时期\",\"绑定指的是函数调用\",\"动态绑定一定是对虚函数的绑定\",\"因此：\",\"静态绑定会生成一个指令，call一个具体函数地址\",\"动态绑定：若指针指向的是虚函数，则根据派生类前四个字节获取获取虚函数表指针，进一步获取虚函数表中虚函数地址，指令上是call一个寄存器，寄存器放的地址，只能运行时才能知道\"]},\"960\":{\"c\":[\"c/c++\"]},\"961\":{\"c\":[\"多态\"]},\"962\":{\"h\":\"STL顺序容器：vector、deque、list\"},\"963\":{\"h\":\"我们经常提到STL，那么STL究竟是什么呢？\",\"t\":[\"STL：其英文全称为standard template libaray，即标准模板库。我们根据需要直接实例化这些模板，提高了我们使用的效率。\"]},\"964\":{\"h\":\"一、vector容器\",\"t\":[\"。 容器中对象的构造析构，内存的开辟释放通过空间配置器allocator实现：allocate(内存开辟)、deallocate(内存释放)、construct(对象构造)、destroy(对象析构)。\"]},\"965\":{\"h\":\"1.1使用方式\",\"t\":[\"使用方式：使用前需要包含：#include <vector> 1.增加： ①push_back()；//在容器末尾增加一个元素，时间复杂度O(1)，会导致容器扩容。 ②insert()；//在it迭代器指向的位置增加一个元素，时间复杂度O(n)，也会导致容器扩容。\",\"2.删除： ①pop_back()；//在容器末尾删除一个元素，时间复杂度O(1)。 ②erase();//删除it迭代器指向的元素，时间复杂度O(n)。\",\"3.查询： ①operator[]//数据下标的随机访问vec[5]，时间复杂度O(1)。 ②iterator//迭代器进行遍历，一定要考虑迭代器失效问题。 ③find,for_each//泛型算法。 ④foreach//C++11提供的语法糖，通过迭代器iterator来实现的。 注意： [迭代器失效的底层核心原理 | 张威的编程学习笔记 (gitee.io)](https://iszhwei.gitee.io/ccpp/05 运算符重载/迭代器失效的底层核心原理.html)\",\"4.常用方法： ①size();//返回容器底层有效元素的个数。 ②empty();//判断容器是否为空。 ③reserve();//为vector预留空间，只给容器底层开辟指定大小空间并不添加新的元素。 ④resize();//扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。 ⑤swap();//两个容器进行元素交换。\"]},\"966\":{\"h\":\"1.2使用实例\",\"t\":[\"实例1：对vector容器中元素遍历。\",\"vector<int> vec; for (int i=0; i<20; i++) { vec.push_back(rand()%100 + 1); } //vec的operator[]运算符重载函数进行vector遍历 int size = vec.size(); for (int i=0; i<size; ++i) { cout << vec[i] << \\\" \\\"; } cout << endl; //迭代器进行遍历 auto it1 = vec.begin(); for (; it1!=vec.end(); ++it1) { cout << *it1 << \\\" \\\"; } cout << endl; \",\"实例2：把vec容器中所有偶数全部删除。\",\"vector<int> vec; for (int i=0; i<20; i++) { vec.push_back(rand()%100 + 1); } //vec的operator[]运算符重载函数进行vector遍历 int size = vec.size(); for (int i=0; i<size; ++i) { cout << vec[i] << \\\" \\\"; } cout << endl; //把vec容器中所有偶数全部删除 auto it2 = vec.begin(); while (it2!=vec.end()) { if (*it2 % 2 == 0) { it2 = vec.erase(it2); } else { ++it2; } } //迭代器进行遍历 auto it1 = vec.begin(); for (; it1!=vec.end(); ++it1) { cout << *it1 << \\\" \\\"; } cout << endl; \",\"实例3：在2删除的基础上，给vector容器中所有的奇数前面都添加一个小于1的偶数 例:44 45。\",\"vector<int> vec; for (int i=0; i<20; i++) { vec.push_back(rand()%100 + 1); } //vec的operator[]运算符重载函数进行vector遍历 int size = vec.size(); for (int i=0; i<size; ++i) { cout << vec[i] << \\\" \\\"; } cout << endl; //把vec容器中所有偶数全部删除 auto it2 = vec.begin(); while (it2!=vec.end()) { if (*it2 % 2 == 0) { it2 = vec.erase(it2); } else { ++it2; } } //迭代器进行遍历 auto it1 = vec.begin(); for (; it1!=vec.end(); ++it1) { cout << *it1 << \\\" \\\"; } cout << endl; //给vector容器中所有的奇数前面都添加一个小于1的偶数 例:44 45 for (it1=vec.begin(); it1!=vec.end(); ++it1) { if (*it1 % 2 != 0) { it1 = vec.insert(it1, *it1-1); ++it1; } } //迭代器进行遍历 it1 = vec.begin(); for (; it1!=vec.end(); ++it1) { cout << *it1 << \\\" \\\"; } cout << endl; \",\"实例4：reserve预留空间，只给容器底层开辟指定大小空间并不添加新的元素。 默认定义的vector底层为0，第一次插入从0变更为1，再变为2，4，8…一直进行扩容，代价十分高，使用初始的内存效率太低，我们若开始知道问题的数据量大小，即可使用reserve预留空间。\",\"vector<int> vec;//默认定义的vector底层为0 vec.reserve(20);//给vector容器预留空间 cout << vec.empty() << endl; cout << vec.size() << endl; for (int i=0; i<20; i++) { vec.push_back(rand()%100 + 1); } cout << vec.empty() << endl; cout << vec.size() << endl; \",\"输出结果: empty()是1为空，0为非空。我们发现刚开始为空，reserve(20)并没有为我们容器添加元素，只是为容器底层开辟空间，容器里面元素个数依旧是0。再添加20个元素的时候，不需要扩容了，效率提高。\",\"实例5：。 resize()不仅给容器底层开辟指定大小空间，还会添加新的元素，元素值为0。\",\"vector<int> vec;//默认定义的vector底层为0 vec.resize(20); cout << vec.empty() << endl; cout << vec.size() << endl; for (int i=0; i<20; i++) { vec.push_back(rand()%100 + 1); } cout << vec.empty() << endl; cout << vec.size() << endl; \"]},\"967\":{\"h\":\"二、deque容器\"},\"968\":{\"h\":\"2.1底层实现\",\"t\":[\"。 \",\"我们来看一下deque容器基本结构： 其底层为动态开辟的二维数组。其有两个宏：MAP_SIZE，为2；QUE_SIZE，为，T为实际的类型。底层有2个维度，还有一个mapper指针，指向第一维的一维数组，默认大小为MAP_SIZE 2；第二维为动态开辟的QUE_SIZE的大小，例如：我们使用整型时会有1024个元素。 双端队列两端都可以做为队头与队尾，现在可以从队尾入，队尾出，也可以队头入，队头出；我们就简单画了一个方向。first与last处于最中间的位置，便于两头都预留足够的空间，每一边都可以进行插入。\",\"deque容器内存的扩容方式： 当我们元素的不断增加，相应的指示位置向后移动，如图2；当元素入满时候，还要从last方向入队，已经没有空间了，就需要再开辟一个二维数组，last移动到第二行开始部分，如图2，3，4；当我们再继续添加元素时，发现满了，再想继续添加元素deque就需要扩容，此时需要扩容第一维了，按照2倍大小扩容为4，如图5，6；刚才的第二维移动到第一维中间部分(oldsize/2)，方便任何一边的元素改动。若需再次扩容，同理。\"]},\"969\":{\"h\":\"2.2使用方式\",\"t\":[\"使用方式：使用前需要包含：#include <deque> 1.增加： ①push_back();//从末尾添加元素，时间复杂度O(1)，可能引起扩容。 ②push_front();//从首部添加元素，时间复杂度O(1)，可能引起扩容。vector中没有该方法，需要使用insert()，为O(n)。 ③insert();//迭代器指向的位置添加元素，时间复杂度O(n)。\",\"2.删除： ①pop_back();//从末尾删除元素，时间复杂度O(1)。 ②pop_front();//从首部删除，时间复杂度O(1)。 ③erase();//迭代器指向的位置进行元素删除，时间复杂度O(n)。\",\"3.查询： ①iterator//迭代器进行遍历，一定要考虑迭代器失效问题。\",\"4.常用方法： ①size();//返回容器底层有效元素的个数。 ②empty();//判断容器是否为空。 ③resize();//扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。 ④swap();//两个容器进行元素交换。 使用实例与vector类似\"]},\"970\":{\"h\":\"三、list容器\",\"t\":[\"list：链表容器，底层数据结构为双向循环链表。使用方式：使用前需要包含：#include <list> 与deque使用方式一模一样，只是有的地方时间复杂度不同。 1.增加： ①push_back();//从末尾添加元素，时间复杂度O(1)，可能引起扩容。 ②push_front();//从首部添加元素，时间复杂度O(1)，可能引起扩容。vector中没有该方法，需要使用insert()，为O(n)。 ③insert();//迭代器指向的位置添加元素，时间复杂度O(1)。往往链表进行insert()时，要先进行query()操作，效率就慢了。\",\"2.删除： ①pop_back();//从末尾删除元素，时间复杂度O(1)。 ②pop_front();//从首部删除，时间复杂度O(1)。 ③erase();//迭代器指向的位置进行元素删除，时间复杂度O(1)。\",\"3.查询： ①iterator//迭代器进行遍历，一定要考虑迭代器失效问题。\",\"4.常用方法： ①size();//返回容器底层有效元素的个数。 ②empty();//判断容器是否为空。 ③resize();//扩容。不仅给容器底层开辟指定大小空间，还会添加新的元素。 ④swap();//两个容器进行元素交换。 使用实例与vector类似。\"]},\"971\":{\"h\":\"四、vector、deque、list对比分析\",\"t\":[\"容器使用场景：\"]},\"972\":{\"h\":\"deque底层内存是否是连续的？\",\"t\":[\"不是，deque底层是动态开辟的二维数组空间，第二维都是独立开辟的空间，每一个第二维是连续的，但所有的二维不是连续的。\"]},\"973\":{\"h\":\"vector与deque容器之间的区别：\",\"t\":[\"vector特点： 底层是一个动态开辟的数组，内存是连续的，2倍的方式进行扩容。当我们默认定义一个vector时候，容器底层没有开辟空间，当添加元素时候才从：0-1-2-4-8…进行扩容，扩容效率低。reserve函数可以预留空间，并未添加元素。deque特点： 区别： 1.底层数据结构：vector底层是一个动态开辟的数组，内存是连续的；deque底层是动态开辟的二维数组空间，内存不连续。 2.前中后删除元素的时间复杂度：它们中间与末尾插入删除一样为O(1)，但最前面进行元素添加时候deque为O(1)，vector为O(n)。 3 4.\"]},\"974\":{\"h\":\"vector与list容器之间的区别：\",\"t\":[\"vector特点： 底层是一个动态开辟的数组，内存是连续的，2倍的方式进行扩容。当我们默认定义一个vector时候，容器底层没有开辟空间，当添加元素时候才从：0-1-2-4-8…进行扩容，扩容效率低。reserve函数可以预留空间，并未添加元素。 list特点： 底层是一个双向循环链表。\",\"区别:即数组与链表区别\\n数组增加删除为O(n)，查询O(n)，随机访问为O(1)；链表增加删除一个结点本身为O(1)，但搜索的时间为O(n)。如果增加删除使用多，优先使用list；随机访问使用多，优先使用vector。\"]},\"975\":{\"c\":[\"c/c++\"]},\"976\":{\"c\":[\"STL\"]},\"977\":{\"h\":\"函数对象与函数指针\"},\"978\":{\"h\":\"一、函数对象与函数指针\",\"t\":[\"函数对象:拥有operator()重载函数的对象即函数对象，函数对象，但在C++里为函数对象。\"]},\"979\":{\"h\":\"问题一：什么是函数对象呢？\",\"t\":[\"例如：我们C语言进行函数调用与C++中两个函数调用。\",\"在这里插入图片描述\",\"看起来它们好像一模一样()，但是这里我们就把()运算符重载函数的对象，称作，或者称作\"]},\"980\":{\"h\":\"问题二：那么使用函数对象有什么好处呢？\",\"t\":[\"template<typename T> bool compare(T a, T b) { return a > b; } int main() { cout << compare(10, 20) << endl; cout << compare('b','y') << endl; return 0; } \",\"我里我们实现了 但是它不够灵活，我们有时想比较小于，每次改动符号有些麻烦，C语言中的函数指针刚好可以很好解决这个问题。\"]},\"981\":{\"h\":\"使用C语言中函数指针解决：\",\"t\":[\"//使用C的函数指针解决 template<typename T> bool mygreater(T a, T b) { return a > b; } template<typename T> bool myless(T a, T b) { return a < b; } //compare是C++的库函数模板 template<typename T, typename Compare> bool compare(T a, T b, Compare comp) { return comp(a, b); } int main() { cout << compare(10, 20,mygreater<int>) << endl; cout << compare(10, 20,myless<int>) << endl; return 0; } \",\"在这里插入图片描述\",\"这时，就可以很好的解决这个问题了，我们传入不同的函数指针来解决，想比较大就传入mygreater，想比较小就传入myless，通过函数指针间接调用函数； 但是这里，我们通过函数指针虽然解决了问题，但。因此，C++有一个专门的函数对象来解决这个问题。\"]},\"982\":{\"h\":\"使用C++中函数对象解决：\",\"t\":[\"好处：\",\"通过函数对象调用()运算符重载，可以，比通过函数指针调用函数(不能内联调用)效率高。\",\"因为函数对象是用类生成的，所以可以添加相关的成员变量用来记录函数对象使用时更多的信息。\",\"//C++函数对象实现 template<typename T> class mygreater { public: bool operator()(T a, T b)//二元函数对象 { return a > b; } }; template<typename T> class myless { public: bool operator()(T a, T b)//二元函数对象 { return a < b; } }; //compare是C++的库函数模板 template<typename T, typename Compare> bool compare(T a, T b, Compare comp) { return comp(a, b);//编译过程知道调用对象的函数operator()(a, b); } int main() { cout << compare(10, 20,mygreater<int>()) << endl; cout << compare(10, 20,myless<int>()) << endl; return 0; } \",\"执行成功：函数对象相比于函数指针。\",\"在这里插入图片描述\"]},\"983\":{\"h\":\"二、使用实例\"},\"984\":{\"h\":\"实例1：优先级队列\",\"t\":[\"我们的优先级队列，底层依赖vector容器，底层默认为一个大根堆。\",\"int main() { priority_queue<int> que;//底层vector for (int i=0; i<10; ++i)//大根堆 { que.push(rand() % 100); } while (!que.empty()) { cout << que.top() << \\\" \\\"; que.pop(); } cout << endl; return 0; } \",\"打印一下：堆顶元素最大\",\"如果我们如何做呢？ 只是库中的实现：\",\"template<class _Ty, class _Container = vector<_Ty>, class _Pr = less<typename _Container::value_type> > \",\"我们将less改为greater即可变为小根堆即可。\",\"using MinHeap = priority_queue<int, vector<int>, greater<int>>; \"]},\"985\":{\"h\":\"实例2：set\",\"t\":[\"set底层为红黑树，默认底层从小到大进行输出。底层为：\",\"template<class _Kty, class _Pr = less<_Kty>, class _Alloc = allocator<_Kty> > \",\"。\",\"set<int, greater<int>> set; for (int i=0; i<10; ++i) { set.insert(rand() % 100); } for (int v : set) { cout << v << \\\" \\\"; } cout << endl; \",\"此时：就是从大到小排序。\"]},\"986\":{\"c\":[\"c/c++\"]},\"987\":{\"c\":[\"STL\"]},\"988\":{\"h\":\"容器适配器：栈、队列、优先级队列\"},\"989\":{\"h\":\"一、容器适配器\",\"t\":[\"什么是容器适配器？：适配器底层没有自己的数据结构，它是另外一个容器的封装，它的方法全部由底层依赖的容器进行实现的；它没有实现自己的迭代器，不能使用迭代器遍历。\",\"来看这个例子：我们使用容器适配器来实现一个栈。\",\"template<typename T, typename Container=deque<T>> class Stack { public: void push(const T &val); { con.push_back(val); } void pop() { con.pop_back(); } T top()const { return con.back(); } private: Container con; }; \",\"实现成功，相当于栈将deque代理了一下，也成为代理模式。push将底层容器的push_back代理了，pop将底层pop_back代理了，栈的top将容器底层的back代理了。\"]},\"990\":{\"h\":\"二、栈\",\"t\":[\"我们使用库中的栈，需要加上头文件<stack>\",\"stack常用方法： 1.push();//入栈 2.pop();//出栈 3.top();//查看栈顶元素 4.empty();//判断栈空 5.size();//返回元素个数\",\"简单使用一下：\",\"stack<int> s1; for (int i=0; i<20; ++i) { s1.push(rand() % 100 + 1); } cout << \\\"栈中元素个数:\\\" <<s1.size() << endl; while (!s1.empty()) { cout << s1.top() << \\\" \\\"; s1.pop(); } \"]},\"991\":{\"h\":\"三、队列\",\"t\":[\"我们使用库中的队列，需要加上头文件<queue>\",\"stack常用方法： 1.push();//入队 2.pop();//出队 3.front();//查看队头元素 4.back();//产看队尾元素 5.empty();//判空 6.size();//返回队列元素个数\",\"简单使用一下：\",\"queue<int> que; for (int i=0; i<20; ++i) { que.push(rand() % 100 + 1); } cout << \\\"队列中元素个数:\\\" <<que.size() << endl; while (!que.empty()) { cout << que.front() << \\\" \\\"; que.pop(); } \"]},\"992\":{\"h\":\"四、优先级队列\",\"t\":[\"优先级队列：底层数据结构为。 我们使用库中的优先级队列，需要加上头文件<queue>；优先级队列，谁优先级大谁先出队，谁优先级小，谁后出队。\",\"stack常用方法： 1.push();//入优先级队列 2.pop();//出优先级队列 3.top();//查看队顶元素 4.empty();//判断队空 5.size();//返回元素个数\",\"简单使用一下：\",\"priority_queue<int> pque; for (int i=0; i<20; ++i) { pque.push(rand() % 100 + 1); } cout << \\\"优先级队列中元素个数:\\\" <<pque.size() << endl; while (!pque.empty()) { cout << pque.top() << \\\" \\\"; pque.pop(); } \",\"执行成功：数据从大到小依次出队，数据越大优先级越高。\"]},\"993\":{\"h\":\"问题一：stack与queue第二个模板类型参数依赖deque，为什么不依赖vector？而优先级队列为什么底层依赖vector？\",\"t\":[\"vector的，没有deque好。(需要从0开始2倍扩容)\",\"对于queue来说，需要支持，时间复杂度需要为O(1)，deque恰好符合条件，若用vector其底层效率太低。\",\"vector需要大片的连续内存，而deque只需要分段的内存，当存储大量数据时，显然deuqe对于更好一些。\"]},\"994\":{\"h\":\"问题二：优先级队列为什么底层依赖vector？\",\"t\":[\"优先级队列底层默认把数据组成一个大根堆结构，将大根堆结构看作一棵树，如果将大根堆结构所有元素放入数组中，使用下标计算其结点。若根节点为i，左孩子为2i+1，右孩子为2i+2；大根堆为堆顶，其元素最大，，因此底层依赖vector；而deque的第二维不是连续的，不能使用。\"]},\"995\":{\"c\":[\"c/c++\"]},\"996\":{\"c\":[\"STL\"]},\"997\":{\"h\":\"无序关联容器、有序关联容器\"},\"998\":{\"h\":\"一、无序关联容器\",\"t\":[\"关联容器分为：无序关联容器与有序关联容器，简单对比下：\",\"在这里插入图片描述\",\"无序关联容器：底层为，里面，。\"]},\"999\":{\"h\":\"1.1单重集合与多重集合\",\"t\":[\"set:集合，存储的是unordered_set：单重集合：不允许key重复。unordered_multiset：多重集合：允许key重复。 包含的头文件：\",\"#include <unordered_set> \",\"unordered_set与unordered_multiset常用方法： 增加：insert(val); 遍历：iterator自己搜索，调用find()； 删除：erase(key); 或 erase(it); size();//返回容器中元素个数。 count(val);//返回元素值为val的个数，val不会重复。 find(val);在集合容器中查找key,存在返回迭代器，不存在返回容器末尾迭代器。\",\"实例1：unordered_set使用1\",\"unordered_set<int> set1;//不允许存储key值重复的元素 for (int i=0; i<50; ++i) { set1.insert(rand()%20 + 1);//与vector/deque/list插入不同 } cout << set1.size() << endl; cout << set1.count(15) << endl;//返回key为15的元素的个数 \",\"测试成功：有许多重复的元素，但是unordered_set不存储key值重复元素，15出现了一次。\",\"实例2：unordered_set使用2\",\"unordered_set<int> set1;//不允许存储key值重复的元素 for (int i=0; i<50; ++i) { set1.insert(rand()%20 + 1);//与vector/deque/list插入不同 } auto it1 = set1.begin();//迭代器遍历容器 for (; it1!=set1.end(); ++it1) { cout << *it1 << \\\" \\\"; } cout << endl; set1.erase(20);//按key值删除元素 for (it1=set1.begin(); it1!=set1.end();) { if (*it1 == 30) { it1 = set1.erase(it1);//迭代器删除元素 } else { ++it1; } } it1 = set1.find(20); if (it1 != set1.end()) { set1.erase(it1); } for (int v : set1) { cout << v << \\\" \\\"; } cout << endl; \",\"实例3：unordered_multiset使用\",\"unordered_multiset<int> set1;//允许存储key值重复的元素 for (int i=0; i<50; ++i) { set1.insert(rand()%20 + 1);//与vector/deque/list插入不同 } cout << set1.size() << endl; cout << set1.count(15) << endl;//返回key为15的元素的个数 \",\"测试成功：允许key值重复。\"]},\"1000\":{\"h\":\"1.2单重映射表与多重映射表\",\"t\":[\"map:映射表，存储的是unordered_map：单重映射表，存储的键值对unordered_multimap：多重映射表 包含的头文件：\",\"#include <unordered_map> \",\"实例1：unordered_map使用1\",\"unordered_map<int,string> map1; map1.insert(make_pair(1000,\\\"张三\\\"));//打包成键值对 map1.insert(make_pair(1010,\\\"李四\\\")); map1.insert(make_pair(1020,\\\"王五\\\")); map1.insert(make_pair(1000,\\\"王五\\\")); cout << map1.size() << endl;//键值对个数 \",\"测试成功：unordered_map不允许重复。\",\"实例2：unordered_multimap使用\",\"unordered_multimap<int,string> map1; map1.insert(make_pair(1000,\\\"张三\\\"));//打包成键值对 map1.insert(make_pair(1010,\\\"李四\\\")); map1.insert(make_pair(1020,\\\"王五\\\")); map1.insert(make_pair(1000,\\\"王五\\\")); cout << map1.size() << endl;//键值对个数 \",\"测试成功：unordered_multimap允许重复值。\",\"实例3：unordered_map使用2\",\"unordered_map<int,string> map1; map1.insert(make_pair(1000,\\\"张三\\\"));//打包成键值对 map1.insert(make_pair(1010,\\\"李四\\\")); map1.insert(make_pair(1020,\\\"王五\\\")); map1.insert(make_pair(1030,\\\"王五\\\")); cout << map1.size() << endl;//键值对个数 //map operator[](key) =>value cout << map1[1000] << endl; \",\"测试成功：unordered_map提供[]运算符重载查询。\",\"unordered_map<int,string> map1; map1.insert(make_pair(1000,\\\"张三\\\"));//打包成键值对 map1.insert(make_pair(1010,\\\"李四\\\")); map1.insert(make_pair(1020,\\\"王五\\\")); map1.insert(make_pair(1030,\\\"王五\\\")); map1.erase(1020);//删除 map1[2000] = \\\"刘帅\\\";//相当于插入 map1[1000] = \\\"张三2\\\";//相当于修改操作 cout << map1.size() << endl;//键值对个数 //map operator[](key) =>value 查询 cout << map1[1000] << endl; \",\"测试成功：\",\"实例4：查找\",\"auto it1 = map1.find(1030); if (it1 != map1.end()) { cout << \\\"key:\\\" << it1->first << \\\"value:\\\" << it1->second << endl; } \",\"测试成功：\"]},\"1001\":{\"h\":\"1.3海量数据\",\"t\":[\"案例1：。\",\"const int ARR_LEN = 1000; int arr[ARR_LEN] = {0}; for (int i=0; i<ARR_LEN; i++) { arr[i] = rand()%20 + 1; } //上面的1000个整数中，统计哪些数字重复了，并且统计数字重复的次数 unordered_map<int, int> map1; for (int k : arr) { /*auto it = map1.find(k); if (it == map1.end())//数字没出现过 { map1.insert(make_pair(k,1)); } else { it->second++; }*/ map1[k]++; } auto it = map1.begin(); for (; it!=map1.end(); ++it) { if (it->second > 1) { cout << \\\"key:\\\" << it->first << \\\"value:\\\" << it->second << endl; } } \",\"查询成功：\",\"案例2：海量数据去重。\",\"const int ARR_LEN = 1000; int arr[ARR_LEN] = {0}; for (int i=0; i<ARR_LEN; i++) { arr[i] = rand()%20 + 1; } //上面的整数中，将数字进行去重打印 unordered_set<int> set; for (int v : arr) { set.insert(v); } for (int v : set) { cout << v << \\\" \\\"; } cout << endl; \",\"去重成功：\"]},\"1002\":{\"h\":\"二、有序关联容器\",\"t\":[\"有序关联容器：底层为，里面，。 有序关联容器包含的头文件：\",\"#include <map> #include <set> \",\"set：单重集合，重复的只出现一次，从小到大元素有序排列(红黑树的中序遍历)。 multiset:：多重集合，可以存储重复的元素，从小到大元素有序排列。 map：单重映射表，重复的只出现一次，从小到大元素有序排列。 multimap：多重映射表，可以存储重复的元素，从小到大元素有序排列。\",\"无序关联容器与有序关联容器用法几乎都是一样的。我们直接看实例： 实例1：set实例\",\"set<int> set1; for (int i=0; i<20; i++) { set1.insert(rand()%20 + 1); } for (int v : set1) { cout << v << \\\" \\\"; } cout << endl; \",\"测试成功：\",\"实例2：set存放自定义类型\",\"class Student { public: Student(int id, string name) :_id(id), _name(name){} bool operator<(const Student &stu)const { return _id < stu._id; } private: int _id; string _name; friend ostream& operator<<(ostream &out, const Student &stu); }; ostream& operator<<(ostream &out, const Student &stu) { out << \\\"id:\\\" << stu._id << \\\" name:\\\" << stu._name << endl; return out; } int main() { set<Student> set1; set1.insert(Student(1000,\\\"张文\\\")); set1.insert(Student(1020,\\\"李广\\\")); for (auto it=set1.begin(); it!=set1.end(); ++it) { cout << *it << endl; } return 0; } \",\"测试成功：\",\"实例3：map实例\",\"class Student { public: Student(int id = 0, string name = \\\"\\\") :_id(id), _name(name){} private: int _id; string _name; friend ostream& operator<<(ostream &out, const Student &stu); }; ostream& operator<<(ostream &out, const Student &stu) { out << \\\"id:\\\" << stu._id << \\\" name:\\\" << stu._name << endl; return out; } int main() { map<int, Student> stuMap; stuMap.insert(make_pair(1010,Student(1010,\\\"张文\\\"))); stuMap.insert(make_pair(1020,Student(1020,\\\"李广\\\"))); stuMap.insert(make_pair(1030,Student(1030,\\\"高阳\\\"))); //stuMap.erase(it) stuMap.erase(1020) //cout << stuMap[1020] << endl; auto it = stuMap.begin(); for (; it!=stuMap.end(); ++it) { cout << \\\"key:\\\" << it->first << \\\"value:\\\" << it->second << endl; } cout << endl; return 0; } \"]},\"1003\":{\"h\":\"总结\",\"t\":[\"最后对我们常用的容器简单总结下：\",\"在这里插入图片描述\"]},\"1004\":{\"c\":[\"c/c++\"]},\"1005\":{\"c\":[\"页面配置\",\"使用指南\"]},\"1006\":{\"h\":\"泛型算法与绑定器\"},\"1007\":{\"h\":\"一、泛型算法\",\"t\":[\"使用STL库中提供的泛型算法需要引入：#include <algorithm>泛型算法：template + 迭代器 + 函数对象；用模板实现的，接收的是容器的迭代器，还可以更改运算结果（通过函数对象更改结果）。\",\"特点：\",\"泛型算法的参数接受的都是。(遍历各种容器)\",\"泛型算法的参数还可以接受。\",\"sort,find,find_if,binary_search,for_each //所有容器都可以使用 \",\"实例1：sort\",\"int arr[] = {12, 4, 78, 9, 21, 43, 56, 52, 42, 31}; vector<int> vec(arr, arr+sizeof(arr)/sizeof(arr[0])); for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; sort(vec.begin(), vec.end());//begin——end之间元素默认小到大排序 for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; \",\"测试结果：成功从小到大排序\",\"实例2：在上面有序的容器进行二分查找\",\"int arr[] = {12, 4, 78, 9, 21, 43, 56, 52, 42, 31}; vector<int> vec(arr, arr+sizeof(arr)/sizeof(arr[0])); for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; sort(vec.begin(), vec.end());//begin——end之间元素默认小到大排序 for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; auto it = find(vec.begin(), vec.end(), 21); if(it != vec.end()) { cout << \\\"21存在\\\" <<endl; } if (binary_search(vec.begin(), vec.end(), 21));//有序的容器进行二分查找 { cout << \\\"21存在\\\" <<endl; } \",\"测试结果：查找成功\",\"实例3：改变sort排序方式\",\"//传入函数对象greater，改变容器元素比较方式 sort(vec.begin(), vec.end(), greater<int>()); for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; \",\"测试结果：从大到小排序\",\"实例4：for_each，将容器中所有偶数打印出来。\",\"//for_each可以遍历容器的所有元素，可以自行添加合适的函数对象 //对容器的元素进行过滤。 for_each(vec.begin(), vec.end(), [](int val)->void//lambda表达式 { if (val %2 == 0) { cout << val << \\\" \\\"; } }); \"]},\"1008\":{\"h\":\"二、绑定器\",\"t\":[\"需要包含：#include <functional>绑定器：绑定器 + 二元函数对象 = 一元函数对象。bind1st:把operator()(a,b)，只需要传入一个实参。 bind2nd:把二元函数对象operator()(a,b)，只需要传入一个实参。\",\"实例1：在上面排好序的容器中，将48按序插入到vector中 找第一个小于48的数字，需要的是一元函数对象。\",\"//78 56 52 43 42 31 21 12 9 4 //find_if //将48按序插入到vector中 找第一个小于48的数字，需要的是一元函数对象 //因此我们需要绑定器 //greater a > b less a < b auto it2 = find_if(vec.begin(), vec.end(), bind1st(greater<int>(), 48)); //bind2nd(less<int>(),48); //[](int val)->bool{return val < 48;}); lambda表达式 vec.insert(it2, 48); for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; \",\"测试结果：插入成功\"]},\"1009\":{\"c\":[\"c/c++\"]},\"1010\":{\"c\":[\"STL\"]},\"1011\":{\"h\":\"迭代器iterator\",\"t\":[\"普通的正向迭代器iterator：打印元素时从，。\",\"常量的正向迭代器const_iterator：打印元素时从第一个打到最后一个，。\",\"反向迭代器reverse_iterator：打印元素时从，既可读也可以修改。\",\"常量的反向迭代器const_reverse_iterator：打印元素时从最后一个打印到第一个，只能读而不能写。\",\"我们的顺序容器、关联容器，都支持正向迭代器与反向迭代器。\",\"实例1：普通正向迭代器的使用\",\"int main() { vector<int> vec; for (int i=0; i<20; i++) { vec.push_back(rand()%100); } vector<int>::iterator it1 = vec.begin(); //auto it1 = vec.begin();也可以 for (; it1!=vec.end(); it1++) { cout << *it1 << \\\" \\\"; if (*it1 % 2 == 0) { *it1 = 0; } } cout << endl; for (int v : vec) { cout << v << \\\" \\\"; } cout << endl; return 0; } \",\"实例2：常量的正向迭代器的使用 const_iterator底层原理：\",\"//const_iterator <= iterator class const_iterator { public: const T& operator*() { return *_ptr; } } class iterator : public const_iterator { T& operator*() { return *_ptr; } } //class const_iterator{}基类 //class iterator : public const_iterator派生类 \",\"//vector<int>::iterator it1 = vec.begin();//可以接受派生类对象 vector<int>::const_iterator it1 = vec.begin(); \",\"将上面普通的正向迭代器换为常量的正向迭代器，编译器报错(常量迭代器不能修改*it1 = 0;❌)。\",\"实例3：反向迭代器的使用\",\"vector<int> vec; for (int i=0; i<20; i++) { vec.push_back(rand()%100); } //rbegin()返回的是最后一个元素的反向迭代器的表示 //rend()返回的是首元素前驱位置的迭代器的表示 vector<int>::reverse_iterator rit = vec.rbegin(); //auto rit = vec.rbegin(); for (; rit!=vec.rend(); ++rit) { cout << *rit << endl; } cout << endl; \",\"测试成功：与正向迭代器打印相反。\",\"实例4：常量的反向迭代器的使用 将上面的反向迭代器改为常量的反向迭代器：只能读而不能修改。\",\"//vector<int>::reverse_iterator rit = vec.rbegin(); vector<int>::const_reverse_iterator rit = vec.rbegin(); \"]},\"1012\":{\"c\":[\"c/c++\"]},\"1013\":{\"c\":[\"STL\"]},\"1014\":{\"h\":\"log4cpp库的使用\",\"t\":[\"log4cpp开发文档：Main Page (sourceforge.net)\"]},\"1015\":{\"h\":\"安装\",\"t\":[\"Log4cpp的主页为：Log library for C++ download | SourceForge.net\",\"下载log4cpp（如log4cpp-1.1.1.tar.gz）\",\"先将log4cpp-1.1.1.tar.gz拖入用户主目录(~)\",\"依次执行下面的步骤\",\"$ cd ~/log4cpp/ $ ./configure $ make $ make check $ sudo make install //这里已经安装成功. \",\"默认lib库路径是 ： /usr/local/lib/\",\"image-20240411204317307\",\"默认头文件的位置： /usr/local/include/log4cpp\",\"image-20240411204413778\"]},\"1016\":{\"h\":\"make出现报错 ISO C++17 does not allow dynamic exception specifications\",\"t\":[\"image-20240411203054816\",\"解决方法：\",\"安装低版本的g++及gcc（如g++-9及gcc-9）\",\"sudo apt-get install gcc-9 sudo apt-get install g++-9 \",\"设置默认编辑器\",\"sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 50 --slave /usr/bin/g++ g++ /usr/bin/g++-9 \"]},\"1017\":{\"h\":\"log4cpp基本结构\",\"t\":[\"log4cpp从大的结构上分为,。除此以外还提供了一些帮助类，简化我们对日志的代码设置。\"]},\"1018\":{\"h\":\"日志类别(Category)\",\"t\":[\"Category，日志输出主体类，提供了输出各种日志级别的方法，并且能够设置类别优先级，低于此优先级的类都不再输出，，其他分类都是root分类的子分类，有点类似于java的单继承结构，子分类的输出同时会输出到父分类中。\",\"// 根分类root log4cpp::Category& root = log4cpp::Category::getRoot(); // 子分类subCat1 log4cpp::Category& sub1 = log4cpp::Category::getInstance(\\\"sub1\\\"); //用于%c时输出Category的类别“sub1” root.error(\\\"test root error\\\"); root.warn(\\\"test root error\\\"); root.info(\\\"test root error\\\"); sub1.fatal(\\\"test sub1 error\\\"); sub1.notice(\\\"test sub1 error\\\"); sub1.debug(\\\"test sub1 error\\\"); \"]},\"1019\":{\"h\":\"日志追加器(Appender)\",\"t\":[\"Appender，主要是用来确定日志输出行为，例如。类Appender是由Category来加载的，，一个Appender也可以被多个Category加载，但是有些Appender类没有设置互斥，日志的多线程支持主要是在Category里做的处理，因此不要使用一个Appender加载到多个Category中。\",\"// log4cpp::OstreamAppender:输出到输出流中（输出到控制台上） // log4cpp::FileAppender：输出到文件中 // log4cpp::RollingFileAppender：输出到文件中并且能够设置文件最大超过多少时生成新文件 // log4cpp::DailyRollingFileAppender：每天生成一个新文件 // log4cpp::NTEventLogAppender：将日志输出到Windows事件日志中去 // log4cpp::StringQueueAppender // 内存队列 // ... log4cpp::Appender *appender = new log4cpp::FileAppender(\\\"test\\\", \\\"D:/log4cppTest/log4cppTest.log\\\"); root.addAppender(appender); \"]},\"1020\":{\"h\":\"StringQueueAppender 内存队列-多线程调试\",\"t\":[\"“”。因为printf导致IO中断，会使得本线程挂起，其花费的时间比一条普通指令多数千倍，若多个线程同时运行，则严重干扰了线程间的运行方式。所以。StringQueueAppender的功能是将日志记录到一个字符串队列中，该字符串队列使用了STL中的两个容器，即字符串容器std::string和队列容器std::queue，具体如下：\",\"std::queue<std::string> _queue; _queue变量是StringQueueAppender类中用于具体存储日志的内存队列。StringQueueAppender的使用方法与OstreamAppender类似，其创建函数只接收一个参数“名称”，记录完成后需要程序员自己从队列中取出每条日志，例子程序StringQueueAppenderExam如下：\",\"#include<iostream> #include<log4cpp/Category.hh> #include<log4cpp/OstreamAppender.hh> #include<log4cpp/BasicLayout.hh> #include<log4cpp/Priority.hh> #include<log4cpp/StringQueueAppender.hh> using namespacestd; int main(int argc,char* argv[]) { log4cpp::StringQueueAppender* strQAppender = newlog4cpp::StringQueueAppender(\\\"strQAppender\\\"); strQAppender->setLayout(newlog4cpp::BasicLayout()); log4cpp::Category& root =log4cpp::Category::getRoot(); root.addAppender(strQAppender); root.setPriority(log4cpp::Priority::DEBUG); root.error(\\\"Hello log4cpp in a Error Message!\\\"); root.warn(\\\"Hello log4cpp in a WarningMessage!\\\"); cout<<\\\"Get message from MemoryQueue!\\\"<<endl; cout<<\\\"-------------------------------------------\\\"<<endl; queue<string>& myStrQ =strQAppender->getQueue(); while(!myStrQ.empty()) { cout<<myStrQ.front(); myStrQ.pop(); } log4cpp::Category::shutdown(); return 0; } \"]},\"1021\":{\"h\":\"日志布局（Layout)\",\"t\":[\"Layout,设置日志输出风格，有BasicLayout、SimpleLayout、PatternLayout,其中BasicLayout，SimpleLayout主要是提供的成型的简单日志风格，实际中基本不会使用，主要是使用PatternLayout对日志做格式输出，Layout是加载到Appender中去的。\",\"// %% 输出一个% // %c 输出Categroy名称 // %d 输出日期 // %m 输出消息 // %n 输出换行 // %p 输出Priority // %d{%Y-%m-%d %H:%M:%S:%l}对输出日期做定制，年月日时分秒毫秒 // %t 线程ID log4cpp::PatternLayout *patternLayout = new log4cpp::PatternLayout(); patternLayout->setConversionPattern(\\\"%d{%Y-%m-%d %H:%M:%S.%l} %t [%p] %m %n\\\"); appender->setLayout(patternLayout); \"]},\"1022\":{\"h\":\"Category、Appender和Layout三者的关系\",\"t\":[\"系统中可以有多个Category，它们都是继承自同一个根，每个Category负责记录自己的日志;每个Category可以添加多个Appender，每个Appender指定了一个日志的目的地，例如文件、字符流或者Windows日志，当Category记录一条日志时，该日志被写入所有附加到此Category的Appender;每个Append都包含一个Layout，该Layout定义了这个Appender上日志的格式。\"]},\"1023\":{\"h\":\"日志级别(Priority)\"},\"1024\":{\"h\":\"Log4cpp记录日志的原理\",\"t\":[\"。\"]},\"1025\":{\"h\":\"系统中默认的优先级等级如下：\",\"t\":[\"typedef enum { EMERG = 0, // emergency FATAL = 0, // fatal ALERT = 100, // alert CRIT = 200, // critical ERROR = 300, // error WARN = 400, // wanning NOTICE = 500, // notice INFO = 600, // infomation DEBUG = 700, // debug NOTSET = 800 } PriorityLevel; \",\"注意：取值越小，优先级越高。例如一个Category的优先级为101，则所有EMERG、FATAL、ALERT日志都可以记录下来，而其他则不能。\",\"// 代码设置 root.setPriority(log4cpp::Priority::DEBUG); appender->setThreshold() \"]},\"1026\":{\"h\":\"帮助类\",\"t\":[\"帮助类， log4cpp主要提供如下几个类来简化代码设置：SimpleConfigurator，BasicConfigurator，PropertyConfigurator，其中SimpleConfigurator和BasicConfigurator，主要是使用代码的方式，进行了一些简单的默认配置，而PropertyConfigurator，是通过配置文件的方式对日志进行配置，也是最常用的,下面就是配置文件的格式：\",\"#文件名为logTest.Property #配置root Category的Priority为DEBUG, Appender为rootAppender log4cpp.rootCategory=DEBUG, rootAppender #配置子Category sub1的Priority为DEBUG, Appender为A1 log4cpp.category.sub1=DEBUG, A1 #配置rootAppender为FileAppender log4cpp.appender.rootAppender=FileAppender #配置日志文件名为test1.log，存放在D盘根目录下 log4cpp.appender.rootAppender.fileName=D:/test1.log #配置layout为PatternLayout log4cpp.appender.rootAppender.layout=PatternLayout #设置日志输出风格 log4cpp.appender.rootAppender.layout.ConversionPattern=%d{%Y-%m-%d %H:%M:%S.%l} %t [%p] %m %n #配置A1为RollingFileAppender log4cpp.appender.A1=RollingFileAppender #配置日志文件名为test2.log，存放在D盘根目录下 log4cpp.appender.A1.fileName=D:/test2.log #配置日志文件最大不能超过1M log4cpp.appender.A1.maxFileSize=1024 * 1024 #日志文件最多存储3个文件，超过就会删除旧的 log4cpp.appender.A1.maxBackupIndex=2 #设置日志风格 log4cpp.appender.A1.layout=PatternLayout log4cpp.appender.A1.layout.ConversionPattern=%d{%Y-%m-%d %H:%M:%S.%l} %t [%p] %m %n // 代码设置配置文件 log4cpp::PropertyConfigurator::configure(logTest.Property); \"]},\"1027\":{\"h\":\"注意\",\"t\":[\";;;\"]},\"1028\":{\"h\":\"代码使用\"},\"1029\":{\"h\":\"windows环境下\",\"t\":[\"获取到源代码后，找到源码目录中的msvc10目录，使用VS2010打开msvc10.sln解决方案文件，编译源码获得log4cpp.DLL和log4cpp.lib;在源码目录中有include文件夹，将include整个拷贝到我们的工程目录下，将include添加到工程属性中的附加包含目录中(QT工程则添加到INCLUDEPATH中去)，这时就能够正常使用了。\"]},\"1030\":{\"h\":\"linux环境下\",\"t\":[\"编译使用log4cpp库的CPP文件时，要加上库文件，才能顺利的编译通过，如下示例\",\"$ g++ log4test.cpp -llog4cpp -lpthread \",\"运行时，如若提示缺少log4cpp库文件，表示，需要进行以下设置\",\"以管理员身份登录终端，然后执行以下操作：\",\"$ sudo vim /etc/ld.so.conf \",\"在打开的文件末尾另起一行添加动态库log4cpp的路径(这里是/usr/local/lib)，然后保存退出\",\"执行命令ldconfig使设置生效即可。\",\"$ sudo ldconfig //更新库文件的缓存信息 \"]},\"1031\":{\"h\":\"测试用例\",\"t\":[\"#include <log4cpp/BasicLayout.hh> #include <log4cpp/SimpleLayout.hh> #include <log4cpp/PatternLayout.hh> #include <log4cpp/OstreamAppender.hh> #include <log4cpp/FileAppender.hh> #include <log4cpp/RollingFileAppender.hh> #include <log4cpp/Category.hh> #include <log4cpp/Priority.hh> #include <iostream> using std::cout; using std::endl; using namespace log4cpp;//一次性将log4cpp中的实体全部引出来 void test() { //日志的格式 /* BasicLayout *pbl = new BasicLayout(); */ SimpleLayout *psl = new SimpleLayout(); //日志的目的地 /* OstreamAppender *pos = new OstreamAppender(\\\"OstreamAppender123\\\", &cout); */ /* pos->setLayout(pbl); */ OstreamAppender *pos = new OstreamAppender(\\\"OstreamAppender123\\\", &cout); pos->setLayout(psl); //日志种类（日志记录器） Category &root = Category::getRoot(); root.addAppender(pos); root.setPriority(Priority::ERROR);//过滤器 root.fatal(\\\"The log is fatal\\\"); root.alert(\\\"The log is alter\\\"); root.crit(\\\"The log is crit\\\"); root.error(\\\"The log is error\\\"); root.warn(\\\"The log is warn\\\"); //回收资源 Category::shutdown(); } void test2() { //日志的格式 PatternLayout *ppl1 = new PatternLayout(); ppl1->setConversionPattern(\\\"%d %c [%p] %m %n\\\"); PatternLayout *ppl2 = new PatternLayout(); ppl2->setConversionPattern(\\\"%d %c [%p] %m %n\\\"); //日志的目的地 OstreamAppender *pos = new OstreamAppender(\\\"OstreamAppender123\\\", &cout); pos->setLayout(ppl1); RollingFileAppender *ppfa = new RollingFileAppender(\\\"RollingFileAppender123\\\", \\\"test.log\\\", 5 * 1024, 3); ppfa->setLayout(ppl2); //日志种类（日志记录器） Category &root = Category::getRoot(); root.addAppender(pos); root.addAppender(ppfa); root.setPriority(Priority::ERROR);//过滤器 size_t idx = 0; while(idx < 100) { root.fatal(\\\"The log is fatal\\\"); root.alert(\\\"The log is alter\\\"); root.crit(\\\"The log is crit\\\"); root.error(\\\"The log is error\\\"); root.warn(\\\"The log is warn\\\"); ++idx; } //回收资源 Category::shutdown(); } void test3() { //日志的格式 PatternLayout *ppl1 = new PatternLayout(); ppl1->setConversionPattern(\\\"%d %c [%p] %m %n\\\"); PatternLayout *ppl2 = new PatternLayout(); ppl2->setConversionPattern(\\\"%d %c [%p] %m %n\\\"); //日志的目的地 OstreamAppender *pos = new OstreamAppender(\\\"OstreamAppender123\\\", &cout); pos->setLayout(ppl1); FileAppender *pfl = new FileAppender(\\\"FileAppender1234\\\", \\\"wd.log\\\"); pfl->setLayout(ppl2); //日志种类（日志记录器） Category &root = Category::getRoot().getInstance(\\\"MyCat\\\"); root.addAppender(pos); root.addAppender(pfl); root.setPriority(Priority::ERROR);//过滤器 root.fatal(\\\"The log is fatal\\\"); root.alert(\\\"The log is alter\\\"); root.crit(\\\"The log is crit\\\"); root.error(\\\"The log is error\\\"); root.warn(\\\"The log is warn\\\"); //回收资源 Category::shutdown(); } int main(int argc, char **argv) { test2(); return 0; } \"]},\"1032\":{\"h\":\"封装成日志类（单例模式）\",\"t\":[\"线程安全、自动释放、回滚日志、同时存在文件和屏幕打印\",\"#include <log4cpp/Category.hh> #include <log4cpp/RollingFileAppender.hh> #include <log4cpp/OstreamAppender.hh> #include <log4cpp/PatternLayout.hh> #include <log4cpp/Priority.hh> #include <iostream> #include <string> using log4cpp::Category; using log4cpp::RollingFileAppender; using log4cpp::OstreamAppender; using log4cpp::PatternLayout; using log4cpp::Priority; using std::cout; using std::endl; using std::string; class Logger { public: static Logger *getInstance(const char* fileName = \\\"myLog.txt\\\"); static void destroy(); void warn(const char *msg); void warn(const char * msg, const char *file, const char *func, int line); void error(const char *msg); void error(const char * msg, const char *file, const char *func, int line); void debug(const char *msg); void debug(const char * msg, const char *file, const char *func, int line); void info(const char *msg); void info(const char * msg, const char *file, const char *func, int line); private: Logger(string fileName); ~Logger(); Logger(const Logger&) = delete; Logger& operator=(const Logger&) = delete; private: PatternLayout *_ptnLayout1; PatternLayout *_ptnLayout2; OstreamAppender *_osAppender; RollingFileAppender *_rfAppender; Category &_mycategory; }; \",\"#include \\\"Logger.h\\\" Logger *Logger::getInstance(const char *fileName ) { static Logger logger(fileName); // 注册destroy函数，在进程结束的时候执行，从而自动回收单例 atexit(Logger::destroy); return &logger; } void Logger::destroy() { Category::shutdown(); } Logger::Logger(string fileName) : _ptnLayout1(new PatternLayout()) , _ptnLayout2(new PatternLayout()) , _osAppender(new OstreamAppender(\\\"osAppender\\\", &cout)) , _rfAppender(new RollingFileAppender(\\\"fAppender\\\", fileName, 5 * 1024, 3)) , _mycategory(Category::getRoot().getInstance(\\\"myCategory\\\")) { cout << \\\"Logger()\\\" << endl; _ptnLayout1->setConversionPattern(\\\"%d [%p] %m%n\\\"); _ptnLayout2->setConversionPattern(\\\"%d [%p] %m%n\\\"); _osAppender->setLayout(_ptnLayout1); _rfAppender->setLayout(_ptnLayout2); _mycategory.setPriority(Priority::DEBUG); _mycategory.addAppender(_osAppender); // 设置同时存入文件和屏幕显示 _mycategory.addAppender(_rfAppender); } Logger::~Logger() { cout << \\\"~Logger()\\\" << endl; } void Logger::warn(const char *msg) { _mycategory.warn(\\\"%s\\\", msg); } void Logger::warn(const char *msg, const char *file, const char *func, int line) { _mycategory.warn(\\\"%s@%s,%d : %s\\\", func, file, line, msg); } void Logger::error(const char *msg) { _mycategory.error(\\\"%s\\\", msg); } void Logger::error(const char *msg, const char *file, const char *func, int line) { _mycategory.error(\\\"%s@%s,%d : %s\\\", func, file, line, msg); } void Logger::debug(const char *msg) { _mycategory.debug(\\\"%s\\\", msg); } void Logger::debug(const char *msg, const char *file, const char *func, int line) { _mycategory.debug(\\\"%s@%s,%d : %s\\\", func, file, line, msg); } void Logger::info(const char *msg) { _mycategory.info(\\\"%s\\\", msg); } void Logger::info(const char *msg, const char *file, const char *func, int line) { _mycategory.info(\\\"%s@%s,%d : %s\\\", func, file, line, msg); } \",\"#include \\\"Logger.h\\\" int main() { Logger * log = Logger::getInstance(); log->warn(\\\"This is warn msg!\\\", __FILE__, __FUNCTION__, __LINE__); log->error(\\\"This is error msg!\\\", __FILE__, __FUNCTION__, __LINE__); log->debug(\\\"This is debug msg!\\\", __FILE__, __FUNCTION__, __LINE__); log->info(\\\"This is info msg!\\\", __FILE__, __FUNCTION__, __LINE__); log->warn(\\\"This is warn msg!\\\"); log->error(\\\"This is error msg!\\\"); log->debug(\\\"This is debug msg!\\\"); log->info(\\\"This is info msg!\\\"); //Logger::destory(); return 0; } \",\"$./a.out Logger() 2024-04-11 23:03:02,056 [WARN] main@test.cc,6 : This is warn msg! 2024-04-11 23:03:02,057 [ERROR] main@test.cc,7 : This is error msg! 2024-04-11 23:03:02,057 [DEBUG] main@test.cc,8 : This is debug msg! 2024-04-11 23:03:02,057 [INFO] main@test.cc,9 : This is info msg! 2024-04-11 23:03:02,058 [WARN] This is warn msg! 2024-04-11 23:03:02,058 [ERROR] This is error msg! 2024-04-11 23:03:02,059 [DEBUG] This is debug msg! 2024-04-11 23:03:02,059 [INFO] This is info msg! ~Logger() \"]},\"1033\":{\"c\":[\"c/c++\"]},\"1034\":{\"c\":[\"日志\"]},\"1035\":{\"h\":\"valgrind\",\"t\":[\"valgrind\",\"\\\" 安装方式： $ sudo apt install valgrind \\\" 使用方式: \\\" 编译代码时，需要加上-g $ valgrind --tool=memcheck --leak-check=full ./test \"]},\"1036\":{\"c\":[\"c/c++\"]},\"1037\":{\"c\":[\"内存泄漏\"]},\"1038\":{\"h\":\"不带引用计数的智能指针\"},\"1039\":{\"h\":\"1. 基础知识\"},\"1040\":{\"h\":\"裸指针\",\"t\":[\"int main() { int* p = new int(10); *p = 30; delete p; return 0; } \",\"如果我们，会造成内存泄漏；\",\"或者由于中间程序的执行顺序和我们预想的不一样，导致，导致内存资源泄漏。\",\"堆内存是我们用户手动开辟，手动释放 用不好裸指针也是造成我们内存资源的一种因素\"]},\"1041\":{\"h\":\"智能指针\",\"t\":[\"智能指针本身是一个类模板，原理利用栈上的对象出作用域会自动析构这么一个特点，把资源释放的代码全部放在这个析构函数中执行，就达到了所谓的智能指针。\",\"//智能指针就是对普通指针的一个封装 template<typename T> class CSmartPtr { public: CSmartPtr(T *ptr = nullptr) :mptr(ptr) {} ~CSmartPtr() { delete mptr; } private: T *mptr; }; int main() { CSmartPtr<int> ptr(new int); return 0; } \",\"1）智能指针体现在把裸指针进行了一次面向对象的封装，在构造函数中初始化资源地址，在析构函数中负责释放资源 2）利用栈上的对象出作用域自动析构这个特点，在智能指针的析构函数中保证释放资源\",\"上面的代码实现的是一个简单的智能指针，能够实现内存的自动释放。CSmartPtr<int> ptr(new int); 这行代码中出现了new，可能会有朋友会误认为智能指针是定义在堆（heap）上的。其实不是，。\",\"思考：能不能在堆上定义智能指针？ 例如：\",\"CSmartPtr *p = new CSmartPtr(new int) \",\"我们可以看到。智能指针初始化的是一个对象，而不是指针。\",\"使用时，我们不能直接把智能指针定义在堆上，这样就没意义了。\",\"#include <iostream> using namespace std; template<typename T> class CSmartPtr { public: CSmartPtr(T* p = nullptr) :ptr(p) {} ~CSmartPtr() { delete ptr; } T& operator*() { return *ptr; } T* operator->() //箭头运算符的重载 { return ptr; } private: T* ptr; }; class Test { public: void show() { cout << \\\"liufeng\\\" << endl; } }; int main() { CSmartPtr<int>p(new int); *p = 20; cout << *p << endl; CSmartPtr<Test>q(new Test()); q->show(); (q.operator->())->show(); return 0; } \"]},\"1042\":{\"h\":\"2. 不带引用计数的智能指针\",\"t\":[\"智能指针使用时，包含#include <memory>头文件\",\"不带引用计数的智能指针：\",\"auto_ptr：C++库里面\",\"scoped_ptr 和 unique_ptr ： C＋+11新标准\",\"不带引用计数的智能指针怎么解决浅拷贝问题？\"]},\"1043\":{\"h\":\"2.1 auto_ptr\",\"t\":[\"int main() { auto_ptr<int> p1(new int); auto_ptr<int> p2 = p1; *p1 = 10; return 0; } \",\"上面这段代码最终会报错。p1指向了堆上开辟的一块内存，然后用p1拷贝构造p2。我们看了auto_ptr 的源码后得知，auto_ptr 在做拷贝构造函数时，做的是浅拷贝，并且将p2指针指向p1的内存空间，再将。\"]},\"1044\":{\"h\":\"auto_ptr怎么解决浅拷贝问题？\",\"t\":[\"在源码中，不带引用计数，成员变量只有一个裸指针；\",\"怎么管理资源的？永远让最后一个智能指针管理资源，前面的智能指针全部被置为nullptr； 这也就造成上面程序的p1不能使用的情况；\"]},\"1045\":{\"h\":\"容器中不能使用auto_ptr\",\"t\":[\"int main() { vector<auto_ptr<int>> vec; vec.push_back(auto_ptr<int>(new int(10))); vec.push_back(auto_ptr<int>(new int(20))); vec.push_back(auto_ptr<int>(new int(30))); cout << *vec[0] << endl; vector<auto_ptr<int>> vec2 = vec; cout << *vec[0] << endl; return 0; } \",\"使用容器难免会涉及到容器的拷贝。上面的代码将auto_ptr运用在容器中，第一句cout << *vec[0] << endl;可以正常打印出10，但是第二句cout << *vec[0] << endl;无法正确打印。这是由于vector<auto_ptr<int>> vec2 = vec;。\"]},\"1046\":{\"h\":\"2.2 scoped_ptr\",\"t\":[\"比auto_ptr还暴力，使用的也比较少。\",\"直接 将 了；\"]},\"1047\":{\"h\":\"2.3 unique_ptr\",\"t\":[\"不带引用技术的智能指针，推荐使用unique_ptr；\",\"定义： 只让一个智能指针管理资源，不会让多个智能指针管理资源（编译报错）；\",\"也 将 了:\",\"template<typename T> unique_ptr<T> getSmartPtr() { unique_ptr ptr(new T()); return ptr; } int main() { unique_ptr<int> p1(new int); //unique_ptr<int> p2(p1); 不能拷贝构造 unique_ptr<int> p2(std::move(p1)); //转为右值就可以进行拷贝构造了 unique_ptr<int> p3 = getSmartPtr<int>(); // 右边是得到unique_ptr临时对象是右值,故可调用拷贝构造 return 0; } \"]},\"1048\":{\"c\":[\"c/c++\"]},\"1049\":{\"c\":[\"智能指针\"]},\"1050\":{\"h\":\"多线程访问共享对象的线程安全问题\",\"t\":[\"void handler01(A* q) { std::this_thread::sleep_for(std::chrono::seconds(2)); q->testA(); } int main() { A* p = new A(); thread t1(handler01, p); delete p; t1.join(); // 等待线程t1执行完才会往下走 return 0; } \",\"我们可以发现当调用q->testA();时，。 所，可以使用shared_ptr和weak_ptr，即\",\"void handler01(weak_ptr<A> pw) { std::this_thread::sleep_for(std::chrono::seconds(2)); // 重点在这里！！！！ shared_ptr<A> sp = pw.lock(); // 尝试提升为shared_ptr if (sp != nullptr) { sp->testA(); } else { cout << \\\"A对像已被析构\\\" << endl; } } int main() { { shared_ptr<A> p(new A()); thread t1(handler01, weak_ptr<A>(p)); // detach是使主线程不用等待子线程可以继续往下执行，但即使主线程终止了，子线程也不一定终止。 t1.detach(); } std::this_thread::sleep_for(std::chrono::seconds(20)); return 0; } \",\"强弱智能指针在线程中，通过对象的资源计数 来 监测对象的生存状态。\"]},\"1051\":{\"c\":[\"c/c++\"]},\"1052\":{\"c\":[\"智能指针\"]},\"1053\":{\"h\":\"带引用计数的智能指针\",\"t\":[\"shared_ptr和weak_ptr；\",\"带引用计数的好处：。\"]},\"1054\":{\"h\":\"带引用计数的智能指针是怎么解决多个指针持有一个资源的？\",\"t\":[\"带引用计数：\",\"当1个智能指针引用这个资源的时候，这个资源相应的引用计数就加1，当这个智能指针出作用域，不再使用这个资源的时候，这个资源的引用计数就减1。\",\"当引用计数减1不为0的时候，这个智能指针不使用这个资源了，但是还有其他智能指针在使用这个资源，这个智能指针不能析构这个资源，只能直接走人。\",\"当引用计数减1为0的时候，说明当前智能指针是最后使用这个资源的智能指针，所以它要负责这个资源的释放。（完美的解决了智能指针的浅拷贝—就是多个智能指针多次释放同一个资源）\"]},\"1055\":{\"h\":\"带引用计数的智能指针的实现\",\"t\":[\"#include <iostream> #include <memory> using namespace std; //对资源进行引用计数的类 template<typename T> class RefCnt { public: RefCnt(T* ptr = nullptr) :mptr(ptr) { if (mptr != nullptr) { mcount = 1; } } void addRef() { mcount++; } //增加资源的引用计数 int defRef() { return --mcount; } void show() { cout << mcount << endl; } private: T* mptr; //int mcount; atomic_int mcount; }; template<typename T> class CSmartPtr { public: CSmartPtr(T* p = nullptr) :ptr(p) { mpRefCnt = new RefCnt<T>(ptr); } ~CSmartPtr() { if (0 == mpRefCnt->defRef()) { delete ptr; ptr = nullptr; } } T& operator*() { return *ptr; } T* operator->() { return ptr; } void Count() { return mpRefCnt->show(); } CSmartPtr(const CSmartPtr<T>& src) :ptr(src.ptr), mpRefCnt(src.mpRefCnt) { if (ptr != nullptr) { mpRefCnt->addRef(); } } CSmartPtr<T>& operator=(const CSmartPtr<T>& src) { if (this == &src) { return *this; } //检查自己原先指向的资源，因为自己要改变指向了，如果执行delRef后，引用计数为0的话，就释放资源； if (0 == mpRefCnt->defRef()) { delete ptr; } ptr = src.ptr; mpRefCnt = src.mpRefCnt; mpRefCnt->addRef(); return *this; } private: T* ptr; //指向资源的指针 RefCnt<T>* mpRefCnt; //指向该资源引用计数的类 }; int main() { CSmartPtr<int>p(new int(50)); CSmartPtr<int>q(p); cout << *p << endl; cout << *q << endl; p.Count(); cout << p.operator->() << endl; return 0; } \",\"上面的CSmartPtr和标准的shared_ptr的区别是：\",\"；\",\"shared_ptr将m_count定义成\",\"库中的shared_ptr和weak_ptr都是线程安全的，可以直接使用在多线程的环境下。\"]},\"1056\":{\"h\":\"shared_ptr的交叉引用问题\",\"t\":[\"观察，强智能指针观察\",\"强智能指针循环引用（交叉引用）是什么问题？什么结果？怎么解决？\",\"class B; class A { public: A() { cout << \\\"A()构造\\\" << endl; } ~A() { cout << \\\"~A()析构\\\" << endl; } shared_ptr<B> ptr2; }; class B { public: B() { cout << \\\"B()构造\\\" << endl; } ~B() { cout << \\\"~B()析构\\\" << endl; } shared_ptr<A> ptr1; }; int main() { shared_ptr<A> pa(new A()); shared_ptr<B> pb(new B()); cout << pa.use_count() << endl;//1 cout << pb.use_count() << endl;//1 pa->ptr2 = pb; pb->ptr1 = pa; cout << pa.use_count() << endl;//2 cout << pb.use_count() << endl;//2 } \",\"出main函数作用域，pb先析构（将B资源的引用计数从2减为1），再析构pa（将A资源的引用计数从2减为1），此后，AB对象的引用计数均为1，对象不能析构；\",\"产生的问题：new出来的资源无法释放，造成问题。\",\"解决办法：\",\"class B; class A { public: A() { cout << \\\"A()构造\\\" << endl; } ~A() { cout << \\\"~A()析构\\\" << endl; } weak_ptr<B> ptr2; //引用对象的地方使用 弱智能指针 }; class B { public: B() { cout << \\\"B()构造\\\" << endl; } ~B() { cout << \\\"~B()析构\\\" << endl; } weak_ptr<A> ptr1; //引用对象的地方使用 弱智能指针 }; int main() { shared_ptr<A> pa(new A()); //定义对象 使用强智能指针 shared_ptr<B> pb(new B()); pa->ptr2 = pb; pb->ptr1 = pa; cout << pa.use_count() << endl;//1 cout << pb.use_count() << endl;//1 } \",\"。\",\"可以正常释放资源！\"]},\"1057\":{\"h\":\"weak_ptr怎么使用资源\",\"t\":[\"class B; class A { public: A() { cout << \\\"A()构造\\\" << endl; } ~A() { cout << \\\"~A()析构\\\" << endl; } weak_ptr<B> ptr2; void testA() { cout << \\\"非常好的方法\\\" << endl; } }; class B { public: B() { cout << \\\"B()构造\\\" << endl; } ~B() { cout << \\\"~B()析构\\\" << endl; } void func() { //_ptr1->testA(); //弱智能指针是无法调用A类的testA函数的； } weak_ptr<A> ptr1; //引用对象的地方使用 弱智能指针 }; \",\"弱智能指针只会观察资源，不能使用资源；\",\"，不能将弱智能指针当成裸指针看待。\",\"怎么解决弱指针指针不能调用函数的问题？\",\"。\",\"class B; class A { public: A() { cout << \\\"A()构造\\\" << endl; } ~A() { cout << \\\"~A()析构\\\" << endl; } weak_ptr<B>ptr2; void testA() { cout << \\\"非常好的方法\\\" << endl; } }; class B { public: B() { cout << \\\"B()构造\\\" << endl; } ~B() { cout << \\\"~B()析构\\\" << endl; } void func() { shared_ptr<A>ps = ptr1.lock(); if (ps != nullptr) //有可能提升成功，也有可能失败，需要判断 { ps->testA(); } cout << ps.use_count() << endl;//智能指针ps提升成功，引用技术加1到2 //智能指针ps出函数作用域自动析构，引用计数从2减到1 } weak_ptr<A>ptr1; }; int main() { shared_ptr<A>ptra(new A()); shared_ptr<B>ptrb(new B()); ptra->ptr2 = ptrb; ptrb->ptr1 = ptra; cout << ptra.use_count() << endl;//1 cout << ptra.use_count() << endl;//1 ptrb->func(); cout << ptra.use_count() << endl;//1 cout << ptra.use_count() << endl;//1 ptrb->func(); } \",\"在多线程中，弱智能指针观察的资源有可能被释放，有可能没有被释放，；\",\"弱智能指针需要使用对象，需要从一个观察者提升为强智能指针，在提升的过程中有可能提升失败，资源已经释放了；有可能提升成功，资源还没释放。\"]},\"1058\":{\"c\":[\"c/c++\"]},\"1059\":{\"c\":[\"智能指针\"]},\"1060\":{\"h\":\"自定义删除器\",\"t\":[\"并不是说所有资源的释放都是delete指针 进行释放的。\",\"比如说，用智能指针来托管数组的资源，delete就得加个中括号[]了，\",\"如果用智能指针管理的是文件资源，或者是其他资源，释放的方式不是delete。\",\"作用：能保证资源的绝对释放\",\"unique_ptr shared_ptr都可以提供自定义删除器，本质上也就是智能指针第二参数给函数对象类，在类的operator()运算符重载资源释放工作，用法见下方代码：\",\"#include <iostream> #include <vector> #include <memory> #include <functional> #include <thread> using namespace std; template<typename T> class MyDeletor { public: void operator()(T* ptr)const { cout << \\\"call MyDeletor::operator()\\\" << endl; delete[] ptr; } }; template<typename T> class MyFileDeletor { public: void operator()(T* ptr)const { cout << \\\"call MyFileDeletor::operator()\\\" << endl; fclose(ptr); } }; int main() { unique_ptr<int, MyDeletor<int>> ptr1(new int[100]); unique_ptr<FILE, MyFileDeletor<FILE>> ptr2(fopen(\\\"aaa.txt\\\", \\\"w\\\")); //lambda表达式方法,lambda表达式也就是一个临时的函数对象 unique_ptr<int, function<void(int*)>> ptr3(new int[100], [](int* p)->void { cout << \\\"lambda!\\\" << endl; delete[]p; }); unique_ptr<FILE, function<void(FILE*)>> ptr4(fopen(\\\"aaa.txt\\\", \\\"w\\\"), [](FILE* p)->void { cout << \\\"FILE deleter lambda!\\\" << endl; fclose(p); }); return 0; } \",\"lamda表达式对象的类型如何确定？\",\"function函数对象类型，可以留下lamda表达式的类型\"]},\"1061\":{\"c\":[\"c/c++\"]},\"1062\":{\"c\":[\"智能指针\",\"lambda\"]},\"1063\":{\"h\":\"为什么c和c++函数参数从右往左压栈？\",\"t\":[\"因为c/c++支持“函数参数长度可变”这个特性\",\"可变参数函数：函数声明时参数列表有...，如printf（const char* format,…）\",\"函数调用的过程：\",\"将参数从右往左压栈\",\"执行call指令，先将下一行指令的地址压栈，再进入调用函数\",\"进入后，先将调用函数的栈底指针（即esp指针）压栈，然后再开辟栈空间\",\"指令生成是在编译阶段生成，不知道运行时传入了几个参数，从右往左压栈，因为参数压完后又压入了下一行指令的地址以及调用函数栈底指针，因此第一个参数的位置永远是ebp+8，通过ebp的偏移依次获取其他参数\",\"如果从左往右压栈，不知道传入参数个数，每次第一个参数的位置也是不确定的！！！\",\"[指令角度理解堆栈调用过程 | 张威的编程学习笔记 (gitee.io)](https://iszhwei.gitee.io/ccpp/00 基础必备/指令角度堆栈调用过程.html)\"]},\"1064\":{\"c\":[\"c/c++\"]},\"1065\":{\"c\":[\"c++补充\"]},\"1066\":{\"h\":\"分析这段代码构造函数和析构函数的调用顺序\",\"t\":[\"注意返回临时对象或用临时对象构造对象时，会被编译器优化\",\"别忘了第六步s的析构\",\"因此优化一下：\",\"string fun(string& s1, string& s2) { return s1 + s2; } int main() { string s = fun(s1, s2); } \"]},\"1067\":{\"h\":\"对于对象的优化：\",\"t\":[\"对象作为参数，传递时按\",\"返回对象是，不要先定义在返回\",\"接收返回值是对象的函数调用，优先按方式接收，不要按赋值方式接收\",\"string s; s = fun(s1, s2); //不要这样写 \"]},\"1068\":{\"c\":[\"c/c++\"]},\"1069\":{\"c\":[\"c++补充\"]},\"1070\":{\"h\":\"空结构体\"},\"1071\":{\"h\":\"对于c语言\",\"t\":[\"Windows下VS是不允许定义空struct结构体的\",\"Linux/Unix下gcc编译器，空结构体是0\"]},\"1072\":{\"h\":\"对于c++\",\"t\":[\"无论是vs还是gcc/g++下定义的空结构体大小为1，\"]},\"1073\":{\"h\":\"为什么c++空类占用内存大小为1\",\"t\":[\"c语言空结构定义变量里面什么都没有，所以为0\",\"c++里不叫变量，而是对象，定义一个变量只需要内存就行，而对象需要内存还要构造函数构造才叫对象，构造函数会生成一个this指针存放对象的起始地址，即c++区别c的在于创建对象需要调用构造函数，生成对象必须要有内存传给this调用构造函数，构造函数才能知道在哪里初始化/构造，因为没有东西因此默认给1字节的内存用于构造对象\"]},\"1074\":{\"c\":[\"c/c++\"]},\"1075\":{\"c\":[\"c++补充\"]},\"1076\":{\"h\":\"reallocate\",\"t\":[\"作用： 对内存池中的__chuck块进行扩容或缩容，一般用的比较少\",\"template <bool threads, int inst> void* __default_alloc_template<threads, inst>::reallocate(void* __p, size_t __old_sz, size_t __new_sz) { // 参数:chunk块的其实地址、调整前chunk块的大小、调整后chunk块的大小 void* __result; size_t __copy_sz; if (__old_sz > (size_t) _MAX_BYTES && __new_sz > (size_t) _MAX_BYTES) { // __old_sz和__new_sz都大于128字节，并不是从内存池分配的内存，直接调用库函数realloc return(realloc(__p, __new_sz)); } // __old_sz和__new_sz处于同一数量区间，不用扩容或缩容 if (_S_round_up(__old_sz) == _S_round_up(__new_sz)) return(__p); // __result指向重新分配的空间 __result = allocate(__new_sz); // __copy_sz 保存最小值 __copy_sz = __new_sz > __old_sz? __old_sz : __new_sz; // 从__p拷贝到__result，扩容拷贝__old_sz字节，缩容拷贝__new_sz memcpy(__result, __p, __copy_sz); // 归还原来的chunk块到内存池 deallocate(__p, __old_sz); return(__result); } \"]},\"1077\":{\"c\":[\"c/c++\"]},\"1078\":{\"c\":[\"SGI STL源码\"]},\"1079\":{\"h\":\"SGI STL二级空间配置器重要成员解读\",\"t\":[\"为了。所以对于进行管理。\",\"SGI STL提供了一级空间配置器和二级空间配置器，而SGI STL一级空间配置器也和STL标准模板库的实现是一样的（都是malloc/free）\",\"其中一级空间配置器allocator采用malloc和free来管理内存，和C++标准库中提供的allocator是一样的，如果我们频繁对内存进行申请和释放，每次都使用malloc和free，效率就很低了 但其二级空间配置器allocator采用了基于freelist自由链表原理的 内存池机制 实现内存管理，只管理不大于128字节的小块内存分配\",\"vector的声明\",\"template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) > class vector : protected _Vector_base<_Tp, _Alloc> \",\"可以看到，容器的默认空间配置器是__STL_DEFAULT_ALLOCATOR( _Tp)，它是一个宏定义，如下：\",\"# ifndef __STL_DEFAULT_ALLOCATOR # ifdef __STL_USE_STD_ALLOCATORS # define __STL_DEFAULT_ALLOCATOR(T) allocator< T > # else # define __STL_DEFAULT_ALLOCATOR(T) alloc # endif # endif \",\"从上面可以看到__STL_DEFAULT_ALLOCATOR通过宏控制有两种实现，一种是allocator< T >，另一种是alloc，这两种分别就是SGI STL的一级空间配置器和二级空间配置器的实现。\",\"template <int __inst> class __malloc_alloc_template // 一级空间配置器内存管理类 -- 通过malloc和free管理内 存 \",\"template <bool threads, int inst> class __default_alloc_template { // 二级空间配置器内存管理类 -- 通过自定义内存池实现内 存管理 \"]},\"1080\":{\"h\":\"一级空间配置器\",\"t\":[\"//stl_alloc.h //一级空间配置器的实现，类似与c++ STL的空间配置器 template <int __inst> class __malloc_alloc_template { //... static void* allocate(size_t __n) { void* __result = malloc(__n); //底层通过malloc分配内存 if (0 == __result) __result = _S_oom_malloc(__n); return __result; } static void deallocate(void* __p, size_t /* __n */) { free(__p); //使用free释放内存 } }; typedef __malloc_alloc_template<0> malloc_alloc; typedef malloc_alloc alloc; #ifdef __STL_USE_STD_ALLOCATORS template <class _Tp> class allocator { typedef alloc _Alloc; // The underlying allocator. //... _Tp* allocate(size_type __n, const void* = 0) { return __n != 0 ? static_cast<_Tp*>(_Alloc::allocate(__n * sizeof(_Tp))) : 0; } // __p is not permitted to be a null pointer. void deallocate(pointer __p, size_type __n) { _Alloc::deallocate(__p, __n * sizeof(_Tp)); } void construct(pointer __p, const _Tp& __val) { new(__p) _Tp(__val); } void destroy(pointer __p) { __p->~_Tp(); } }; \",\"//C++ STL空间配置器 //容器的空间配置器 template <typename T> struct Allocator { T* allocate(size_t size)//只负责内存开辟 { return (T*)malloc(sizeof(T) * size); } void deallocate(void *p)//只负责内存释放 { free(p); } void construct(T *p, const T &val)//已经开辟好的内存上，负责对象构造 { new (p) T(val);//定位new，指定内存上构造val，T(val)拷贝构造 } void destroy(T *p)//只负责对象析构 { p->~T();//~T()代表了T类型的析构函数 } }; \"]},\"1081\":{\"h\":\"二级空间配置器\",\"t\":[\"//stl_alloc.h # define __NODE_ALLOCATOR_THREADS true template <bool threads, int inst> class __default_alloc_template { //通过内存池的实现管理内存 }; typedef __default_alloc_template<__NODE_ALLOCATOR_THREADS, 0> alloc; \",\"__NODE_ALLOCATOR_THREADS 表示节点是否支持线程安全\"]},\"1082\":{\"h\":\"二级空间配置器重要成员解读\",\"t\":[\"![](SGI STL二级空间配置器重要成员解读.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16.png)\",\"template <bool threads, int inst> class __default_alloc_template { enum {_ALIGN = 8}; //对齐8字节 // 数组对应位置挂的内存池最大的__chunk块的的大小为128B，即freelist有16个元素，如果大于128字节就相当于是大块内存，不通过内存池管理，还是用malloc、free管理 enum {_MAX_BYTES = 128}; //最大字节数128字节 enum {_NFREELISTS = 16}; // _MAX_BYTES/_ALIGN 自由链表的个数 union _Obj { union _Obj* _M_free_list_link;//这个可以看成节点的next域，指向下一个空闲chunk块的起始地址 char _M_client_data[1]; /* The client sees this. */ }; //多线程对于堆上和数据段上的数据一般都加volatile修饰，防止线程对数据缓存， //不能及时看到其他线程对共享数据的修改 //自由链表大小_NFREELISTS = 16，存储类型为_Obj* static _Obj* __STL_VOLATILE _S_free_list[_NFREELISTS]; // 记录内存块的分配状态，Chunk allocation state. // 全部会初始化为0 static char* _S_start_free; static char* _S_end_free; static size_t _S_heap_size; // 向OS申请的所有内存大小 //... }; template <bool __threads, int __inst> char* __default_alloc_template<__threads, __inst>::_S_start_free = 0;//nullptr template <bool __threads, int __inst> char* __default_alloc_template<__threads, __inst>::_S_end_free = 0;//nullptr template <bool __threads, int __inst> size_t __default_alloc_template<__threads, __inst>::_S_heap_size = 0; //静态成员类外初始化，初始化自由链表 template <bool __threads, int __inst> typename __default_alloc_template<__threads, __inst>::_Obj* __STL_VOLATILE //free-list的16个元素初始化为0（nullptr） __default_alloc_template<__threads, __inst> ::_S_free_list[ # if defined(__SUNPRO_CC) || defined(__GNUC__) || defined(__HP_aCC) _NFREELISTS # else __default_alloc_template<__threads, __inst>::_NFREELISTS # endif ] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, }; // The 16 zeros are necessary to make version 4.1 of the SunPro // compiler happy. Otherwise it appears to allocate too little // space for the array. \",\"chunk 块\",\"如果_S_start_free和_S_end_free相等，则需要像OS申请内存\",\"_Obj 的结构，每个chunk块的头信息，会指向下一个空闲chunk块的起始地址\\nchunk块：就是_S_free_list每个元素下面挂的8、16、24字节的内存块\"]},\"1083\":{\"c\":[\"c/c++\"]},\"1084\":{\"c\":[\"SGI STL源码\"]},\"1085\":{\"h\":\"SGI STL的verctor是怎么管理对象的\",\"t\":[\"![](SGI STL的verctor是怎么管理对象的.assets/image-20240429164446966.png)\"]},\"1086\":{\"h\":\"SGI STL push_pack()和pop_pack()\",\"t\":[\"//stl_construct.h template <class _T1, class _T2> inline void _Construct(_T1* __p, const _T2& __value) { new ((void*) __p) _T1(__value); } template <class _T1, class _T2> inline void construct(_T1* __p, const _T2& __value) { _Construct(__p, __value); } //stl_vector.h template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) > class vector : protected _Vector_base<_Tp, _Alloc> { //... void push_back(const _Tp& __x) { if (_M_finish != _M_end_of_storage) { construct(_M_finish, __x); ++_M_finish; } else _M_insert_aux(end(), __x); } \",\"//stl_construct.h template <class _Tp> inline void _Destroy(_Tp* __pointer) { __pointer->~_Tp(); } template <class _Tp> inline void destroy(_Tp* __pointer) { _Destroy(__pointer); } //stl_vector.h template <class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) > class vector : protected _Vector_base<_Tp, _Alloc> { //... void pop_back() { --_M_finish; destroy(_M_finish); } }; \",\"底层定义的对象的构造和析构，由全局函数模板Construct和Destroy完成\"]},\"1087\":{\"h\":\"C++ STLpush_pack()和pop_pack()\",\"t\":[\"[vector迭代器的实现 | 张威的编程学习笔记 (iszhwei.github.io)](https://iszhwei.github.io/ccpp/05 运算符重载/vector迭代器的实现.html)\",\"//容器的空间配置器 template <typename T> struct Allocator { T* allocate(size_t size)//只负责内存开辟 { return (T*)malloc(sizeof(T) * size); } void deallocate(void *p)//只负责内存释放 { free(p); } void construct(T *p, const T &val)//已经开辟好的内存上，负责对象构造 { new (p) T(val);//定位new，指定内存上构造val，T(val)拷贝构造 } void destroy(T *p)//只负责对象析构 { p->~T();//~T()代表了T类型的析构函数 } }; template <typename T, typename Alloc = Allocator<T>> class vector//向量容器 { //... void push_back(const T &val)//尾插 { if (full()) { expand(); } //*_last++ = val; _allocator.construct(_last, val);//_last指针指向的内存构造一个值为val的对象 _last++; } void pop_back()//尾删 { if (empty()) return; //--_last; //不仅要把_last指针--，还需要析构删除的元素 --_last; _allocator.destroy(_last); } }; \",\"底层定义的对象的构造和析构，由空间配置器完成\"]},\"1088\":{\"c\":[\"c/c++\"]},\"1089\":{\"c\":[\"SGI STL源码\"]},\"1090\":{\"h\":\"两个重要的辅助接口函数\",\"t\":[\"template <bool threads, int inst> class __default_alloc_template { //... //将 __bytes 上调至最邻近的8的倍数 static size_t _S_round_up(size_t __bytes) { return (((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1)); } //返回 __bytes 大小的chunk块位于 free-list 中的编号 static size_t _S_freelist_index(size_t __bytes) { return (( (__bytes) + (size_t)_ALIGN-1) / (size_t)_ALIGN - 1); } }; \",\"//将 __bytes 上调至最邻近的8的倍数 static size_t _S_round_up(size_t __bytes) { return (((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1)); } /* _ALIGN = 8 ~((size_t) _ALIGN - 1)) 先将_ALIGN转为4字节 00000000 00000000 00000000 00001000 然后减1，取反，最终得到的是一个无符号的大整数 (size_t) _ALIGN-1) => 00000000 00000000 00000000 00000111 ~((size_t) _ALIGN - 1) => 11111111 11111111 11111111 11111000 ((__bytes) + (size_t) _ALIGN-1) & ~((size_t) _ALIGN - 1) 按位与11111111 11111111 11111111 11111000与，低3位永远为0，但是 基数为7，加1就会进位为8，所以： 1~8 =》8 9~16 =》16 17~24 =》24 ... 如果__bytes = 4 00000000 00000000 00000000 00001011 & 11111111 11111111 11111111 11111000 = 00000000 00000000 00000000 00001000 8 */ \",\"//返回 __bytes 大小的chunk块位于 free-list 中的编号 static size_t _S_freelist_index(size_t __bytes) { return (( (__bytes) + (size_t)_ALIGN-1) / (size_t)_ALIGN - 1); } /* (__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN (1~8 + 7) / 8 = 1 (9~16 + 7) / 8 = 2 ... ((__bytes) + (size_t)_ALIGN-1)/(size_t)_ALIGN - 1得到的是下标 (1~8 + 7) / 8 - 1 = 0 (9~16 + 7) / 8 - 1 = 1 ... */ \"]},\"1091\":{\"c\":[\"c/c++\"]},\"1092\":{\"c\":[\"SGI STL源码\"]},\"1093\":{\"h\":\"内存归还dealloacte\",\"t\":[\"归还分配出去的__chunk块，并\",\"修改_S_free_list对应的元素（保存当前还未分配出去__chunk块的首地址）\",\"修改归还的__chunk块的next域\",\"归还__p指向的__n字节chunk块到内存池\",\"// 归还__p指向的__n字节内存空间到内存池 static void deallocate(void* __p, size_t __n){ if (__n > (size_t) _MAX_BYTES) //因为大于128字节的是由malloc分配，所以释放的底层是free malloc_alloc::deallocate(__p, __n); else { // _S_freelist_index(__n):获取__n字节在_S_free_list中哪个小的内存池分配的 // __my_free_list 指向小内存池的起始地址 _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n); // __q指向要归还的__chunk块 _Obj* __q = (_Obj*)__p; #ifndef _NOTHREADS _Lock __lock_instance;//因为要修改静态链表，加锁保证线程安全 #endif // 即将归还__chunk块的next被赋值成当前还未分配出去__chunk块的首地址 __q -> _M_free_list_link = *__my_free_list; // 修改_S_free_list的元素，即修改了当前还未分配出去__chunk块的首地址 *__my_free_list = __q; } } \"]},\"1094\":{\"c\":[\"c/c++\"]},\"1095\":{\"c\":[\"SGI STL源码\"]},\"1096\":{\"h\":\"内存池allocate分配过程\",\"t\":[\"根据想分配的内存大小，先定位到_S_free_list 相应的元素__my_free_list（总共16个元素）\",\"如果__my_free_list下没有挂着空闲的chunk块，那直接从备用内存或者使用malloc申请chunk块，然后分配空间\",\"如果还有空闲的chunk块，那就使得_S_free_list 相应的元素指向__my_free_list下面挂着的下一块空闲的内存块，然后把前一块内存分配出去\",\"template <bool threads, int inst> class __default_alloc_template { //... class _Lock; friend class _Lock; class _Lock { //出作用域自动解锁 public: _Lock() { __NODE_ALLOCATOR_LOCK; } //构造函数加锁 ~_Lock() { __NODE_ALLOCATOR_UNLOCK; } //析构函数解锁 }; /* __n must be > 0 */ static void* allocate(size_t __n) { void* __ret = 0; if (__n > (size_t) _MAX_BYTES) { //enum {_MAX_BYTES = 128}; //超过128字节，使用一级空间配置器，底层malloc方法开辟内存 __ret = malloc_alloc::allocate(__n); } else { //小于128则通过内存池管理 //定义一个指针指向__n个字节应该在内存池哪个块分配 _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n); #ifndef _NOTHREADS //对于自由链表的增删改要加锁，不是线程安全的 _Lock __lock_instance; #endif //result为第一个chunk块地址 _Obj* __RESTRICT __result = *__my_free_list; if (__result == 0) //若__result下没有挂着空闲的chunk块， //_S_refill直接构造chunk后分配， //_S_round_up(__n)指的是内存池每个块的大小， __ret = _S_refill(_S_round_up(__n)); else {//如果不为空，则ret指向链表的第一个节点 //因为第一个chunk块要被分配出去了， //也就是_S_free_list的元素直接指向后面的节点 *__my_free_list = __result -> _M_free_list_link; __ret = __result;// 这时候是要把__result分配出去 } } return __ret; }; }; \"]},\"1097\":{\"c\":[\"c/c++\"]},\"1098\":{\"c\":[\"SGI STL源码\"]},\"1099\":{\"h\":\"分配内存池_S_refill源码\",\"t\":[\"作用：\",\"根据__n，在_S_free_list中对应位置的元素指向一个__nobjs（默认为20）个__n字节chunk块的内存池\",\"并且把第一个__chunk块分配出去，并填写剩下所有__chunk块的next域。\",\"只有从备用内存中分配出来，并挂在_S_free_list 下的，才会填写chunk块头的_M_free_list_link\",\"template <bool __threads, int __inst> void* __default_alloc_template<__threads, __inst>::_S_refill(size_t __n){ int __nobjs = 20; // 局部变量，内存池中开辟__chunk 块的数量 // 申请__nobjs个__n字节chunk的内存池，__nobjs按引用传入_S_chunk_alloc，__nobjs可能会在_S_chunk_alloc里被修改 // 如果_S_start_free和_S_end_free之间的备用内存不够分配20个__n字节的chunk时，会修改__nobjs char* __chunk = _S_chunk_alloc(__n, __nobjs); _Obj* __STL_VOLATILE* __my_free_list;// 二级指针，遍历_S_free_list数组 _Obj* __result; _Obj* __current_obj; _Obj* __next_obj; int __i; // 当内存池最多只能包含1个__n字节chunk块的时候，直接返回，不需要进入for循环再填写next域 if (1 == __nobjs) return(__chunk); // _S_freelist_index(__n)返回的是分配的__n字节在_S_free_list的哪个元素中分配 // __my_free_list 指向分配__n字节的元素 __my_free_list = _S_free_list + _S_freelist_index(__n); /* Build free list in chunk */ // 指向待分配出去的内存块 __result = (_Obj*)__chunk; // __chunk 是char*，实际上+__n就是越过了一个__chunk块，指向了第二个__chunk 块的起始地址 // __next_obj 和*__my_free_list 都指向第二个块 *__my_free_list = __next_obj = (_Obj*)(__chunk + __n); // i从1开始，表示__current_obj 一开始就指向第二个__chunk块 // 整个for循环做的就是把内存是填写剩下所有__chunk块的next域 for (__i = 1; ; __i++) { __current_obj = __next_obj; __next_obj = (_Obj*)((char*)__next_obj + __n); //因为每循环依次__i都加1，最后一个下标__i为__nobjs-1 if (__nobjs - 1 == __i) { // next域填写完成，最后一个__chunk块的next域为0地址 __current_obj -> _M_free_list_link = 0; break; } else { __current_obj -> _M_free_list_link = __next_obj; } } return(__result); } \"]},\"1100\":{\"c\":[\"c/c++\"]},\"1101\":{\"c\":[\"SGI STL源码\"]},\"1102\":{\"h\":\"实际分配内存池_S_chunk_alloc源码\",\"t\":[\"_S_chunk_alloc(size_t __size, int& __nobjs)作用：到备用内存中拿__nobjs个__size字节的chunk块分配\",\"如果备用内存足够，就从备用内存中拿，然后将_S_start_free指向分配后，空闲备用空间的首地址\",\"如果备用内存不够了，就malloc申请，并让_S_start_free 指向malloc的首地址，让_S_end_free指向为malloc空间的尾地址，然后递归调用_S_chunk_alloc重新在备用内存中拿__nobjs个__size字节的chunk块分配\",\"有一个疑问：为什么其他申请的16B的内存可以在_S_free_list 的8B的内存池申请 后来我懂了，源码中用 static char* _S_end_free、_S_start_free变量，标识备用内存池的范围。也就是不管分配多少字节的内存，都是在_S_start_free和_S_end_free区间内给用户分配。_S_free_list的每个元素都是一个指针，保存的是专门为分配对应字节的一大块内存空闲位置的起始地址\",\"再到备用内存给用户分配size字节的时候：\",\"若二级空间配置器应用管理的剩余内存还够20*size个字节，则直接分出去20*size专门用来分配20个size字节的chunk，然后需要在_S_refill函数中填写next域\",\"若不够分配20*size个字节\",\"但是够分配size个字节，那将备用的内存尽可能多的分割出完整的size内存块（修改了__nobjs大小）。此时也需要在_S_refill函数中填写next域，\",\"然而当备用内存只能分割出一个size内存块时，就不用再填写地址域了。其实也没有办法再填写了，因为没内存了。\",\"若实在太小，连一个size内存块也分配不出来。剩余的备用内存就会根据自身的大小被挂在_S_free_list 的对应位置，然后需要重新找OS申请新的内存（malloc）\",\"向OS申请成功，则分配一个大块的空闲内存，并返回__size*__nobjs大小的内存用于分配\",\"向OS申请失败则\",\"在_S_free_list中查找一个比__size大的空闲chunk分配出去，然后再回到之前的分配流程分配出去。\",\"如果在_S_free_list中不存在比__size大的空闲chunk，则再次尝试正常申请内存（malloc）\",\"申请成功，则返回正常分配\",\"申请失败，先检查时候设置用于释放某些可以释放的资源的回调函数，\",\"如果没有设置，则抛出异常\",\"若有设置则调用回调函数释放资源，然后再次malloc分配\",\"若分配成功则返回正常分配\",\"若失败则循环调用回调函数释放资源然后malloc分配，直至分配成功\",\"进入if中:\",\"进入else中：\",\"template <bool __threads, int __inst> char* __default_alloc_template<__threads, __inst>::_S_chunk_alloc(size_t __size, int& __nobjs) // 按引用接收__nobjs，如果不够__nobjs会改变该值的大小 { char* __result;//指向待分配的内存首地址 // 实际分配的字节数，8 * 20 size_t __total_bytes = __size * __nobjs; //需要返回的内存大小 //_S_end_free、_S_start_free都是static char*变量，标识备用内存池的范围，初始值为0 // _S_start_free、_S_end_free分别记录内存池（__size * __nobjs）可用的起始和末尾地址 size_t __bytes_left = _S_end_free - _S_start_free;//备用内存中可用内存大小 if (__bytes_left >= __total_bytes) {//完全足够，直接分配 // 正常的__size在对应的内存池分配，备用的内存池还可以继续分配__size * __nobjs // 可以分配出去一个小的内存池 __result = _S_start_free; // 修改_S_start_free，分配__total_bytes空间出去 _S_start_free += __total_bytes;//_S_start_free指向剩余可以内存首地址 return(__result); } else if (__bytes_left >= __size) { // 注意这里为什么是大于等于一个chunk块的大小__size，因为容器申请只是申请一个内存块 // 而是空间配置器程序调用_S_chunk_alloc希望能够分配20个chunk块的内存，可以不满足分配20个块的要求，但必须满足容器申请1个内存块的要求，所以可以修改__nobjs的值 // 假设我们向内存池申请16字节的时候，我们在_S_free_list向OS申请8字节时备用的内存池进行申请 // 此时会进入else if // 剩余的字节数还能分配出__nobjs个完整的__size的__chunk块 __nobjs = (int)(__bytes_left/__size); // 现在的__total_bytes 肯定不大于 _S_end_free - _S_start_free __total_bytes = __size * __nobjs; // __result 指向空闲内存池的首地址，也就是即将被分配出去的首地址 __result = _S_start_free; // 更新空闲内存池的首地址 _S_start_free += __total_bytes; return(__result); } else { // 没有足够的空间分配了 或者_S_free_list还没有申请过内存池 ，需要申请内存 // _S_heap_size初始值为0，第一次向OS申请的话__bytes_to_get = 2 * 8 * 20 = 320 // _S_heap_size记录了已经向OS申请的所有空间 size_t __bytes_to_get = 2 * __total_bytes + _S_round_up(_S_heap_size >> 4);//所以，新申请的内存只会越来越大 // Try to make use of the left-over piece. if (__bytes_left > 0) {//原来备用内存有剩余，但是不足size的情况 // 由于之前申请的备用内存太小，甚至无法分出一个size // 这里剩余的内存必然为8的整数倍，且在区间[8,128)内。因为从OS申请空间的时候就是按照8的整数申请的 // 之前申请的备用内存，会被挂在__my_free_list后，专门用于分配指定大小的内存 // 而且只能分配 <指定大小的内存> 一次 //找到__bytes_left大小的空间在自由链表的位置，因为元素为指针，所以遍历用二级指针 _Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__bytes_left); // 剩余内存连接到_S_freelists上 ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list; *__my_free_list = (_Obj*)_S_start_free; } // 用malloc申请__bytes_to_get个字节，也就是一个小的内存池了，_S_start_free 指向小内存池的首地址 _S_start_free = (char*)malloc(__bytes_to_get); if (0 == _S_start_free) { // 向OS申请内存失败 size_t __i; _Obj* __STL_VOLATILE* __my_free_list; _Obj* __p; // Try to make do with what we have. That can't // hurt. We do not try smaller requests, since that tends // to result in disaster on multi-process machines. // 1. 剩余的备用内存连一个__size的空间都不够，2. 向OS申请__bytes_to_get字节内存失败 // __i从__size开始到128(_MAX_BYTES)在_S_free_list中从前往后找挂载的空闲内存块 for (__i = __size; __i <= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN) { //当前__i大小的chunk应该在_S_free_list挂载的位置 __my_free_list = _S_free_list + _S_freelist_index(__i); __p = *__my_free_list;//表示挂载第一个chunk的地址 if (0 != __p) {//如果当前位置存在挂载的chunk的情况 // 找到_S_free_list中已经分配内存池的位置 // 修改_S_free_list的对应位置的地址，准备分配出一整个__i块出去 *__my_free_list = __p -> _M_free_list_link;//指向第二个chunk地址 // 在_S_free_list别的地方拿到未分配的内存块后，修改_S_start_free、_S_end_free // 得到新的备用内存，重新给用户分配__nobjs个__size的空间 _S_start_free = (char*)__p; _S_end_free = _S_start_free + __i; return(_S_chunk_alloc(__size, __nobjs)); // Any leftover piece will eventually make it to the right free list. } } // 若for循环完成，依然找不到空闲的内存块 _S_end_free = 0; // In case of exception. // 重新再次申请__bytes_to_get字节 _S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get); // This should either throw an exception or remedy the situation. // Thus we assume it succeeded. } //分配成功之后： // _S_heap_size 记录所有申请的堆空间大小 _S_heap_size += __bytes_to_get; // _S_end_free 指向空闲小内存池的尾地址 _S_end_free = _S_start_free + __bytes_to_get; // return(_S_chunk_alloc(__size, __nobjs)); } } \",\"malloc_alloc::allocate源码\",\"// 可以设置一个回调函数，当OS开辟内存失败的时候，调用此函数。 // 此函数可能用于释放某些可以释放的资源 #ifndef __STL_STATIC_TEMPLATE_MEMBER_BUG static void (* __malloc_alloc_oom_handler)(); #endif static void* malloc_alloc::allocate(size_t __n){ // 再次尝试一下正常向OS申请空间 void* __result = malloc(__n); // 正常向OS申请空间失败，调用_S_oom_malloc if (0 == __result) __result = _S_oom_malloc(__n); return __result; } template <int __inst> void* __malloc_alloc_template<__inst>::_S_oom_malloc(size_t __n){ void (* __my_malloc_handler)(); // 函数指针 void* __result; // 死循环，如果一直分配不成功，则会不停的调用回调函数 for (;;) { __my_malloc_handler = __malloc_alloc_oom_handler; // 设置回调函数 if (0 == __my_malloc_handler) { // 用户也没有设置任何回调函数，释放内存，那直接抛出异常 __THROW_BAD_ALLOC; } // 用户设置了回调函数，先调用函数进行资源释放 (*__my_malloc_handler)(); __result = malloc(__n); if (__result) return(__result); } } \"]},\"1103\":{\"c\":[\"c/c++\"]},\"1104\":{\"c\":[\"SGI STL源码\"]},\"1105\":{\"h\":\"总结\",\"t\":[\"SGI STL二级空间配置器内存池的实现优点：\",\"对于每一个字节数的chunk块分配，都是给出一部分进行使用，另一部分作为备用，这个备用可以给当前字节数使用，也可以给其它字节数使用\",\"对于备用内存池划分完chunk块以后，如果还有剩余的很小的内存块，再次分配的时候，会把这些小的内存块挂到_S_free_list的对应位置，再次分配出去，备用内存池使用的干干净净！\",\"当指定字节数内存分配失败以后，有一个异常处理的过程，查看_S_free_list从__size -> 128字节所有的chunk块，如果哪个字节数有空闲的chunk块，直接借一个出去。如果上面操作失败，还会调用_S_oom_malloc，其内部有一个预先设置好的malloc内存分配失败的回调函数，若分配不成功则会不停地调用次回调函数释放空间。若没设置回调函数，则直接malloc throw bad_alloc\",\"源码阅读的方法：先拎清主要逻辑（主要干的什么），再关注侧枝（其他的函数），不要一行行的阅读，可以辅助画图理解\"]},\"1106\":{\"c\":[\"c/c++\"]},\"1107\":{\"c\":[\"SGI STL源码\"]},\"1108\":{\"h\":\"C++对象的优化\"},\"1109\":{\"h\":\"1、对象 使用过程中 背后调用了哪些方法？\",\"t\":[\"了解构造和析构的调用，以及调用顺序\"]},\"1110\":{\"h\":\"用临时对象生成新对象\",\"t\":[\"class Test { public: Test(int a = 10) :ma(a) { cout << \\\"Test(int)\\\" << endl; } ~Test() { cout << \\\"~Test()\\\" << endl; } Test(const Test &t) :ma(t.ma) { cout << \\\"Test(const Test&)\\\" << endl; } Test& operator=(const Test &t) { cout << \\\"operator=\\\" << endl; ma = t.ma; return *this; } private: int ma; }; int main() { Test t1;//调用构造函数 Test t2(t1);//调用拷贝构造函数 Test t3 = t1;//调用拷贝构造函数，因为t3还没有生成 //Test(20) 显示生成临时对象，是没有名字的，所以其生存周期：所在的语句 //语句结束，临时对象就析构了 /* C++编译器对于对象构造的优化：用临时对象生成新对象的时候，临时对象 就不产生了，直接构造新对象就可以了 */ Test t4 = Test(20);//和Test t4(20);没有区别的！ cout << \\\"--------------\\\" << endl; return 0; } \",\"C++编译器对于对象构造的优化：\"]},\"1111\":{\"h\":\"用临时对象给已存在对象赋值\",\"t\":[\"int main() { Test t1;//调用构造函数 Test t2(t1);//调用拷贝构造函数 Test t3 = t1;//调用拷贝构造函数，因为t3还没有生成 //Test(20) 显示生成临时对象，是没有名字的，所以其生存周期：所在的语句 //语句结束，临时对象就析构了 /* C++编译器对于对象构造的优化：用临时对象生成新对象的时候，临时对象 就不产生了，直接构造新对象就可以了 */ Test t4 = Test(20);//和Test t4(20);没有区别的！ cout << \\\"--------------\\\" << endl; //t4.operator=(t2) t4 = t2;//调用赋值重载函数，因为t4原本已存在 //Test(30)显式生成临时对象 //t4原本已存在，所以不是构造，这个临时对象肯定要构造生成的 //临时对象生成后，给t4赋值 //出语句后，临时对象析构 //t4.operator=(const Test &t) t4 = Test(30); cout << \\\"--------------\\\" << endl; return 0; } \",\"，所以不是构造，，给t4赋值出语句后，临时对象析构\"]},\"1112\":{\"h\":\"显示生成临时对象和隐式生成临时对象\",\"t\":[\"int main() { Test t1; Test t2(t1); Test t3 = t1; Test t4 = Test(20); cout << \\\"--------------\\\" << endl; t4 = t2;//t4调用赋值重载函数 t4 = Test(30); //显式生成临时对象，赋值给t4，出语句后，临时对象析构 t4 = (Test)30; /* 把30强转成Test类型int->Test(int) 把其他类型转成类类型的时候，编译器就看这个类类型 有没有合适的构造函数 把整型转成Test，就看这个类类型有没有带int类型参数的构造函数 ， 有，就可以显式生成临时对象，然后赋值给t4 出语句后，临时对象析构 */ //隐式生成临时对象,然后赋值给t4，出语句后，临时对象析构 t4 = 30; //把整型转成Test，Test(30) int->Test(int) char*->Test(char*) cout << \\\"--------------\\\" << endl; return 0; } \",\"把转成的时候，编译器就看这个类类型 有没有合适的\"]},\"1113\":{\"h\":\"临时对象的指针和引用\",\"t\":[\"指针指向临时对象，出了语句，；\",\"引用指向临时对象，出了语句，。引用相当于给临时对象起了一个名字。\",\"int main() { Test t1; Test t2(t1); Test t3 = t1; Test t4 = Test(20); cout << \\\"--------------\\\" << endl; t4 = t2; t4 = Test(30); t4 = (Test)30; t4 = 30; cout << \\\"--------------\\\" << endl; Test* p = &Test(40);//指针指向临时对象，这个临时对象肯定是要生成的 //然后p指向这个临时对象的地址 //出语句后，临时对象析构 //此时p指向的是一个已经析构的临时对象，p相当于野指针了 const Test& ref = Test(50);//引用一个临时对象，这个临时对象也是要生成的 //出语句后，临时对象不析构，因为引用相当于是别名，临时对象出语句析构是因为没有名字 //用引用变量引用临时对象是安全的，临时对象就是有名字了，临时对象的生存周期就变成引用变量的 //生存周期了。引用变量是这个函数的局部变量，return完，这个临时对象才析构 cout << \\\"--------------\\\" << endl; return 0; } \"]},\"1114\":{\"h\":\"示例二\",\"t\":[\"class Test { public: //因为a,b有默认值，所以构造有3种方式： //Test() Test(10) Test(10, 10) Test(int a = 5, int b = 5)//构造函数 :ma(a), mb(b) { cout << \\\"Test(int, int)\\\" << endl; } ~Test()//析构函数 { cout << \\\"~Test()\\\" << endl; } Test(const Test& src)//拷贝构造函数 :ma(src.ma), mb(src.mb) { cout << \\\"Test(const Test&)\\\" << endl; } void operator=(const Test& src)//赋值重载函数 { ma = src.ma; mb = src.mb; cout << \\\"operator=\\\" << endl; } private: int ma; int mb; }; //对象的构造顺序标识：1,2,3...14 Test t1(10, 10);//1.Test(int, int) int main() { Test t2(20, 20);//3.Test(int, int) Test t3 = t2;//4.Test(const Test&) //第一次运行到它才初始化的，static Test t4(30, 30); static Test t4 = Test(30, 30);//5.Test(int, int) t2 = Test(40, 40);//6.Test(int, int) operator= 出语句调用 ~Test() //(50,50)是逗号表达式，(表达式1，表达式2，表达式n) //(50,50)的最后的结果是最后一个表达式n的结果 50 //(50, 50) = (Test)50; Test(int) t2 = (Test)(50, 50);//7.Test(int,int) operator= 出语句调用~Test() t2 = 60;//Test(int) 8.Test(int,int) operator=出语句调用~Test() Test* p1 = new Test(70, 70);//9. Test(int,int) 要调用delete才析构对象 Test* p2 = new Test[2];//10. Test(int,int) Test(int,int) 要调用delete[]才析构对象 Test* p3 = &Test(80, 80);//11. Test(int,int) 出语句调用~Test() const Test& p4 = Test(90, 90);//12. Test(int,int) delete p1;//13.~Test() delete[]p2;//14. ~Test() ~Test() } Test t5(100, 100);//2.Test(int, int) \",\"t2 = (Test)(50, 50);由于将（50，50）等价于50，所以最后调用Test(50)\",\"注意Test t5(100, 100);//2.Test(int, int)在mian()前，因为****\",\"析构顺序：p1->p2(析构2次)->p4->t3->t2->t4->t5->t1\"]},\"1115\":{\"h\":\"2、 函数调用过程中 对象被后续调用的方法太多\",\"t\":[\"#include <iostream> using namespace std; class Test { public: //有默认值，可以有2种构造方式：Test() Test(20) Test(int data = 10) :ma(data) { cout << \\\"Test(int)\\\" << endl; } ~Test() { cout << \\\"~Test()\\\" << endl; } Test(const Test& t) :ma(t.ma) { cout << \\\"Test(const Test&)\\\" << endl; } void operator=(const Test& t) { cout << \\\"operator=\\\" << endl; ma = t.ma; } int getData()const { return ma; } private: int ma; }; Test GetObject(Test t) //不能返回局部的或临时的对象的指针或引用 { int val = t.getData(); Test tmp(val); return tmp; } int main() { Test t1;//1、调用带整型参数的构造函数 Test t2;//2、调用带整型参数的构造函数 t2 = GetObject(t1);//函数调用，实参传递给形参，是初始化还是赋值？ //当然是初始化，对象初始化是调用构造函数，赋值是两个对象都存在 调用左边对象的=重载 //t1是已经构造好的Test对象，而形参是t是正在定义的Test对象 //3、调用Test(const Test&) 拿t1拷贝构造形参t //4、调用Test(int)的构造，构造tmp对象 然后return tmp;tmp是不能直接给t2赋值的 //因为tmp和t2是两个不同函数栈帧上的对象，是不能直接进行赋值的 GetObject函数完成调用时 //tmp对象作为局部对象就析构了 ，为了把返回值带出来， 在return tmp;这里，首先要在main函数栈帧 //上构建一个临时对象，目的就是把tmp对象带出来， //5、调用 Test(const Test&)，tmp拷贝构造main函数栈帧上的临时对象 //6、出 GetObject作用域，tmp析构 //7、形参t对象析构 //8、operator =，把main函数刚才构建的临时对象赋值给t2，临时对象没名字，出了语句就要析构 //9、把main函数刚才构建的临时对象析构 //10、main函数结束，t2析构 //11、t1析构 return 0; } \"]},\"1116\":{\"h\":\"3、总结三条对象优化原则\",\"t\":[\"函数参数传递过程中，对象优先按，这样可以！\",\"函数返回对象的时候，应该优先返回一个，而\",\"收返回值是对象的函数调用的时候，优先按的方式接收，\",\"Test GetObject(Test& t) //引用传递 { int val = t.getData(); //Test tmp(val); //return tmp; //返回临时对象 return Test(val); } int main() { Test t1; Test t2 = GetObject(t1); //t2 = GetObject(t1); return 0; } \"]},\"1117\":{\"c\":[\"c/c++\"]},\"1118\":{\"c\":[\"对象优化\"]},\"1119\":{\"h\":\"C++的右值引用的应用\"},\"1120\":{\"h\":\"1、CMyStirng代码的问题分析\",\"t\":[\"class CMyString { public: CMyString(const char* str = nullptr) { cout << \\\"CMyString(const char*)\\\" << endl; if (str != nullptr) { mptr = new char[strlen(str) + 1]; strcpy(mptr, str); } else { // 最少都初始化只有一个\\\\0的字符串，使得不需要对字符串判空操作 mptr = new char[1]; *mptr = '\\\\0'; } } ~CMyString() { cout << \\\"~CMyString\\\" << endl; delete[]mptr; mptr = nullptr; } // 带左值引用参数的拷贝构造 CMyString(const CMyString& str) { cout << \\\"CMyString(const CMyString&)\\\" << endl; mptr = new char[strlen(str.mptr) + 1]; strcpy(mptr, str.mptr); } // 带左值引用参数的赋值重载函数 CMyString& operator=(const CMyString& str) { cout << \\\"operator=(const CMyString&)\\\" << endl; if (this == &str) return *this; delete[]mptr; mptr = new char[strlen(str.mptr) + 1]; strcpy(mptr, str.mptr); return *this; } const char* c_str()const { return mptr; } private: char* mptr; }; CMyString GetString(CMyString& str) { const char* pstr = str.c_str(); CMyString tmpStr(pstr); return tmpStr; } int main() { CMyString str1(\\\"aaaaaaaaaaaaaaaaaaaa\\\"); CMyString str2; str2 = GetString(str1); cout << str2.c_str() << endl; return 0; } \",\"CMyString(const char*) CMyString(const char*) CMyString(const char*) CMyString(const CMyString&) // m1 ~CMyString operator=(const CMyString&) // m2 ~CMyString aaaaaaaaaaaaaaaaaaaa ~CMyString ~CMyString \",\"m1位置处，是GetString返回时候调用拷贝构造返回main函数栈帧的临时对象，这里会做，因为对象存放一个动态开辟的char数组。并且拷贝完立马就释放了。\",\"m2位置是main函数上临时对象给str2拷贝赋值，等于说又做一次，并且拷贝完立马就释放了。\",\"这两次操作的，我们\"]},\"1121\":{\"h\":\"解决方法\",\"t\":[\"[引用 | 张威的编程学习笔记 (gitee.io)](https://iszhwei.gitee.io/ccpp/02 c__基础/引用.html#右值引用)\",\"右值引用、实现接收右值的拷贝构造和拷贝赋值函数（移动构造和赋值）\",\"临时对象是右值\",\"添加的函数如下：\",\"// 带右值引用参数的拷贝构造，移动构造 // 将右边的资源直接窃取过来 CMyString(CMyString&& str) // str传入的就是右值亦称为将亡值 { cout << \\\"CMyString(CMyString&& str)\\\" << endl; mptr = str.mptr; str.mptr = nullptr; } // 带右值引用参数的赋值重载函数,移动赋值 // 将右边的资源直接窃取过来 CMyString& operator=(CMyString&& str) { cout << \\\"operator=(CMyString&& str)\\\" << endl; if (this == &str) return *this; delete[] mptr; mptr = str.mptr; str.mptr = nullptr; return *this; } \",\"CMyString(const char*) CMyString(const char*) CMyString(const char*) CMyString(CMyString&& str) ~CMyString operator=(CMyString&& str) ~CMyString aaaaaaaaaaaaaaaaaaaa ~CMyString ~CMyString \",\"两次拷贝全都走移动构造和移动赋值，全都是进行指针指向的改变，而不是内存空间的重新分配，这样必然可以极大的提高效率\"]},\"1122\":{\"h\":\"operator+() 效率问题\",\"t\":[\"CMyString operator+ (const String &lhs, const String &rhs) { char* ptmp = new char[strlen(lhs._ptr) + strlen(rhs._ptr) + 1];//内存泄漏 strcpy(ptmp, lhs.mptr); strcat(ptmp, rhs.mptr); return CMyString(ptmp); } \",\"如果上面这样写会导致，因此不能直接返回临时对象\",\"CMyString operator+(const CMyString &lhs, const CMyString& rhs) { char* ptmp = new char[strlen(lhs.mptr) + strlen(rhs.mptr) + 1]; strcpy(ptmp, lhs.mptr); strcat(ptmp, rhs.mptr); CMyString tmpStr(ptmp); delete[] ptmp; return tmpStr; //return CMyString(ptmp); } \",\"这样写虽然解决了内存泄漏问题，\"]},\"1123\":{\"h\":\"解决办法\",\"t\":[\"CMyString operator+(const CMyString& lhs, const CMyString& rhs) { //char *ptmp = new char[strlen(lhs.mptr) + strlen(rhs.mptr) + 1]; CMyString tmpStr; tmpStr.mptr = new char[strlen(lhs.mptr) + strlen(rhs.mptr) + 1]; strcpy(tmpStr.mptr, lhs.mptr); strcat(tmpStr.mptr, rhs.mptr); //delete []ptmp; return tmpStr;//直接调用右值拷贝构造函数 //return CMyString(ptmp); } \",\"#include <iostream> using namespace std; class CMyString { public: CMyString(const char* str = nullptr) { cout << \\\"CMyString(const char*)\\\" << endl; if (str != nullptr) { mptr = new char[strlen(str) + 1]; strcpy(mptr, str); } else { mptr = new char[1]; *mptr = '\\\\0'; } } ~CMyString() { cout << \\\"~CMyString\\\" << endl; delete[]mptr; mptr = nullptr; } //带左值引用参数的拷贝构造 CMyString(const CMyString& str) { cout << \\\"CMyString(const CMyString&)\\\" << endl; mptr = new char[strlen(str.mptr) + 1]; strcpy(mptr, str.mptr); } //带右值引用参数的拷贝构造 CMyString(CMyString&& str)//str引用的就是一个临时对象 { cout << \\\"CMyString(CMyString&&)\\\" << endl; mptr = str.mptr; str.mptr = nullptr; } //带左值引用参数的赋值重载函数 CMyString& operator=(const CMyString& str) { cout << \\\"operator=(const CMyString&)\\\" << endl; if (this == &str) return *this; delete[]mptr; mptr = new char[strlen(str.mptr) + 1]; strcpy(mptr, str.mptr); return *this; } //带右值引用参数的赋值重载函数 CMyString& operator=(CMyString&& str)//str引用的是临时对象 { cout << \\\"operator=(CMyString&&)\\\" << endl; if (this == &str) return *this; delete[]mptr; mptr = str.mptr; str.mptr = nullptr; return *this; } const char* c_str()const { return mptr; } private: char* mptr; friend CMyString operator+(const CMyString& lhs, const CMyString& rhs); friend ostream& operator<<(ostream& out, const CMyString& str); }; CMyString operator+(const CMyString& lhs, const CMyString& rhs) { //char *ptmp = new char[strlen(lhs.mptr) + strlen(rhs.mptr) + 1]; CMyString tmpStr; tmpStr.mptr = new char[strlen(lhs.mptr) + strlen(rhs.mptr) + 1]; strcpy(tmpStr.mptr, lhs.mptr); strcat(tmpStr.mptr, rhs.mptr); //delete []ptmp; return tmpStr;//直接调用右值拷贝构造函数 //return CMyString(ptmp); } ostream& operator<<(ostream& out, const CMyString& str) { cout << str.mptr; return out; } CMyString GetString(CMyString& str) { const char* pstr = str.c_str(); CMyString tmpStr(pstr); return tmpStr; } int main() { CMyString str1 = \\\"hello \\\"; CMyString str2 = \\\"world!\\\"; cout << \\\"--------------------------\\\" << endl; CMyString str3 = str1 + str2; cout << \\\"--------------------------\\\" << endl; cout << str3 << endl; } \"]},\"1124\":{\"h\":\"分析下面打印什么\",\"t\":[\"int main() { CMyString str1 = \\\"aaa\\\"; vector<CMyString> vec; vec.reserve(10); cout << \\\"----------------------------------\\\" << endl; vec.push_back(str1); // 调用左值引用的拷贝 vec.push_back(CMyString(\\\"nnn\\\")); // 调用构造 和 右值引用的拷贝 cout << \\\"----------------------------------\\\" << endl; } \",\"匹配左值： 调用左值引用的拷贝构造；\",\"匹配右值： 调用右值引用的拷贝构造；\",\"CMyString(const char*) ---------------------------------- CMyString(const CMyString&) CMyString(const char*) CMyString(CMyString&& str) ~CMyString ---------------------------------- ~CMyString ~CMyString ~CMyString \"]},\"1125\":{\"c\":[\"c/c++\"]},\"1126\":{\"c\":[\"对象优化\"]},\"1127\":{\"h\":\"move移动语义和forward完美转发\",\"t\":[\"vector使用右值的拷贝构造函数，可以直接用临时对象拷贝构造，直接将资源移动过来。\",\"//容器空间适配器 template<typename T> struct Allocator { T *allocate(size_t size)//负责内存的开辟 { return (T*)malloc(sizeof(T)*size); } void deallocate(void *p)//负责内存的释放 { free(p); } void construct(T *p, const T &val)//负责对象的构造 { new(p) T(val); } void destroy(T *p)//负责对象的析构 { p->~T(); } }; template<typename T,typename Alloc = Allocator<T>> class vector { public: vector(size_t size = 10) { _first = _allocator.allocate(size);//只给数组开辟空间，不进行构造 _last = _first; _end = _first + size; } ~vector() { T *ptmp = _first; for (; ptmp != _last; ++ptmp)//首先释放数组中的有效元素 { _allocator.destroy(ptmp); } //释放数组 _allocator.deallocate(_first); _first = _end = _last = nullptr; } vector(const vector&src) { //首先申请空间 size_t size = src._end - src._first;//获取src的数组长度 _first = _allocator.allocate(size);//申请空间 _last = _first; int len = src._last - src._first; for (int i = 0; i < len; i++)//拷贝数据 { _allocator.construct(_last++, src._first[i]); } _end = _first + size; } void operator=(const vector&src) { //1,判断是否为自赋值 if (this == &src) return; //2，释放原来对象占用的空间 ~vector(); //3，和拷贝构造过程一样 size_t size = src._end - src._first;//获取src的数组长度 _first = _allocator.allocate(size);//申请空间 _last = _first; int len = src._last - src._first; for (int i = 0; i < len; i++) { _allocator.construct(_last++, src._first[i]); } _end = _first + size; } void push_back(const T &val) { if (full()) expand(); _allocator.construct(_last++, val); } void pop_back() { if (empty()) return; --_last; _allocator.destroy(_last); } T back() { if (empty()) throw \\\"the vector is empty\\\"; return *(_last - 1); } bool full()const { return _last == _end; } bool empty()const { return _first == _last; } size_t size()const { return _last - _first; } private: T *_first;//指向数组的首元素的地址 T *_last;//指向数据最后一个有效元素的后继 T *_end;//指向数组有效空间最后一个元素的后继 Alloc _allocator;//空间适配器 void expand()//二倍扩容 { size_t len = _end - _first;//当前的数组大小 size_t size = len * 2;//扩容之后的数组的大小 T *ptmp = _allocator.allocate(size);//先申请大小为原来二倍的空间 T *pcur = _first;// for (int i = 0; i < len; i++) _allocator.construct(ptmp + i, *pcur++); for (int i = 0; i < len; i++) _allocator.destroy(_first++); _allocator.deallocate(_first); _first = ptmp; _end = _first + size; _last = _first + len; } }; \",\"这里我们只讲述vector中的push_back方法；\",\"匹配右值的push_back函数：\",\"我们在vector类里面增加一个带右值引用的push_back的重载函数，\",\"在空间配置器里面增加一个带右值引用的construct的方法。\",\"void push_back(T &&val) { if (full()) expand(); _allocator.construct(_last++, std::move(val)); } void construct(T *p, T &&val)//负责对象的构造 { new(p) T(std::move(val)); } \",\"上面用到了方法std::move()移动语义。。。由于我们知道，(直接使用回调用左值的construct函数，而不是右值的)，所以我们在传参的时候，希望使用它的本身的右值语义，我们这里使用std::move()相当于将左值强制转换成右值引用类型。move()源码如下\",\"但是上面的方法不免显得有点了，因为一旦我们要使用val的右值引用就必须给它。\",\"我们可以使用函数模板来简化我们的代码量。\",\"template<typename Ty> void push_bask(Ty&& val) { if(full()) { expand(); } // forward完美转发，能复原val原本类型，即右值引用-》右值；左值引用-》左值 _allocate.construct(_last++, std::forward<Ty>(val)); } template <typename Ty> void construct(T* p, Ty&& val) {//负责对象的构造 new(p) T(std::forward<Ty>(val)); } int main(void) { CMyString str1 = \\\"aaa\\\"; vector<CMyString> vec; cout << \\\"----------------------------------\\\" << endl; vec.push_back(str1); //CMyString& vec.push_back(CMyString(\\\"nnn\\\")); //CMyString&& cout << \\\"----------------------------------\\\" << endl; } \",\"std::forward<Ty>(val)自动识别val是左值还是右值并返回对应类型\",\"引用折叠:右值引用+右值引用=右值引用\",\"右值引用+左值引用=左值引用\",\"函数模板参数推演Ty是左值CMyString&& 还是 CMyString& CMyString&& + && =CMyString&& CMyString& + && = CMyString& \"]},\"1128\":{\"c\":[\"c/c++\"]},\"1129\":{\"c\":[\"对象优化\"]},\"1130\":{\"h\":\"amix/vimrc的配置和使用\"},\"1131\":{\"h\":\"安装前先安装插件\",\"t\":[\"sudo apt install -y ack universal-ctags \"]},\"1132\":{\"h\":\"amix 的 Vim 配置\",\"t\":[\"awesome版本包括很多很棒的插件，配置和配色方案\",\"git clone --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtime sh ~/.vim_runtime/install_awesome_vimrc.sh \"]},\"1133\":{\"h\":\"个性化配置\",\"t\":[\"vi ~/.vim_runtime/my_configs.vim \",\"\\\"my_configs.vim添加以下内容 set nu set hlsearch syntax on set cursorline set tabstop=4 set cindent set shiftwidth=4 set path +=.,/usr/include set fileencodings=utf-8,gb18030,gbk,gb2312 colorscheme dracula nmap <tab> :bn<CR> #normal模式循环切换文件 \"]},\"1134\":{\"h\":\"常用的使用方法\"},\"1135\":{\"h\":\"~/.vim_runtime/vimrcs/extended.vim 中的设置：\",\"t\":[\"F5 运行编译当前文件\",\",e打开配置文件my_configs.vim\",\"符号补全(){}[]\\\"\\\"''，区分了输入一半补全和全输入光标后插入（技巧值得学习）\"]},\"1136\":{\"h\":\"全局查找文件(ctrlp插件)\",\"t\":[\"ctrl + f --打开全局文件搜索面板\",\"Esc --退出全局文件搜索面板\"]},\"1137\":{\"h\":\"tab(标签)相关\",\"t\":[\"tabnew + 名字 -- 创建标签\",\"gt --后一个标签\",\"gT --前一个标签\",\":q --关闭标签\"]},\"1138\":{\"h\":\"目录树(NERD_tree插件)\",\"t\":[\",nn --打开目录树\",\",nn --关闭目录树\"]},\"1139\":{\"h\":\"窗口相关\",\"t\":[\":sp --竖直方向上拆分当前窗口\",\":vsp --水平方向上拆分当前窗口\",\"ctrl + w + w --切换窗口\",\":q --关闭窗口，窗口只有一个tab的情况\"]},\"1140\":{\"h\":\"如何打开一个工程\",\"t\":[\"在某个工程的根目录下输入打开vim，则该vim窗口的文件操作默认为整个工程，比如全局搜索文件或字段\"]},\"1141\":{\"h\":\"全局搜索字段(ack插件)\",\"t\":[\",g --打开全局字段搜索面板，默认大小写敏感，-i 不区分大小写，-w 全词匹配\",\"q --退出全局字段搜索面板\",\"Vim神级配置（amix）安装与使用_spf_amix vim-CSDN博客\"]},\"1142\":{\"h\":\"常用操作\",\"t\":[\"删除多行\",\"数字dG \",\"当前行到48行的内容都删除\",\"48dG \",\"复制多行\",\"数字yG \",\"注释\",\"ctrl v 先选中多行 gc 注释 \",\"代码对齐\",\"gg=G 或者 ctrl v选中 = dui'qu \"]},\"1143\":{\"h\":\"配色设置\",\"t\":[\":colorscheme 空格 <tab>查看已安装的主题有哪些\",\"flazz/vim-colorschemes: one colorscheme pack to rule them all! (github.com)这个仓库有大量的vim配色文件***.vim，打开合适的配色文件将里面的内容复制到~/.vim/colors/下\",\"在~/.vim_runtime/vimrcs/extended.vim中添加colorscheme 主题名配置每次vim默认打开的文件\"]},\"1144\":{\"c\":[\"linux\"]},\"1145\":{\"c\":[\"vim配置\"]},\"1146\":{\"h\":\"bind1st和bind2d使用\",\"t\":[\"bind1st和bind2d是STL中的；\",\"bind1st和bind2d作用： 将二元函数对象的一个参数绑定，使其变为一元函数对象；\",\"缺点： 只能用于二元函数对象。\",\"函数对象： 对象拥有小括号重载函数的对象。\",\"#include <functional> --包含c++库中的所有的函数对象 bind1st #include <algorithm> --包含了c++库中的所有的泛型算法 \"]},\"1147\":{\"h\":\"例1—改变排序顺序\",\"t\":[\"#include <iostream> #include <vector> #include <functional> #include <algorithm> #include <ctime> using namespace std; template<typename Container> void showContainer(Container& con) { typename Container::iterator it = con.begin(); //编译器是从上到下编译的，这个还没有实例化，它不知道这个名字作用域后面的iterator是类型还是变量 //typename告知编译器后面类型的作用域后面是类型 for (; it != con.end(); ++it) { cout << *it << \\\" \\\"; } cout << endl; } int main() { vector<int> vec; srand(time(nullptr)); for (int i = 0; i < 20; ++i) { vec.push_back(rand() % 100 + 1);//随机出来的数字，并不是有序的 } showContainer(vec); sort(vec.begin(), vec.end());//默认小到大排序，传入的是起始和末尾的后继的迭代器 showContainer(vec); //greater 二元函数对象 sort(vec.begin(), vec.end(), greater<int>());//大到小排序 showContainer(vec); return 0; } \",\"greater是一个二元函数对象：（因为一次需要从容器中拿2个函数对象出来）\"]},\"1148\":{\"h\":\"例2—将70按顺序插入到vec容器中\",\"t\":[\"问题：将70按顺序插入到vec容器中\",\"使用find_if函数需要传入一个**一元函数对象（**一次从容器中拿出一个元素和70进行比较 ）\",\"注意：库里面提供的函数对象，没有办法直接使用；怎么办？\",\"使用绑定器，将二元函数对象转换为一元函数对象；\",\"#include <iostream> #include <vector> #include <functional> #include <algorithm> #include <ctime> using namespace std; template<typename Container> void showContainer(Container& con) { typename Container::iterator it = con.begin(); for (; it != con.end(); ++it) { cout << *it << \\\" \\\"; } cout << endl; } template<typename Iterator, typename Compare> Iterator my_find_if(Iterator first, Iterator last, Compare comp) //遍历这2个迭代器之间的元素，如果满足函数对象的运算，就返回当前迭代器，如果都不满足，返回end() { for (; first != last; ++first) { if (comp(*first))//comp.operator()(*first)一元函数对象，因为要从容器拿1个元素和它指定的元素比较 //my_find_if需要1元函数对象，而在库里面都是二元的 { return first; } } return last; } template<typename Compare, typename T> class _mybind1st//绑定器是函数对象的一个应用 { public: _mybind1st(Compare comp, T val) :_comp(comp), _val(val) {} bool operator()(const T& second) { return _comp(_val, second);//greater } private: Compare _comp; T _val; }; //mybind1st(greater<int>(), 70) //mybind1st就是将函数对象封装了一下。 template<typename Compare, typename T> _mybind1st<Compare, T> mybind1st(Compare comp, const T& val) { //直接使用函数模板，好处是，可以进行类型的推演 return _mybind1st<Compare, T>(comp, val); } int main() { vector<int> vec; srand(time(nullptr)); for (int i = 0; i < 20; ++i) { vec.push_back(rand() % 100 + 1); } showContainer(vec); sort(vec.begin(), vec.end());//默认小到大排序 showContainer(vec); //greater 二元函数对象 sort(vec.begin(), vec.end(), greater<int>());//大到小排序 showContainer(vec); /* 把70按顺序插入到vec容器当中 找第一个小于70的数字 operator()(const T &val) greater a > b less a < b 绑定器 + 二元函数对象 =》 一元函数对象 bind1st: + greater bool operator()(70, const _Ty& _Right) bind2nd: + less bool operator()(const _Ty& _Left, 70) */ auto it1 = my_find_if(vec.begin(), vec.end(), mybind1st(greater<int>(), 70)); //auto it1 = my_find_if(vec.begin(), vec.end(),bind2nd(less<int>(), 70)); if (it1 != vec.end()) { vec.insert(it1, 70); } showContainer(vec); return 0; } \"]},\"1149\":{\"c\":[\"c/c++\"]},\"1150\":{\"c\":[\"bind绑定器\"]},\"1151\":{\"h\":\"bind和function实现muduo中的线程池\",\"t\":[\"#include <iostream> #include <typeinfo> #include <string> #include <memory> #include <vector> #include <functional> #include <thread> using namespace std; using namespace placeholders; //线程类 class Thread { public: Thread(function<void(int)> func, int no)//使用function接收bind :_func(func), _no(no) {} thread start() { thread t(_func, _no);// _func(_no) return t; } private: function<void(int)> _func;//存储线程处理函数 int _no; }; //线程池类 class ThreadPool { public: ThreadPool() {} ~ThreadPool() { //因为vector存储的是指针，所以需要手动释放资源 //释放Thread对象占用的堆资源 for (int i = 0; i < _pool.size(); ++i) { delete _pool[i]; } } //开启线程池 void startPool(int size) { //创建线程池 for (int i = 0; i < size; ++i) { _pool.push_back( new Thread(bind(&ThreadPool::runInThread, this, _1), i)); } //将线程句柄存储起来用于等待完成 for (int i = 0; i < size; ++i) { _handler.push_back(_pool[i]->start()); } for (thread& t : _handler) { t.join(); } } private: vector<Thread*> _pool; vector<thread> _handler; //把runInThread这个成员方法充当线程函数 thread pthread_create void runInThread(int id) { cout << \\\"call runInThread! id:\\\" << id << endl; } }; int main() { ThreadPool pool; pool.startPool(10); return 0; } \",\"不管是C++中的thread还是Linux中的pthread_create，需要的线程函数都是C函数，是不能够使用成员方法的，不可能将一个成员方法的函数指针扔给C的函数指针。\",\"编译之后需要一个对象，将当前对象this绑定上去\"]},\"1152\":{\"c\":[\"c/c++\"]},\"1153\":{\"c\":[\"bind绑定器\",\"function函数对象\",\"线程池\"]},\"1154\":{\"h\":\"C++11绑定器介绍\",\"t\":[\"C++ STL的bind只能用于二元的绑定器\",\"C++11 bind绑定器 => 返回的结果还是一个，可以。\",\"C++11的bind和function比较：\",\"function可以直接将函数类型留下来。\",\"bind绑定器可以给函数绑定固定的参数。\",\"#include <iostream> #include <typeinfo> #include <string> #include <memory> #include <vector> #include <functional> #include <thread> using namespace std; /* C++11 bind绑定器 => 返回的结果还是一个函数对象 */ void hello(string str) { cout << str << endl; } int sum(int a, int b) { return a + b; } class Test { public: int sum(int a, int b) { return a + b; } }; int main() { //bind是函数模板 可以自动推演模板类型参数 bind(hello, \\\"hello bind!\\\")();//bind绑定了一个\\\"hello bind!\\\"参数， //返回的结果是绑定器，也就是函数对象, 需要调用它的()重载符号 cout << bind(sum, 10, 20)() << endl; cout << bind(&Test::sum, Test(), 20, 30)() << endl; return 0; } \",\"bind是函数模板 \",\"返回的结果是绑定器，也就是函数对象, \",\"绑定器问题：\",\"只能使用在语句中，出了语句就不能使用了；\",\"如何将绑定器的类型留下来？\",\"综合运用function和bind。 \",\"定义funtion，返回值是void，有一个string形参变量的函数类型，用来记录bind绑定器绑定的结果。\",\"可以通过function函数对象类型，把绑定器的类型留下来，可以重复的去使用。\"]},\"1155\":{\"h\":\"参数占位符\",\"t\":[\"调用的时候，用户自己传入参数！！！\",\"参数占位符placeholders::_1： 参数具体是什么，不知道，等待用户传递；(最多有20个占位参数)\",\"因此在调用时，必须在（）中传入参数；\",\"using namespace placeholders; int main() { //参数占位符 绑定器出了语句，无法继续使用 //只是占位的作用，调用的时候就要传递参数了 //书写的时候使用多少个占位符，就是意味着用户调用的时候要传入几个参数 bind(hello, _1)(\\\"hello bind 2!\\\"); cout << bind(sum, _1, _2)(200, 300) << endl; //此处把bind返回的绑定器binder就复用起来了 function<void(string)> func1 = bind(hello, _1); func1(\\\"hello china!\\\"); func1(\\\"liu feng ni hao\\\"); return 0; } \"]},\"1156\":{\"c\":[\"使用指南\"]},\"1157\":{\"c\":[\"页面配置\",\"使用指南\"]},\"1158\":{\"h\":\"function函数对象类型实现原理\",\"t\":[\"通过两个例子：一个是持有普通函数，一个是持有类成员方法；查看类的成员方法到底是什么。\",\"#include <iostream> #include <typeinfo> #include <string> #include <functional> using namespace std; /* function函数对象类型的实现原理 */ void hello(string str) { cout << str << endl; } int sum(int a, int b) { return a + b; } /// template<typename Fty> class myfunction {}; #if 0 //模板的部分偏特化 template<typename R, typename A1> class myfunction<R(A1)> { public: using PFUNC = R(*)(A1); //需要接受外部传进来的函数类型，使用函数指针接收 myfunction(PFUNC pfunc) :_pfunc(pfunc) {} R operator()(A1 arg) { return _pfunc(arg);//hello(arg) } private: PFUNC _pfunc;//用于保存函数类型 }; //模板的部分偏特化 template<typename R, typename A1, typename A2> class myfunction<R(A1, A2)> { public: using PFUNC = R(*)(A1, A2); myfunction(PFUNC pfunc) :_pfunc(pfunc) {} R operator()(A1 arg1, A2 arg2) { return _pfunc(arg1, arg2);//hello(arg) } private: PFUNC _pfunc; }; #endif //可变参模板 template<typename R, typename... A>//一组可变参数个数 class myfunction<R(A...)> { public: using PFUNC = R(*)(A...); myfunction(PFUNC pfunc) :_pfunc(pfunc) {} R operator()(A... arg) { return _pfunc(arg...);//hello(arg) 表示一组形参变量 } private: PFUNC _pfunc; }; int main() { function<void(string)> func1(hello); func1(\\\"hello world!\\\");//func1.operator()(\\\"hello world!\\\") myfunction<int(int, int)> func2(sum); cout << func2(10, 20) << endl; return 0; } \",\"用函数指针保存函数类型\",\"由于反返回类型只有一个，函数参数的类型有多种可能或者不确定，如果每个都写出来太麻烦，可以使用可变模板参数代替\"]},\"1159\":{\"c\":[\"c/c++\"]},\"1160\":{\"c\":[\"function函数对象\"]},\"1161\":{\"h\":\"function函数对象类型的应用\",\"t\":[\"function：函数对象类；\",\"绑定器、函数对象、lambda表达式实际上都是函数对象。\",\"如果我们最终得到的绑定器、函数对象、lambda表达式，这些函数对象，想在多条语句中应用 ，怎么办？如何将这些函数对象的类型留下来？\",\"源码中希望你用一个函数类型来实例化function模板。\"]},\"1162\":{\"h\":\"区别函数类型和函数指针类型：\",\"t\":[\"函数指针类型：\",\"是一个，指向返回值是void，不带形参的函数。\",\"void(*)() \",\"函数类型：\",\"我们需要用函数类型来实例化function。\",\"只给出返回值和参数列表即可\",\"void() \"]},\"1163\":{\"h\":\"示例\"},\"1164\":{\"h\":\"无参函数类型\",\"t\":[\"用函数对象类型func1将hello1函数类型保留下来了，然后就可以使用func1()调用了\",\"void hello1() { cout << \\\"hello world\\\" << endl; } //从function的类模板定义处，看到希望用一个函数类型实例化function function<void()> func1 = hello1; func1(); //func1.operator()()=>hello1() \",\"#结果 hello world \"]},\"1165\":{\"h\":\"有参函数类型\",\"t\":[\"void hello2(string str) //void (*pfunc)(string) { cout << str << endl; } function<void(string)> func2 = hello2; func2(\\\"hello world2!\\\");//func2.operator()(string str)=>hello2(str) \",\"#结果 hello world2! \",\"int sum(int a, int b) { return a + b; } function<int(int, int)> func3 = sum; cout << func3(20, 30) << endl; //50 \",\"function不仅仅可以留下，也可以留下。（）\"]},\"1166\":{\"h\":\"function是对一个函数/函数对象的包装\",\"t\":[\"也可以说function是对一个函数/函数对象的包装。\",\"[](int a, int b)->int {return a + b;}是函数对象\",\"function<int(int, int)> func4 = [](int a, int b)->int {return a + b;} cout << func4(100, 200) << endl; //300 \",\"上面是对function作用于全局函数，将其函数类型留下来。\",\"当然，function也可以将类的成员方法留下来！\"]},\"1167\":{\"h\":\"function也可以将类的成员方法留下来\",\"t\":[\"class Test { public: //必须依赖一个对象void (Test::*pfunc)(string) void hello(string str) { cout << str << endl; } }; //成员方法的调用必须依赖一个对象 function<void(Test*, string)> func5 = &Test::hello; func5(&Test(), \\\"call Test::hello!\\\"); \",\"Test* 传给了 this指针\"]},\"1168\":{\"h\":\"function使用举例\",\"t\":[\"funtion的作用：\",\"保留的类型，然后再各处都可以使用。\",\"我们使用function，将函数的类型保存下来使用\",\"#include <iostream> #include <vector> #include <map> #include <functional>//使用function函数对象类型 #include <algorithm> #include <ctime> #include <string> using namespace std; void doShowAllBooks() { cout << \\\"查看所有书籍信息\\\" << endl; } void doBorrow() { cout << \\\"借书\\\" << endl; } void doBack() { cout << \\\"还书\\\" << endl; } void doQueryBooks() { cout << \\\"查询书籍\\\" << endl; } void doLoginOut() { cout << \\\"注销\\\" << endl; } int main() { int choice = 0; map<int, function<void()>> actionMap; actionMap.insert({ 1, doShowAllBooks });//老版本：insert(make_pair(xx,xx)); actionMap.insert({ 2, doBorrow }); actionMap.insert({ 3, doBack }); actionMap.insert({ 4, doQueryBooks }); actionMap.insert({ 5, doLoginOut }); for (;;) { cout << \\\"-----------------\\\" << endl; cout << \\\"1.查看所有书籍信息\\\" << endl; cout << \\\"2.借书\\\" << endl; cout << \\\"3.还书\\\" << endl; cout << \\\"4.查询书籍\\\" << endl; cout << \\\"5.注销\\\" << endl; cout << \\\"-----------------\\\" << endl; cout << \\\"请选择:\\\"; cin >> choice; auto it = actionMap.find(choice);//map pair first second if (it == actionMap.end()) { cout << \\\"输入数字无效，重新选择!\\\" << endl; } else { it->second(); } //不好，因为这块代码无法闭合 无法做到“开-闭原则” /*switch (choice) { case 1: break; case 2: break; case 3: break; case 4: break; case 5: break; default: break; }*/ } return 0; } \"]},\"1169\":{\"c\":[\"c/c++\"]},\"1170\":{\"c\":[\"function函数对象\"]},\"1171\":{\"h\":\"lambda表达式\",\"t\":[\"C++11 函数对象的升级版 =》 lambda表达式\",\"函数对象的缺点：（需要定义一个类）\",\"函数对象使用在 泛型算法参数传递 比较性质/自定义操作 优先级队列 智能指针（自定义智能指针的删除器）\",\"lambda表达式原理： 就是函数对象更高级的实现！\"]},\"1172\":{\"h\":\"1、lambda表达式语法\",\"t\":[\"[捕获外部变量](形参列表)->返回值{操作代码} 如果lambda表达式的返回值不需要，那么\\\"->返回值\\\"可以省略 [捕获外部变量] []：表示不捕获任何外部变量 [=]：以传值的方式捕获外部的所有变量 [&]：以传引用的方式捕获外部的所有变量 [this]：捕获外部的this指针 [=,&a]：以传值的方式捕获外部的所有变量，但是a变量以传引用的方式捕获 [a, b]：以值传递的方式捕获外部变量a和b [a, &b]：a以值传递捕获，b以传引用的方式捕获 \"]},\"1173\":{\"h\":\"示例\",\"t\":[\"lambda表达式对应函数对象小括号重载函数的\",\"template<typename T = void>//用不到参数直接写void class TestLambda { public: TestLambda01() {} void operetor()() { cout << \\\"hello world!\\\" << endl; } }; int main() { auto func1 = []()->void {cout << \\\"hello world!\\\" << endl;}; func1(); TestLambda01<> t1; t1(); return 0; } \",\"[]为空，。\",\"()是运算符重载函数，具体接收的参数的个数\",\"然后是返回值，看是无类型还是其他类型。\",\"最后是函数代码\",\"template<typename T = int> class TestLambda03 { public: TestLambda03(int a, int b) : ma(a), mb(b) {} void operator()(int a, int b) const { int tmp = ma; ma = mb; mb =tmp; } private: int ma; int mb; } auto func3 = [a, b]() { int tmp = a; a = b; b = tmp; } \",\"[]不为空，\",\"template<typename T = int> class TestLambda02 { public: TestLambda02() {} int operator()(int a, int b) const { return a + b; } } auto func2 = [](int a, int b)->int { return a + b;}; cout << func2(20, 30) << endl; TestLambda02<> t2; cout << t2(20, 30) << endl; \"]},\"1174\":{\"h\":\"值传递\",\"t\":[\"加上mutable，表示将的形参a，b改掉；。\",\"int a = 10; int b = 20; auto func3 = [a, b]() mutable { int tmp = a; a = b; b = tmp; }; \"]},\"1175\":{\"h\":\"引用传递\",\"t\":[\"修改的是实参，不需要加mutable\",\"int a = 10; int b = 20; auto func3 = [&a, &b]() { int tmp = a; a = b; b =tmp; }; \"]},\"1176\":{\"h\":\"lambda应用\"},\"1177\":{\"h\":\"例1—从大到小排序\",\"t\":[\"for(int i = 0; i < 20; ++i) { vec.push_back(rand() % 100 + 1); } sort(vec.begin(), vec.end(), [](int a, int b)->bool { return a >b;}); for(int val : vec) { cout << val << \\\" \\\"; } cout << endl; \"]},\"1178\":{\"h\":\"例2—按序插入元素65\",\"t\":[\"auto it = find_if(vec.begin(), vec.end(), [](int a)->bool{ return a < 65;}); if(it != vec.end()) { vec.insert(it, 65); } for(int val : vec) { cout << val << \\\" \\\"; } cout << endl; \"]},\"1179\":{\"h\":\"for_each\",\"t\":[\"for_each(vec.begin(), vec.end(), [](int a) { if(a % 2 == 0) { cout << a << \\\" \\\"; } }); cout << endl; \"]},\"1180\":{\"h\":\"lambda表达式的应用实践\",\"t\":[\"既然lambda表达式只能使用在语句当中，如果想跨语句使用之前定义好的lambda表达式，怎么办？用什么类型来表示lambda表达式？\",\"lambda表达式 =》 函数对象 用function类型绑定它\",\"用function类型表示函数对象的类型\",\"bind绑定器绑定的结果依然还是一个函数对象；\"]},\"1181\":{\"h\":\"1、计算器案例\"},\"1182\":{\"h\":\"2、智能指针案例\"},\"1183\":{\"h\":\"3、优先级队列\",\"t\":[\"上面写法灵活性太差。现在优化：\",\"priority_queue本身就有3个模板参数，分别是元素类型、容器类型、函数对象。\",\"可以接收外部自定义的函数对象\",\"#include <iostream> #include <functional> #include <queue> using namespace std; class Data { public: Data(int val1 = 10, int val2 = 10) :ma(val1), mb(val2) {} int ma; int mb; }; int main() { //优先级队列 //priority_queue<Data> queue; using FUNC = function<bool(Data&, Data&)>; priority_queue<Data, vector<Data>, FUNC> maxHeap([](Data& d1, Data& d2)->bool { return d1.mb > d2.mb; }); maxHeap.push(Data(10, 20)); maxHeap.push(Data(15, 15)); maxHeap.push(Data(20, 10)); return 0; } \"]},\"1184\":{\"c\":[\"c/c++\"]},\"1185\":{\"c\":[\"lambda\"]},\"1186\":{\"h\":\"模板的完全特例化和非完全特例化\",\"t\":[\"有完全特例化，就选择对应的，有部分特例化，就匹配，没有的话，就\",\"template<typename T> bool compare(T a, T b) { cout << \\\"template compare\\\" << endl; return a > b; } int main() { compare(10, 20); compare(\\\"aaa\\\", \\\"bbb\\\"); //T const char* return 0; } \",\"能运用在int类型上，字符串比较就不行了。 此时的实例化compare代码就不行了，。\",\"需要多加一个模板的完全特例化：（完全特例化： 类型完全是已知的）\"]},\"1187\":{\"h\":\"模板的完全特化\",\"t\":[\"template后面的<>什么参数都没有，表示参数都是已知的。\",\"template<> bool compare<const char*>(const char* a, const char* b) { cout << \\\"compare<const char*>\\\" << endl; return strcmp(a, b) > 0; } \"]},\"1188\":{\"h\":\"模板的部分特例化\",\"t\":[\"#include <iostream> #include <cstdio> using namespace std; template<typename T> class Vector { public: Vector() { cout << \\\"call Vector template init\\\" << endl; } }; //下面这个是对char*类型提供的完全特例化版本 #1 template<>//特例化的语法 class Vector<char*> { public: Vector() { cout << \\\"call Vector<char*> init\\\" << endl; } }; //下面这个是对指针类a型提供的部分特例化版本 #2 template<typename Ty> class Vector<Ty*> { public: Vector() { cout << \\\"call Vector<Ty*> init\\\" << endl; } }; //指针函数指针（有返回值，有两个形参变量）提供的部分特例化 template<typename R, typename A1, typename A2> class Vector<R(*)(A1, A2)> { public: Vector() { cout << \\\"call Vector<R(*)(A1, A2)> init\\\" << endl; } }; //针对函数（有一个返回值，有两个形参变量）类型提供的部分特例化 template<typename R, typename A1, typename A2> class Vector<R(A1, A2)> { public: Vector() { cout << \\\"call Vector<R(A1, A2)> init\\\" << endl; } }; int sum(int a, int b) { return a + b; } int main() { Vector<int> vec1; Vector<char*> vec2; Vector<int*> vec3; Vector<int(*)(int, int)> vec4; Vector<int(int, int)> vec5;//function //注意区分一下函数类型和函数指针类型 //用函数指针定义的变量本身就是一个指针 typedef int(*PFUNC1)(int, int); //PFUNC1是函数指针类型 PFUNC1 pfunc1 = sum; cout << pfunc1(10, 20) << endl; typedef int PFUNC2(int, int); //PFUNC2是函数类型 //函数类型在定义的时候，需要将指针*加上 PFUNC2* pfunc2 = sum; cout << (*pfunc2)(10, 20) << endl; return 0; } \"]},\"1189\":{\"h\":\"模板的实参推演\",\"t\":[\"//T包含了所有的大的类型 返回值，所有形参的类型都取出来 tempalte<typename T> void func(T a) { cout << typeid(T).name() << endl; } int sum(int a, int b) { return a + b;} int main() { func(10); //int func(\\\"aaa\\\"); //const char * func(sum); //T int (*)(int, int) int (int, int) } \",\"我们，我们直接用一个函数指针的模板部分特例化来做：\",\"template<typename R, typename A1, typename A2> void fun2(R(*a)(A1, A2)) { cout << typeid(R).name() << endl; //int cout << typeid(A1).name() << endl; //int cout << typeid(A2).name() << endl; //int } fun2(sum); \",\"定义一个Test类，里面有一个成员函数sum\",\"class Test { public: int sum(int a, int b) { return a + b; } }; template <typename T> void func(T a) { cout << typeid(T).name << endl; } int main() { func(&Test::sum); //int (__thiscall Test::*)(int, int) } \",\"得到一个指向成员方法的函数指针类型。将其参数细分：\",\"template<typename R, typename T, typename A1, typename A2> void func3(R(T::* a)(A1, A2)) { cout <<typeid(R).name() <<endl; //int cout <<typeid(T).name() <<endl; //class Test cout <<typeid(A1).name() <<endl; //int cout <<typeid(A2).name() <<endl; //int } \"]},\"1190\":{\"h\":\"总结\",\"t\":[\"这几个例子指导我们在写函数模板，类模板时，针对一个具体情况，把他们一个大类型的细分类型，定义相应的参数，接收大类型的所有细分类型，使用的就是模板部分偏特化。\"]},\"1191\":{\"c\":[\"c/c++\"]},\"1192\":{\"c\":[\"类模板\"]},\"1193\":{\"h\":\"C++11内容总结\"},\"1194\":{\"h\":\"1、关键字和语法\",\"t\":[\"nullptr： 之前的NULL，是一个宏定义，代码上是的\",\"右值引用： 非常强大；\",\"auto：可以根据右值，推导出右值的类型，然后左边变量的类型也就已知了 nullptr：给指针专用（能够和整数进行区别） 以前用的NULL是宏定义，在代码上无法区分整数和指针地址 #define NULL 0 （都是4字节，但是毕竟逻辑意义不一样，要区分的！） for each：可以遍历数组（底层是指针遍历），容器（底层是迭代器遍历） for(Type val : container) => 底层就是通过指针或者迭代器来实现的 { cout<<val<<\\\" \\\"; } 右值引用：move移动语义函数和forward类型完美转发函数 模板的一个新特性：typename... A 表示可变参（类型参数） 表示参数可能会很多 \"]},\"1195\":{\"h\":\"2、绑定器和函数对象\",\"t\":[\"function：函数对象 bind：绑定器 是C的bind1st和bind2nd+二元函数对象 =》 一元函数对象的升级 lambda表达式 \"]},\"1196\":{\"h\":\"3、智能指针\",\"t\":[\"shared_ptr和weak_ptr \"]},\"1197\":{\"h\":\"4、容器\",\"t\":[\"array底层：\",\"Ty：类型参数，底层元素的类型\",\"_Size：数组的大小，固定的\"]},\"1198\":{\"h\":\"5、C++语言级别支持的多线程编程\",\"t\":[\"createThread（Windows） pthread_create（linux） clone（linux） \"]},\"1199\":{\"c\":[\"c/c++\"]},\"1200\":{\"c\":[\"c++11\"]},\"1201\":{\"h\":\"C++11多线程编程\",\"t\":[\"C++语言级别的多线程编程=》代码可以跨平台 windows/linux/mac\"]},\"1202\":{\"h\":\"1、C++多线程介绍\",\"t\":[\"thread(线程类) mutex(互斥锁) condition_variable(线程间的通信，条件变量) 智能锁：(自动的加锁解锁) lock_guard unique_lock atomic 原子类型 基于CAS操作的原子类型 线程安全的 sleep_for(睡眠) \",\"C++语言层面 thread（底层用的还是下面平台的方法） windows linux strace ./a.out（程序启动的跟踪打印的命令） | | createThread pthread_create \",\"可以通过编译器的编译，加个宏，识别当前的操作系统来适配通过语言层面编写thread底层自动调用相应的函数。\",\"，让用户更加方便使用。\"]},\"1203\":{\"h\":\"2、多线程编程\",\"t\":[\"线程内容：\"]},\"1204\":{\"h\":\"1、怎么创建启动一个线程？\",\"t\":[\"std::thread定义一个线程对象，传入线程所需要的线程函数和参数， 线程自动开启\"]},\"1205\":{\"h\":\"2、子线程如何结束\",\"t\":[\"子线程函数运行完成，线程就结束了\"]},\"1206\":{\"h\":\"3、主线程如何处理子线程\",\"t\":[\"t.join() : 等待t线程结束，当前线程继续往下运行 t.detach() : 把t线程设置为分离线程，主线程结束，整个进程结束，所有子线程都自动结束了！\",\"测试结果：\",\"join()： 主线程会等待子线程运行结束，才继续执行\",\"hello thread1会永远运行在main thread之前的，因为主线程join了，在等待子线程。\"]},\"1207\":{\"h\":\"子线程睡眠：\",\"t\":[\"this_thread()： 是一个namespace，里面有一些方法；\",\"get_id()：获取线程id;\",\"yield()：放弃当前线程这一轮的时间片\",\"sleep_for()：睡眠多长时间\",\"sleep_until()：睡到哪一个时间点\",\"std::chrono()：定义了一些和时间相关的常量。\",\"问题：主线程运行完成，查看如果当前进程还有未运行完成的子线程，进程就会异常终止\",\"解决办法：\",\"主线程等待子线程结束，主线程继续往下运行t1.join();\",\"把子线程设置为分离线程t1.detach();\",\"#include <iostream> #include <thread> using namespace std; void threadHandle1(int time) { //让子线程睡眠time秒 std::this_thread::sleep_for(std::chrono::seconds(time)); cout << \\\"hello thread1!\\\" << endl; } void threadHandle2(int time) { //让子线程睡眠time秒ace this_thread是namespace std::this_thread::sleep_for(std::chrono::seconds(time)); cout << \\\"hello thread2!\\\" << endl; } int main() { //创建了一个线程对象,传入一个线程函数(作为线程入口函数), //新线程就开始运行了，没有先后顺序，随着CPU的调度算法执行 std::thread t1(threadHandle1, 2); std::thread t2(threadHandle2, 3); //主线程(main)运行到这里，等待子线程结束，主线程才继续往下运行 t1.join(); t2.join(); //把子线程设置为分离线程，子线程和主线程就毫无关系了 //主线程结束的时候查看其他线程 //但是这个子线程运行完还是没运行完都和这个主线程没关系了 //这个子线程就从这个main分离出去了 //运行程序时也看不到这个子线程的任何输出打印了 //t1.detach(); cout << \\\"main thread done!\\\" << endl; //主线程运行完成，查看如果当前进程还有未运行完成的子线程 //进程就会异常终止 return 0; } \"]},\"1208\":{\"h\":\"3、线程间互斥—mutex互斥锁和lock_gard\",\"t\":[\"所有线程都在输出，不能串行执行，因为线程都是并行执行的。\",\"//c++ thread模拟车站三个窗口买票的程序 int ticketCount = 100; //车站有100张车票，由三个窗口一起卖票 void sellTicket(int index) { while(tickeCount > 0) { //cout << \\\"窗口：\\\" << index << \\\"卖出第：\\\" //<< ticketCount << \\\"张票\\\" << endl; cout << ticketCount << endl; ticketCount--; std::this_thread::sleep_for(std::chrono::milliseconds(100)); } } int main() { list<std::thread> tlist; for(int i = 1; i <= 3; ++i) { tlist.push_back(std::thread(sellTicket, i)); } for(std::thread& t : tlist) { t.join(); } cout << \\\"所以窗口买票结束！\\\" << endl; return 0; } \",\"可以看到有很多问题。（每次运行结果都存在差异，程序存在竞态条件）\",\"多线程程序 涉及 问题；\",\"竞态条件： 多线程执行的结果不一致的情况，会随着CPU对线程不同的调用顺序，而产生不同的运行结果。\",\"不是线程安全的操作！\",\"每个线程在1个指令周期之内是要保证完成的，但是在多个指令完全由CPU的调度决定的，线程在运行完每个指令的时候，都有可能CPU的时间片到了，线程阻塞住。等待下一轮我们再轮到这个线程执行，才能把剩余的时间片给到这个线程，线程继续执行下面的指令 。 两个线程可能减完的值是相同的，然后把相同的值写回去了\",\"所以，我们要保证这个操作线程安全！！！每次只有1个线程去做减减操作\"]},\"1209\":{\"h\":\"使用 mutex ，包含头文件： #include <mutex>\",\"t\":[\"#include <iostream> #include <thread> #include <mutex> #include <list> using namespace std; int ticketCount = 100; std::mutex mtx; //全局的一把互斥锁 //模拟买票的线程函数 void sellTicket(int index) { mtx.lock(); while(ticketCount > 0) //特殊情况：ticketCount = 1 所以要进行 锁+双重判断 { //cout << \\\"窗口：\\\" << index << \\\"卖出第：\\\" //<< ticketCount << \\\"张票\\\" << endl; cout << ticketCount << endl; ticketCount--; std::this_thread::sleep_for(std::chrono::milliseconds(100)); } mtx.unlock(); } \",\"上面程序还是有问题的：会导致；\",\"修改：；\",\"//模拟买票的线程函数 void sellTicket(int index) { while(ticketCount > 0) //特殊情况：ticketCount = 1 所以要进行 锁+双重判断 { mtx.lock(); //cout << \\\"窗口：\\\" << index << \\\"卖出第：\\\" //<< ticketCount << \\\"张票\\\" << endl; cout << ticketCount << endl; ticketCount--; std::this_thread::sleep_for(std::chrono::milliseconds(100)); mtx.unlock(); } } \",\"代码还是有问题的，！！！ 原因： 当ticketCount = 1时，此时线程1进入临界区执行卖票，此时ticketCount还未变为0，解决方法： 。\",\"注意：这里我把休眠时间挪到解锁之后，为了cpu充分调度！\",\"//模拟买票的线程函数 void sellTicket(int index) { while(ticketCount > 0) { mtx.lock(); if(ticketCount > 0) { //cout << \\\"窗口：\\\" << index << \\\"卖出第：\\\" //<< ticketCount << \\\"张票\\\" << endl; cout << ticketCount << endl; ticketCount--; } mtx.unlock(); std::this_thread::sleep_for(std::chrono::milliseconds(100)); } } \",\"问题：如果一个线程中间出现问题，或者其他情况，，怎么办？\",\"还是要采用 的思想；\",\"；\",\"两者都可以。\"]},\"1210\":{\"h\":\"lock_guard\",\"t\":[\"将锁封装了，成员变量是一把互斥锁；\",\"控制锁的构造和析构，。\",\"，类似scoped_ptr（拷贝构造和赋值函数删除掉）\",\"lock_guard构造函数直接加锁；\",\"lock_guard析构函数直接解锁；\",\"//模拟买票的线程函数 void sellTicket(int index) { while(ticketCount > 0) { lock_guard<std::mutex> lock(mtx);//智能指针的思想，是栈上的局部对象，出作用域就自动析构，释放锁 if(ticketCount > 0) { //cout << \\\"窗口：\\\" << index << \\\"卖出第：\\\" //<< ticketCount << \\\"张票\\\" << endl; cout << ticketCount << endl; ticketCount--; } mtx.unlock(); std::this_thread::sleep_for(std::chrono::milliseconds(100)); } } \",\"。\"]},\"1211\":{\"h\":\"unique_lock\",\"t\":[\"和unique_ptr类似。\",\"把带左值引用参数的拷贝构造函数和赋值重载函数删除了。\",\"支持带右值引用参数的拷贝构造函数和赋值重载函数（支持 临时对象拷贝构造一个新对象，临时对象给另一个对象赋值）。\"]},\"1212\":{\"h\":\"unique_lock源码\",\"t\":[\"右值引用的拷贝构造：\",\"右值引用的赋值重载：\",\"左值引用参数的拷贝构造函数和赋值重载函数删除\",\"成员变量：\",\"指向一把锁的指针\",\"lock()和unlock()方法：\"]},\"1213\":{\"c\":[\"c/c++\"]},\"1214\":{\"c\":[\"多线程\"]},\"1215\":{\"h\":\"C++11线程间的同步通信(生产者-消费者模型)\"},\"1216\":{\"h\":\"1、多线程编程两个问题\"},\"1217\":{\"h\":\"1.1、线程间的互斥\",\"t\":[\"竞态条件： 多线程执行的结果出现不一致的情况，由于CPU对线程不同的调用顺序，而产生不同的运行结果。\",\"发生竞态条件的代码段，称为临界区代码段（只有一个线程可以进来），保证临界区代码段原子操作，\",\"C++11的mutex底层实现：\",\"使用strace ./a.out跟踪代码，使用C++11提供的mutex，Linux底层使用的也是自己的pthread_mutex互斥锁。\"]},\"1218\":{\"h\":\"1.2、线程间的同步通信\",\"t\":[\"线程间不通信的话，每个线程受CPU的调度，没有任何执行上的顺序可言，线程1和线程2是根据CPU调度算法来的，两个线程都有可能先运行，是不确定的，线程间的运行顺序是不确定的；\",\"所以多线程程序出问题，难以复现，因为谁也不知道当时线程执行的先后顺序，我们一般可以得到每个线程的线程栈信息来分析是否发生的问题之类的。\",\"我们要保证线程间的运行顺序\",\"通信就是：\",\"线程1和线程2一起运行，线程2要做的事情必须先依赖于线程1完成部分的事情，然后告诉线程2这部分东西做好了，线程2就可以继续向下执行了。\",\"或者是线程1接下来要做某些操作，这些操作需要线程2把另外一部分事情做完，然后通知一下线程1它做完了，然后线程1才能做这些操作。\"]},\"1219\":{\"h\":\"2、生产者-消费者线程模型\",\"t\":[\"如果直接使用queue，使用queue的push和pop操作时，会涉及线程安全问题。我们直接在queue的基础上，直接将其封装成线程安全的queue。 注意：线程函数代码和后面的main函数代码都是不会变的；\",\"//这里模拟生产者生产10个物品，消费者消费10个物品 void producer(Queue* que)//生产者线程 { for (int i = 1; i <= 10; ++i) { que->put(i); std::this_thread::sleep_for(std::chrono::milliseconds(100));//睡眠100毫秒 } } void consumer(Queue* que)//消费者线程 { for (int i = 1; i <= 10; ++i) { que->get(); std::this_thread::sleep_for(std::chrono::milliseconds(100));//睡眠100毫秒 } } int main() { Queue que; //两个线程共享的队列 std::thread t1(producer, &que);//开启生产者线程 std::thread t2(consumer, &que);//开启消费者线程 //主线程等待两个子线程都执行完再结束。 t1.join(); t2.join(); return 0; } \",\"使用lock_guard，不用直接使用互斥锁的lock和unlock方法，通过栈上的对象构造和出作用域析构，来自动调用互斥锁的lock和unlock方法；\",\"std::mutex mtx; //自定义互斥锁，做线程间的互斥操作 //生产者生产一个物品，通知消费者消费一个；消费完了，消费者再通知生产者继续生产物品 class Queue { public: void put(int val) { //生产物品 lock_guard<std::mutex> guard(mtx);//相当于scoped_ptr que.push(val); cout << \\\"生产者 生产：\\\" << val << \\\"号物品\\\" << endl; } int get() { //消费物品 lock_guard<std::mutex> guard(mtx); //相当于scoped_ptr int val = que.front(); que.pop(); cout << \\\"消费者 消费\\\" << val << \\\"号物品\\\" << endl; return val; } private: queue<int> que; }; \",\"封装的queue代码，为什么每次出错都是不一样的？\",\"；（需要有线程间的通信机制）\",\"我们需要：生产者生产一个物品，通知消费者消费一个；消费完了，消费者再通知生产者继续生产物品\",\"条件变量： 可以精确做线程间的同步通信；\",\"信号量也可以做，但是做不到生产一个消费一个，这么精确。\",\"注意：，因为lock_gard将拷贝构造和赋值重载都delete了（实参到形参是一个的过程，传不进来）\",\"#include <iostream> #include <thread>//多线程的头文件 #include <mutex>//互斥锁的头文件 #include <condition_variable>//条件变量的头文件 #include <queue>//C++ STL所有的容器都不是线程安全 using namespace std; std::mutex mtx;//定义互斥锁，做线程间的互斥操作 std::condition_variable cv;//定义条件变量，做线程间的同步通信操作 //生产者生产一个物品，通知消费者消费一个；消费完了，消费者再通知生产者继续生产物品 class Queue { public: void put(int val)//生产物品 { unique_lock<std::mutex> lck(mtx);//unique_ptr while (!que.empty()) { //que不为空，生产者应该通知消费者去消费，消费者消费完了，生产者再继续生产 //生产者线程进入#1等待状态，并且#2把mtx互斥锁释放掉 cv.wait(lck);//传入一个互斥锁，当前线程挂起，处于等待状态，并且释放当前锁 lck.lock() lck.unlock } que.push(val); /* notify_one:通知唤醒另外的一个线程的 notify_all:通知唤醒其它所有线程的 通知其它所有的线程，我生产了一个物品，你们赶紧消费吧 其它线程得到该通知，就会从等待状态 =》 到阻塞状态 =》 但是要获取互斥锁才能继续向下执行 */ cv.notify_all(); cout << \\\"生产者 生产:\\\" << val << \\\"号物品\\\" << endl; } int get()//消费物品 { //lock_guard<std::mutex> guard(mtx);//相当于scoped_ptr unique_lock<std::mutex> lck(mtx);//相当于unique_ptr 更安全 while (que.empty()) { //消费者线程发现que是空的，通知生产者线程先生产物品 //#1 挂起，进入等待状态 #2 把互斥锁mutex释放 cv.wait(lck); }//如果其他线程执行notify了,当前线程就会从等待状态 =》到阻塞状态 =》但是要获取互斥锁才能继续向下执行 int val = que.front(); que.pop(); cv.notify_all();//通知其它线程我消费完了，赶紧生产吧 cout << \\\"消费者 消费:\\\" << val << \\\"号物品\\\" << endl; return val; } private: queue<int> que; }; //这里模拟生产者生产10个物品，消费者消费10个物品 void producer(Queue* que)//生产者线程 { for (int i = 1; i <= 10; ++i) { que->put(i); std::this_thread::sleep_for(std::chrono::milliseconds(100));//睡眠100毫秒 } } void consumer(Queue* que)//消费者线程 { for (int i = 1; i <= 10; ++i) { que->get(); std::this_thread::sleep_for(std::chrono::milliseconds(100));//睡眠100毫秒 } } int main() { Queue que; //两个线程共享的队列 std::thread t1(producer, &que);//开启生产者线程 std::thread t2(consumer, &que);//开启消费者线程 //主线程等待两个子线程都执行完再结束。 t1.join(); t2.join(); return 0; } \"]},\"1220\":{\"h\":\"3、lock_gard和unique_lock\",\"t\":[\"lock_gard和unique_lock可以看成unique_ptr和scope_ptr之间的关系，lock_gard和unique_lock做的事情是一样的，。\",\"lock_gard源码：\",\"unique_lock源码：\",\"image-20240427160328925\"]},\"1221\":{\"h\":\"4、流程分析\",\"t\":[\"首先消费者线程拿到互斥锁，生产者线程没有拿到互斥锁，生产者线程处于阻塞状态；\",\"消费者线程发现que队列是空的，进入while循环，进入的等待状态，将互斥锁释放（都是由条件变量控制的）；\",\"此时生产者线程拿到互斥锁，不进入while循环，生产对象放入que队列中，notify_all通知其他线程，也就是消费者线程，由等待状态进入阻塞状态， 当生产者线程函数完之后，出了函数作用域，将mutex互斥锁释放了，消费者线程拿到锁了，阻塞状态变为运行状态，继续向下执行；\",\"消费者线程消费完之后，继续通知生产者，我消费完了。\"]},\"1222\":{\"c\":[\"c/c++\"]},\"1223\":{\"c\":[\"c++11线程\"]},\"1224\":{\"h\":\"再谈mtx和lock_guard和unique_lock\"},\"1225\":{\"h\":\"1、mutex\",\"t\":[\"std::mutex mtx; int main() { mtx.lock(); mtx.unlock(); return 0; } \",\"，因为代码之间可能由于逻辑走掉了，代码发生异常了，造成锁没有释放掉，成\"]},\"1226\":{\"h\":\"2、lock_guard\",\"t\":[\"利用的是智能指针的概念。\",\"在它的构造函数里面可以主动的获取这把锁lock。\",\"当这个对象出作用域，自动调用析构函数，析构函数中有释放锁的操作unlock。\",\"它把。\",\"或者中，因为要用到拷贝构造函数和赋值函数，。\",\"std::mutex mtx; int main() { //只能用在简单的加锁解锁的临界区代码中； guard_lock<std::mutex> guard(mtx); //mtx.lock(); //mtx.unlock(); return 0; } \"]},\"1227\":{\"h\":\"3、unique_lock\",\"t\":[\"利用的是智能指针的概念。\",\"在它的构造函数里面可以主动的获取这把锁lock。\",\"当这个对象出作用域，自动调用析构函数，析构函数中有释放锁的操作unlock。\",\"它把左值引用的拷贝构造函数和赋值函数都删除掉了。\",\"它还提供了一对lock和unlock方法。\",\"std::mutex mtx;//底层是pthread_mutex_t std::condition_variable cv;//底层是pthread_condition_t unique_lock<std::mutex> lck(mtx); cv.wait(lck); //=> #1.使当前线程进入等待状态 #2.lck.unlock可以把mtx给释放掉 \",\"注意： 条件变量cv.wait里面传的是unique_lock，也只能传unique_lock，因为lock_gard将拷贝构造和赋值重载都delete了（实参到形参是一个拷贝构造的过程，传不进来）\"]},\"1228\":{\"h\":\"4、lock_gard和unique_lock对比\",\"t\":[\"lock_gard和unique_lock可以看成unique_ptr和scope_ptr之间的关系； \",\"因为要用到拷贝构造函数和赋值函数，或者中，。\",\"lock_gard和unique_lock做的事情是一样的，都是在构造函数中国自动执行mutex的lock()函数，在析构函数中自动执行mutex的unlock()函数。\"]},\"1229\":{\"h\":\"5、notify_all\",\"t\":[\" /* 通知在cv上等待的线程，条件成立了，起来干活了！ 其它在cv上等待的线程，收到通知， 从等待状态 =》到阻塞状态(不能直接运行) =》只有当前线程释放锁了，其他线程才能获取互斥锁了 =》线程继续往下执行 */ cv.notify_all(); \"]},\"1230\":{\"c\":[\"c/c++\"]},\"1231\":{\"c\":[\"c++11\"]},\"1232\":{\"h\":\"页面配置\",\"t\":[\"问题： 前面在进行卖票操作时，多线程操作不安全，票的数量Count不正确；\",\"解决方法： 前面是通过lock_gard互斥锁解决的；\",\"int count=100; lock_guard<std::mutex> guard(mtx); count++; lock_guard<std::mutex> guard(mtx); count--; \",\"这里使用互斥锁存在的问题：\",\"解决方法：\",\"使用CAS保证上面++ --操作的原子特性就足够了，CAS也叫做无锁操作；\",\"（并不是说不加锁，只是这个加锁不在我们的软件层面，CPU和内存通信是通过系统总线进行的，，当一个线程在做CPU和内存之间数据的交换，也就是说内存有一个数据读到CPU，CPU进行计算再把数据写回内存块的这样一个过程，线程没有做完的话，它是不允许其他线程再去使用总线的，即硬件上实现的加锁操作，对于软件层面可以说是无锁操作）\",\"无锁队列 => 就是由CAS来实现的\",\"优点： 有助于提高。\"]},\"1233\":{\"h\":\"C++11的atomic原子类型\",\"t\":[\"#include <atomic>//包含了很多原子类型 \",\"yield()：线程，等待下一次调度；然后线程处于，等待下一次CPU的调度，重新获取时间片\",\"#include <iostream> #include <thread> #include <atomic> //包含了很多原子类型 #include <list> using namespace std; volatile std::atomic_bool isReady = false; volatile std::atomic_int mycount = 0; void task() { while (!isReady)//还没有准备好 { std::this_thread::yield();//线程出让当前的CPU时间片，等待下一次调度 //线程相当于还是就绪状态，等待CPU的下一次调度 } for (int i = 0; i < 100; ++i) { mycount++; } } int main() { list<std::thread> tlist; for (int i = 0; i < 10; ++i) { tlist.push_back(std::thread(task));//启动10个线程 } std::this_thread::sleep_for(std::chrono::seconds(3));//主线程睡眠3秒 isReady = true;//所有子线程都进行mycount++ for (std::thread& t : tlist) { t.join(); } cout << \\\"mycount:\\\" << mycount << endl; return 0; } \",\"因为mycount类型就是一个CAS原子操作，如果是普通int，结果就不一定是1000了；\",\"上面数据段的变量不加volatile出现的问题：\",\"一个进程中，不同的线程栈不同，但是堆和数据段都是共享的；\",\"共享的变量，多线程会进行缓存，问题就是main线程中的isReady改成true后，其他线程不能立马看到isReady改成true了，；\",\"解决方法： 在数据段的变量前面加上，一个线程对共享变量的改变，马上均能反应到另一个线程上。\",\"线程缓存可以加快线程运行的效率，因为线程就像人一样，好不容易从内存上跑到CPU上，它还要不断从内存上取东西做运算，它好不容易占1次CPU的时间片，还要在CPU和内存中不断来回跑，很浪费时间，所以操作系统对线程的执行来说，都是会让线程来CPU执行的时候把它们共享的变量在线程的栈上拷贝一份，统一的都带到CPU的缓存里，加个volatile ，就是让所有的线程对共享变量不再进行缓存，保证我们代码的正确性，一个线程对共享变量的改变马上就可以反映到另外一个线程里面了，这就是原子类型。\"]},\"1234\":{\"c\":[\"c/c++\"]},\"1235\":{\"c\":[\"c++11\"]},\"1236\":{\"h\":\"页面配置\",\"t\":[\"在Linux使用过程中，需要了解当前系统开放了哪些端口，并且要查看开放这些端口的具体进程和用户，可以通过netstat命令进行简单查询\"]},\"1237\":{\"h\":\"netstat命令各个参数\",\"t\":[\"-a或--all：显示所有连线中的Socket； -A<网络类型>或--<网络类型>：列出该网络类型连线中的相关地址； -c或--continuous：持续列出网络状态； -C或--cache：显示路由器配置的快取信息； -e或--extend：显示网络其他相关信息； -F或--fib：显示FIB； -g或--groups：显示多重广播功能群组组员名单； -h或--help：在线帮助； -i或--interfaces：显示网络界面信息表单； -l或--listening：显示监控中的服务器的Socket； -M或--masquerade：显示伪装的网络连线； -n或--numeric：直接使用ip地址，而不通过域名服务器； -N或--netlink或--symbolic：显示网络硬件外围设备的符号连接名称； -o或--timers：显示计时器； -p或--programs：显示正在使用Socket的程序识别码和程序名称； -r或--route：显示Routing Table； -s或--statistice：显示网络工作信息统计表； -t或--tcp：显示TCP传输协议的连线状况； -u或--udp：显示UDP传输协议的连线状况； -v或--verbose：显示指令执行过程； -V或--version：显示版本信息； -w或--raw：显示RAW传输协议的连线状况； -x或--unix：此参数的效果和指定\\\"-A unix\\\"参数相同； --ip或--inet：此参数的效果和指定\\\"-A inet\\\"参数相同。 \"]},\"1238\":{\"h\":\"示例\",\"t\":[\"# 列出所有监听 tcp 端口 netstat -lt # 显示TCP端口的统计信息 netstat -st # 查看某个服务监听端口(使用最多的),查看所有80端口使用情况 netstat -tunlp |grep 100 netstat -an | grep 3306 //查看所有3306端口使用情况 netstat -nlp |grep LISTEN //查看当前所有监听端口· netstat -rn【查看本机路由表】 netstat -an【查看本机所有的网络】 找出程序运行的端口：netstat -ap | grep ssh \",\"# 1.查找请求数前20个IP（常用于查找攻来源）： netstat -anlp|grep 80|grep tcp|awk '{print $5}'|awk -F: '{print $1}'|sort|uniq -c|sort -nr|head -n20 netstat -ant |awk '/:80/{split($5,ip,”:”);++A[ip[1]]}END{for(i in A) print A[i],i}' |sort -rn|head -n20 # 2.用tcpdump嗅探80端口的访问看看谁最高 tcpdump -i eth0 -tnn dst port 80 -c 1000 | awk -F”.” '{print $1″.”$2″.”$3″.”$4}' | sort | uniq -c | sort -nr |head -20 # 3.查找较多time_wait连接 netstat -n|grep TIME_WAIT|awk '{print $5}'|sort|uniq -c|sort -rn|head -n20 # 4.找查较多的SYN连接 netstat -an | grep SYN | awk '{print $5}' | awk -F: '{print $1}' | sort | uniq -c | sort -nr | more # 5.根据端口列进程 netstat -ntlp | grep 80 | awk '{print $7}' | cut -d/ -f1 \"]},\"1239\":{\"h\":\"结果解释\",\"t\":[\"è¿éåå¾çæè¿°\",\"1、0.0.0.0代表本机上可用的任意地址。 比如0.0.0.0:135 表示本机上所有地址的135端口，这样多ip计算机就不用重复显示了。 2、TCP 0.0.0.0:80表示在所有的可用接口上监听TCP80端口 3、0.0.0.0为默认路由，即要到达不再路由表里面的网段的包都走0.0.0.0这条规则\",\"然后127.0.0.1就是表示你本机ip地址的意思了。\",\"然后[::]:21这又是什么鬼？\",\"这个表示ipv6的21号端口的意思。\",\"还有UDP的外部链接怎么都是*:*呢？\",\"*：*是网址的通配符，就是192.168.15.12，这个类型的整体描述。\"]},\"1240\":{\"h\":\"解释一下状态（state）\",\"t\":[\"LISTEN：(Listening for a connection.)侦听来自远方的TCP端口的连接请求 SYN-SENT：(Active; sent SYN. Waiting for a matching connection request after having sent a connection request.)再发送连接请求后等待匹配的连接请求 SYN-RECEIVED：(Sent and received SYN. Waiting for a confirming connection request acknowledgment after having both received and sent connection requests.)再收到和发送一个连接请求后等待对方对连接请求的确认 ESTABLISHED：(Connection established.)代表一个打开的连接 FIN-WAIT-1：(Closed; sent FIN.)等待远程TCP连接中断请求，或先前的连接中断请求的确认 FIN-WAIT-2：(Closed; FIN is acknowledged; awaiting FIN.)从远程TCP等待连接中断请求 CLOSE-WAIT：(Received FIN; waiting to receive CLOSE.)等待从本地用户发来的连接中断请求 CLOSING：(Closed; exchanged FIN; waiting for FIN.)等待远程TCP对连接中断的确认 LAST-ACK：(Received FIN and CLOSE; waiting for FIN ACK.)等待原来的发向远程TCP的连接中断请求的确认 TIME-WAIT：(In 2 MSL (twice the maximum segment length) quiet wait after close. )等待足够的时间以确保远程TCP接收到连接中断请求的确认 CLOSED：(Connection is closed.)没有任何连接状态 \"]},\"1241\":{\"c\":[\"使用指南\"]},\"1242\":{\"c\":[\"linux工具和基本命令\"]},\"1243\":{\"h\":\"tree常用命令\"},\"1244\":{\"h\":\"windows 上tree查看文件名\",\"t\":[\"tree /f \"]},\"1245\":{\"h\":\"Linux tree常用命令\",\"t\":[\"tree 命令格式和参数：\",\"-a 显示所有文件和目录。（默认）\",\"-d 显示目录名称而非内容。\",\"-L 打印的层级\"]},\"1246\":{\"c\":[\"linux\"]},\"1247\":{\"c\":[\"linux工具和基本命令\"]},\"1248\":{\"h\":\"wget使用方法\",\"t\":[\"基本的语法是：wget [参数列表] URL\"]},\"1249\":{\"h\":\"使用 wget 下载单个文件\",\"t\":[\"以下的例子是从网络下载一个文件并保存在当前目录\",\"wget http://cn.wordpress.org/wordpress-3.1-zh_CN.zip \",\"在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。\"]},\"1250\":{\"h\":\"使用 wget -i 下载多个文件\",\"t\":[\"首先，保存一份下载链接文件\",\" cat > filelist.txt url1 url2 url3 url4 \",\"接着使用这个文件和参数-i下载\",\" wget -i filelist.txt \"]},\"1251\":{\"h\":\"使用 wget -O 下载并重命名\",\"t\":[\"wget默认会以最后一个符合”/”的后面的字符来命令，对于动态链接的下载通常文件名会不正确。\",\"错误：下面的例子会下载一个文件并以名称download.php?id=1080保存\",\" wget http://www.centos.bz/download?id=1 \",\"即使下载的文件是zip格式，它仍然以download.php?id=1080命令。\",\"正确：为了解决这个问题，我们可以使用参数-O来指定一个文件名：\",\" wget -O wordpress.zip http://www.centos.bz/download.php?id=1080 \"]},\"1252\":{\"h\":\"使用 wget -c 断点续传\",\"t\":[\"使用wget -c重新启动下载中断的文件:\",\" wget -c http://cn.wordpress.org/wordpress-3.1-zh_CN.zip \",\"当文件特别大或者网络特别慢的时候，往往一个文件还没有下载完，连接就已经被切断，此时就需要断点续传。wget的断点续传是自动的，只需要使用-c参数，例如： wget -c http://the.url.of/incomplete/file 使用断点续传要求服务器支持断点续传。-t参数表示重试次数，例如需要重试100次，那么就写-t 100，如果设成-t 0，那么表示无穷次重试，直到连接成功。-T参数表示超时等待时间，例如-T 120，表示等待120秒连接不上就算超时。\"]},\"1253\":{\"h\":\"使用 wget -b 后台下载\",\"t\":[\"对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载\",\"wget -b http://cn.wordpress.org/wordpress-3.1-zh_CN.zip Continuing in background, pid 1840. Output will be written to `wget-log`. 你可以使用以下命令来察看下载进度 tail -f wget-log \"]},\"1254\":{\"h\":\"使用wget FTP下载\",\"t\":[\"你可以使用wget来完成ftp链接的下载。 使用wget匿名ftp下载\",\" wget ftp-url \",\"使用wget用户名和密码认证的ftp下载\",\" wget –ftp-user=USERNAME –ftp-password=PASSWORD url \"]},\"1255\":{\"h\":\"伪装代理名称下载\",\"t\":[\"有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过–user-agent参数伪装。\",\"wget –user-agent=\\\"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16\\\" 下载链接 \"]},\"1256\":{\"h\":\"使用wget –tries增加重试次数\",\"t\":[\"如果网络有问题或下载一个大文件也有可能失败。wget默认重试20次连接下载文件。 如果需要，你可以使用–tries增加重试次数。\",\" wget –tries=40 URL \"]},\"1257\":{\"c\":[\"linux\"]},\"1258\":{\"c\":[\"linux工具和基本命令\"]},\"1259\":{\"h\":\"打包和压缩\"},\"1260\":{\"h\":\"tar的使用方法\",\"t\":[\"image-20240311104103732\",\"tar cfv packet.tar file* #将file*打包成packet.tar tar xfv packet.tar #从包文件中释放文件 tar cfvz packet.tar.gz test #将test打包并压缩 #tar rfvz packet.tar.gz file1 #error,压缩后不能追加 tar xfvz packet.tar.gz #解压缩 \",\"z使用gzip文件\"]},\"1261\":{\"h\":\"gzip和bzip的介绍\",\"t\":[\"属于一种典型的压缩方法——哈夫曼编码树的方法\",\"gzip用来将文件压缩成后缀为.gz的压缩文件，或者将后缀为.gz的文件进行解压。\",\"Bzip2用来将文件压缩成后缀名为.bz2的压缩文件，或者将后缀为.bz2的压缩文件解压\",\"$ gzip/bzip2 [选项] [压缩或解压缩的文件名] \",\"常用参数：\",\"-d: 将压缩文件进行解压。\",\"-v： 在压缩或解压过程中显示解压或压缩的文件。\",\"# 将main.c 进行压缩，则使用 $ gzip/bzip2 –v main.c #会将main.c 压缩成 main.c.gz 或者 main.c.bz2 # 解压 $ gzip –dv main.c.gz $ bzip2 –dv main.c.bz2 \"]},\"1262\":{\"h\":\"unzip命令处理.zip文件\",\"t\":[\"此项专门用于解压zip格式文档的工具，在成功解压同时亦会自动移除原始zip文件\",\"unzip filename.zip \"]},\"1263\":{\"h\":\"总结\",\"t\":[\"解压看文件后缀选择相应工具\",\"***.tar和***.tar.gz-tar\",\"***.gz-gzip\",\"***.bz2-bzip2\"]},\"1264\":{\"c\":[\"linux\"]},\"1265\":{\"c\":[\"linux工具和基本命令\"]},\"1266\":{\"h\":\"软链接（符号链接）和硬链接\"},\"1267\":{\"h\":\"硬链接\",\"t\":[\"如果A文件和B文件的关系是硬链接的关系。当用户修改A文件的内容，B文件的内容也会被改变；反之，修改文件B，文件A内容也会改变。\",\"特点：\",\"可以在多个文件间进行，ls -l显示文件的硬链接数\",\"做硬链接\",\"做硬链接（Linux的文件系统：ext4、xfs等）\",\"所有的硬链接、具备相同的iNode节点号\"]},\"1268\":{\"h\":\"软链接\",\"t\":[\"类似Windows的快捷方式，为一个源文件创建一个快捷方式\",\"ls -l文件类型为l,文件大小是其链接文件的路径名称的字符数\"]},\"1269\":{\"h\":\"ln命令\"},\"1270\":{\"h\":\"给file1创建硬链接\",\"t\":[\"ln file1 file2 \"]},\"1271\":{\"h\":\"给file1创建软链接，file2为创建的软链接名\",\"t\":[\"ln -s file1 file2 \",\"#硬链接 $touch file1 $ln file1 file2 #创建硬链接 $ls -l #查看硬链接数 total 0 -rw-rw-r-- 2 zw zw 0 2月 21 19:53 file1 -rw-rw-r-- 2 zw zw 0 2月 21 19:53 file2 $echo \\\"hello world\\\" > file1 #写入file1 $cat file2 #file2也被修改 hello world $echo \\\"1111\\\" >> file2 #修改file2 $cat file1 #file1 也被修改 hello world 1111 #软连接 $ln -s file1 file3 #同一文件夹下建立软链接 $ll total 20 drwxrwxr-x 3 zw zw 4096 2月 21 20:08 ./ drwxr-xr-x 18 zw zw 4096 2月 21 20:09 ../ -rw-rw-r-- 2 zw zw 17 2月 21 19:54 file1 -rw-rw-r-- 2 zw zw 17 2月 21 19:54 file2 lrwxrwxrwx 1 zw zw 5 2月 21 19:59 file3 -> file1 drwxrwxr-x 2 zw zw 4096 2月 21 20:08 test/ $ln -s ~/link/file1 ./test/file5 # 链接到其他文件夹 $ll ./test/ total 8 drwxrwxr-x 2 zw zw 4096 2月 21 20:30 ./ drwxrwxr-x 3 zw zw 4096 2月 21 20:08 ../ lrwxrwxrwx 1 zw zw 19 2月 21 20:28 file5 -> /home/zw/link/file1 $ln -s ~/link/test2 ./test/temp/1111 #对目录做软链接 $cd ~/link/test/temp/1111 $pwd /home/zw/link/test/temp/1111 $pwd -P #显示文件的实际路径，而不是软链接的路径 /home/zw/link/test2 \"]},\"1272\":{\"h\":\"软链接的删除\",\"t\":[\"不管是链接的是文件还是目录，正确的删除方法：\",\"rm -r ./dir \",\"rm -r ./dir/ \"]},\"1273\":{\"c\":[\"linux\"]},\"1274\":{\"c\":[\"linux工具和基本命令\"]},\"1275\":{\"h\":\"配置一台ubuntu\"},\"1276\":{\"h\":\"网络设置\",\"t\":[\"桥接：虚拟机和电脑在同一网络，同一子网下其他的电脑可以访问虚拟机\",\"NAT:宿主机充当虚拟路由器\",\"image-20240209211150556\"]},\"1277\":{\"h\":\"为什么配置成静态ip\",\"t\":[\"自动状态下ip地址可能会变，设置成静态ip有利于xshell外部连接\",\"image-20240209211620696\",\"ctl alt t 打开命令窗口ping www.baidu.com\"]},\"1278\":{\"h\":\"静态ip配置之桥接模式（适用于使用路由器连接网络的同学）\",\"t\":[\"选择一个合适的静态ip，不要和其他Windows、Linux或者手机等设备的IP冲突\",\"如何判断IP冲突没有？在shell或者是Windows下的命令行里面使用ping命令测试你想要的IP地址，如果能ping通，那么就不要使用这个IP地址了\",\"打开虚拟机的网络设定，进入IPV4分页，选择manual。修改IP，网络掩码（255.255.255.0）和网关（这个保持和自动情况下一致即可）\",\"修改DNS让它和Windows里面的DNS一致（例如：202.103.44.150）\",\"关闭网络，然后重新打开，再使用ifconﬁg来检查是否设置成功\"]},\"1279\":{\"h\":\"静态ip配置之NAT模式（适用于所有同学）\",\"t\":[\"在虚拟机中选择NAT模式，并且将Ubuntu的网络设置设为自动\",\"检查当前能否ping同百度，若不能则尝试重启网络\",\"记录当前的ip地址、网关和DNS\",\"将Ubuntu的网络设置为静态的，其中所有的信息和第3步记录的内容一致\",\"关闭网络，然后重新打开，再使用ifconﬁg来检查是否设置成功\"]},\"1280\":{\"h\":\"安装必备工具\",\"t\":[\"sudo apt install net-tools #ifconfig #使用sudo命令需要输入用户口令 sudo apt install gcc g++ make tree vim git ssh #ssh客户端 \",\"ps -elf|grep sshd查看是否安装成功\"]},\"1281\":{\"h\":\"修改 .bahsrc\"},\"1282\":{\"h\":\"修改PS1样式\",\"t\":[\"cd ~ vi .bashrc \",\"在最后添加\",\"export PS1=\\\"\\\\[\\\\e[32;1m\\\\]\\\\u \\\\[\\\\e[33;1m\\\\]\\\\t \\\\[\\\\e[35;1m\\\\]\\\\w \\\\n\\\\[\\\\e[0;40m\\\\]$\\\" \",\"source .bashrc生效\"]},\"1283\":{\"h\":\"修改ll\",\"t\":[\"修改成alias ll='ls -lh' \"]},\"1284\":{\"h\":\"换源\",\"t\":[\"先确定linux版本号ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror、\",\"sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak sudo vi /etc/apt/sources.list \",\"# 清华源 ubuntu 22.04 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ jammy-backports main restricted universe multiverse #deb http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse # deb-src http://security.ubuntu.com/ubuntu/ jammy-security main restricted universe multiverse \",\"sudo apt upgrade #更新软件包列表，检查可用的软件包更新 sudo apt update #安装可用的软件包更新 \"]},\"1285\":{\"h\":\"安装vmware-tool\",\"t\":[\"在VMware菜单栏里点击虚拟机选项，找到安装VMware tools选项。\",\"然后进入系统，在右边任务栏中找到DVD图标，打开后找到VMware Tools压缩文件，并将其复制到桌面。\",\"tar -zxvf VMwareTools-10.3.22-15902021.tar.gz解压\",\"进入解压完成的文件夹：cd vmware-tools-distrib\",\"sudo ./vmware-install.pl\",\"重启系统后设置虚拟机窗口为自动适应\"]},\"1286\":{\"h\":\"美化vim\"},\"1287\":{\"h\":\"方法一：安装vimplus\",\"t\":[\"安装代码补全工具\",\"sudo apt install vim-youcompleteme \",\"如果vim test.c 随便写一段代码有弹出的内容说明装好了\",\"显示所有已装的vim插件\",\"vim-addons \",\"image-20240210155930348\",\"安装不成功需要删掉重装，成功会显示不是installed\",\"# vim-addons remove youcompleteme vim-addons install youcompleteme \",\"image-20240210160207328\",\"3.安装vimplus\",\"#先安装git sudo apt install git #xia'z git clone https://gitee.com/chxuan/vimplus.git ~/.vimplus cd ~/.vimplus ./install.sh \"]},\"1288\":{\"h\":\"方法二：使用amix/vimrc\"},\"1289\":{\"h\":\"安装前先安装插件\",\"t\":[\"sudo apt install -y ack universal-ctags \"]},\"1290\":{\"h\":\"amix 的 Vim 配置\",\"t\":[\"awesome版本包括很多很棒的插件，配置和配色方案\",\"git clone --depth=1 https://github.com/amix/vimrc.git ~/.vim_runtime sh ~/.vim_runtime/install_awesome_vimrc.sh \"]},\"1291\":{\"h\":\"个性化配置\",\"t\":[\"vi ~/.vim_runtime/my_configs.vim \",\"\\\"my_configs.vim添加以下内容 set nu set hlsearch syntax on set cursorline set tabstop=4 set cindent set shiftwidth=4 set path +=.,/usr/include set fileencodings=utf-8,gb18030,gbk,gb2312 colorscheme dracula \"]},\"1292\":{\"h\":\"常用的使用方法\",\"t\":[\"vim的配置和使用\"]},\"1293\":{\"h\":\"报错：No module named ‘distutils.sysconfig’\",\"t\":[\"解决方法：\",\"$sudo apt install python3-pip python3-distutils \"]},\"1294\":{\"h\":\"可能遇到的报错\"},\"1295\":{\"h\":\"E: Unable to locate package ***\",\"t\":[\"sudo apt update \",\"并且检查要安装的软件名是否正确\"]},\"1296\":{\"h\":\"apt-get update 出现E: Could not get lock /var/lib/apt/lists/lock\",\"t\":[\"方法一：kill掉占用资源的进程\",\"资源锁被别的进程占用，先查看一下\",\"$ ps -e | grep apt 2708 ? 00:00:00 apt.systemd.dai 2713 ? 00:00:00 apt.systemd.dai $ sudo kill -9 2708 2713 \",\"再次执行\",\"$ sudo apt-get update \",\"方法二： 重启释放资源\",\"$ sudo reboot \",\"方法三：等一会\"]},\"1297\":{\"c\":[\"ubuntu\"]},\"1298\":{\"c\":[\"配置\"]},\"1299\":{\"h\":\"字符串转不同进制数学\",\"t\":[\"strtol()函数字符串转换成十进制、十六进制 、二进制、 八进制 long类型\",\"#include <stdlib.h> long int strtol (const char* str, char** endptr, int base); \",\"str 为要转换的字符串，endstr 为第一个不能转换的字符的指针，base 为字符串 str 所采用的进制。\",\"参数 base 范围从2 至36，或0。\",\"strtol() 会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 isspace() 函数来检测），直到遇上数字或正负符号才开始做转换，再遇到非数字或字符串结束时(’\\\\0’)结束转换，并将结果返回。\",\"#include <iostream> #include <string> int main() { char szNumbers[] = \\\"2001 60c0c0 -1101110100110100100000 0x6fffff\\\"; char * pEnd; long int li1, li2, li3, li4; li1 = strtol(szNumbers, &pEnd, 10); //用十进制 解析2001 li2 = strtol(pEnd, &pEnd, 16); //用十六进制 解析60c0c0 li3 = strtol(pEnd, &pEnd, 2); //用二进制 解析-1101110100110100100000 li4 = strtol(pEnd, NULL, 0); //自动判断 解析0x6fffff printf(\\\"转换成10进制: %ld、%ld、%ld、%ld\\\\n\\\", li1, li2, li3, li4); //转换成10进制: 2001、6340800、-3624224、7340031 return 0; } \",\"#获取8进制参数 #include <iostream> #include <cstdlib> #include <unistd.h> #include <cstdio> //#include <cstring> //./my_mkdir new_directory 0777 #依然会受到umask的影响 int main(int argc, char** argv) { if(argc ！= 3) { std::cout << \\\"Args Error!\\\" << std::endl; return -1; } mode_t mode = strtol(argv[2], nullptr, 8); //字符串转8进制长整型数字 int ret = mkdir(argv[1], mode); if(-1 == ret) { //std::cout << \\\"mkdir :\\\" << strerror(ret) << std::endl; perror(\\\"mkdir\\\"); } } \",\"atoi这个只能字符串转十进制\"]},\"1300\":{\"c\":[\"使用指南\"]},\"1301\":{\"c\":[\"页面配置\",\"使用指南\"]},\"1302\":{\"h\":\"CMake的使用\"},\"1303\":{\"h\":\"CMake介绍\",\"t\":[\"CMake： 使用简单方便，可以跨平台，构建项目编译环境。比直接写Makefile简单()，可以通过简单的，一个命令便将我们项目想编译的可执行文件、静态库、动态库都编译出来了。\"]},\"1304\":{\"h\":\"安装\"},\"1305\":{\"h\":\"Linux环境安装CMake\",\"t\":[\"sudo apt install cmake cmake -version #查看版本 \",\"或者 通过编译好的版本安装 Download CMake\",\"下载cmake-3.29.2-linux-x86_64.tar.gz\",\"移动到Linux下并解压（jie'ya'h）\",\"tar -zxvf cmake-3.29.2-linux-x86_64.tar.gz cd cmake-3.29.2-linux-x86_64/bin \",\"查看版本\",\"./cmake -version \",\"建立软链接\",\"sudo ln -s ~/app/cmake-3.29.2-linux-x86_64/bin/cmake /usr/bin/cmake cmake -version #再测试 \",\"image-20240412142839918\"]},\"1306\":{\"h\":\"vscode环境安装CMake\",\"t\":[\"vscode下载相应插件-CMake、CMake Tools\",\"shell终端查找cmake位置，前面我们建立的软链接，直接使用/usr/bin/cmake\",\"whereis cmake \",\"点击CMake Tools的扩展设置\",\"image-20240412134918477\",\"选择远程主机配置，找到Cmake:Build Environment，添加相应环境变量即可。\",\"image-20240412143331454\"]},\"1307\":{\"h\":\"使用方法\"},\"1308\":{\"h\":\"Linux上CMake使用\",\"t\":[\"先cmake在make\",\"cd 到 build 目录下，执行cmake .. && make命令\"]},\"1309\":{\"h\":\"vscode使用\",\"t\":[\"需要在远程连接的工程根路径下建立一个主CMakeLists.txt。\",\"主CMakeLists.txt添加相应配置，指定搜索的子目录为要参与构建的项目\",\"工具启动时先处理主CMakeList.txt，再处理muduocode里的子CMakeList.txt，如图为子CMakeList.txt。\",\"再直接点击vscode里cmake的按钮即可将生成的所有中间文件都放入一个build目录中，可执行文件放入bin目录中，无论是Linux上直接操作还是vscode进行配置，可以依据自己的需求进行改变。\"]},\"1310\":{\"h\":\"CMake常用预定义变量\",\"t\":[\"1、PROJECT_NAME：通过 project() 指定项目名称； 2、PROJECT_SOURCE_DIR：工程的根目录； 3、PROJECT_BINARY_DIR：执行 cmake 命令的目录； 4、CMAKE_CURRENT_SOURCE_DIR：当前 CMakeList.txt 文件所在的目录； 5、CMAKE_CURRENT_BINARY_DIR：编译目录，可使用 add subdirectory 来修改； 6、EXECUTABLE_OUTPUT_PATH：二进制可执行文件输出位置； 7、LIBRARY_OUTPUT_PATH：库文件输出位置； 8、BUILD_SHARED_LIBS：默认的库编译方式 ( shared 或 static ) ，默认为 static； 9、CMAKE_C_FLAGS：设置 C 编译选项； 10、CMAKE_CXX_FLAGS：设置 C++ 编译选项； 11、CMAKE_CXX_FLAGS_DEBUG：设置编译类型 Debug 时的编译选项； 12、CMAKE_CXX_FLAGS_RELEASE：设置编译类型 Release 时的编译选项； 13、CMAKE_GENERATOR：编译器名称； 14、CMAKE_COMMAND：CMake 可执行文件本身的全路径； 15、CMAKE_BUILD_TYPE：工程编译生成的版本， Debug / Release；\"]},\"1311\":{\"h\":\"添加可执行文件作为构建目标\"},\"1312\":{\"h\":\"同一目录 ，单个/多个源文件\",\"t\":[\"直接写\",\"cmake_minimum_required (VERSION 2.8) #指定运行此配置文件所需的 CMake 的最低版本 project (demo1) #参数值是 demo1，该命令表示项目的名称是 demo1 add_executable(main main.cpp) #将名为 main.cpp 的源文件编译成一个名称为 main 的可执行文件 \",\"使用GLOB自动查找当前目录下指定扩展名的文件，实现批量添加源文件。最好是启用CONFIGURE_DEPENDS选项，添加新文件时会自动更新变量\",\"cmake_minimum_required(VERSION 3.10) project(yx) file(GLOB sources CONFIGURE_DEPENDS *.cpp *.h) add_executable(main ${sources}) \",\"使用GLOB_RECURSE可以包含所有子文件夹下的文件，为了避免将build目录里临时生成的cpp也加进来，建议把源码都放在src目录下\",\"aux_source_directory自动会查找指定目录下的所有源文件，然后将结果存进指定变量名\",\"aux_source_directory(. sources) #就是把当前目录下需要的文件搜集到sources变量中 \",\"cmake_minimum_required (VERSION 2.8) project (demo2) aux_source_directory (./ DIR_SRCS) add_executable (demo ${DIR_SRCS}) \",\"使用set命令去新建变量来存放需要的源文件。因为aux_source_directory也存在弊端，它会把指定目录下的所有源文件都加进来，实际项目中可能有些是我们不需要的文件。\",\"cmake_minimum_required (VERSION 2.8) project (demo2) set ( DIR_SRCS ./main.cpp ./add.cpp ) add_executable (demo ${DIR_SRCS}) \"]},\"1313\":{\"h\":\"多个目录 ，多个源文件\",\"t\":[\"一般来说，当文件比较多时，我们会进行分类管理，根据功能把代码放在不同目录下，这样方便查找\",\"03demo/ ├── add │ ├── add.cpp │ └── add.h ├── sub │ ├── sub.cpp │ └── sub.h └── main.cpp\"]},\"1314\":{\"h\":\"方法一：include_directories指定头文件，aux_source_directory指定源文件\",\"t\":[\"CMakeLists.txt 和 main.cpp 在同一目录下，内容修改成如下所示\",\"cmake_minimum_required (VERSION 2.8) project (demo3) include_directories (./add ./sub)#向工程添加多个指定头文件的搜索路径，路径之间用空格分隔 aux_source_directory (./ DIR_SRCS) aux_source_directory (./add DIR_SRCS1) aux_source_directory (./sub DIR_SRCS2) add_executable (demo ${DIR_SRCS} ${DIR_SRCS1} ${DIR_SRCS2}) \"]},\"1315\":{\"h\":\"方法二：（lib 库）分别在 add 和 sub 目录里各编写一个 CMakeLists.txt 文件\",\"t\":[\"为了方便，我们可以先将 add 和 sub 目录里的文件**再由 main 函数调用根目录中的 CMakeLists.txt**\",\"cmake_minimum_required (VERSION 2.8) project (demo3) include_directories (./add ./sub) #头文件 add_subdirectory (./add) #指明本项目包含子目录 add 和 sub，这样当执行 cmake 时，就会进入子目录去找 CMakeLists.txt 来生成 Makefile add_subdirectory (./sub) aux_source_directory (./ DIR_SRCS) add_executable (demo ${DIR_SRCS}) target_link_libraries (demo myadd mysub) #指明可执行文件 demo 需要链接一个名为 myadd 和 mysub 的链接库 \",\"这种写法**，**\",\"add 目录中的 CMakeLists.txt\",\"aux_source_directory (./ DIR_LIB_SRCS) add_library (myadd SHARED ${DIR_LIB_SRCS}) #将add目录的源文件编译成动态库 \",\"sub 目录中的 CMakeLists.txt\",\"aux_source_directory (./ DIR_LIB_SRCS) add_library (mysub STATIC ${DIR_LIB_SRCS}) \",\"add_library第 1 个参数指定库的名字；第 2 个参数决定是动态还是静态，不写****；第 3 个参数指定生成库的源文件。注意：SHARED 和 STATIC 是 cmake 的关键字，必须！\"]},\"1316\":{\"h\":\"常用的组织结构\",\"t\":[\"把源文件放到 src 目录下 把头文件放到 include 目录下 把生成的库文件放到 lib 目录下 把生成的对象文件放到 build 目录下 把最终输出的 elf 文件放到 bin 目录下\",\"04demo/ ├── bin ├── build ├── include │ ├── add.h │ └── sub.h ├── lib └── src ├── lib_add │ └── add.cpp ├── sub │ └── sub.cpp └── main.cpp\",\"最外层新建一个 CMakeLists.txt用于掌控全局，使用add_subdirectory来添加要生成 elf 文件的源码目录即可\",\"cmake_minimum_required (VERSION 2.8) project (demo4) add_subdirectory (./src) #指定搜索的子目录 \",\"src 目录下，新建一个 CMakeLists.txt\",\"add_subdirectory (./lib_add) #指定搜索的子目录 aux_source_directory (./ DIR_SRCS1) aux_source_directory (./sub DIR_SRCS2) include_directories (../include) link_directories (${PROJECT_SOURCE_DIR}/lib) #添加非标准库的搜索路径 add_executable (demo ${DIR_SRCS1} ${DIR_SRCS2}) target_link_libraries (demo myadd) set (EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) #设置可执行文件的最终存储路径 \",\"EXECUTABLE_OUTPUT_PATH和PROJECT_SOURCE_DIR是 cmake 自带的预定义变量\",\"EXECUTABLE_OUTPUT_PATH：目标二进制可执行文件的存放位置 PROJECT_SOURCE_DIR：当前工程的根目录\",\"lib_add 目录下，也要新建一个 CMakeLists.txt\",\"aux_source_directory (./ DIR_LIB_SRCS) add_library (myadd_shared SHARED ${DIR_LIB_SRCS}) add_library (myadd_static STATIC ${DIR_LIB_SRCS}) set_target_properties (myadd_shared PROPERTIES OUTPUT_NAME \\\"myadd\\\") set_target_properties (myadd_static PROPERTIES OUTPUT_NAME \\\"myadd\\\") set (LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib) \"]},\"1317\":{\"h\":\"添加 编译选项\",\"t\":[\"有时编译程序时想添加一些编译选项，如 -g、-Wall、-std=c++11 等，就可以使用add_compile_options来操作，也可以通过set命令修改CMAKE_CXX_FLAGS或CMAKE_C_FLAGS，这两个是 cmake 自带的预定义变量，用于设置编译选项 这两种方式的效果是一样的，但请注意它们还是有区别的：\",\"add_compile_options命令添加的编译选项是针对****\",\"而set命令设置CMAKE_C_FLAGS或CMAKE_CXX_FLAGS变量则是分别只针对 c 和 c++ 编译器的\",\"cmake_minimum_required (VERSION 2.8) project (demo5) #设置编译选项 #add_compile_options (-std=c++11 -Wall) set (CMAKE_CXX_FLAGS \\\"-std=c++11 -Wall ${CMAKE_CXX_FLAGS}\\\") aux_source_directory (./ DIR_SRCS) add_executable (demo ${DIR_SRCS}) set (EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) \",\"cd 到 build 目录下，执行cmake .. && make命令，就可以在 bin 目录下得到 elf 文件\"]},\"1318\":{\"h\":\"添加 控制选项\",\"t\":[\"希望在编译代码时****，这时可以使用 cmake 的option命令\",\"假设我们现在的工程会生成 2 个 bin 文件，main1 和 main2，现在整体结构如下 06demo/ ├── bin ├── build ├── CMakeLists.txt └── src ├── CMakeLists.txt ├── └── \",\"外层的 CMakeLists.txt 内容如下\",\"cmake_minimum_required (VERSION 2.8) project (demo6) option (MYDEBUG \\\"enable debug mode\\\" OFF) add_subdirectory (./src) \",\"option命令\",\"其第一个参数是这个 option 的名字，\",\"第二个参数是字符串，用来描述这个 option 是来干嘛的，\",\"第三个是 option 的值，ON或OFF，也可以不写，不写就是默认 OFF\",\"src 目录下的 CMakeLists.txt，如下\",\"add_executable (main1 main1.cpp) if (MYDEBUG) add_executable (main2 main2.cpp) else() message (STATUS \\\"Currently is not in debug mode\\\") endif() set (EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) \",\"这里使用了 if-else 根据 option 来决定是否编译 main2.cpp\",\"message为用户打印显示一条消息，可以用下述可选的关键字指定消息类型\",\"(无) = 重要消息 STATUS = 非重要消息 WARNING = CMake 警告，会继续执行 AUTHOR_WARNING = CMake 警告 (dev)，会继续执行 SEND_ERROR = CMake 错误，继续执行，但是会跳过生成的步骤 FATAL_ERROR = CMake 错误，终止所有处理过程 \",\"cd 到 build 目录下输入cmake .. && make就可以只编译出 main1，如果想编译出 main2\",\"直接修改 CMakeLists.txt，把 OFF 改成 ON，这种方法有点麻烦\",\"cd 到 build 目录，然后输入**cmake .. -DMYDEBUG=ON && make**，这样就可以编译出 main1 和 main2\"]},\"1319\":{\"h\":\"为什么要在 build 目录下运行 cmake？\",\"t\":[\"如果不这样做，cmake 运行时就会跟文件，这样会对程序的目录结构造成污染，而在 build 目录下运行 cmake，生成的附带文件就只会待在 build 目录下，如果我们不想要这些文件就可以直接清空 build 目录，非常方便\"]},\"1320\":{\"h\":\"CMAKE_BUILD_TYPE 控制构建类型\",\"t\":[\"默认空字符串，相当于Debug调试模式 其它模式：Release、MinSizeRel、RelWithDebInfo，这3种模式都定义了NDEBUG宏，会导致****\",\"set(CMAKE_BUILD_TYPE Release) \",\"大多数项目为了默认为Release模式，CMakeLists中会写如下三行\",\"if (NOT CMAKE_BUILD_TYPE) set(CMAKE_BUILD_TYPE Release) endif() \"]},\"1321\":{\"h\":\"NDEBUG宏 的使用\",\"t\":[\"在CMakeLists中写上\",\"add_definitions(-DNDEBUG) #定义了NDEBUG宏 \",\"这样对于下面的test.cpp，assert不起作用，输出xx\",\"#include <iostream> #include <cassert> int main() { int m=3; #ifdef NDEBUG std::cout<<\\\"xx\\\"<<std::endl; #else std::cout<<\\\"yy\\\"<<std::endl; #endif assert(m == 2); return 0; } \"]},\"1322\":{\"h\":\"几个目录\",\"t\":[\"cmake_minimum_required(VERSION 3.29) project(LoggerCMake) set(SRC_LIST Logger.cc test.cc) #直接写源文件 add_executable(Logger ${SRC_LIST}) target_link_libraries(Logger log4cpp pthread) \"]},\"1323\":{\"c\":[\"linux\"]},\"1324\":{\"c\":[\"编译工具\"]},\"1325\":{\"h\":\"gcc/g++ 常见的编译命令\"},\"1326\":{\"h\":\"基本编译命令\",\"t\":[\"编译C程序：gcc filename.c -o outputname\",\"编译C++程序：g++ filename.cpp -o outputname\"]},\"1327\":{\"h\":\"添加编译选项\",\"t\":[\"-g：添加调试信息，用于gdb等调试器。\",\"-O2 或 -O3：优化代码，提高运行效率。\",\"-Wall：显示所有警告信息。\",\"-Wextra：显示额外的警告信息。\",\"-Werror：将所有警告当作错误处理。\",\"gcc -g -O2 -Wall filename.c -o outputname g++ main.cc -m32 -g -o main.o #-m32指定编译为32位程序 \",\"image-20240310154324639\"]},\"1328\":{\"h\":\"包含头文件和库\",\"t\":[\"-I：指定头文件搜索路径。\",\"-L：指定库文件搜索路径。\",\"-l：链接指定的库。 例如：gcc -I/path/to/headers -L/path/to/libs -lmylib filename.c -o outputname\"]},\"1329\":{\"h\":\"编译多个源文件\",\"t\":[\"gcc file1.c file2.c file3.c -o outputname \"]},\"1330\":{\"h\":\"预处理、编译、汇编和链接\",\"t\":[\"-E：只进行预处理，输出到标准输出。\",\"-S：编译并汇编，输出汇编代码。\",\"-c：编译并汇编，输出目标文件（.o）。\",\"例如，只进行预处理：gcc -E filename.c -o output.i\"]},\"1331\":{\"h\":\"使用静态库和动态库\",\"t\":[\"静态库：在链接时，库文件会被拷贝到可执行程序中（产品中打包了库文件）\",\"动态库：在链接时库文件会提供自己的位置，在运行时根据位置进行加载（运行时加载的库文件）\",\"特点\",\"可执行程序的大小\",\"安装难度\",\"升级\",\"静态\",\"大\",\"低\",\"难\",\"动态\",\"小\",\"高\",\"容易\",\"创建静态库： \",\"生成目标文件gcc -c mylib.c -o amylib.o\",\"打包成库文件ar crsv libmylib.a mylib.o\",\"创建动态库： \",\"编译时生成与gcc -c mylib.c -o amylib.o -fpic\",\"从目标文件生成动态文件gcc -shared -o libmylib.so mylib.o\",\"链接静态库：gcc filename.c -L. -lmylib -o outputname\",\"链接动态库：除了上面的链接命令（gcc filename.c -L. -lmylib -o outputname ），还需要在运行时指定动态库的位置，可以使用LD_LIBRARY_PATH环境变量或/etc/ld.so.conf文件来实现。\"]},\"1332\":{\"h\":\"如何更新动态库🍗🍗🍗\",\"t\":[\"动态库的好处：用户不需要重新链接就能更新库文件\",\"重新编译库\",\"gcc -shared -o libmylib.so mylib.c -fPIC \",\"更新版本号：如果服务端；如果不更新协议，可以多个客户端版本共用一个服务端。\",\"安装新库：需要将它安装到系统中合适的位置。这通常意味着将库文件复制到某个标准库目录，如 /usr/local/lib 或 /usr/lib\",\"mv libmylib.so libmylib.so.0.0.1 sudo cp libmylib.so.0.0.1 /usr/lib/ sudo rm libmylib.so #删除旧的软链接 sudo ln -s libmylib.so.0.0.1 libmylib.so #重新建立新链接 \",\"image-20240310173458700\",\"版本号决定了新旧程序\",\"保存所有版本的库文件（因为不知道新版本的库文件是否会产生bug）\",\"建立库文件和libmylib.so的软链接（为了让程序链接或运行过程中能正确找到相应的库文件）\",\"如果更新，重建软链接即可\",\"更新库缓存：在某些系统上，如 Linux，当新的共享库被安装后，你可能需要更新系统的库缓存。这通常可以通过运行 ldconfig 命令完成，该命令会重新生成 /etc/ld.so.cache 文件，该文件包含了系统中所有共享库的列表。\",\"sudo ldconfig \",\"或者，如果你的库安装在一个非标准目录，你可能需要编辑 /etc/ld.so.conf 文件并添加你的库目录，然后再运行 ldconfig。\"]},\"1333\":{\"h\":\"gcc -fpic 什么作用（了解）\",\"t\":[\"主要用于生成位置无关代码（Position Independent Code，简称 PIC）。这种代码的特性在于没有绝对跳转，所有的跳转都是相对跳转，因此代码可以被加载器加载到内存的任意位置并正确执行（因为共享库在加载到内存时，其位置不是固定的，因此必须能够处理这种不确定性）。\",\"使用 -fPIC 选项编译的源文件在引用函数头文件时，有更宽松的尺度。例如，只需要包含函数的声明头文件，即使没有相应的 C 文件来实现这些函数，编译成共享库（.so 文件）也可以成功\"]},\"1334\":{\"h\":\"ar crsv 作用\",\"t\":[\"ar 是 Unix-like 系统中的一个工具，用于创建、修改和提取静态库文件（通常具有 .a 扩展名）\",\"c：创建一个库。如果库已经存在，则替换它。\",\"r：将文件插入库中。如果文件已存在于库中，则替换它。\",\"s：创建或更新库的目标文件索引。这对于加速链接过程很有用，因为链接器可以使用索引来快速找到库中的特定符号。\",\"v：详细模式。显示正在执行的操作的详细信息。\",\"示例：\",\"当你使用 ar crsv libname.a file1.o file2.o 这样的命令时，你实际上是在告诉 ar：\",\"创建一个名为 libname.a 的静态库（如果它不存在的话）。\",\"将 file1.o 和 file2.o 这两个目标文件添加到库中（如果它们已经存在于库中，则替换它们）。\",\"更新或创建库的索引。\",\"显示执行过程中的详细信息。\"]},\"1335\":{\"h\":\"同时存在动态库（共享库）和静态库\",\"t\":[\"默认行为：在许多系统中，如果没有显式指定，链接器默认会优先链接到，因为它们通常更小，多个程序可以共享同一个库文件，从而节省磁盘空间。\",\"链接器选项：链接器通常接受一些选项来控制它应该优先链接到哪种类型的库。例如，GCC 链接器接受 -static 和 -shared 选项来分别指示链接器优先链接到静态库或动态库。\",\"如果你想要控制链接的优先级，你可以使用以下策略：\",\"显式指定库文件：在链接时，你可以直接指定要链接的库文件的路径。例如，使用 -L 选项来添加库文件的搜索路径，并使用 -l 选项来指定库名。如果你想要链接到静态库，你可以直接指定静态库文件的路径（包括 .a 扩展名）。🍔\",\"gcc your_program.o -L/path/to/libs -l:libmylib.a -o your_program \",\"使用链接器选项：使用 -static 选项告诉链接器优先链接静态库。🍔\",\"gcc your_program.o -static -lmylib -o your_program_static \",\"修改环境变量：某些系统允许通过设置环境变量（如 LD_LIBRARY_PATH 对于运行时动态库搜索，或者 LIBRARY_PATH 对于链接时库搜索）来影响库的搜索顺序。\"]},\"1336\":{\"c\":[\"linux\"]},\"1337\":{\"c\":[\"编译工具\"]},\"1338\":{\"h\":\"gdb调试出错的程序\",\"t\":[\"利用黑匣子（当程序异常终止时，操作系统保存程序执行时的内存映像的文件）\",\"ulimit -c unlimited 命令在 Linux 系统中用于设置 core 文件的大小限制为无限制\",\"image-20240310141538480\",\"具体来说，ulimit -c unlimited 命令的作用如下：\",\"取消大小限制：默认情况下，Linux 系统可能不生成 core 文件，或者对 core 文件的大小有限制。使用 ulimit -c unlimited 可以确保当程序崩溃时，系统不会因文件大小限制而截断 core 文件，从而可以保存完整的内存映像。\",\"image-20240310141436371\",\"便于调试：完整的 core 文件对于程序员和系统管理员来说是非常有价值的，因为它可以帮助他们了解程序崩溃时的状态，包括变量的值、内存布局等，从而更容易地定位问题所在。\",\"注意安全性：需要注意的是，。此外，core 文件可能包含敏感信息，因此需要注意文件的安全性和隐私保护。\",\"用-g编译代码\",\"执行代码，生成core\",\"gdb a.out core\",\"bt 查看堆栈\"]},\"1339\":{\"h\":\"gdb 设置命令行参数\",\"t\":[\"image-20240310142108995\"]},\"1340\":{\"h\":\"gdb 基本命令\",\"t\":[\"set args：设置程序运行时的参数。\",\"show args：查看设置好的运行参数。\",\"bt（或backtrace）：查看当前调用栈的信息。\",\"break（或b）：设置断点。例如，break functionname 会在函数functionname的入口处设置断点；break filename:linenum 会在filename文件的linenum行设置断点。\",\"info break（或i b）：查看当前所有断点的信息。\",\"delete break（或d）：删除断点。例如，delete num 会删除编号为num的断点。\",\"ignore :想要临时跳过某个断点几次时ignore breakpoint-number count\",\"run（或r）：开始执行程序，直到遇到断点或程序结束。\",\"continue（或c）：从当前位置开始连续执行程序，直到遇到下一个断点或程序结束。\",\"next（或n）：执行下一行代码，跳过函数调用。\",\"step（或s）：执行下一行代码，进入函数调用。\",\"finish：执行当前函数，直到返回，然后停下来等待命令。\",\"set var：修改变量的值。例如，set var variable=value 会将variable的值设置为value。\",\"print（或p）：打印变量或表达式的值。例如，print variable 会打印variable的值。\",\"list（或l）：列出源代码。例如，list functionname 会列出functionname函数的源代码；list linenum 会列出从linenum开始的源代码。\",\"quit（或q）：退出GDB。\"]},\"1341\":{\"h\":\"监视功能 display\",\"t\":[\"display expression 是GDB（GNU Debugger）中的一个命令，用于在每次程序停止时自动显示一个或多个表达式的值。这对于监视变量或内存地址在程序执行过程中的变化非常有用。\",\"使用 display 命令时，GDB会为每个显示的表达式分配一个编号。你可以使用 undisplay 命令加上这个编号来删除特定的自动显示表达式。例如，如果 display 命令为某个表达式分配了编号1，你可以使用 undisplay 1 来删除它。\"]},\"1342\":{\"h\":\"监视变量值\",\"t\":[\"(gdb) display count \",\"每次程序停止时（例如，在断点处），GDB都会自动显示 count 变量的当前值。\"]},\"1343\":{\"h\":\"监视指针指向的内容\",\"t\":[\"(gdb) display *ptr \"]},\"1344\":{\"h\":\"监视内存地址的内容\",\"t\":[\"(gdb) display *(int*)0x12345678 \",\"这个命令将显示内存地址 0x12345678 处作为整数（int）解释的值。每次程序停止时，这个值都会被更新\"]},\"1345\":{\"h\":\"监视表达式的结果\",\"t\":[\"(gdb) display a + b * c \",\"这里，a、b 和 c 是程序中的变量。每次程序停止时，GDB都会计算并显示 a + b * c 这个表达式的值。\"]},\"1346\":{\"h\":\"监视结构体成员\",\"t\":[\"(gdb) display myStruct.member \",\"myStruct 是一个结构体变量，member 是该结构体中的一个成员。每次程序停止时，GDB都会显示 myStruct.member 的当前值。\"]},\"1347\":{\"h\":\"x 命令来查看指定地址的内存值\",\"t\":[\"x命令来查看指定地址的内存值，以及按照不同的格式（如字节、字、双字、浮点数等）来解析这些内存值\",\"x/格式 地址 \",\"格式：指定如何解析和显示内存内容。常用的格式有： \",\"b：字节（一个字节）\",\"h：半字（两个字节）\",\"w：字（，32位）\",\"g：巨字（八个字节，64位）\",\"i：机器指令（以汇编指令格式显示\",\"f：浮点数（按照浮点数的格式显示）\",\"s：字符串（以ASCII字符串格式显示）\",\"c：字符（以ASCII字符格式显示）\",\"u：无符号十进制整数\",\"t：二进制整数\",\"o：八进制整数\",\"x 或 d：十六进制或十进制整数（默认是十六进制）\",\"地址：要检查的内存地址。\"]},\"1348\":{\"h\":\"示例\",\"t\":[\"查看从地址0x12345678开始的4个字节，并以十六进制显示：\",\"(gdb) x/4xb 0x12345678 \",\"以二进制格式查看内存内容\",\"(gdb) x/tb 0x401000 \",\"查看从地址0x12345678开始的指令，并以汇编指令格式显示：\",\"(gdb) x/i 0x12345678 \",\"查看从地址0x12345678开始的字符串（直到遇到空字符'\\\\0'为止）：\",\"(gdb) x/s 0x12345678 \",\"查看从当前程序计数器（PC）开始的指令：\",\"(gdb) x/i $pc \"]},\"1349\":{\"c\":[\"linux\"]},\"1350\":{\"c\":[\"编译工具\"]},\"1351\":{\"h\":\"makefile使用方法\"},\"1352\":{\"h\":\"使用方法\",\"t\":[\"先建立一个名为makefile或者是Makefile的文件，然后在里面写入符合语法规则的编译命令，完成以后只需要在文件所在目录使用make命令就能运行编译命令\"]},\"1353\":{\"h\":\"书写规则\",\"t\":[\"从第一行命令开始，先确认目标文件，根据目标文件确定所需的依赖文件，然后递归地找到依赖文件的依赖文件，直到依赖文件是没有子依赖文件\",\"#注释 书写格式 [目标文件]:[依赖文件] <tab>[command] \"]},\"1354\":{\"h\":\"原则\",\"t\":[\"，即只有目标文件比依赖旧或者目标文件不存在，才会执行命令\"]},\"1355\":{\"h\":\"伪目标\",\"t\":[\"以不会存在的文件名作为目标。make伪目标，命令会一直执行\",\"make .PHONY #查看定义了哪些伪目标 make clean # 清除所有生成的目标文件和最终程序 make rebuild #重新编译 \"]},\"1356\":{\"h\":\"变量名\",\"t\":[\"自定义变量：变量名:=变量内容（字符串）。$(变量名)使用变量，实际上就是\",\"自动变量：变量内容会随着规则自动变化\",\"变量\",\"说明\",\"$@\",\"目标文件\",\"$<\",\"第一个依赖文件\",\"$^\",\"所有依赖文件，以空格分隔\",\"$?\",\"日期新于目标文件的所有相关文件列表，逗号分隔\",\"$(@D)\",\"目标文件的目录名部分\",\"$(@F)\",\"目标文件的文件名部分\",\"预定义变量\",\"变量名\",\"功能\",\"默认含义\",\"AR\",\"打包库文件\",\"ar\",\"AS\",\"汇编程序\",\"as\",\"CC\",\"C编译器\",\"gcc\",\"CPP\",\"C预编译器\",\"$(CC) -E\",\"CXX\",\"C++编译器\",\"g++\",\"RM\",\"删除\",\"rm –f\",\"ARFLAGS\",\"库选项\",\"无\",\"ASFLAGS\",\"汇编选项\",\"无\",\"CFLAGS\",\"C编译器选项\",\"无\",\"CPPFLAGS\",\"C预编译器选项\",\"无\",\"CXXFLAGS\",\"C++编译器选项\",\"无\"]},\"1357\":{\"h\":\"= 和 := 的区别\",\"t\":[\"使用 = 赋值的变量被称为递归展开变量。这可能导致变量的值在每次引用时都可能不同。\",\"A = $(B) B = Hello all: @echo $(A) # 输出 \\\"Hello\\\" \",\"使用 := 赋值的变量被称为直接展开变量。在赋值时就被展开，之后不会再次展开，因此变量的值在赋值后就固定不变。这也是工作当中的\",\"A := $(B) B = Hello all: @echo $(A) # 输出空行，因为A在赋值时B还未定义 \"]},\"1358\":{\"h\":\"通配符和模式匹配\"},\"1359\":{\"h\":\"使用bash的规则来应用通配符\",\"t\":[\"clean: rm -rf *.o \"]},\"1360\":{\"h\":\"% 通配符\",\"t\":[\"%表达式 可以作某个规则的目标（目标：上一个规则的依赖）\",\"CXX:=g++ out:=main objs:=main.o add.o $(out):$(objs) $(CXX) $^ -o $@ #main.o:main.c # $(CXX) -c $^ -o $@ #add.o:add.c # $(CXX) -c $^ -o $@ %.o:%.c $(CXX) -c $^ -o $@ #把main.o add.o用%.o匹配出来，再用%.c重新组合成main.c add.c \",\"%表达式根据变量内容生成新的内容\",\"srcs:= main.c add.c sub.c #objs:=main.o add.o sub.o objs:=$(srcs:%.c=%.o) \"]},\"1361\":{\"h\":\"内置函数\",\"t\":[\"# 格式 $([function] [arguments]) \",\"使用wildcard函数可以使用通配符，找到所有满足通配符的文件名\",\"srcfiles:=$(wildcard src/*.c) \",\"使用subst函数来实现文本替换\",\"# 语法 $(subst from,to,text) # 示例 ORIGINAL_TEXT := Hello, World! REPLACED_TEXT := $(subst World,Makefile,$(ORIGINAL_TEXT)) #Hello, Makefile! \",\"使用patsubst函数来实现模式文本替换\",\"$(patsubst pattern,replacement,text) # 示例 SRCS := main.c util.c file.c OBJS := $(patsubst %.c,%.o,$(SRCS)) \"]},\"1362\":{\"h\":\"循环\",\"t\":[\"LIST:=one two three all: for i in $(LIST); do echo $$i; done # 等价于 all: for i in one two three; do echo $i; done \"]},\"1363\":{\"h\":\"make命令的 -f 指定makefile文件\",\"t\":[\"有些时候makefile文件的名字不希望以makefile或者Makefile来命名，此时可以使用make命令的-f参数来指定makefile文件\",\"make -f newMake \"]},\"1364\":{\"h\":\"示例\"},\"1365\":{\"h\":\"指定源文件生成一个可执行程序\",\"t\":[\"# makefile目录下的指定源文件生成一个可执行程序 # 定义编译器 CC = gcc # 定义源文件 SRCS = main.c util.c #指定源文件生成一个可执行程序 #SRCS:=$(wildcard *.c) #所有的源文件生成一个可执行程序 # 定义目标文件 OBJS = $(SRCS:.c=.o) # 定义最终目标 TARGET = my_program # 伪目标，当只输入make时执行 all: $(TARGET) # 链接目标文件生成最终程序 $(TARGET): $(OBJS) $(CC) $(OBJS) -o $(TARGET) # 编译源文件生成目标文件 %.o: %.c $(CC) -c $< -o $@ # Phony目标，确保clean总是被执行，即使存在名为clean的文件或目录 .PHONY: clean rebuild # 清除所有生成的目标文件和最终程序 clean: rm -f $(OBJS) $(TARGET) # 重新编译 rebuild: clean all \",\".PHONY增加makefile的可读性\"]},\"1366\":{\"h\":\"每个源文件生成可执行程序\",\"t\":[\"SRCS:=$(wildcard *.c) TARGETS:=$(SRCS:%.c=%) all:$(TARGETS) for i in $^; do gcc -o $$i $$i.c;done .PHONY:clean clean: rm $(TARGETS) \",\"不使用循环\",\"CC:=gcc SRCS:=$(wildcard *.c) TARGETS:=$(SRCS:%.c=%) all:$(TARGETS) %:%.c $(CC) $^ -o $@ .PHONY:clean clean: rm $(TARGETS) \"]},\"1367\":{\"h\":\"有头文件的情况\",\"t\":[\"#bubbleSort.cc bubbleSort.h main.cc #Makefile CXX:=g++ CXXFLAGS:=-std=c++11 #deps := $(wildcard *.h) srcs:=$(wildcard *.cc) #1.cc 2.cc 3.cc objs:=$(patsubst %.cc,%.o,$(srcs)) exe:=main all:$(exe) $(exe):$(objs) $(CXX) $^ -o $@ #%:%.cc $(deps) $(CXX) $< -o $@ %:%.cc $(CXX) $^ -o $@ .PHONY: clean rebuild clean: $(RM) $(exe) $(objs) rebuild:clean all \",\"image-20240310234105841\"]},\"1368\":{\"h\":\"Makefile missing separator. Stop.怎么解决\",\"t\":[\"makefile的命令行，开头必须用tab键\"]},\"1369\":{\"c\":[\"linux\"]},\"1370\":{\"c\":[\"编译工具\"]},\"1371\":{\"h\":\"c语言连接MySQL\",\"t\":[\"安装开发c/c++的库：apt install libmysqlclient-dev\"]},\"1372\":{\"h\":\"1. 连接数据库使用的头文件和库文件\",\"t\":[\"#include <mysql/mysql.h> 有些也在 #include <mysql.h> 程序中使用了访问mysql的有关函数接口，需要在链接时指定库名: linux平台为 -lmysqlclient \"]},\"1373\":{\"h\":\"2、初始化连接句柄\",\"t\":[\"MYSQL *mysql_init(MYSQL *mysql); 该方法用来初始化一个连接句柄，如果参数为空，则返回一个指向新分配的连接句柄的指针。如果传递一个已 有的结构，它将被重新初始化。出错时返回为NULL。 \"]},\"1374\":{\"h\":\"3. 连接数据库\",\"t\":[\"MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long clientflag); 参数介绍，其中 mysql是上一步mysql_init方法初始化后返回的指针， host是主机名，或者连接的服务器IP地址，本地可以使用\\\"localhost\\\"，或\\\"127.0.0.1\\\"或\\\"\\\"，或 NULL user是用户名，数据库中添加的用户，管理员是\\\"root\\\"， passwd 是用户的密码, db 是数据库的名字， port 是数据库的端口 3306，也可直接写0，意味着使用mysql默认端口， unix_socket 一般为NULL,表示不使用unix套接字或者管道 clientflag 标志位，一般给0 返回值，失败为NULL,成功与第一个参数值相同。 \"]},\"1375\":{\"h\":\"4. 关闭连接\",\"t\":[\"void mysql_close(MYSQL *mysql); 在不使用时，可以用该方法关闭连接。 \"]},\"1376\":{\"h\":\"5. 执行sql语句\",\"t\":[\"int mysql_query(MYSQL *mysql, const char *q); 参数: mysql 是之前连接后返回的指针， q 是要执行的sql语句，末尾可以没有分号，这个在命令工具中使用不同。 返回值：成功返回0。 注意:如果sql语句中有二进制数据，则应该使用mysql_real_query(); \"]},\"1377\":{\"h\":\"6. 提取结果\",\"t\":[\"MYSQL_RES *mysql_store_result(MYSQL *mysql); 一次性提取所有数据 //MYSQL_RES *mysql_use_result(MYSQL *mysql);一次提取一行数据q 该方法，是在执行 mysql_query()成功之后调用的，可以立刻保存在客户端中收到的所有数据。 它返回一个指向结果集结构的指针。如果失败返回NULL; \"]},\"1378\":{\"h\":\"7. 获取结果集中有多少行\",\"t\":[\"uint64_t mysql_num_rows(MYSQL_RES *res); 只有执行了 mysql_store_result()之后,才可以调用该方法，获取结果集中的行数。如果没有返回行，则为0; \"]},\"1379\":{\"h\":\"8. 取出结果集中的一行记录\",\"t\":[\"MYSQL_ROW mysql_fetch_row(MYSQL_RES *result); 从结果集中取出一行，并把它存放到一个行结构中。当数据用完或者出错时，返回为NULL，通常该方法需要循环调用。 \"]},\"1380\":{\"h\":\"9. 查看记录行的列数\",\"t\":[\"unsigned int mysql_field_count(MYSQL *mysql); \"]},\"1381\":{\"h\":\"10. 释放结果集占用的内存\",\"t\":[\"void mysql_free_result(MYSQL_RES *result); 执行完sql语句，得到返回的结果集，处理完数据后，需要调用该方法释放存放结果集的内存空间。 \"]},\"1382\":{\"h\":\"11. 获取错误信息\",\"t\":[\"unsigned int mysql_errno(MYSQL *mysql); 返回错误码 const char *mysql_error(MYSQL *mysql); 返回错误信息描述 \"]},\"1383\":{\"h\":\"12. 连接测试程序\",\"t\":[\"#include <stdio.h> #include <mysql/mysql.h> int main(){ MYSQL connect;//mysql连接对象 mysql_init(&connect); //连接到mysql if(mysql_real_connect(&connect,\\\"localhost\\\",\\\"root\\\",\\\"root\\\",\\\"test\\\",3306,NULL,0)){ printf(\\\"连接mysql成功\\\\n\\\"); }else{ printf(\\\"err:%s\\\\n\\\",mysql_error(&connect)); printf(\\\"连接mysql失败\\\\n\\\"); } //关闭mysql连接 mysql_close(&connect); return 0; } \"]},\"1384\":{\"h\":\"增加、修改、删除的程序\",\"t\":[\"仅仅是SQL语句不同\",\"#include <stdio.h> #include <unistd.h> #include <stdlib.h> #include <mysql/mysql.h> int main(){ MYSQL* conn = mysql_init(NULL); if(NULL == conn){ printf(\\\"err:%s\\\\n\\\",mysql_error(conn)); exit(0); } //连接到mysql if(mysql_real_connect(conn,\\\"localhost\\\",\\\"root\\\",\\\"root\\\",\\\"testdb\\\",3306,NULL,0)){ printf(\\\"连接mysql成功\\\\n\\\"); }else{ printf(\\\"err:%s\\\\n\\\",mysql_error(conn)); exit(0); } char sql[128] = {0}; // sprintf(sql, \\\"insert into stu values(%s, %d)\\\", \\\"\\\\\\\"小李\\\\\\\"\\\", 23); // sprintf(sql, \\\"update stu set age = %d where name = %s\\\", 30, \\\"\\\\'小张\\\\'\\\"); sprintf(sql, \\\"delete from stu where name = %s\\\", \\\"\\\\'小张\\\\'\\\"); int res = mysql_query(conn, sql); if(0 != res){ printf(\\\"err:%s\\\\n\\\",mysql_error(conn)); exit(0); } printf(\\\"sql执行成功\\\\n\\\"); //关闭mysql连接 mysql_close(conn); return 0; } \"]},\"1385\":{\"h\":\"查询的程序\",\"t\":[\"#include <stdio.h> #include <unistd.h> #include <stdlib.h> #include <mysql/mysql.h> int main(){ MYSQL* conn = mysql_init(NULL); if(NULL == conn){ printf(\\\"err:%s\\\\n\\\",mysql_error(conn)); exit(0); } //连接到mysql if(mysql_real_connect(conn,\\\"localhost\\\",\\\"root\\\",\\\"root\\\",\\\"testdb\\\",3306,NULL,0)){ printf(\\\"连接mysql成功\\\\n\\\"); }else{ printf(\\\"err:%s\\\\n\\\",mysql_error(conn)); exit(0); } char sql[128] = {0}; sprintf(sql, \\\"select * from stu\\\"); int res = mysql_query(conn, sql); if(0 != res){ printf(\\\"err:%s\\\\n\\\",mysql_error(conn)); exit(0); } printf(\\\"sql执行成功\\\\n\\\"); // 获取结果集 MYSQL_RES* mysql_res = mysql_store_result(conn); if(NULL == mysql_res){ printf(\\\"err:%s\\\\n\\\",mysql_error(conn)); exit(0); } // 获取记录条数以及属性个数 int num = mysql_num_rows(mysql_res); int column = mysql_field_count(conn); if(0 == num){ printf(\\\"没有查询到信息\\\\n\\\"); exit(0); } printf(\\\"查询到%d条信息， 每条信息有%d个属性\\\\n\\\", num, column); // 循环打印获取的记录 for(int i = 0; i < num; i++){ MYSQL_ROW mysql_row = mysql_fetch_row(mysql_res); if(NULL == mysql_row){ printf(\\\"数据处理完成\\\\n\\\"); } for(int j = 0; j < column; j++){ printf(\\\"%s \\\", mysql_row[j]); } printf(\\\"\\\\n\\\"); } // 释放结果集 mysql_free_result(mysql_res); //关闭mysql连接 mysql_close(conn); return 0; } \"]},\"1386\":{\"c\":[\"mysql\"]},\"1387\":{\"c\":[\"c/c++连接数据库\"]},\"1388\":{\"h\":\"mysql5.7的安装\"},\"1389\":{\"h\":\"查看当前有没有安装MySQL\"},\"1390\":{\"h\":\"执行以下命令，如果执行后什么都没有返回，则进入MySQL的安装步骤\",\"t\":[\"dpkg -l | grep mysql \"]},\"1391\":{\"h\":\"如果执行以上命令，显示如下，就证明MySQL已经安装完毕，直接使用MySQL即可\",\"t\":[\"image-20240209194830447\"]},\"1392\":{\"h\":\"安装MySQL\"},\"1393\":{\"h\":\"Ubuntu18.04下安装MySQL5.7\",\"t\":[\"Ubuntu18.04下安装MySQL，默认安装的事MySQL5.7\",\"#更新软件列表 $ sudo apt update #安装MySQL $ sudo apt install mysql-server mysql-client \"]},\"1394\":{\"h\":\"Ubuntu20.04下安装MySQL5.7\",\"t\":[\"Ubuntu18.04下安装MySQL，默认安装的事MySQL8.0\"]},\"1395\":{\"h\":\"下载安装包（这里以5.7.37为例）\",\"t\":[\"MySQL :: Download MySQL Community Server (Archived Versions)\",\"选择Ubuntu Linux 18.04 (x86, 64-bit), DEB Bundle\",\"wget https://downloads.mysql.com/archives/get/p/23/file/mysql-server_5.7.37-1ubuntu18.04_amd64.deb-bundle.tar \"]},\"1396\":{\"h\":\"解压安装包\",\"t\":[\"对于路径多多使用tab键\",\"tar -xvf mysql-server_5.7.32-1ubuntu18.04_amd64.deb-bundle.tar \"]},\"1397\":{\"h\":\"安装MySQL5.7.32\",\"t\":[\"# 更新依赖源 sudo apt-get update sudo apt-get upgrade # 安装libaio1、libtinfo5依赖 sudo apt-get install libaio1 sudo apt-get install libtinfo5 # 依次安装 sudo dpkg -i mysql-common_5.7.32-1ubuntu18.04_amd64.deb sudo dpkg-preconfigure mysql-community-server_5.7.32-1ubuntu18.04_amd64.deb #此步需要输入数据的root密码 sudo dpkg -i libmysqlclient20_5.7.32-1ubuntu18.04_amd64.deb sudo dpkg -i libmysqlclient-dev_5.7.32-1ubuntu18.04_amd64.deb sudo dpkg -i libmysqld-dev_5.7.32-1ubuntu18.04_amd64.deb sudo dpkg -i mysql-community-client_5.7.32-1ubuntu18.04_amd64.deb sudo dpkg -i mysql-client_5.7.32-1ubuntu18.04_amd64.deb sudo dpkg -i mysql-common_5.7.32-1ubuntu18.04_amd64.deb # 继续安装依赖 sudo apt-get -f install sudo apt-get -f install libmecab2 # 安装mysql－server sudo dpkg -i mysql-community-server_5.7.32-1ubuntu18.04_amd64.deb sudo dpkg -i mysql-server_5.7.32-1ubuntu18.04_amd64.deb # 检测安装 mysql -u root -p \"]},\"1398\":{\"h\":\"安装完成之后，输入下面命令进行查看\",\"t\":[\"netstat -tap | grep mysql \",\"通过上述命令检查之后，如果看到有 mysql 的socket处于 LISTEN 状态则表示安装成功\"]},\"1399\":{\"h\":\"使用c/c++操作mysql数据库之前需要安装MySQL库\",\"t\":[\"#安装MySQL客户端依赖包，后面进行编程时候需要使用 $ sudo apt install libmysqlclient-dev \",\"mysql头文件在/usr/include/mysql/目录下\",\"#include <mysql/mysql.h> \"]},\"1400\":{\"h\":\"配置MySQL\"},\"1401\":{\"h\":\"初始化配置\",\"t\":[\"sudo mysql_secure_installation \",\"image-20240305232223229\"]},\"1402\":{\"h\":\"检查MySQL的服务状态，输入如下命令\",\"t\":[\"$ systemctl status mysql.service #或者使用如下命令(两者都可以查看当前MySQL的状态) $ sudo service mysql status \",\"image-20240305232611466\"]},\"1403\":{\"h\":\"登录MySQL\",\"t\":[\"mysql -u root -p \"]},\"1404\":{\"h\":\"ubuntu18.04安装MySQL异常问题\"},\"1405\":{\"h\":\"卸载MySQL\",\"t\":[\"如果在安装MySQL过程中安装多次都失败了，可以选择先清除MySQL，方法步骤如下。\",\"首先在系统终端中查看MySQL的依赖项，运行命令\",\"dpkg --list|grep mysql \",\"卸载命令\",\"sudo apt-get remove mysql-common sudo apt-get autoremove --purge mysql-server-5.7 # 清除残留数据，运行命令 dpkg -l|grep ^rc|awk '{print$2}'|sudo xargs dpkg -P \",\"再次查看MySQL的剩余依赖项，运行命令\",\"dpkg --list|grep mysql # 继续删除剩余依赖项，如： sudo apt-get autoremove --purge mysql-apt-config # 继续运行步骤1中的命令 dpkg --list|grep mysql #直到执行该命令后什么都没有显示。 \"]},\"1406\":{\"h\":\"安装MySQL中常见问题\"},\"1407\":{\"h\":\"密码设置问题ERROR 1819 (HY000): Your password does not satisfy the current policy\",\"t\":[\"requirements\",\"密码设置一直不符合要求，其实就是密码设置简单了，稍微设置复杂点即可，或者修改密码设置等级与 长度。 可能出现的就是这个报错\",\"ERROR 1819 (HY000): Your password does not satisfy the current policy requirements \",\"可以在mysql中进行如下修改：\",\"mysql> #这个标志表示已经成功进入mysql命令行界面 #然后在mysql命令行输入命令（以分号结尾） mysql> use mysql; mysql> SHOW VARIABLES LIKE 'validate_password%'; +--------------------------------------+--------+ | Variable_name | Value | +--------------------------------------+--------+ | validate_password_check_user_name | OFF | | validate_password_dictionary_file | | | validate_password_length | 8 | | validate_password_mixed_case_count | 1 | | validate_password_number_count | 1 | | validate_password_policy | MEDIUM | | validate_password_special_char_count | 1 | +--------------------------------------+--------+ 7 rows in set (0.08 sec) mysql> #然后设置密码策略为简单 mysql> set global validate_password_policy=LOW; Query OK, 0 rows affected (0.00 sec) mysql> #设置密码长度为4 mysql> set global validate_password_length=4; Query OK, 0 rows affected (0.00 sec) mysql> #然后在继续查看密码相关信息 mysql> show variables like 'validate_password%'; +--------------------------------------+-------+ | Variable_name | Value | +--------------------------------------+-------+ | validate_password_check_user_name | OFF | | validate_password_dictionary_file | | | validate_password_length | 4 | | validate_password_mixed_case_count | 1 | | validate_password_number_count | 1 | | validate_password_policy | LOW | | validate_password_special_char_count | 1 | +--------------------------------------+-------+ 7 rows in set (0.00 sec) mysql> #接着输入如下命令（以分号结尾），有四个命令，相应的'你的命名'换成自己想设计的密码， mysql> update mysql.user set authentication_string=password('你的密码，四位') where user='root' and Host ='localhost'; mysql> update user set plugin=\\\"mysql_native_password\\\"; mysql> flush privileges; mysql> quit; \"]},\"1408\":{\"h\":\"使用远程登录的配置修改\",\"t\":[\"进入配置文件修改相应配置，命令如下：\",\"sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf \",\"注释掉bind-address = 127.0.0.1，\",\"保存退出，然后进入mysql数据库，\",\"mysql -u root -p # 执行授权命令 #你的密码需要自己设置，不要直接复制 mysql> grant all on *.* to root@'%' identified by '你的密码' with grant option; # 刷新权限 mysql> flush privileges; #然后执行exit命令退出mysql服务 mysql> exit; \",\"再执行如下命令重启mysql\",\"systemctl restart mysql \"]},\"1409\":{\"h\":\"MySQL常用命令\",\"t\":[\"#查看MySQL的状态 $ sudo service mysql status #MySQL的启动 $ sudo service mysql start #MySQL的停止 $sudo service mysql stop \",\"show global variables like 'port'; #查看mysql端口号 \"]},\"1410\":{\"h\":\"设置MySQL的自动补全功能\",\"t\":[\"$ cd /etc/mysql/mysql.conf.d/ $ sudo vim mysqld.cnf \",\"在下面加入一行auto-rehash，显示如下：\",\"image-20240305235207200\",\"然后保存退出\",\"当你在vim中编辑了一个文件，并想以超级用户权限保存它时，你可以使用 :w!sudo tee % 命令。这实际上会执行以下步骤：\",\"首先，w! 会尝试保存当前文件，即使它是只读的或你没有写入权限。\",\"然后，sudo tee % 会以超级用户权限将vim编辑器中的内容写入到当前编辑的文件中。\",\"然后必须要重启MySQL，命令如下\",\"sudo service mysql start \",\"这样在MySQL中就可以进行自动联想功能（类似Linux下的命令行一样，也是Tab键。注意：只能联想表和列的名字，并没有Linux下面的功能强大）。\"]},\"1411\":{\"h\":\"在重启MySQL时候如果出现打不开，可以查看日志\",\"t\":[\"查看系统日志\",\"vim /var/log/syslog #在里面搜索关键字mysql、erro \",\"查看MySQL自己的日志\",\"vim /var/log/mysql/error.log \"]},\"1412\":{\"c\":[\"mysql\"]},\"1413\":{\"c\":[\"安装方法\"]},\"1414\":{\"h\":\"关系型数据库表设计\"},\"1415\":{\"h\":\"一对一\",\"t\":[\"主要是通过外键实现\",\"父表：被依赖/关联的表\",\"子表：设置外键的表\",\"#用户表 User 父表 uid name age sex 1100 zhang 20 M 1000 liu 19 F 2000 wang 21 M #身份信息 Info 子表 cardid addrinfo 131331 aaaaa 646465 bbbbb 894946 ccccc \",\"在子表添加一列关联父表的主键（），一般放到服务层实现，现在不在mysql上做，减轻mysql压力\",\"#用户表 User 父表 uid name age sex 1100 zhang 20 M 1000 liu 19 F 2000 wang 21 M #身份信息 Info 子表 uid cardid addrinfo 2000 131331 aaaaa 1000 646465 bbbbb 1100 894946 ccccc \"]},\"1416\":{\"h\":\"一对多\",\"t\":[\"image-20240404103638709\"]},\"1417\":{\"h\":\"多对多\",\"t\":[\"可以发现上述表中存在大量的冗余信息=》如果加减商品或者价格变动，需要修改多项数值\",\"image-20240404103955415\",\"image-20240404110003096\"]},\"1418\":{\"c\":[\"mysql\"]},\"1419\":{\"c\":[\"mysql基础\"]},\"1420\":{\"h\":\"基本数据类型\"},\"1421\":{\"h\":\"数值类型\",\"t\":[\"image-20240406204529908\"]},\"1422\":{\"h\":\"选取适当的数据类型\",\"t\":[\"比如age TINYINT; 不要写成age int\"]},\"1423\":{\"h\":\"选数据类型两个原则\",\"t\":[\"是否越界 （text类型评论发送不了全文）\",\"精度是否足够（float 7; double 15）\"]},\"1424\":{\"h\":\"INT(7) 什么意思\",\"t\":[\"int底层内存存储的数据大小固定不变（INT 类型总是占用 4 个字节的存储空间，无论括号中的数字是多少），括号内数字是一个显示时显示的宽度；即，与显示和格式化有关，与数据的实际存储或值域无关\"]},\"1425\":{\"h\":\"字符串类型\",\"t\":[\"image-20240406204601492\",\"字符串使用单引号'name'\",\"varchar使用的时候要指定大小，如varchar(50)\"]},\"1426\":{\"h\":\"varchar与char的区别：\",\"t\":[\"首先明确的是，char的长度是不可变的，而varchar的长度是可变的。\",\"定义一个char[10]和varchar[10],如果存进去的是‘abcd’,那么char所占的长度依然为10，除了字符‘abcd’外，后面跟六个空格，而varchar就立马把长度变为4了；。\",\"char的存取数度还是要比varchar要得多，因为其长度固定，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率，而varchar是以空间效率为首位的。\",\"char的存储方式是，对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节；而varchar的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节，。\"]},\"1427\":{\"h\":\"日期和时间类型\",\"t\":[\"image-20240406204703570\",\"select unix_timestamp(now());距离1970-1-1的秒数\"]},\"1428\":{\"h\":\"enum和set\",\"t\":[\"enum枚举只能取其中一个数据类型\",\"create table students( id int auto increment primary key, name varchar(20), gender enum('male', 'female') #字符串用单引号 ); insert into students(name, gender) values('zhangsan', 'male'),('lisi', 'female'); creata table orders( id int auto_increment primary ket, product_name varchar(100), payment_methods set('cash', 'credit card', 'debit card') ); insert into orders(product_name, payment_methods) values('book', 'credit card, cash'); \"]},\"1429\":{\"c\":[\"mysql\"]},\"1430\":{\"c\":[\"mysql基础\"]},\"1431\":{\"h\":\"完整性约束/约束条件\"},\"1432\":{\"h\":\"主键约束\",\"t\":[\"primary key不能重复；不能为空；能唯一标识一条记录\"]},\"1433\":{\"h\":\"自增键约束\",\"t\":[\"auto_increment，不能用于字符串\"]},\"1434\":{\"h\":\"唯一键约束\",\"t\":[\"unique保证索引不重复-唯一索引；可以为空；可以用not null约束；default 设置默认值\"]},\"1435\":{\"h\":\"非空约束\",\"t\":[\"not null\"]},\"1436\":{\"h\":\"默认值约束\",\"t\":[\"default\"]},\"1437\":{\"h\":\"外键约束\",\"t\":[\"foreign key另一个表的主键；可以重复；可以为空\",\"create table user( id int primary key auto_increment comment '主键索引', nickname varchar(50) unique not null comment '昵称'， age tinyint unsigned not null default 18, sex enum('male', 'female') ); \",\"image-20240406214640176\",\"现代的后端开发中  外键、存储函数、存储过程、触发器...这些限制逻辑或者代码逻辑是由MySQL本身控制的，现在性能瓶颈在于存储层逻辑，所以主要核心CRUD由MySQL做，其他的，减少MySQL的压力\"]},\"1438\":{\"c\":[\"mysql\"]},\"1439\":{\"c\":[\"mysql基础\"]},\"1440\":{\"h\":\"常用函数\"},\"1441\":{\"h\":\"字符串函数\"},\"1442\":{\"h\":\"数值函数\"},\"1443\":{\"h\":\"时间和日期函数\",\"t\":[\"NOW()：返回当前的日期和时间 UNIX_TIMESTAMP(data)：返回日期date的UNIX时间戳 CURRENT_TIMESTAMP、CURRENT_TIMESTAMP() ：当前时间 CURDATE()：当前日期 CURTIME()：当前时间 DATE_FORMAT(date, \\\"%y-%m-%d\\\")：格式化日期时间等 \"]},\"1444\":{\"h\":\"聚合函数\",\"t\":[\"count、sum、avg、max、min \"]},\"1445\":{\"c\":[\"mysql\"]},\"1446\":{\"c\":[\"mysql基础\"]},\"1447\":{\"h\":\"用户管理与授权\",\"t\":[\"查看用户信息： select user,host,plugin from mysql.user; 创建用户示例： create user 'stu'@'localhost' identified by '123456'; 创建用户指定加密方式 示例：create user 'stu1'@'localhost' identified WITH mysql_native_password by '123456'; 更新用户密码，指定加密方式，注意密码强度大小写数字： ALTER user 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456'; 授权用户对那些数据库的那些表可以进行操作 示例： GRANT SELECT ON database_name.table_name TO 'user_name'@'localhost'; GRANT INSERT ON database_name.table_name TO 'user_name'@'localhost'; GRANT ALL ON database_name.table_name TO 'user_name'@'localhost'; GRANT ALL PRIVILEGES ON *.* TO 'user_name'@'%'; -- * 表示任意所有库、所有表，%表示任意地址 删除用户：drop user 'name'@'localhost'; \"]},\"1448\":{\"c\":[\"mysql\"]},\"1449\":{\"c\":[\"mysql基础\"]},\"1450\":{\"h\":\"知识拓展\"},\"1451\":{\"h\":\"什么是关系型数据库？\",\"t\":[\"**关系型数据库（RDBMS）**是建立在关系模型基础上的数据库系统。关系模型是一种数据模型，它表示数据之间的联系，包括一对一、一对多和多对多的关系。在关系型数据库中，数据以表格的形式存储，每个表格称为一个“关系”，每个关系由行（记录或元组）和列（字段或属性）组成。\",\"每个关系都有一个唯一的标识符，称为“主键”，用于唯一标识关系中的每一行数据。主键可以是单列或多列的组合，其值能够唯一地标识关系中的每一行数据。\"]},\"1452\":{\"h\":\"常见的数据库有哪些？\",\"t\":[\"关系型数据库 \",\"MySQL、Oracle、MariaDB(MySQL作者担心MySQL收购后收费写的)\",\"安卓开发使用的SQList（进程类的数据库，不同进程访问不同的SQList；Mysql是基于C/S，多个进程访问同一个MySQL数据库）\",\"金融行业使用的DB2\",\"非关系型数据库 key-value \",\"NoSQL、Redis\",\"HBase（大数据分析列式数据库）\"]},\"1453\":{\"h\":\"MySQL区别于其他关系型数据库的特点\",\"t\":[\"引擎是插件式的，常用的引擎有MyISAM InnoDB Memory\"]},\"1454\":{\"h\":\"MySQL的服务模型是？\",\"t\":[\"I/O复用+可伸缩的线程池\"]},\"1455\":{\"h\":\"epoll比select性能好，为什么不用epoll而是选用select?\",\"t\":[\"最主要原因在于访问数据库涉及到磁盘IO，磁盘IO速度慢，select性能足够\"]},\"1456\":{\"c\":[\"mysql\"]},\"1457\":{\"c\":[\"mysql基础\"]},\"1458\":{\"h\":\"范式设计\"},\"1459\":{\"h\":\"范式设计好处\",\"t\":[\"主要是为了减少数据冗余\",\"如果冗余太多，那么数据插入、删除、更新的时候，要对多条记录的同样的数据进行更新删除，可能会产生问题\"]},\"1460\":{\"h\":\"第一范式（1NF）\",\"t\":[\"满足第一范式才被称为关系型数据库。每一列保持原子特性，不能再分割。则设计成一对多的实体关系。例如地址字段，可以再细分为省，市，区等不可再分割（即原子特性）的字段\"]},\"1461\":{\"h\":\"第二范式（2NF）\",\"t\":[\"主要针对联合主键，，则设计成一对多的实体关系。\",\"例如：选课关系表为SelectCourse(学号, 姓名, 年龄, 课程名称, 成绩, 学分)，（学号，课程名称）是联合主键，但是学分字段只和课程名称有关，和学号无关，相当于只依赖联合主键的其中一个字段，不符合第二范式。\",\"表1 学号 姓名 年龄 成绩 课程id 表2 课程id 课程名称 学分 \",\"image-20240407090807653\"]},\"1462\":{\"h\":\"第三范式（3NF）\",\"t\":[\"属性不依赖于其它非主属性\",\"示例：学生关系表为Student（学号， 姓名， 年龄， 所在学院， 学院地点， 学院电话），学号是主键，但是学院电话只依赖于所在学院，并不依赖于主键学号，因此该设计不符合第三范式，应该把学院专门设计成一张表，学生表和学院表，两个是一对多的关系。\",\"image-20240407084815669\"]},\"1463\":{\"h\":\"BC范式（BCNF）\",\"t\":[\"每个表只有一个候选键（除了主键，其他键是可以重复存储的）\",\"候选键：在一个数据库中每行的值都不相同，则可称为候选键\",\"示例：在上面第三范式的noNF表，中可以看出，每一个员工的email都是唯一的（不可能两个人用同一个email），则此表不符合BC范式，拆成一对一\",\"image-20240407085829027\"]},\"1464\":{\"h\":\"第四范式（4NF）\",\"t\":[\"消除表中的多值依赖\",\"也就是说可以减少维护数据一致性的工作。比上图的noNF表中的skill技能这个字段，有的人是“java，mysql”，有的人描述的是“Java，MySQL”，这样数据就不一致了，解决办法就是将多值属性放入一个新表，所以满足第四范式的关系图如下：\",\"image-20240407090151306\",\"image-20240407090705269\"]},\"1465\":{\"h\":\"不满足的范式的表怎么办\",\"t\":[\"视情况拆分成一对一、一对多、多对多的关系\"]},\"1466\":{\"c\":[\"mysql\"]},\"1467\":{\"c\":[\"mysql基础\"]},\"1468\":{\"h\":\"mysql运算符\"},\"1469\":{\"h\":\"算数运算符\",\"t\":[\"image-20240406210003709\",\"运算后的结果如果需要存储在表内，需要注意\",\"update user set age = age + 1 \"]},\"1470\":{\"h\":\"逻辑运算符\",\"t\":[\"image-20240406210021446\",\"取反：当满足条件时，返回不满足条件的部分（ 使用！记得加上括号() ）\"]},\"1471\":{\"h\":\"比较运算符\",\"t\":[\"image-20240406210040984\",\"不等于 用!=\",\"区间 between\",\"判断是否为空 is NULL; is not NULL\",\"通配符 LIKE\",\"_匹配一个字符 %匹配一个到多个字符\",\"通配符在最前面不能使用索引查询；在中间或后面可以使用索引\",\"select * insert Employeeaddress where addressID in (select AddressID from noNF where EmployeeID=1); \",\"in的效率其实不高\"]},\"1472\":{\"c\":[\"mysql\"]},\"1473\":{\"c\":[\"mysql基础\"]},\"1474\":{\"h\":\"mysql CRUD操作\",\"t\":[\"涉及一些的过程\"]},\"1475\":{\"h\":\"insert增加\",\"t\":[\"可以先在本地文本编辑器写，然后复制到shell运行，记录命令\",\"insert into user values(1,'zhang san', 22, 'male'); #不要这样写，因为后面可以会涉及字段的增删，这样写数据和字段（个数、顺序、类型）必须一一对应 insert into user(name, age, sex) values('zhang san', 22, 'male'); #这样写即使字段顺序不一致也无所谓 insert into user(name, age, sex) values('zhang san', 22, 'male'),('li si', 21, 'female'),('wang wu', 18, 'male'); \",\"image-20240407131732168\"]},\"1476\":{\"h\":\"每次插入一条 和 一次插入多条 的区别在于：\",\"t\":[\"下面的方法能够减少tcp\",\"所以一般项目都会用到连接池，项目一般只有几个或十几个人可以不用连接池，稍微有点流量必须使用连接池减少数据操作时的网络握手和挥手的过程\"]},\"1477\":{\"h\":\"注意：\",\"t\":[\"当插入数据时**，那么该字段插入。若创建表时字段没有显示的指定默认值时，默认值插入**\",\"insert into person(name) values(\\\"王五\\\"); \",\"image-20240413094600216\"]},\"1478\":{\"h\":\"update修改\",\"t\":[\"update user set age=age+1 where name='zhang san'; \"]},\"1479\":{\"h\":\"注意\",\"t\":[\"UPDATE语句通常都要添加WHERE子句，用于添加要修改记录的条件，否则！\"]},\"1480\":{\"h\":\"delete删除\",\"t\":[\"delete from user where id=1; delete from user where age between 10 and 18; delete from user; #表数据清空了 \",\"注意：即使delete from user;都清空了，id也是继续增加，不是从1开始\"]},\"1481\":{\"h\":\"主键id是自增的有上限，用完了能否复用被删掉的id？\",\"t\":[\"，`auto_increment`自增，只能往上加，当到达上限后就会插入失败；可以\",\"一般一个表的数据不会超过千万级，否则查询速度太慢了=>水平或垂直分库分表操作\"]},\"1482\":{\"c\":[\"mysql\"]},\"1483\":{\"c\":[\"mysql核心SQL\"]},\"1484\":{\"h\":\"DCL语句小结\"},\"1485\":{\"h\":\"(1)授予权限grant\",\"t\":[\"grant 权限 on 库名.* to “用户名”； select//查询权限 update//修改权限 insert//插入权限 delete//删除权限 create//创建数据库、表的权限 drop//删除数据库、表的权限 all//所有权限 \"]},\"1486\":{\"h\":\"(2)回收权限revoke：\",\"t\":[\"revoke 权限 on 库名.* from “用户名”；//权限回收不能越级，也不能反祖。 //也可以授予多个权限只回收部分权限。 select//查询权限 update//修改权限 insert//插入权限 delete//删除权限 create//创建数据库、表的权限 drop//删除数据库、表的权限 all//所有权限 \"]},\"1487\":{\"c\":[\"mysql\"]},\"1488\":{\"c\":[\"mysql核心SQL\"]},\"1489\":{\"h\":\"DML语句小结\",\"t\":[\"DML数据操作语言：操纵数据，针对数据的增删改查；\"]},\"1490\":{\"h\":\"(1)增insert：\",\"t\":[\"insert into 表名 values(数据的集合)；//添加一条数据； insert into 表名(字段名1，字段名2，字段名3) values(“数据1”，“数据2”，“数据3”)； //添加指定字段数据，其他系统默认； insert into 表名 values(数据集合1)，(数据集合2)，(数据集合3)；//insert进行小批量数据插入 \"]},\"1491\":{\"h\":\"(2)删delete：\",\"t\":[\"delete from 表名；//删除表中所有数据 delete from 表名 where 字段名 = “数据”； //过滤数据，符合该条件的删除； \"]},\"1492\":{\"h\":\"(3)改update：\",\"t\":[\"update 表名 set 字段名 = “新的数据” where 字段名 = “旧的数据”；//修改数据，有过滤条件。 update 表名 set 字段名 = “新的数据”； //修改表中所有数据 \"]},\"1493\":{\"h\":\"(4)查select：\"},\"1494\":{\"h\":\"1.普通查询\",\"t\":[\"select * from 表名；// * 表示通匹表中所有字段，不建议使用，易泄露信息； select 字段名1，字段名2，字段名3… from 表名；//等值于上面的查询 select * from 表名 where 字段名 = “数据”； //有过滤条件 \"]},\"1495\":{\"h\":\"2.去重查询\",\"t\":[\"select distinct 字段名 from 表名；//重复的只出现一次 \"]},\"1496\":{\"h\":\"3.排序查询\",\"t\":[\"select distinct 字段名 from 表名 order by 字段名；//不加asc，系统默认加升序查询 select distinct 字段名 from 表名 order by 字段名 asc；//升序排序查询 select distinct 字段名 from 表名 order by 字段名 desc；//降序排序查询 \"]},\"1497\":{\"h\":\"4.分组查询:Sum()相加，count统计数据个数，year获取年份\",\"t\":[\"select 字段名，操作名(字段名2) from 表名 group by 字段名； //进行分组查询:先分组，再在组内查询。 \"]},\"1498\":{\"h\":\"5.等值查询：按照笛卡尔乘积方式处理，效率太低\"},\"1499\":{\"h\":\"6.连接查询:先将范围缩小，再按照笛卡尔乘积方式处理，效率提高。\"},\"1500\":{\"h\":\"6.1外连接查询\",\"t\":[\"左外连接查询：左表过滤的结果必须全部存在;右表匹配左表过滤后的结果若匹配成功，补成功的数据，否则补NULL； 左外连接使用的十分多。\",\"select 左表.字段名1，字段名2 from select 字段名1，字段名2 from 左表 where 字段名2 判断条件 //过滤左表数据 left join select 字段名1， 字段名3 from 右表 where 字段名 判断条件 //过滤右表数据 on 左表.字段名1 = 右表.字段名1； \",\"右外连接查询:右表过滤的结果必须全部存在;左表匹配右表过滤后的结果若匹配成功，补成功的数据，否则补NULL； 右外连接使用的不是非常多。\",\"select 左表.字段名1，字段名2 from select 字段名1，字段名2 from 左表 where 字段名2 判断条件 //过滤左表数据 right join select 字段名1， 字段名3 from 右表 where 字段名 判断条件 //过滤右表数据 on 左表.字段名1 = 右表.字段名1； \",\"全外连接查询: 左表和右表数据全部都存在，与左外连接、右对应一边不存在则补空。**\",\"select 左表.字段名1，字段名2 from select 字段名1，字段名2 from 左表 where 字段名2 判断条件 //过滤左表数据 full join select 字段名1， 字段名3 from 右表 where 字段名 判断条件 //过滤右表数据 on 左表.字段名1 = 右表.字段名1； \"]},\"1501\":{\"h\":\"6.2内连接查询：只筛选匹配项，不匹配不显示。\",\"t\":[\"select 左表.字段名1，字段名2 from select 字段名1，字段名2 from 左表 where 字段名2 判断条件 //过滤左表数据 inner join select 字段名1， 字段名3 from 右表 where 字段名 判断条件 //过滤右表数据 on 左表.字段名1 = 右表.字段名1； \"]},\"1502\":{\"h\":\"7.聚合查询:\",\"t\":[\"​ ①聚合查询1：带去重效果；\",\"select * from 表1 union select * from 表2； \",\"​ ①聚合查询2：不带去重效果；\",\"select * from 表1 union all select * from 表2； \"]},\"1503\":{\"c\":[\"mysql\"]},\"1504\":{\"c\":[\"mysql核心SQL\"]},\"1505\":{\"h\":\"mysql的库操作\"},\"1506\":{\"h\":\"库操作\",\"t\":[\"查询数据库\",\"show databases; \",\"创建数据库\",\"create database ChatDB; \",\"drop database ChatDB; \",\"选择数据库\",\"use ChatDB; \"]},\"1507\":{\"h\":\"库操作小结\",\"t\":[\"(1)增create：\",\"create database 库名；创建一个数据库； create database if not exists 库名；存在则创建，否则不创建； \",\"(2)删dorp：\",\"drop database 库名；删除一个数据库； drop database if exists 库名；存在则删除，否则不删除； \",\"(3)改later： 基本不用； (4)查show：\",\"show databases；查看整个库下所有的数据库； show create database 库名；查看一个库的创建信息； show tables；查看该库层面下的所有表； \",\"(5)用use：\",\"use 库名；选定一个库使用； \"]},\"1508\":{\"h\":\"其他\",\"t\":[\"数据库下清屏语句：system clear；\",\"-- 查看当前数据库 SELECT DATABASE(); -- 显示当前时间、用户名、数据库版本 SELECT now(), user(), version(); \"]},\"1509\":{\"c\":[\"mysql\"]},\"1510\":{\"c\":[\"mysql核心SQL\"]},\"1511\":{\"h\":\"单表select查询\",\"t\":[\"select * from user; \",\"项目中很少使用select * from user; ，而是（）\",\"因为可能后期表结构会根据需求调整，可能会出现没有预料的列出现\",\"一下就查询到客户的所有信息，容易造成信息泄露，而第二种方法虽然麻烦点，但是安全程度更高\",\"select name,age,sex from user; \",\"select后面选择的具体的列需要具体考虑，因为会涉及****问题，回表会降低查询效率\",\"select name from user where age>21 and sex='male'; select name,age,sex from user where age>=21 and age<=25; select name,age,sex from user where age between 21 and 25; \",\"select name,age,sex from user where name like 'zhang%'; select name,age,sex from user where name like 'zhang_'; select name,age,sex from user where name like '%si%'; \"]},\"1512\":{\"h\":\"去重 distinct\",\"t\":[\"查看哪个年龄段有分布-\",\"select distinct age from user; \",\"虽然group by也能去重，但是group by功能强大也耗时，可以使用distinct\"]},\"1513\":{\"h\":\"空值查询\",\"t\":[\"select name,age,sex from user where name is null; select name,age,sex from user where name is not null; \"]},\"1514\":{\"h\":\"union 合并 查询\",\"t\":[\"UNION [ALL | DISTINCT] # 注意：union默认去重，不用修饰distinct，\",\"select name,age,sex from user where age>22 or sex='male'; select name,age,sex from user where age>22 union all select name,age,sex from user where sex='male'; \",\"仅看====\"]},\"1515\":{\"h\":\"带 in 子查询\",\"t\":[\"select name,age,sex from user where age in (20,21); select name,age,sex from user where age not in (20,21); select name,age,sex from user where id in(select id from user where age>21); \",\"image-20240407162501541\"]},\"1516\":{\"h\":\"分页查询 limit\",\"t\":[\"select * from user limit 3; #limit 0,3 select * from user limit 2,3; select * from user limit 3 offset 2; #为了兼容其他关系型数据库的分页语法 \"]},\"1517\":{\"h\":\"limit只是对select显示条数进行限制了，还是说还能影响SQL的查询效率呢？\"},\"1518\":{\"h\":\"mysql是如何查询的\",\"t\":[\"mysql是查找名字为“lisi”的记录，是只找前两行还是全部查找后返回第二行？？？\"]},\"1519\":{\"h\":\"如何提高查询效率？\",\"t\":[\"关系型数据库就是二维表，效率的高低取决于扫描表的数据量 ，扫的少效率就高，扫地多效率就低\"]},\"1520\":{\"h\":\"explain 查看执行计划\",\"t\":[\"explain可以将执行语句的执行过程和一些关键信息罗列出来\"]},\"1521\":{\"h\":\"explain各个字段代表的意思\",\"t\":[\"id ：select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序\",\"例子中属于单表搜索，没有联合搜索和多表的查询，因此只有1行\",\"select_type ：查询类型 或者是 其他操作类型\",\"SIMPLE 简单查询，不包括子查询和union查询\",\"table ：正在访问哪个表\",\"partitions ：匹配的分区\",\"type ：访问的类型\",\"NULL > system > const > eq_ref > ref > ref_or_null > index_merge > range > index > ALL \",\"索引查询是const常量级的时间，表示不管哪个位置查询效率/时间是一样的\",\"possible_keys ：显示可能应用在这张表中的索引，一个或多个，但不一定实际使用到\",\"key ：实际使用到的索引，如果为NULL，则没有使用索引\",\"如果字段类型是unique，会自动创建一个唯一键索引\",\"key_len ：表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度\",\"ref ：显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或常量被用于查找索引列上的值\",\"rows ：表示查询时扫描的行数\",\"没有加索引就会全文扫描\",\"是索引，只扫1行\",\"filtered ：查询的表行占表的百分比\",\"Extra ：包含不适合在其它列中显示但十分重要的额外信息\",\"image-20240416141102785\",\"image-20240416140713583\"]},\"1522\":{\"h\":\"limit对于查询的作用\",\"t\":[\"虽然explain查看执行计划显示全文扫描，实际上mysql看到用户只需要1条数据，查询到就会截至查询并返回；\"]},\"1523\":{\"h\":\"快速插入海量数据- 存储过程\",\"t\":[\"delimiter $ #修改语句结束的符号 ; -> $ Create Procedure add_t_user (IN n INT) #add_t_user 函数名字；n为int型输入变量, out可以定义输出变量 BEGIN DECLARE i INT; #声明变量, 赋初值也可以这样写declare i int default 0 SET i=0; #如果不修改语句结束符这里分号;代表着语句的结束 WHILE i<n DO #循环条件i<n 循环开始DO INSERT INTO t_user VALUES(NULL,CONCAT(i+1,'@ﬁxbug.com'),i+1); SET i=i+1; END WHILE; #开始循环不加分号，结束循环需要加 END$ #函数结束 delimiter ; #修改回来 call add_t_user(2000000); #调用 \"]},\"1524\":{\"h\":\"limit实际应用的优化\",\"t\":[\"分页查询中，上，因此****\"]},\"1525\":{\"h\":\"排序order by\",\"t\":[\"select id,nickname,name,age,sex from user where sex='M' and age>=20 and age<=25 order by age asc; #以age升序，不写默认也是升序 select id,nickname,name,age,sex from user where sex='M' and age>=20 and age<=25 order by age desc; #以age降序 select id,nickname,name,age,sex from user where sex='M' and age>=20 and age<=25 order by age,name asc; #总体以age升序，当age相同时再以name升序 \",\"image-20240416155709023\",\"当数据量比较大时order by可能会出现比较耗时情况，然后通过explain查看执行计划，发现这条语句涉及到了外排序\",\"外排序涉及到了磁盘IO，所以慢\",\"如果数据量太大，无法一次性弄到内存中怎么办呢？这种情况下的排序称为外排序。外排序——归并思想的实现_外排序归并问题的算法思想-CSDN博客\",\"优化：\",\"order by后以索引进行排序\",\"注意select后的字段是否涉及到了回表查询\"]},\"1526\":{\"h\":\"分组group by\",\"t\":[\"select age,count(age) as count from user group by age; select age,count(age) as count from user group by age having age>20; #可以使用having对order by结果进行过滤 select age,count(age) as count from user where age>20 group by age; \"]},\"1527\":{\"h\":\"MySQL5.7 group by会自动排序，MySQL8.0没有\"},\"1528\":{\"h\":\"MySQL5.7\",\"t\":[\"MySQL5.7分析explain可以看到涉及到了外排序\"]},\"1529\":{\"h\":\"MySQL8.0\",\"t\":[\"image-20240416170741355\"]},\"1530\":{\"h\":\"注意\",\"t\":[\"order by和group by性能都和索引相关\"]},\"1531\":{\"h\":\"练习题\",\"t\":[\"下表bank_bill是某银行代缴话费的主流水表结构：\",\"字段名\",\"描述\",\"serno\",\"流水号\",\"date\",\"交易日期\",\"accno\",\"账号\",\"name\",\"姓名\",\"amount\",\"金额\",\"brno\",\"缴费网点\",\"1、统计表中缴费的总笔数和总金额\",\"select count(serno),sum(amount) from bank_bill; \",\"2、给出一个sql，按网点和日期统计每个网点每天的营业额，并按照营业额进行倒序排序\",\"select brno,date,sum(amount) as money from bank_bill group by brno,date order by brno,mone desc; \"]},\"1532\":{\"c\":[\"mysql\"]},\"1533\":{\"c\":[\"mysql核心SQL\"]},\"1534\":{\"h\":\"多表select-连接查询\"},\"1535\":{\"h\":\"为什么需要连接查询\",\"t\":[\"当单表设计不满足范式设计时需要进行拆分，因此可能涉及到多表查询。连接查询相比单表查询减少了TCP三次握手和四次挥手，也减少了mysql server对client sql的校验过程。当然，一般满足范式三即可，范式越高表越多，连接查询效率越低。\"]},\"1536\":{\"h\":\"概述\",\"t\":[\"左连接：指的是表1特有的数据\",\"内连接：指的是两个表的交集\",\"右连接：指的是表2特有的数据\"]},\"1537\":{\"h\":\"内连接\",\"t\":[\"#学生表 CREATE TABLE student( uid INT UNSIGNED PRIMARY KEY AUTO_INCREMENT, name VARCHAR(50) NOT NULL, age TINYINT UNSIGNED NOT NULL, sex ENUM('M', 'W') NOT NULL); #课程表 CREATE TABLE course( cid INT UNSIGNED PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(50) NOT NULL COMMENT '课程名称', credit TINYINT UNSIGNED NOT NULL COMMENT '学分'); #考试结果 CREATE TABLE exame( uid INT UNSIGNED NOT NULL, cid INT UNSIGNED NOT NULL, #time INT UNSIGNED NOT NULL, #int用时间戳表示考试时间 没有用date类型 time DATE NOT NULL, #DATE 年-月-日 比较明显 score FLOAT NOT NULL, PRIMARY KEY(uid,cid) #一个学生有多门课，一个课又有多个学生，但是这两个组合在一起就是唯一的，使用联合主键 ); \",\"insert into student (name, age,sex) values ('zhangsan', 18, 'M'), ('gaoyang', 20, 'W'), ('chenwei', 22, 'M'), ('linfeng', 21, 'W'), ('liuxiang', 19, 'W'); insert into course(cname,credit) values ('C++基础课程',5), ('C++高级课程',10), ('C++项目开发',8), ('C++算法课程',12); insert into exame (uid,cid, time,score) values (1,1,'2021-04-09', 99.0), (1,2,'2021-04-10', 80.0), (2,2,'2021-04-10', 90.0), (2,3,'2021-04-12', 85.0), (3,1,'2021-04-09', 56.0), (3,2,'2021-04-10', 93.0), (3,3, '2021-04-12', 89.0), (3,4, '2021-04-11', 100.0), (4,4,'2021-04-11', 99.0), (5,2,'2021-04-10', 59.0), (5,3,'2021-04-12', 94.0), (5,4,'2021-04-11', 95.0); \",\"#单表查询 select a.uid,a.name,a.age,a.sex from student as a where a.uid=1; select c.score from exame c where c.uid=1 and c.cid=2; #两张表的连接查询 select a.uid,a.name,a.age,a.sex,c.score from student as a inner join exame c on a.uid=c.uid where c.uid=1 and c.cid=2; \",\"别名as，可以省略\",\"内连接inner join 或者 join，inner也可以省略\",\"on 表示按什么连接\",\"连接语句中会先以数据量区分大表和小表，小表永远是整表扫描，然后去大表搜索\",\"数据量，是满足where过滤后每个表剩余的数据的量（有可能a原本有20行，b有10行，满足where过滤后a还有5行，b不变，那么a为小表，b为大表）\",\"因为小表永远整表扫描，有没有索引没意义\",\"索引是否用到和select没有关系，要看where过滤时有没有用到\",\"即，从student表中取出所有的a.uid，然后拿着这些uid去exame大表中搜索\",\"#三张表的联合查询 select a.uid,a.name,a.age,a.sex,b.cid,b.cname,b.credit,c.score from exame c inner join student a on c.uid=a.uid join course b on c.cid=b.cid where c.uid=1 and c.cid=2; \",\"先考虑表和表之间用什么字段关联，即先把表的连接写好，再写where过滤条件\"]},\"1538\":{\"h\":\"练习\",\"t\":[\"#获取每一门课考试人数 select b.cid,b.cname,count(*) from exame c join course b on c.cid=b.cid group by c.cid; \",\"#获取每一门课超过九十分的人数 select b.cid,b.cname,count(*) from exame c join course b on c.cid=b.cid where c.score>90 group by c.cid; \",\"#获取C++高级课程超过九十分的人数 select b.cid,b.cname,count(*) from exame c join course b on c.cid=b.cid where c.score>90 group by c.cid having c.cid=2; #having用在分组后过滤 #获取C++高级课程超过九十分的人数 select b.cid,b.cname,count(*) from exame c join course b on c.cid=b.cid where c.score>90 and c.cid=2; \",\"#获取每一门课超过九十分的人数并排序 select b.cid,b.cname,count(*) cnt from exame c join course b on c.cid=b.cid where c.score>90 group by c.cid order by cnt; select b.cid,b.cname,count(*) cnt from exame c join course b on c.cid=b.cid where c.score>90 group by c.cid order by cnt desc; \",\"#1、cid=2这门课程考试成绩的最高分的学生信息和课程信息 select a.uid,a.name,b.cid,b.cname,b.credit,c.cid,c.score from exame c join student a on c.uid = a.uid join course b on c.cid = b.cid where c.cid=2 order by c.score desc limit 1; #2、cid=2这门课程的考试平均成绩&每门课程考试的平均成绩+课程信息 select avg(score) from exame where cid=2; select b.cid,b.cname,b.credit,avg(score) from exame c join course b on c.cid=b.cid group by cid; \"]},\"1539\":{\"h\":\"与limit相结合\",\"t\":[\"select后字段的多少也会影响想查询效率\",\"select * from t_user limit 1500000,10; select id from t_user limit 1500000,10; select email from t_user limit 1500000,10; \",\"对于偏移量我们之前是使用where 优化的\",\"select * from t_user where id>2500000 limit 10 \",\"但是有些情况我们不知道具体偏移量是多少，又想获取多列信息，那么该如何优化\",\"select a.id,a.email,a.password from t_user a join (select id from t_user limit 1500000,10) b on a.id=b.id; \",\"原因在于小表是整表扫描获取id后存入到临时表，然后再去大表搜索，\"]},\"1540\":{\"h\":\"大小表\",\"t\":[\"#查看两个表内连接后两个表的所有信息 explain select a.*,b.* from student a join exame b on a.uid=b.uid; \",\"先执行where过滤，b就只剩3条数据，此时在进行内连接b就变成了小表，所以进行全表扫描\"]},\"1541\":{\"h\":\"条件过滤\",\"t\":[\"select a.*,b.* from student a join exame b on a.uid=b.uid where b.cid=3; select a.*,b.* from student a join exame b on a.uid=b.uid and b.cid=3; \",\"对于inner join内连接，过滤条件写在where的后面和on连接条件里面，效果是一样的\",\"where 可以使用索引过滤，效率上比较快\"]},\"1542\":{\"h\":\"外连接\"},\"1543\":{\"h\":\"左外连接查询\",\"t\":[\"// 把left这边的表所有的数据显示出来，在右表中不存在相应数据，则显示NULL select a.* from User a left outer join Orderlist b on a.uid=b.uid where a.orderid is null; \",\"outer 可以省略，加了left或right就左连接或右连接\"]},\"1544\":{\"h\":\"右外连接查询\",\"t\":[\"// 把right这边的表所有的数据显示出来，在左表中不存在相应数据，则显示NULL select a.* from User a right outer join Orderlist b on a.uid=b.uid where b.orderid is null; \",\"内连接小表全扫描\",\"左连接表边表全扫描，右边匹配左边，没有为NULL\",\"右连接右边表全扫描，左边匹配右边，没有为NULL\",\"# 查询所有没有考试的同学信息 select * from student where not uid in (select distinct uid from exame); select a.* from student a left join exame b on a.uid=b.uid where b.cid not is null; \",\"select distinct uid from exame会产生一张中间表存储结果供外面的sql查询 \",\"中间表也不一定都会产生，因为mysql server都会做优化，可以用explain 查看是否产生中间表\",\"not in\",\"in虽然会用到索引但是一般也会产生中间表，这也是为什么不喜欢用带in子查询的原因所在\",\"外连接如果on后面只写连接条件，过滤条件全写在where后，外连接就会和内连接查询结果一样\",\"对于查询不在的情况，where后面值判断是否为null，其他\"]},\"1545\":{\"c\":[\"mysql\"]},\"1546\":{\"c\":[\"mysql核心SQL\"]},\"1547\":{\"h\":\"SQL概述\"},\"1548\":{\"h\":\"结构化查询语句SQL（Structure Query Language）\",\"t\":[\"所有的关系型数据库都支持SQL语句\",\"SQL主要可以划分为以下 3 个类别：\",\"DDL（Data Deﬁnition Languages）语句-\",\"数据定义语言，这些语句定义了不同的数据库、表、列、索引等数据库对象的定义。常用的语句关键字主要包括 create、drop、alter等。\",\"DML（Data Manipulation Language）语句-\",\"数据操纵语句，用于添加、删除、更新和查询数据库记录，并检查数据完整性，常用的语句关键字主要包括 insert、delete、update 和select 等。\",\"用的最多就是查询select\",\"DCL（Data Control Language）语句\",\"数据控制语句，用于控制不同的许可和访问级别的语句。这些语句定义了数据库、表、字段、用户的。主要的语句关键字包括 grant、revoke 等。\"]},\"1549\":{\"c\":[\"mysql\"]},\"1550\":{\"c\":[\"mysql核心SQL\"]},\"1551\":{\"h\":\"mysql的表操作\",\"t\":[\"查看表\",\"show tables; \",\"创建表\",\"create table user( id int unsigned primary key auto_increment, name varchar(50) unique not null, age tinyint not null, sex enum(\\\"male\\\", \\\"female\\\") not null )engine=INNODB default charset=utf8; \",\"查看表结构\",\"desc user; \",\"查看建表sql\",\"show create table user\\\\G \",\"image-20240407114100091\",\"删除表\",\"drop table user; \",\"实践中一些接口如果老是报错，先用命令行执行api调用的SQL语句，看一下执行时间是否超时，比如sql执行时间为10s，而api设置的相应等待时间为5s，因此需要优化查询\"]},\"1552\":{\"h\":\"表操作小结\",\"t\":[\"(1)增create：\",\"create table 表名 ( 字段名称 字段类型 字段约束 [注释]， 字段名称 字段类型 字段约束 [注释]， … )；//创建一个表； \",\"添加注释COMMENT\",\"字符集：latin1特点为：不能存储中文；若想存储中文使用utf8\",\"(2)删drop：\",\"drop table 表名；删除一个表 \",\"(3)改alter：\",\"alter table 表名 modify 字段名称 字段新类型； //修改字段类型方式1 alter table 表名 change 字段名称 字段名称 新字段类型； //修改字段类型方式2 alter table 表名 change 旧字段名 新字段名 新字段类型； //修改字段名 alter table 表名 add 新字段 类型 约束； //表中新添加一个字段 alter table 表名 add 新字段 类型 约束 after 某字段名； //添加一个字段到任意位置之后(除了第一个位置无法处理) alter table 表名 add 新字段 类型 约束 first； //添加一个字段到首位置 alter table 表名 drop 字段名； //删除字段 alter table 表名 rename 新表名； //修改表名 \",\"alter table student modify age int(4); #age数据类型为INT(3)改为INT(4) alter table student change age age int(4);#新旧都是age,因此只改变数据类型 alter table student change age student_age smallint;#age字段名改为student_age，并同时将其类型改为SMALLINT alter table student add email varchar(100);#添加一个新的email字段，数据类型为VARCHAR(100);置末 alter table student add birthdate date after email;#添加一个birthdate字段，数据类型为DATE，放在email字段之后 alter table student add student_id int primary key auto_increment first; #首位置添加一个student_id字段，数据类型为INT，并设置为主键（约束）： alter table student drop email;#删除email字段 alter table student rename xuesheng; #将students表重命名为xuesheng \",\"(4)查show：\",\"show tables；查看当前库下的表； show create table 表名；查看表的创建信息； desc 表名；查看表字段信息； \"]},\"1553\":{\"c\":[\"mysql\"]},\"1554\":{\"c\":[\"mysql核心SQL\"]},\"1555\":{\"h\":\"MySQL存储引擎\",\"t\":[\"mysql的一大优点就是插件式存储引擎\",\"不同存储引擎主要是影响表的结构、数据以及索引的存储方式\",\"show engines; #查看支持的存储引擎 \",\"这些默认配置都在mysql的配置文件中可以修改 sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf \"]},\"1556\":{\"h\":\"查看mysql存储的文件\",\"t\":[\"cd /var/lib su root cd mysql \",\"如果切换root失败，可以先修改root密码 sudo passwd root 再继续切换\"]},\"1557\":{\"h\":\"Q:不同存储引擎有什么区别\",\"t\":[\"A:5.5版本前默认的存储引擎是myisam，5.5及只有的版本改为了innodb；不同存储引擎主要是存储方式不一样，一张表需要存储的有表结构、表数据和表索引，myisam的一张表分为了 .frm .MYD .MYI三个文件，数据和索引是单独存放的；那么对于innodb来说，除了单独存储索引外，它的索引和数据是一起存放的；myisam支持表级锁和全文索引、不支持事务，innodb支持行锁和表索、支持事务、支持外键一致性约束\"]},\"1558\":{\"h\":\"Q:为什么innodb不加主键会自动生成一个主键，而myisam不会\",\"t\":[\"因为myisam数据和索引是单独存放的，加了主键就存放再.myi文件中，没加就不用存\",\"而innodb索引和数据是存放在一起的，并且数据存放在索引树上，没有索引没法存放数据\"]},\"1559\":{\"h\":\"了解\",\"t\":[\"image-20240417192441961\"]},\"1560\":{\"c\":[\"mysql\"]},\"1561\":{\"c\":[\"mysql存储引擎\"]},\"1562\":{\"h\":\"InnoDB的主键和二级索引树\"},\"1563\":{\"h\":\"主键\",\"t\":[\"​ \",\"主键树中叶子节点key是主键值，data是主键所在行的数据\",\"select * from student; #在有序链表中进行全文搜索 select * from stduent where uid=5; #等值搜索，从根节点开始在B+树上进行二分搜索 select * from stduent where uid<5; #范围查询，在有序链表中查找 select * from stduent where name='liuxiang'; #没有索引，在有序链表上进行整表搜索 \",\"image-20240418162100913\"]},\"1564\":{\"h\":\"二级索引\",\"t\":[\"select name from student where name='liuxiang'; select uid,name from student where name='liuxiang'; select * from student where name='liuxiang'; #回表 \"]},\"1565\":{\"h\":\"回表的过程\"},\"1566\":{\"h\":\"练习\",\"t\":[\"select * from student where age=20 order by name; \",\"Q:name现在是索引，如果只给age添加索引行不行？还有什么没考虑得到呢？\",\"A：不行，由于一张表的一次sql查询只能用一个索引，之创建age键索引，会有Using filesort！！需要创建age,name的多列索引（先按age排序，age相同再按name排序）\",\"遇到外部排序Using filesort一定要优化\"]},\"1567\":{\"c\":[\"mysql\"]},\"1568\":{\"c\":[\"mysql索引\"]},\"1569\":{\"h\":\"InnoDB自适应哈希索引\",\"t\":[\"自适应哈希索引作用：MySQL Server为避免频繁回表，\",\"自动创建的\",\"也是只能等值查询\",\"是InnoDB对B+树二级索引的一个优化措施\",\"假如name是有索引的，我们不断使用如下的方式查询，那就得先访问name的二级索引树，从二级索引树上取出主键uid，然后回表，用这个uid去主键索引树上取得对应的数据\",\"select * from student where name = \\\"zhangsan\\\"; select * from student where name = \\\"gaoyang\\\"; select * from student where name = \\\"linfeng\\\"; ... \",\"InnoDB存储引擎会做如下优化：如果检测到某个二级索引不断被使用，二级索引成为热数据，那么InnoDB会根据在二级索引树上的索引值在构建一个哈希索引来加速搜索（）\",\"蓝色的箭头表搜索二级索引树然后回表的过程\",\"黄色箭头就是直接等值查询搜索哈希表，直接拿到数据地址的过程。**使用哈希索引O(1)的时间复杂度就访问到哈希索引name，然后取出data即可（**对于InnoDB来说应该是直接取得数据，而不是拿到数据地址后再访问）\",\"注意：，我们可以查看相关参数指标，如果自适应哈希索引可以提高效率，那我们使用它，否则我们就关闭它\",\"自适应哈希索引是默认开启的：\",\"show variables like 'innodb_adaptive_hash_index'; \",\"在MySQL5.7以前，操作哈希表是只有一把锁的，锁的粒度太大，效率很低。在MySQL5.7以后，每个分区都会有自己的锁，锁的粒度减小，要是各个线程在同一个分区（一个分区可以包含一个或多个桶）进行并发操作，就需要加锁。要是在不同的分区操作，就不用加锁。\",\"show variables like 'innodb_adaptive_hash_index_parts'; \",\"我们通过以下命令查看两个关键信息：\",\"show engine innodb status\\\\G \",\"RW-latch阻塞/等待线程的数量，自适应哈希索引默认分配了8个分区，，则需要考虑关闭自适应哈希索引\",\"，也需要考虑关闭自适应哈希索引\",\"项目中如果遇到并发量很大，服务器处理请求慢时，可以使用show engine innodb status\\\\G查看是否需要关闭AHI，也是提高数据库性能的一种方式\"]},\"1570\":{\"c\":[\"mysql\"]},\"1571\":{\"c\":[\"mysql索引\"]},\"1572\":{\"h\":\"MySQL优化之慢日志查询\",\"t\":[\"对于SQL和索引的优化问题，我们会使用explain去分析SQL语句。但是真正的企业级项目有，我们不可能从头开始一条一条explain去分析。我们从什么地方可以获取那些运行时间长，耗性能的SQL？？\",\"我们可以打开慢查询日志\"]},\"1573\":{\"h\":\"慢查询使用方法\",\"t\":[\"根据具体的业务和并发量来，设置好后开启业务，压测后打开慢查询日志，就会看到超过执行时间的SQL，然后使用explain分析这些耗时的SQL语句\",\"步骤如下：\",\"打开慢查询日志开关slow_query_log\",\"设置合理的、业务可以接受的慢查询时间上限\",\"压测执行各种业务\",\"查看慢查询日志，找出所有执行耗时的SQL语句\",\"用explain分析这些耗时的SQL语句，从而针对性优化\",\"MySQL可以设置慢查询日志，当SQL执行的时间超过我们设定的时间，那么这些SQL就会被记录在慢查询日志当中，然后我们通过查看日志，用explain分析这些SQL的执行计划，来判定为什么效率低下，是<？还是？或者是索引使用到了，但是由于，花费的时间就是很长，那么此时我们可以把表分成多个小表等。\"]},\"1574\":{\"h\":\"慢查询日志相关的参数\",\"t\":[\"（MySQL定义的很多的全局的开关，都是在全局变量中存储，可以用show/set variables查看或者设置全局变量的值）\",\"show variables like '%slow_query%'; \",\"慢查询日志开关默认是关闭的\",\"慢查询日志的路径：默认在/var/lib/mysql/下\",\"慢查询日志记录了包含所有执行时间超过参数 long_query_time（单位：秒）所设置值的 SQL语句的日志，在MySQL上用命令可以查看，如下：\"]},\"1575\":{\"h\":\"慢查询日志实践\"},\"1576\":{\"h\":\"1. 打开慢查询日志开关slow_query_log\"},\"1577\":{\"h\":\"1. 打开慢查询日志开关slow_query_log\",\"t\":[\"show variables like 'slow_query%'; set global slow_query_log=on; \",\"在打开慢查询日志开关的时候，报错表示slow_query_log是一个global的变量（也有只影响当前session的变量，如：long_query_time 、profiling），修改后会影响所有的session，即影响所有正在访问当前MySQL server的客户端。\"]},\"1578\":{\"h\":\"2. 设置合理的、业务可以接受的慢查询时间上限long_query_time\",\"t\":[\"show variables like 'long_query%'; set long_query_time=0.1; \",\"查看另一个session，发现还是默认的10s，故long_query_time只影响当前session\"]},\"1579\":{\"h\":\"3. 压测执行各种业务\",\"t\":[\"已经超过我们设置的long_query_time=0.1s\"]},\"1580\":{\"h\":\"4. 查看慢查询日志\",\"t\":[\"路径：/var/lib/mysql/\",\"需要sudo 权限才能查看\"]},\"1581\":{\"h\":\"5. 用explain分析这些耗时的SQL语句，从而针对性优化\",\"t\":[\"做了整表扫描，把有序链表整个扫了一遍。\",\"我们应该给\",\"password添加索引，\",\"password是\",\"create index passwordidx on t_user(password); select * from t_user where password='1500000'; \",\"其他比如涉及、\"]},\"1582\":{\"h\":\"show profiles查看sql具体的运行时间/更详细的时间\",\"t\":[\"MySQL一般只显示小数点后两位的时间\",\"打开profiling开关，显示更详细的时间\",\"set profiling = ON; #profiling变量只影响当前session show profiles; #展示SQL语句精细的耗时时间 \"]},\"1583\":{\"c\":[\"mysql\"]},\"1584\":{\"c\":[\"mysql日志\"]},\"1585\":{\"h\":\"MySQL索引常见问题\"},\"1586\":{\"h\":\"问题1：用联合索引优化using filesort\",\"t\":[\"首先，要给userid加索引（一般过滤条件的字段需要加索引），！\",\"这样的话，在二级索引树上用userid过滤出来的数据中，addtime就已经是有序的了\",\"。用userid选择出来的数据越多，耗费的排序性能差的越大\",\"在这里插入图片描述\",\"addTime有索引，那索引树上的数据就是按照addTime排好序的\"]},\"1587\":{\"h\":\"问题2：给区分度高的字段加索引\",\"t\":[\"比如我们给sex建立索引，而sex就两种，所以用sex过滤出来的数据可能会占到整张表的一大部分，可能不会用到索引\"]},\"1588\":{\"h\":\"问题3：select的字段会导致回表\",\"t\":[\"如果，影响效率。能直接在二级索引树上取的就直接取，避免回表！\"]},\"1589\":{\"h\":\"问题4：多个字段有索引，使用哪个索引？\",\"t\":[\"，数据库引擎会比较用a=1过滤的数据和b=2过滤的数据，\",\"image-20240418220258482\"]},\"1590\":{\"h\":\"问题5：内连接之大表和小表\",\"t\":[\"内连接的时候，小表是整表扫描，每一个都要用到，大表相关联的字段没有索引的话，小表的每一个uid在大表中搜索都是整表搜索。如果大表相关联的字段有索引，小表的每一个uid在大表中就是走索引，搜的非常快。\"]},\"1591\":{\"h\":\"问题6：模糊搜索/范围搜索使用索引\",\"t\":[\"第一个zhang%通配符在后面，可以利用索引进行，可以根据前缀的匹配缩小搜索范围。对于字符串类型来说，\",\"第二个%zhang%通配符在前面，可以匹配任意的数据，所以只能整张表搜索。如果不扫描完整张表，也不知道到底还有没有含有zhang的数据\"]},\"1592\":{\"h\":\"问题7：in和not in是否能用到索引？not in优化成range范围搜索\",\"t\":[\"image-20240418223534192\",\"mysql8.0 in 会使用索引\",\"实际上，MySQL做了如下优化：\",\"select age from student where age not in (20); select age from student where age < 20 or age > 20; -- 优化成了range范围搜索 \"]},\"1593\":{\"h\":\"问题8：索引字段涉及 函数 以及 类型转换 ，无法用到索引\",\"t\":[\"本来是按照password排序作为索引的，经过函数计算之后就成为了另外的值，所以无法使用索引\",\"索引字段涉及等，不会使用索引\",\"select ... where mobile='13711112222'; #存储是字符型，输入字符型就可以使用索引了 \"]},\"1594\":{\"h\":\"问题9：or不能使用索引？\",\"t\":[\"or 实际上也可以用到索引，MySQL 5.7 会对or进行优化成union all联合查询\",\"优化成union后的两个select应该是都可以使用索引的，究竟用不用，还得看使用索引是否能带来效率的提升\",\"Mysql8.0 or可以用索引了\"]},\"1595\":{\"h\":\"总结\"},\"1596\":{\"c\":[\"mysql\"]},\"1597\":{\"c\":[\"mysql索引\"]},\"1598\":{\"h\":\"哈希索引\"},\"1599\":{\"h\":\"查看索引类型\",\"t\":[\"show indexes from student; \"]},\"1600\":{\"h\":\"注意MySQL5.7 show create table 反应的索引类型不准\",\"t\":[\"create index nameidx on student(name) using hash; show create table student\\\\G \",\"MySQL5.7 show create 只是显示我们创建索引的时候加的标志，实际上底层到底是不是哈希索引是不准确的\",\"因为搜索引擎是InnoDB，默认创建的是B+树\"]},\"1601\":{\"h\":\"哈希索引\",\"t\":[\"哈希索引是基于的支持，底层结构就是，增删改查的时间复杂度都是，一断电或重启mysql服务器就没了，因为内存搜索，哈希表是最快的\",\"而平衡树的增删改查的时间复杂度是O ( logn )，此外B+树索引是把磁盘上的存储的索引文件加载到内存上构建的数据结构。\"]},\"1602\":{\"h\":\"看起来哈希表比B+树好，那为什么MyISAM和InnoDB存储引擎用的是B+树索引？\",\"t\":[\"选择哪种数据结构构建索引，我们主要看：\",\"搜索的效率要高\",\"磁盘IO花费要少\"]},\"1603\":{\"h\":\"创建哈希索引\",\"t\":[\"如果这个文件使用的是memory基于内存的存储引擎，然后我们创建的索引就是哈希索引，底层是通过链式哈希表实现的\",\"create index nameidx on student(name); \",\"构建链式哈希表：根据选定的哈希函数，把每一行记录的name字段作为参数来求一个哈希值，哈希值对桶的长度取模得到桶的序号（会产生哈希冲突），然后进行存储。\",\"解决哈希冲突的方式：在桶里面用链表串起来（链地址法）\",\"注意：，数据在内存的其他位置\",\"注意：虽然链式哈希表的桶看起来有顺序，实际上存储的。因为我们用哈希函数进行了计算，然后还进行了取模的操作，不可能说我输入的索引值的字典序小，就一定在小的桶里面\",\"哈希表只能进行等值查找，比如：\",\"select * from student name=\\\"zhangsan\\\"; \",\"不能进行，比如：\",\"select * from student name like \\\"zhang%\\\"; \",\"B+输入读取一个块（16K）可以放到相邻的4个页面上；而在哈希表中，不同元素，哪怕是15和16，通过求哈希值，模上桶的个数，最后存储的位置可能会相隔很远。如果用链式哈希表构建索引，一个桶里面的节点代表1次磁盘I/O，由于桶内元素也是没有顺序的，我们进行查找的时候都会遍历完所有的桶内节点，就会导致更多的磁盘I/O。\",\"哈希索引只适用于小数据量的，在内存上的等值查询，处理不在磁盘的数据，并不能为我们减少磁盘I/O的次数！！！\"]},\"1604\":{\"h\":\"小结\",\"t\":[\"由于不同的索引值经过哈希函数计算以及取模后，最后存储的位置非常不确定，没有任何的顺序，只能进行等值查找,不能进行\",\"由于我们绝大部分的数据都是存放在磁盘的，哈希索引没办法减少磁盘I/O的次数，从磁盘上加载数据到内存的次数太多，使用的比较少\",\"此外一旦哈希表扩容，就会导致所有的索引值重新计算存储位置，效率很低。因此一般数据量也不是很大\"]},\"1605\":{\"c\":[\"mysql\"]},\"1606\":{\"c\":[\"mysql索引\"]},\"1607\":{\"h\":\"索引基础\"},\"1608\":{\"h\":\"索引是什么\",\"t\":[\"索引：是存储引擎提高查询的数据结构\",\"索引的核心/目的：提高查询的速度\"]},\"1609\":{\"h\":\"索引的好处和坏处\",\"t\":[\"当表中的数据量到达几十万甚至上百万的时候，SQL查询所花费的时间会很长，导致业务超时出错，此时就需要用索引来加速SQL查询。\",\"由于索引也是需要存储成索引文件的，因此对索引的使用也会涉及。如果索引创建过多，使用不当，会造成SQL查询时，进行大量无用的磁盘I/O操作，降低了SQL的查询效率，适得其反，因此掌握良好的索引创建原则非常重要！\",\"使用索引也会涉及磁盘IO的\",\"好处：提高查询的效率\",\"缺点：\",\"。有时候索引占用的空间甚至比数据占用的空间还多。\",\"虽然索引大大提高了查询的速度，但同时也。因为数据库不仅仅要更新数据，还要更新对应的索引信息。\",\"索引不是越多越好！ 过多的索引会，由于数据的改变，会造成索引文件的改动，过多的磁盘I/O造成CPU负荷太重; 索引太少，查询速度会变慢。我们应该建立合适的索引，找到一个平衡点！\"]},\"1610\":{\"h\":\"索引的分类\",\"t\":[\"物理（真实存在的）上：聚集索引、非聚集索引\",\"逻辑（抽象出来的）上：\",\"普通索引/二级索引：没有任何限制条件，可以给任何类型的字段创建普通索引 \",\"主要是相对于主键索引和唯一索引的说法\",\"创建新表时和已创建的表都可以加索引\",\"数量是不限的，但并非越多越好\",\"一张表的一次sql查询只能用一个索引，索引看 where字段而不是select字段where a=1 and b='M'\",\"唯一索引：使用UNIQUE修饰的字段，值不能够重复，主键索引就隶属于唯一性索引 \",\"不能重复，可以为空。[完整性约束/约束条件 | 张威的编程学习笔记 (gitee.io)](https://iszhwei.gitee.io/mysql/01 MySQL基础/完整性约束.html)\",\"主键索引：使用Primary Key修饰的字段会自动创建索引(MyISAM, InnoDB) \",\"没有加主键时，innodb会自动增加一个int字段当主键索引，而myisam不会\",\"不能重复，不能为空，唯一标识\",\"单列索引：在一个字段上创建索引\",\"多列索引：在表的多个字段上创建索引 \",\"uid+cid，多列索引必须使用到第一个列，才能用到多列索引，否则索引用不上\",\"只用uid或者uid+cid都可以用到多列索引\",\"只用cid不会使用到多列索引\",\"全文索引：只有myisam支持，使用FULLTEXT参数可以设置全文索引，只支持CHAR，VARCHAR和TEXT类型的字段上，常用于数据量较大的字符串类型上，可以提高查询速度 \",\"评论字符串搜索，如果不加索引就会变成字符串匹配\",\"线上项目支持专门的搜索功能，给后台服务器增加专门的搜索引擎支持快速高效的搜索 **elasticsearch 简称es **JAVA实现的，使用的时候简单配置调用API接口即可实现高可用的搜索\",\"C++开源的搜索引擎 搜狗的workﬂow \",\"因为和es相比效率太低，因此文本的搜索很少在后台数据库上搜索，用的比较少\"]},\"1611\":{\"c\":[\"mysql\"]},\"1612\":{\"c\":[\"mysql索引\"]},\"1613\":{\"h\":\"索引的使用和分析\"},\"1614\":{\"h\":\"索引的创建和删除\",\"t\":[\"创建表的时候指定索引字段，会自动给 primary key 和 unique 创建索引。\",\"CREATE TABLE index1(id INT, name VARCHAR(20), sex ENUM('male', 'female'), INDEX (id)); #普通索引，单列索引 CREATE TABLE index1(id INT, name VARCHAR(20), sex ENUM('male', 'female'), INDEX(id, name));#普通索引，多列索引 CREATE TABLE index1(id INT, name VARCHAR(20), sex ENUM('male', 'female'), INDEX(id, name), INDEX(sex));#创建多个索引 CREATE TABLE index1(id INT, name VARCHAR(20), sex ENUM('male', 'female'), INDEX 'index_name' (id)); #还可以自定义一个索引名 \",\"查看默认的索引名-show create table 表名\",\"在已经创建的表上添加索引：\",\"CREATE [UNIQUE] INDEX 索引名 ON 表名（属性名（length） [ASC | DESC]); \",\"常针对字符串类型的数据的索引优化，lenght指定前多少个字符建立索引，只要能区分开就行\",\"create index nameidx on student(name); \",\"删除索引:\",\"DROP INDEX 索引名 ON 表名; \"]},\"1615\":{\"h\":\"索引的优化\",\"t\":[\"面试回答问题，结合实践，不要背课文1... 2... 3...\",\"经常作为where条件过滤的字段考虑添加索引\",\"字符串列创建索引时，尽量规定索引的长度，而不能让索引值的长度key_len过长\",\"索引字段涉及类型强转、mysql函数调用、表达式计算等，索引就用不上了\"]},\"1616\":{\"h\":\"MySQL端口号的查看\",\"t\":[\"#查看MySQL的端口号 sudo netstat -tanp|grep mysqld \"]},\"1617\":{\"h\":\"索引的执行过程\",\"t\":[\"需要注意的是，给该字段加了索引并且以该字段作为过滤条件就能用到该索引，因为mysql server有自己的优化，如果使用索引最后得到的数据占总数据的70-81%左右，便不会使用索引 \",\"使用索引会读取索引文件-花费磁盘IO，如果数据取不完还要去数据表去取数据\",\"即，先进行比较，如果使用索引得到的数据量和扫表得到的数据量接近，就不会使用索引，因为使用索引的步骤比较繁琐\",\"索引的好处是，无论数据的位置在哪里，都是常量级的时间\",\"第二次速度快是因为有数据缓存和索引缓冲\",\"即使有缓存，对于2000000的数据查询时间仍然很长，可以加索引\",\"由于password设置的是字符串类型，而我们输入where password=1000000中password是整型，会涉及到类型转换\"]},\"1618\":{\"h\":\"explain结果字段分析\",\"t\":[\"select_type\",\"simple：表示不需要union操作或者不包含子查询的简单select语句。有连接查询时，外层的查询为simple且只有一个。\",\"primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary且只有一个。\",\"union：union连接的两个select查询，除了第一个表外，第二个以后的表的select_type都是 union。\",\"union result：包含union的结果集，在union和union all语句中，因为它不需要参与查询，所以id字段为null。\",\"table\",\"显示查询的表名；\",\"如果不涉及对数据库操作，这里显示null；\",\"如果显示为尖括号就表示这是个临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生的；\",\"如果是尖括号括起来<union M,N>也是一个临时表，表示这个结果来自于union查询的id为M，N的结果集；\",\"type\",\"const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type就是const。\",\"ref：常见于辅助索引的等值查找，或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找会出现；返回数据不唯一的等值查找也会出现。\",\"range：索引范围扫描，常见于使用<、>、is null、between、in、like等运算符的查询中。\",\"index：索引全表扫描，把索引从头到尾扫一遍；常见于使用索引列就可以处理不需要读取数据文件的查询，可以使用索引排序或者分组的查询。\",\"all：全表扫描数据文件，然后在server层进行过滤返回符合要求的记录。\",\"ref\",\"如果使用常数等值查询，这里显示const；\",\"如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段；\",\"Extra\",\"using ﬁlesort：排序时无法用到索引，常见于order by和group by语句中。\",\"using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。\"]},\"1619\":{\"c\":[\"mysql\"]},\"1620\":{\"c\":[\"mysql索引\"]},\"1621\":{\"h\":\"索引的底层实现原理\",\"t\":[\"数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐一加载每一个磁盘块（对应索引树的节点），索引树越低，越“矮胖”，磁盘IO次数就少\"]},\"1622\":{\"h\":\"AVL平衡二叉树索引\",\"t\":[\"不管是，增加，删除，还是等值查找，时间复杂度都是O(logn)，n 是数据页的数目。并且支持范围查找。\",\"但是当。查找效率低。\",\"数据、索引都是存放在磁盘上，MySQL Server查询数据时需要花费磁盘IO按块读取数据（块一般为16K，内存页面的整数倍）读到内存中\",\"c/c++分配内存：\",\"malloc/new 4字节时，实际上内核的内存管理是按页面（4K）为单位的，如果返回了2个页面，2 * 4K =8K有8K字节，剩余的字节 8k - 4个字节有libc.so或libc++.so库的malloc实现ptmalloc(c库)或者tcmalloc（c++库）来管理\",\"缓存，下次再申请内存时直接在ptmalloc或者tcmalloc上申请，不需要访问内核空间\",\"树的层数=log2N=log10N/log102=logN/log2\",\"写代码时需要强转换成int类型，否则有小数 for(i=0;i< (int)(log(N)/log(2));i++) \",\"2000W数据，最坏情况（这些节点都不在一个磁盘块上，一次磁盘IO读取的数据放在一个节点上）下读取一个索引就需要25次磁盘IO\",\"若m=500阶的平衡树处理log20000000/log500大约需要3次IO就可以\"]},\"1623\":{\"h\":\"B树索引\",\"t\":[\"MySQL支持两种索引，一种的B-树索引（但实际上MySQL采用的是B+树结构），一种是哈希索引，大家知道，B-树和哈希表在数据查询时的效率是非常高的。\",\"B-树是一种m阶平衡树，叶子节点都在同一层，由于每一个节点存储的数据量比较大，索引整个B-树的层数是非常低的，基本上不超过三层。\",\"由于磁盘的读取也是按block块操作的（内存是按page页面操作的），因此****，这样一个B-树节点，就可以通过一次磁盘I/O把一个磁盘块的数据全部存储下来，所以当使用B-树存储索引的时候，磁盘I/O的操作次数是最少的（）。\",\"MyISAM: *.MYD *.MYI\",\"InnoDB: *.ibd\",\"select * from student where uid=5; \",\"：先检查where过滤字段是否有索引，uid有索引 =》 存储引擎 =》kernel =》 磁盘IO（读索引文件）=》内存上 =》用索引文的数据构建B树，B树的好处是减少磁盘IO加速搜索\",\"没有索引只能做整表搜索，比较慢(一行行的搜索)；有索引则加载索引，构建成B树\",\"键值就是索引值，比如以name为索引，紫色键值存放的就是name\",\"每个节点的数据都是有序的，因此在一个节点内的搜索是二分搜索log2N O(logN)\",\"单纯看内存上搜索都是O(logN)和AVL树一样，但是好处在于****\",\"**即索引搜索涉及，一个是读取索引文件到内存上构建B树的磁盘IO，另一个就是在内存上B树的搜索是log2N **\",\"不是读取全部的索引加载到内存，磁盘读取是按块读取，B-树的节点大小一般设置为和磁盘块大小一致\",\"如m=500搜2000W的数据，，内存上搜索25次\"]},\"1624\":{\"h\":\"data：存储的是数据本身内容？还是磁盘上的地址？？\",\"t\":[\"这主要看是什么存储引擎，MyISAM数据和索引分开存储，因此存放的是数据在磁盘上的地址；InnoDB数据和索引存放在同一文件，因此data为数据的内容\"]},\"1625\":{\"h\":\"B+树\"},\"1626\":{\"h\":\"为什么MySQL(MyISAM和InnoDB)索引底层选择B+树而不是B树呢？？？\",\"t\":[\"B树****\",\"B树的 索引+数据内容 分散在不同的节点上，离根节点近，搜索就快；离根节点远，搜索就慢！ 因此，花费的，每一次数据花费的时间也不平均\",\"每一个非叶子节点上，不仅要存储 索引（key），还要存储索引值所在的哪一行的data的数据。因此一个节点，比只存放key值的节点要得多！\",\"B树不方便做看起来也不方便\",\"由上面的三个原因，因此选B+树来构建索引\",\"每一个非叶子节点只存放key，不存储data! \",\"每一个节点存放的key值更多，因此B+树理论上来说，一些，搜索的效率会更好一些\",\"叶子节点上存储了所有的索引值以及对应的data \",\"搜索每一个索引对应的值data，都需要跑到叶子节点，这样每一行记录搜索的\",\"叶子节点被串在一个链表当中，形成了一个有序的链表\",\"如果要进行索引树的搜素或者整表搜索，直接即可！！\",\"做范围查询的时候，直接遍历叶子节点的有序链表即可！！\",\"：先检查where过滤字段是否有索引，没有索引就做整表搜索，效率比较低；如果有索引，操作系统内核kernel花费磁盘IO，读索引文件到内存上 ，用索引文的数据构建B+树，因为B+树是平衡树，搜索效率比较高；而且是一个节点一个节点构建，一个节点对应一个磁盘IO，非叶子叶节点只存储key，单个节点存储的key值比较多，所有的key和data都是存在叶子节点，\"]},\"1627\":{\"h\":\"总结回答为什么使用B+树构建索引？\",\"t\":[\"B-树的每一个节点，存了关键字和对应的数据地址，而B+树的非叶子节点只存关键字，不存数据地址。因此B+树的每一个非叶子节点存储的关键字是远远多于B-树的，B+树的叶子节点存放关键字和数据，因此，从树的高度上来说，B+树的高度要小于B-树，使用的磁盘I/O次数少，因此查询会更快一些。\",\"B-树由于每个节点都存储关键字和数据，因此离根节点进的数据，查询的就快，离根节点远的数据，查询的就慢；B+树所有的数据都存在叶子节点上，因此在B+树上搜索关键字，找到对应数据的时间是比较平均的，没有快慢之分。\",\"在B-树上如果做区间查找，遍历的节点是非常多的；B+树所有叶子节点被连接成了有序链表结构，因此做整表遍历和区间查找是非常容易的。\"]},\"1628\":{\"c\":[\"mysql\"]},\"1629\":{\"c\":[\"mysql索引\"]},\"1630\":{\"h\":\"MySQL事务的隔离级别\"},\"1631\":{\"h\":\"隔离级别概念\",\"t\":[\"事务的隔离级别就是对事务并发的控制\",\"MySQL支持的四种隔离级别是：\",\"TRANSACTION_READ_UNCOMMITTED：未提交读。说明在提交前事务A可以看到事务B的变化。这样，和都是可能发生的。\",\"TRANSACTION_READ_COMMITTED：已提交读（oracle默认），说明读取未提交的数据是不允许的（防止脏读）。在这个级别和可能发生的。\",\"TRANSACTION_REPEATABLE_READ：可重复读（MySQL默认），说明事务保证能够再次读取相同的数据而不会失败，即使其他的事务把这个数据改了，你也不会看到前后两次查询的数据的不同，完全可以保证两次查询的结果是一样的，但是仍然会出现。\",\"TRANSACTION_SERIALIZABLE：串行化，是最高的事务隔离级别，它防止脏读，不可重复读和幻读。串行执行，，一般不会用\",\"事务隔离级别越高，为避免冲突所花费的性能也就越多\",\"在可重复读级别，实际上可以解决部分（）的幻读问题，但是更新产生的幻读问题，要禁止幻读产生，还是需要设置串行化隔离级别\",\"两个MySQL客户端默认工作在可重复读级别\"]},\"1632\":{\"h\":\"查看隔离级别\",\"t\":[\"select @@tx_isolation; #MySQL5.7 select @@transaction_isolation; #8.0 \"]},\"1633\":{\"h\":\"测试read-uncommi tted 隔离级别\",\"t\":[\"两个会话都需要设置成read-uncommitted隔离级别\",\"注意要加单引号\",\"可以看到一个客户端读到了另一个客户端未提交的数据-脏读\",\"image-20240419155523434\"]},\"1634\":{\"h\":\"测试TRANSACTION_READ_COMMITTED隔离级别\",\"t\":[\"由于设置了已提交读隔离级别，事务B并没有发生脏读，这是由各种锁机制以及事务并发的MVCC版本控制实现的\",\"查询到了已经commit的数据，发生了不可重复读，这在已提交读隔离级别是允许发生的\",\"既然发生了不可重复读，幻读就肯定可以发生了\"]},\"1635\":{\"h\":\"测试TRANSACTION_REPEATABLE_READ隔离级别\",\"t\":[\"image-20240419161539787\",\"可重复读隔离级别：对于一个事务来说，可以放心读数据，就算有其他事务修改了数据并且已经提交了，也不会在当前事务表现出来。只要自己没改，数据都是不会变的\",\"在可重复读隔离级别，测试幻读（在一定程度上防止了幻读，但没有完全防止）\",\"可以看到，在当前的可重复读隔离级别，右侧事务无法查询到左侧事务insert的数据，虽然看不到，但\",\"右边的客户端update左侧客户端insert的数据：\",\"实际上，事务A已经插入并且提交了，aaa已经存在，所以事务B update aaa的年龄成功了\",\"前后两次同样的查询，后一次查询与前一次查询的数据量不同，就发生了幻读。也就是可重复读隔离级别下，并没有解决幻读的问题，要彻底解决幻读，就需要设置串行化隔离级别\"]},\"1636\":{\"h\":\"测试TRANSACTION_SERIALIZABLE隔离级别\",\"t\":[\"由于\",\"MySQL server不会让自己执行事务的线程永远阻塞，导致当前线程占用的锁无法释放，而使得其他执行事务的线程也无法获得锁而永远阻塞。所以：\"]},\"1637\":{\"c\":[\"mysql\"]},\"1638\":{\"c\":[\"事务\"]},\"1639\":{\"h\":\"事务并发存在的问题(脏读、不可重复读和幻读)\",\"t\":[\"事务处理如果，并发执行事务时通常会发生以下问题：\",\"脏读（Dirty Read）：。\",\"例如当事务A和事务B并发执行时，当事务A更新后，事务B查询读取到A尚未提交的数据，此时如果事务A rollback了，那事务B读到的数据就不是数据库所存放的数据了，而是无效的脏数据（脏读必须杜绝，因为事务没有commit；而不可重复读和幻读不一定出问题，因为事务已经commit）\",\"不可重复读（NonRepeatable Read）：一个事务的操作导致另一个事务 。\",\"例如当事务A和事务B并发执行时，当事务B查询读取数据后，事务A 更改事务B查询到的数据，此时事务B再次去读该数据，发现前后两次读的数据不一样（事务B读取了事务A已commit的数据）\",\"幻读（Phantom Read）：一个事务的操作导致另一个事务前后。\",\"例如 当事务A和事务B并发执行时，当事务B查询读取数据后，事务A或者了一条满足事务B查询条件的记录，此时事务B再去查询，发现查询到前一次不存在的记录，或者前一次查询的一些记录不见了（事务B读取了事务A新增加的数据或者读到事务A删除的数据）\",\"在有些场景下，不可重复读和幻读一定程度上是可以允许的，不一定非要杜绝（通过设置不同的隔离级别解决），由应用场景需求决定\",\"脏读举例：张三的账户还剩100块，他同时发起两个事务，事务A转账50，事务B购买价格为80的水杯，事务A现对张三的余额减50，然后给另一个人余额加50。由于没有隔离控制，事务B购买水杯前先读取余额，发现只有50，无法购买茶杯，于是茶杯购买失败。此时事务A执行异常，将张三的余额回滚为事务执行前的状态，余额为100。当前场景中事务B读到了事务A还没有commit的数据50，发生了脏读，任何业务场景下都必须杜绝\",\"不可重复读举例：首先事务B查询余额，发现为100。事务A完成转账50，并且commit，事务B再次查询余额，发现变成了50，在某些业务场景下是可以允许的，不一定非要杜绝\",\"幻读举例：事务B查询年龄为20的人，发现有5个。事务A插入或删除了年龄为20的记录，并且commit，事务B再次查询年龄为20的人，发现已经不是5个人了，幻读也是在某些业务场景下是可以允许的，不一定非要杜绝\"]},\"1640\":{\"h\":\"事务相关命令\",\"t\":[\"一般我们业务上如果要考虑到事务处理，我们需要设置为手动提交方式，如果一个事务包含多个SQL，若是自动提交方式，一句SQL执行完就自动提交了，后面的SQL万一执行失败就无法正常rollback，无法保证事务的原子特性\",\"BEGIN：开启一个事务\\nCOMMIT：提交一个事务\\nROLLBACK：回滚一个事务到初始的位置\\nSAVEPOINT point1：设置一个名字为point1的保存点\\nROLLBACK TO point1：事务只回滚到保存点point1，而不是回滚到初始状态SET TRANSACTION_ISOLATION=‘REPEATABLE-READ’：设置事务的隔离级别SELECT @@TRANSACTION_ISOLATION：查询事务的隔离级别\"]},\"1641\":{\"c\":[\"mysql\"]},\"1642\":{\"c\":[\"事务\"]},\"1643\":{\"h\":\"事务的ACID特性\"},\"1644\":{\"h\":\"ACID特性\",\"t\":[\"每一个事务必须满足下面的4个特性：\",\"原子性（Atomic）：事务是一个不可分割的整体，事务必须具有原子特性。当修改数据时，要么全执行，要么全不执行，即不允许部分事务完成\",\"一致性（Consistency）：事务执行之前和执行之后，数据库数据必须保持一致性状态。数据库的一致性状态必须由用户来负责，由并发控制机制实现。拿银行转账来说，只有让一个用户的余额减少，又让一个用户的余额增加才能构成一个完整的事务\",\"隔离性（Isolation）：当两个或者多个事务并发执行时，为了保证数据的安全性，将一个事物内部的操作与其它事务的操作隔离起来，不被其它正在执行的事务所看到，使得并发执行的各个事务之间不能互相影响。隔离级别：数据的安全性和事务的并发性。隔离越严格，安全性越高，并发性越低（就是并发控制，保证数据安全）\",\"持久性（Durability）：事务完成（事务commit成功）以后，DBMS保证它对数据库中的数据的修改是永久性的，即使数据库因为故障出错，也应该能够恢复数据\"]},\"1645\":{\"h\":\"InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？\",\"t\":[\"DB写数据都是先在cache缓存上写的（因为速度快），然后操作系统通过磁盘I/O往磁盘上写，当。然后cache再慢慢往磁盘上写数据，。。由于用户会写很多数据，所以commit不会等着这些数据从缓存全部写到磁盘再返回，因为要经过磁盘I/O，业务上不可能让用户去等那么长时间\",\"持久性是通过 redo log （重做日志）来保证的\",\"原子性是通过 undo log（回滚日志） 来保证的\",\"隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的\",\"一致性则是通过持久性+原子性+隔离性来保证\",\"事务的ACD特性由redo log和undo log机制保证，事务的I特性由事务的锁机制来保证，锁粒度越大，事务隔离性越好，安全性越高，并发性越低，效率越低\"]},\"1646\":{\"c\":[\"mysql\"]},\"1647\":{\"c\":[\"事务\"]},\"1648\":{\"h\":\"事务的概念\"},\"1649\":{\"h\":\"定义\",\"t\":[\"InnoDB支持事务，而MyISAM不支持事务\",\"一个事务是由一条或者多条对数据库操作的SQL语句所组成的一个不可分割的单元，只有当事务中的所有操作都正常执行完了，整个事务才会被提交给数据库；如果有部分事务处理失败，那么事务就要回退到最初的状态，因此，事务要么全部执行成功，要么全部失败。\",\"所以记住事务的几个基本概念，如下：\",\"事务是一组SQL语句的执行，要么全部成功，要么全部失败，不能出现部分成功，部分失败的结果。保证事务执行的原子性\",\"事务的所有SQL语句全部执行成功，才能提交（commit） 事务，把结果写回磁盘\",\"事务执行过程中，有SQL出现错误，那么事务必须要回滚（rollback） 到最初的状态\"]},\"1650\":{\"h\":\"代码上的事务操作\",\"t\":[\"比如转账业务需要多条SQL语句共同完成，只有这些SQL都执行成功才算业务成功了\",\"如果这2句SQL都成功了，那么\",\"如果其中任意一条SQL由于停电，或者服务器出错，导致SQL执行异常，那事务就没有提交，，数据将恢复到事务开始前的状态\",\"这是存储引擎来保证的（redo log和undo log保证的）\"]},\"1651\":{\"h\":\"查看当前数据库支持的存储引擎\",\"t\":[\"show engines; \"]},\"1652\":{\"h\":\"修改提交方式\",\"t\":[\"数据库引擎可以通过命令临时修改，或者通过配置文件永久修改事务的提交方式\",\"select @@autocommit; set @@autocommit=0; #事务手动提交 set autocommit=0; #上面一样 \",\"@@autocommit为1表示，为0表示事\",\"这种修改只对当前会话session有效，一般来说，我们的事务由多条SQL组成，所以我们设置为手动提交。业务都成功，则提交这个事务；如果业务中间出现失败，就回滚1个事务\"]},\"1653\":{\"c\":[\"mysql\"]},\"1654\":{\"c\":[\"事务\"]},\"1655\":{\"h\":\"MySQL MVCC多版本并发控制（脏读和不可重复读解决原理）\"},\"1656\":{\"h\":\"一、MVCC概念\",\"t\":[\"MVCC是多版本并发控制（Multi-Version Concurrency Control），是MySQL中基于乐观锁理论实现隔离级别的方式，用于实现已提交读和可重复读隔离级别，也经常称为多版本数据库。MVCC机制会生成一个数据请求时间点的一致性数据快照 （Snapshot)， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。从用户的角度来看，好象是数据库可以提供同一数据的多个版本（系统版本号和事务版本号）\",\"MVCC多版本并发控制中，读操作可以分为两类：\",\"快照读（非锁定读）：可见，不用加锁。 \",\"如 select做的都是快照读，会把已经commit的数据（即整表数据）生成一个快照（）\",\"当前读：读取的是记录的最新版本，返回当前读的记录，并且对数据加锁。 \",\"如 insert，delete，update，select…lock in share mode/for update这些操作，都是\",\"MVCC：每一行记录实际上有多个版本，每个版本的记录除了数据本身之外，增加了其它字段（DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR）\",\"已提交读隔离级别：每个语句执行前都会重新生成一快照（Read View），快照中只包含已commit的数据。\",\"可重复读隔离级别：启动事务时生成一个快照（Read View），然后整个事务期间都在用这个 Read View，后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的\",\"什么叫事务启动呢？\",\"执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了增删查改操作的 SQL 语句，才是事务真正启动的时机\",\"执行了 start transaction with consistent snapshot 命令，就会马上启动事务\",\"快照内容读取原则：\",\"版本未commit，无法读取生成快照\",\"版本已commit，但是在快照创建后提交的，无法读取\",\"版本已commit，但是在快照创建前提交的，可以读取\",\"当前事务做的修改，是需要重新生成快照的。读取的是最新版本，并且对数据加锁，阻塞其他操作事务修改记录。核心逻辑就是判断版本链中的哪个版本是当前事务可见可处理的\",\"\\\"数据快照\\\"中并不是数据，存储的是一些事务id\",\"![](MySQL MVCC多版本并发控制（脏读和不可重复读解决原理）.assets/cec5ca395e184437abf68a77ec43db2b.png)\",\"Read View 有四个重要的字段：\",\"creator_trx_id ：指的是创建该 Read View 的事务的事务 id\",\"m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。重新生成数据快照m_ids可能会有更新，不重新生成数据快照m_ids就不会更新\",\"min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值\",\"max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是所有已提交的和未提交的事务中最大的事务 id 值 + 1\",\"Innodb如何判断某条记录是否对当前事务可见呢？一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：\",\"如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在创建 Read View 前已经提交的事务生成的，所以该版本的记录对当前事务可见。\",\"如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在创建 Read View 后才启动的事务生成的，所以该版本的记录对当前事务不可见。\",\"如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中： \",\"如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。\",\"如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。\",\"这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）\",\"在已提交读隔离级别下，每次查询都会重新生成数据快照，若其他事务已经提交了，当前事务再次查询时重新生成的数据快照中的m_ids、min_trx_id、max_trx_id可能会发生改变，这样对比每条记录的trx_id后，可见性就会发生改变\",\"在可重复读隔离级别下，每次查询都使用第一次生成的数据快照，\"]},\"1657\":{\"h\":\"二、MVCC应用于已提交读隔离级别\"},\"1658\":{\"h\":\"1.解决脏读\",\"t\":[\"先设置隔离级别为已提交读并开启事务，已提交读解决了脏读，未解决可重复读和幻读\",\"![](MySQL MVCC多版本并发控制（脏读和不可重复读解决原理）.assets/image-20240420160437173.png)\",\"不管是已提交读还是可重复读，只要我们select的时候，就会产生一个数据快照，相当于给当前的数据拍个照片，以后去查询，都是查询快照上的数据（除非有新的数据被commit）。已提交读隔离级别采用非锁定读，非锁定读是在快照上的读取。\",\"在已提交读隔离级别，每一次select都会产生一个新的数据快照，当事务1进行更改的时候，事务2又去select，重新产生数据快照（有可能和前面的快照相同），然而产生新的数据快照的**新的数据已经被事务正确commit**，prepare状态的数据不会出现在快照中\",\"数据有2种状态：prepare（未提交时）和commit（已提交）\",\"事务2第二次select的时候，由于事务1并没有commit新的数据（数据处于prepare状态），当又一次产生数据快照时，产生的数据快照还是undo log回滚日志的链表指向的旧数据，这就解决了脏读问题\",\"然而，在已提交读隔离级别依然会发生不可重复读的现象（两次查询，得到的数据内容不一样，属于正确读取的范围）\",\"![](MySQL MVCC多版本并发控制（脏读和不可重复读解决原理）.assets/d2de0f6308ee48d4ad209a141295607b.png)\"]},\"1659\":{\"h\":\"2. 无法解决不可重复读\",\"t\":[\"因为每一次select都会重新产生1次数据快照，其他事务update后commit，新的数据已经符合生成快照的要求了，于是再次select的时候新commit的数据也会出现在新生成的快照中，发生了不可重复读\"]},\"1660\":{\"h\":\"3. 无法解决幻读\",\"t\":[\"![](MySQL MVCC多版本并发控制（脏读和不可重复读解决原理）.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16.png)\",\"和出现不可重复读现象的原因相同，由于新commit的数据符合生成快照的要求，再次select的时候新commit的数据也会出现在新生成的快照中，自然就出现了幻读\"]},\"1661\":{\"h\":\"三、MVCC应用于可重复读隔离级别\"},\"1662\":{\"h\":\"1.解决脏读\",\"t\":[\"事务第一次select就产生数据快照，而且只产生这一次快照，select时都是直接用老的数据快照，所以可以解决脏读\"]},\"1663\":{\"h\":\"2.解决不可重复读\",\"t\":[\"因为事务，而且只产生这一次快照\",\"设置可重复读隔离级 别，并2个开启事务。事务2 select，生成数据快照，在可重复读隔离级别下，以后再select都不会再生成快照\",\"![](MySQL MVCC多版本并发控制（脏读和不可重复读解决原理）.assets/62a2ec5eff0f4c45b1c3cb131751db46.png)\",\"![](MySQL MVCC多版本并发控制（脏读和不可重复读解决原理）.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-17136021990519.png)\"]},\"1664\":{\"h\":\"3.理解 可重复读隔离级别，只生成一次数据快照\",\"t\":[\"再举一个例子理解：在可重复读隔离级别，只生成一次数据快照\",\"![](MySQL MVCC多版本并发控制（脏读和不可重复读解决原理）.assets/3034373b35e141b6aac48e4e377c245e.png)\",\"![](MySQL MVCC多版本并发控制（脏读和不可重复读解决原理）.assets/dadd16147c434974bbb33a909a48ecf0.png)\",\"由于事务1已经commit了，新的数据不再是prepare状态，已经符合了生成快照的条件。当事务2再select（快照读）的时候，这条age=22的数据自然就被查到了\"]},\"1665\":{\"h\":\"4. 理解 可重复读隔离级别，只能部分解决幻读\",\"t\":[\"![](MySQL MVCC多版本并发控制（脏读和不可重复读解决原理）.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171360298211316.png)\",\"事务2第一次select是两条数据，事务1 insert之后，事务2再次select依然是两条，看似解决了幻读，其实只是部分解决（并不能完全解决幻读）\",\"那我们看一下为什么是部分解决幻读\",\"事务1 insert然后commit后，表格的数据应该是这样的\",\"![](MySQL MVCC多版本并发控制（脏读和不可重复读解决原理）.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_12,color_FFFFFF,t_70,g_se,x_16.png)\",\"此时事务2 update\",\"![](MySQL MVCC多版本并发控制（脏读和不可重复读解决原理）.assets/6670d39aad9e4af19b284a2666571e28.png)\",\"可以看见，update找到了id=24的数据，这就证明update做的是当前读（读最新的commit状态的数据），而不是快照读，因为快照上根本就没有id=24的数据\",\"![](MySQL MVCC多版本并发控制（脏读和不可重复读解决原理）.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171360312686323.png)\",\"其中1000是事务1的ID，2000的事务2的ID\",\"由于每个事务可以看见自己修改、更新的数据，当事务2再次select的时候，就可以看见id=24的数据了，这就发生了幻读（主要因为insert，delete，update，select…lock in share mode/for update这些操作，是当前读）\",\"![](MySQL MVCC多版本并发控制（脏读和不可重复读解决原理）.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_11,color_FFFFFF,t_70,g_se,x_16.png)\",\"未提交读\",\"已提交读\",\"可重复读\",\"串行化\",\"/\",\"MVCC\",\"MVCC + 临键锁\",\"临键锁\",\"脏读、不可重复读、幻读\",\"不可重复读、幻读\",\"幻读\",\"/\"]},\"1666\":{\"c\":[\"mysql\"]},\"1667\":{\"c\":[\"mysql MVCC\",\"mysql日志\"]},\"1668\":{\"h\":\"MySQL意向共享锁、意向排他锁\",\"t\":[\"![image-20240420193947369](MySQL 意向共享锁、意向排他锁.assets/image-20240420193947369.png)\"]},\"1669\":{\"h\":\"一、InnoDB表级锁\",\"t\":[\"我们知道，InnoDB是支持行锁，但不是每次都获取行锁，如果不使用索引的，那还是获取的表锁。而且有的时候，我们希望直接去使用表锁\"]},\"1670\":{\"h\":\"适合使用表索的情况\",\"t\":[\"在绝大部分情况下都应该使用行锁，因为事务的并发效率比表锁更高，但个别情况下也使用表级锁：\",\"事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，给大部分行都加锁（此时不如直接加表锁），不仅这个事务执行效率低，而且可能造成其他事务长时间等待和锁冲突\",\"事务涉及多个表，比较复杂，如果都用行锁，很可能引起死锁，造成大量事务回滚\"]},\"1671\":{\"h\":\"表索的相关命令\",\"t\":[\"当我们希望获取表锁时，可以使用以下命令：\",\"LOCK TABLE user READ -- 获取这张表的读锁 LOCK TABLE user WRITE -- 获取这张表的写锁 事务执行... COMMIT/ROLLBACK; -- 事务提交或者回滚 UNLOCK TABLES; -- 本身自带提交事务，释放线程占用的所有表锁 \"]},\"1672\":{\"h\":\"在使用表锁的时候，涉及到效率的问题\",\"t\":[\"如果我们\",\"假如这张表有1000万个数据，那我怎么知道这1000万行哪些有行锁哪些没有行锁呢？\",\"除了挨个检查，没有更好的办法，这就导致效率低下的问题\",\"我们这里学习的意向共享锁和意向排他锁就是用来解决，由于需要加表锁而去挨个遍历数据，确定是否有某些数据被加了行锁，而导致的效率低下问题。作用就是快速判断表里是否有记录被加锁\"]},\"1673\":{\"h\":\"二、意向共享锁和意向排他锁（表锁而非行锁）\",\"t\":[\"意向锁的作用：为了可以更快速的\",\"意向共享锁（IS锁）：事务在给一行记录加共享锁前，必须先取得该表的IS锁 意向排他锁（IX锁）：事务在给一行记录加排他锁前，必须先取得该表的IX锁\",\"![](MySQL 意向共享锁、意向排他锁.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16.png)\",\"（上面表格所有的锁都是针对整表）\",\"在之前，由InnoDB存储引擎自动加上表的IS或IX锁，我们无法手动获取IS或IX锁\",\"意向锁之间都兼容，不会产生冲突\",\"意向锁存在的意义是为了更高效的获取表锁（表格中的X、S、IX、IS指的是表锁，不是行锁）\",\"意向锁是表级锁，协调表锁和行锁的共存关系，主要目的是显示事务正在锁定某行或者试图锁定某行。\",\"分析事务1获取行X锁和事务2获取表S锁：\",\"首先事务1需要给表的第10行数据加X锁，于是InnoDB存储引擎自动给整张表加上了IX锁。当事务2再想获取整张表的S锁时，看到这张表已经有别的事务获取了IX锁了，就说明这张表肯定有某些数据被加上了X锁，这就导致事务2不能给整张表加S锁了。此时事务2只能等待，无法成功获取表S锁\",\"当某个事务要获取表的X锁时，不需要再检查哪些行被加上了X或S锁，只需要检查整表是否被加上IX或IS锁即可\"]},\"1674\":{\"c\":[\"mysql\"]},\"1675\":{\"c\":[\"mysql锁机制\"]},\"1676\":{\"h\":\"MySQL回滚日志undo log\"},\"1677\":{\"h\":\"一、引入 undo log\",\"t\":[\"![](MySQL回滚日志undo log.assets/image-20240420132938427.png)\",\"一般数据库引擎默认工作在事务的中间两个隔离级别：\",\"TRANSACTION_READ_COMMITTED，已提交读，oracle默认工作级别。不允许读取未commit的数据，这个级别仍然允许不可重复读和幻读产生。\",\"TRANSACTION_REPEATABLE_READ，可重复读，MySQL默认工作级别。保证事务再次读取是依然得到相同的数据，部分解决了幻读，但幻读是仍然会出现的\",\"![img](MySQL回滚日志undo log.assets/image-20240419150312478-pI4JWCa2.png)\",\"注：\",\"事务隔离级别越高，为避免冲突所花费的性能也就越多\",\"在可重复读级别，实际上可以解决部分的幻读问题，但是不能防止update更新产生的虚读问题，要禁止虚读产生，还是需要设置串行化隔离级别\",\"InnoDB的已提交读和可重复读的：MVCC（多版本并发控制），MVCC提供了一种并发的读取方式，即快照读 ，同一份数据会有多个版本\",\"InnoDB提供了2种读取操作：锁定读和非锁定读\",\"锁定读就是读取的时候加锁****（S或X）\",\"非锁定读就是读取的时候没有加锁，指的就是MVCC提供的快照读—>快照读依赖的是的undo log回滚日志\",\"ACD特性用事务日志实现，I 特性用锁+MVCC 实现。事务日志分为undo log（回滚日志） 和 redo log（重做日志）\"]},\"1678\":{\"h\":\"二、undo log\"},\"1679\":{\"h\":\"1.undo log的概念\",\"t\":[\"undo log和redo log统称事务日志，不同于binlog是MySQL Server层的日志，这两个属于存储引擎层的日志\",\"redo log：重做日志，记录事务**的变化**，确保事务的持久性。 undo log：回滚日志，保存了事务发生之前的，用于事务的回滚操作，同时也是实现多版本并发控制（MVCC）下读操作（快照读）的关键技术\"]},\"1680\":{\"h\":\"2.undo log的作用\",\"t\":[\"undo log回滚日志的主要作用：\",\"事务发生错误时回滚rollback，，保证事务出错回滚或者我们手动\",\"提供了MVCC的非锁定读（快照读），依赖undo log实现\"]},\"1681\":{\"h\":\"3.undo log的数据结构\",\"t\":[\"![](MySQL回滚日志undo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16.png)\",\"在MVCC下，针对表的所有记录，除了我们自行设定的字段book_id、book_name、auther，还会添加几个字段\",\"DB_ROW_ID：和MVCC的关系不大，这个是我们创建表的时候，如果没有加PRIMARY KEY，那么InnoDB就自动生成主键列id（DB_ROW_ID），通过这个id作为主键创建索引树，在B+树的叶子节点上存放数据。由于InnoDB的数据和索引是存放在一起的，如果我们没有设置主键，InnoDB会自动生成主键\",\"DB_TRX_ID：事务ID，我们每打开一个客户端session，输入begin，向服务器请求开启一个事务。。当某个事务修改数据时，DB_TRX_ID放的就是该事务的ID，同一个事务无论怎么更改数据，这个事务ID都不会改变\",\"DB_ROLL_PTR：回滚指针，我们看到，存放的是地址，这个地址表示的是一个数据的内存的位置，看起来是一个链表，上图中的这个橙色表是最后的成品，那么这个表是怎么变来的呢？\",\"最初的时候表是这样的：\",\"![](MySQL回滚日志undo log.assets/89f6ddfd541041c6a8b684c31db1262a.png)\",\"现在有一个ID为1001的事务来更改这条数据，这个事务把book_name改成了“笑傲江湖（吕颂贤）”\",\"此时数据涉及到修改了，修改的数据存放在当前这个表中，那修改之前的数据怎么办？防止事务回滚恢复修改前的状态，需要将最初的数据存放在undo log中！\",\"现在undo log的数据结构如下：\",\"![](MySQL回滚日志undo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-17135959581577.png)\",\"现在有一个ID为1002的事务来更改这条数据，这个事务把book_name改成了“笑傲江湖（李亚鹏）”\",\"现在undo log的数据结构如下：\",\"![](MySQL回滚日志undo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171359600478510.png)\",\"MVCC会给我们创建的表增加2个列，一个是事务ID，一个是指向修改前的数据的指针，修改之前的数据都是放在undo log回滚日志当中。对于每个版本的数据，是哪个事务改的DB_TRX_ID就写哪个事务ID，DB_ROLL_PTR指针把当前数据和旧数据串成1个链表。从当前行的DB_ROLL_PTR可以访问到旧数据，进行回滚就很简单了\"]},\"1682\":{\"h\":\"三、undo log举例\",\"t\":[\"原始的user表如下：\",\"![](MySQL回滚日志undo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_7,color_FFFFFF,t_70,g_se,x_16.png)\",\"MVCC机制会对这张表增加2列，修改当前数据的事务ID（DB_TRX_ID）和指向undo log的指针（DB_ROLL_PTR）\",\"我们把id=7的age改为16，如下图所示：\",\"![](MySQL回滚日志undo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171359616071615.png)\",\"原来(id=7,age=15)这个版本的数据放到了undo log中\",\"这时我们再增加了1行新数据，由于新增的数据没有对应的老版本，所以undo log中对应为NULL，如下图所示：\",\"![在这里插入图片描述](MySQL回滚日志undo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171359623530518.png)\",\"回滚的时候发现是NULL，就知道是insert增加的数据，直接执行insert的反操作delete就可以了\",\"同样的，如果我们这时要修改刚刚insert的数据，将id=23的age改成23\",\"![](MySQL回滚日志undo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171359635630221.png)\",\"在已提交读和可重复读隔离级别下，当我们去读数据的时候，可不是像串行化一样通过SX锁或间隙锁实现，而是纯粹通过MVCC的快照读实现的\"]},\"1683\":{\"c\":[\"mysql\"]},\"1684\":{\"c\":[\"mysql日志\",\"mysql MVCC\"]},\"1685\":{\"h\":\"MySQL间隙锁（幻读解决原理）\"},\"1686\":{\"h\":\"一、间隙锁概念\",\"t\":[\"当我们用范围条件而不是相等条件检索数据， 并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)” ，InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁\",\"举例来说， 假如 user 表中只有 101 条记录， 其userid 的值分别是 1,2,…,100,101， 下面的 SQL： select * from user where userid > 100 for update;是一个范围条件的检索，InnoDB 不仅会对符合条件的 userid 值为 101 的记录加锁，也会对userid 大 于 101（但是这些记录并不存在）的\\\"间隙\\\"加锁，防止其它事务在表的末尾增加数据\",\"InnoDB ，对于上面的例子，要是不使用间隙锁，如果其他事务插入了 userid 大于 100 的任何记录，那么本事务如果再次执行上述语句，就会发生幻读\",\"InnoDB串行化隔离级别使用间隙锁（gap lock）解决幻读（事务并发情况下两次查询的数据量不同）问题\",\"间隙锁专用于串行化隔离级别，可解决幻读问题，幻读问题表现为：当前事务没做操作，前后两次相同的查询语句，显示的数据量不一致\",\"我们把事务2 select的指定的条件分为2类：范围查询、等值查询\",\"record lock：记录锁，就是行锁 gap lock：间隙锁，不包含记录本身 next-key lock：record lock（记录本身） + gap lock（不包括记录本身）\"]},\"1687\":{\"h\":\"二、测试间隙锁范围加锁\",\"t\":[\"设置事务为手动提交，然后把隔离级别设置成串行化\"]},\"1688\":{\"h\":\"场景1：用不可重复的 主键 id测试间隙锁\",\"t\":[\"范围查询\",\"事务2的select操作只给三行数据加了共享锁，为什么插入id为9的数据也不行呢？\",\"这是因为在串行化隔离级别中，不仅仅是获取了满足条件的这3行的行锁，而且把表记录之间以及后边空洞的地方也加上了\",\"select * from user where id>11; \",\"图中的地方都上了，上锁范围（左开右闭）为：( 11 , 12 ] ∪ ( 12 ， 22 ] ∪ ( 22 ， 23 ] ∪ ( 23 ， + ∞ ]\",\"也就是说，我们可以在id小于11的地方update/delete，加排它锁。但是操作了id<=11的部分，不影响相同的select * from stu where id>11所获取的数据量，这样就能防止幻读发生\",\"串行化隔离级别通过给select的部分加间隙锁，防止其他事务在加了间隙锁的区间进行增加或删除数据，就能防止幻读\"]},\"1689\":{\"h\":\"场景2：用可重复的age（有索引）测试间隙锁\",\"t\":[\"测试辅助索引树上，间隙锁的范围\",\"select * from user where age>20; \",\"很明显，由于age>20的区间都被事务1加上了间隙锁（这里加的是共享锁），所以事务2插入age=22和age=21都失败了\",\"幻读就是同一事务两次用相同的条件查询数据，下一次查出的数据量和上一次的数据量不一样，就算事务1把age=20的数据插入表，事务2再用age>20查询，得到的数据量也不会改变。\",\"那事务1插入age=20的数据能否成功呢？\",\"依然不能成功，这是因为我们插入的数据id是自增的，所以这条数据(age=20，id=24)，位于辅助索引树中(age=20，id=12)的右边，由于(age=20，id=12)右边都被上了锁，(age=20，id=24)自然无法插入\",\"也就是说，如果我们指定age=20，id合法且<12，则可插入\",\"很显然，事务1插入的age=18和age=19都不在事务2上锁的范围，所以可以插入\",\"如果只是在辅助索引树上查找，\",\"select id from stu where age>14后，辅助索引树加锁区间如下：\",\"image-20240419231953567\"]},\"1690\":{\"h\":\"场景3：MySQL5.7实际情况需要具体分析用的到底是行锁还是表锁\",\"t\":[\"MySQL5.7过滤出的数据占了整张表的一大半，MySQL server没使用索引。\",\"没有加行锁，\",\"age>20用到了，所以可以用\"]},\"1691\":{\"h\":\"三、测试等值间隙锁\"},\"1692\":{\"h\":\"1. 测试不能重复的主键索引\",\"t\":[\"此时事务2 select，由于是等值查询，相当于给这条数据加上了共享锁，事务1现在插入新的数据是可以成功的，因为主键id不能重复，我们不能再插入主键id=3的数据\",\"在这种情况下，由于id=3的数据已经存在，主键和唯一键是不能重复的，事务2进行等值查询时，事务1插入一个新的数据，不用担心这条新插入的数据和查询条件是一样的，如果主键一样，SQL语句执行失败，所以肯定能成功\"]},\"1693\":{\"h\":\"2. 测试能重复的辅助索引\",\"t\":[\"事务2等值查询，给age=21这行数据加上共享锁（record-lock），\",\"事务1插入age=21，这是不能允许的，否则事务2再查询age=18就有两条记录了（幻读）\",\"奇怪的是，我们插入age=18，21都被阻塞了，而22、17成功了\",\"这是因为，为了防止幻读，除了age=21这条数据加了共享锁，其两侧也被加上了间隙锁\",\"因为在这种情况下，插入(age=21,id=5)和(age=21,id=9)是会发生幻读的，所以在一切会影响select * from user where age=18查询结果的地方都加上了间隙锁，但这也会导致一些本不影响查询结果的语句也执行失败，比如插入(age=17，id=10)虽然不影响上述SQL执行结果，由于在间隙锁范围内，依然无法插入\",\"插入(age=22)就可以成功，根据辅助索引值相同，按照主键值升序排列，(age=22，id=9)应该放在(age=22,id=4)前面，不在间隙锁范围内\"]},\"1694\":{\"h\":\"小结\",\"t\":[\"间隙锁是给不存在的数据记录的范围加锁：\",\"对于，在串行隔离级别中如果进行等值查询，InnoDB会给数据加上（）\",\"对于，那只需要就够了，不需要再加间隙锁（）\",\"串行化隔离级别通过和解决（两次查询的数据内容不同），通过解决（两次查询的数据量不同）\"]},\"1695\":{\"c\":[\"mysql\"]},\"1696\":{\"c\":[\"mysql锁机制\"]},\"1697\":{\"h\":\"排它锁和共享锁\",\"t\":[\"排它锁（Exclusive），又称为X锁，写锁共享锁（Shared），又称为S锁，读锁，但是\",\"对事务加X和S锁之间有以下的关系：\",\"一个事务对数据对象A加了 S 锁，可以对A进行但，加锁期间但\",\"一个事务对数据对象A加了 X 锁，就可以对A进行，加锁期间其它事务\"]},\"1698\":{\"h\":\"显式加锁：\",\"t\":[\"select … lock in share mode #强制获取共享锁 select … for update #获取排它锁 \"]},\"1699\":{\"h\":\"测试不同事务之间排它锁和共享锁的兼容性\",\"t\":[\"我们先查看键表的SQL以及内容\",\"查看隔离级别：\",\"首先开启一个事务，给id=7的数据加上排它锁，我们用另一个事务的服务线程给id=7的数据加上排它锁，阻塞了\",\"我们尝试给id=7的数据加上共享锁，还是了；再获取id=8的共享锁和排它锁，可以成功获取id=8的共享锁和排它锁\",\"小结：不同事务之间对于数据的锁，只有SS锁可以共存，XX、SX、XS都不能共存\"]},\"1700\":{\"h\":\"测试行锁加在索引项上\",\"t\":[\"其实行锁是加在索引树上的\",\"事务1用表的无索引字段age作为过滤条件；事务2现在同样想获取这条记录的排它锁，可想而知地了；那现在事务2获取不同行chenwei的记录的排它锁，\",\"。然而现在我们发现获取age=20的排它锁也获取不到了，这是为什么？我们解释一下：\",\"而我们用age作为过滤条件没有用到索引，自然就不会使用行锁，而是使用表锁。这就意味着只有通过索引检索数据，InnoDB才使用行级锁，如果做整表扫描，InnoDB将使用表锁！！！\",\"两个事务可以获取到不同行的排它锁（for update），再一次证明了InnoDB的行锁是加在索引项上的\",\"是如果使用相同的索引字段(zhangsan)作为过滤条件，依然会发生锁冲突，只能串行进行，不能并发进行。\",\"因为现在name走的是索引， 通过zhangsan在辅助索引树上找到它所在行记录的id是1，然后到主键索引树上，获取对应行记录的排他锁（MySQL Server会根据情况，在主键索引树和辅助索引树上加锁）\"]},\"1701\":{\"h\":\"串行化隔离级别测试\",\"t\":[\"在SERIALIZABLE隔离级别下，所有的事务都自动使用排它锁或共享锁，不需要用户手动加锁（for in share mode/for update）\",\"两个事务可以同时获取共享锁（SS共存），事务2插入数据\",\"此时由于insert需要加排它锁，但由于\",\"因为我们给name加上了索引，以上的select相当于给name为zhangsan的数据加上了行共享锁\",\"，因为此时已经被事务1的\",\"事务2在辅助索引树上找zhangsan，找到对应的主键值，然后去主键索引树找到相应的记录，但是发现这行记录已经被共享锁锁住了，事务2可以获取共享锁，但是不能获取排他锁\",\"我们用主键索引id试试能不能update\",\"依然阻塞住了，虽然我们where后面的字段现在使用的id而不是name，但是name也是通过辅助索引树找到对应的主键，再到主键索引树上找相应的记录，而主键索引树上的记录加了锁（MySQL Server会根据情况，在主键索引树和辅助索引树上加锁）\",\"我们update id=8的数据，成功了。因为我们select的时候，只是给id=7 name=zhangsan的数据加上了行锁，我们操作id=8的数据当然可以成功\"]},\"1702\":{\"h\":\"注意\",\"t\":[\"有索引，则使用行锁；没有索引，则使用表锁。\",\"表级锁还是行级锁说的是锁的粒度，共享锁和排他锁说的是锁的性质，不管是表锁还是行锁，都有共享锁和排他锁的区分\"]},\"1703\":{\"c\":[\"mysql\"]},\"1704\":{\"c\":[\"mysql锁机制\"]},\"1705\":{\"h\":\"死锁\"},\"1706\":{\"h\":\"数据库中的死锁\",\"t\":[\"MyISAM 表锁是 deadlock free 的， 这是因为 MyISAM 不支持事务，只支持表锁，而且总是一次获得所需的全部锁，要么全部满足，要么等待，因此不会出现死锁。\",\"在 InnoDB 中，除单个 SQL 组成的事务外，锁是逐步获得的，即锁的粒度比较小（行锁），这就决定了在 InnoDB 中发生死锁是可能的\",\"死锁问题一般都是我们自己的应用造成的，和多线程编程的死锁情况相似，大部分都是由于我们多个线程在获取多个锁资源的时候，获取的顺序不同而导致的死锁问题。因此我们应用在对数据库的多个表做更新的时候，不同的代码段，应对这些表按，以防止锁冲突导致死锁问题\"]},\"1707\":{\"h\":\"死锁场景以及解决办法\",\"t\":[\"死锁出现的场景如下：\",\"事务1成功获取行锁1 事务2成功获取行锁2 … 事务1无法获取行锁2，被阻塞的同时也无法释放行锁1 事务2无法获取行锁1，被阻塞的同时也无法释放行锁2\",\"此时所有的事务都阻塞住了，相当于进程内的所有线程都阻塞住了，发生了死锁问题\",\"解决死锁办法：多个事务/线程获取多个相同资源锁的时候应该。与此同时，\"]},\"1708\":{\"h\":\"操作\",\"t\":[\"设置自动提交 以及 可重复读隔离级别，开启事务\",\"查询一下表数据，在可重复读隔离级别\",\"事务1获取id=7的排他锁，事务2获取id=8的排他锁（）\",\"事务1再次获取id=8的排他锁，发生阻塞\",\"事务2再次获取id=7的排他锁\",\"此时\",\"两个事务发生死锁时，MySQL Server会选择一个事务释放锁并进行rollback\"]},\"1709\":{\"c\":[\"mysql\"]},\"1710\":{\"c\":[\"mysql锁机制\"]},\"1711\":{\"h\":\"表级锁和行级锁\",\"t\":[\"事务隔离级别的实现原理：简单来说就是各种锁机制和MVCC多版本并发控制\",\"我们学习知识的时候，需要了解知识点出现的原因，什么情况下能用到这个知识\",\"我们说到事务，就得说到事务的ACID特性，为什么需要隔离性呢？因为事务要能够允许并发执行，并发执行为了同时保证数据的安全性，一致性和并发的效率，就需要设置事务的隔离级别\"]},\"1712\":{\"h\":\"一、事务隔离机制的选择\",\"t\":[\"image-20240419183553280\",\"如果我们，使用未提交读的事务隔离机制，任由这些线程并发操作数据库，那就会出现脏读（读取了未commit的数据）、不可重复读（两次查询值不同）、幻读（两次查询数据量不同）等问题，数据的安全性最低，优点是并发效率非常高，\",\"如果我们串行化（），，虽然数据的安全性提高了，并发的效率就太低了，\",\"所以我们一般用的是已提交读、可重复读这两个隔离级别，平衡了数据的安全性，一致性以及并发的效率 ，是由并发控制实现的（MVCC是已提交读和可重复读的原理，锁是串行化的原理）\"]},\"1713\":{\"h\":\"二、表级锁&行级锁\",\"t\":[\"表级锁：对整张表加锁。开销小（因为不用去找表的某一行的记录进行加锁，要修改这张表，直接申请加这张表的锁），加锁快，不会出现死锁；锁粒度大，发生锁冲突的概率高，并发度低\",\"行级锁：对某行记录加锁。开销大（需要找到表中相应的记录，有的过程），加锁慢，会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度高\",\"InnoDB存储引擎支持事务处理，表支持行级锁定，并发能力更好\",\"InnoDB行锁是通过给索引上的来实现的，而不是给表的行记录加锁实现的，这就意味着\",\"由于InnoDB的行锁实现是针对索引字段添加的锁，不是针对行记录加的锁，因此虽然访问的是InnoDB引擎下表的不同行，但如果使用相同的索引字段作为过滤条件，依然会发生锁冲突，只能串行进行，不能并发进行\",\"即使SQL中使用了索引，但是经过MySQL5.7的优化器后，如果认为全表扫描比使用索引效率高，此时会放弃使用索引，因此也不会使用行锁，而是使用表锁，比如对一些很小的表，MySQL就不会去使用索引\"]},\"1714\":{\"c\":[\"mysql\"]},\"1715\":{\"c\":[\"mysql锁机制\"]},\"1716\":{\"h\":\"记录锁+间隙锁可以防止删除操作而导致的幻读吗？\"},\"1717\":{\"h\":\"MySQL 是怎么解决幻读的？\",\"t\":[\"MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：\",\"针对快照读（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。\",\"针对当前读（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。\"]},\"1718\":{\"h\":\"加锁分析\",\"t\":[\"问题来了，A 事务在执行 select … for update 语句时，具体加了什么锁呢？\"]},\"1719\":{\"h\":\"如果对 age 没有索引，事务 A 这条查询会加什么锁呢？\",\"t\":[\"我们可以通过 select * from performance_schema.data_locks\\\\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。\",\"从上面输出的信息可以看到，共加了两种不同粒度的锁，分别是：\",\"表锁（LOCK_TYPE: TABLE）：X 类型的意向锁； 行锁（LOCK_TYPE: RECORD）：X 类型的 next-key 锁； 这里我们重点关注「行锁」，图中 LOCK_TYPE 中的 RECORD 表示行级锁，而不是记录锁的意思：\",\"如果 LOCK_MODE 为 X，说明是 next-key 锁； 如果 LOCK_MODE 为 X, REC_NOT_GAP，说明是记录锁； 如果 LOCK_MODE 为 X, GAP，说明是间隙锁；\",\"因此，此时事务 A 在主键索引（INDEX_NAME : PRIMARY）上加了 10 个 next-key 锁，如下：\",\"X 型的 next-key 锁，范围：(-∞, 1] X 型的 next-key 锁，范围：(1, 2] X 型的 next-key 锁，范围：(2, 3] X 型的 next-key 锁，范围：(3, 4] X 型的 next-key 锁，范围：(4, 5] X 型的 next-key 锁，范围：(5, 6] X 型的 next-key 锁，范围：(6, 7] X 型的 next-key 锁，范围：(7, 8] X 型的 next-key 锁，范围：(8, 9] X 型的 next-key 锁，范围：(9, +∞]\",\"这相当于把整个表给锁住了，其他事务在对该表进行增、删、改操作的时候都会被阻塞。\"]},\"1720\":{\"h\":\"如果对 age 建立索引，事务 A 这条查询会加什么锁呢？\",\"t\":[\"继续通过 select * from performance_schema.data_locks\\\\G; 这条语句，查看事务执行 SQL 过程中加了什么锁。\",\"因为表中有两个索引，分别是主键索引和 age 索引，所以会分别对这两个索引加锁。\"]},\"1721\":{\"h\":\"总结\",\"t\":[\"在 MySQL 的可重复读隔离级别下，针对当前读的语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。\"]},\"1722\":{\"c\":[\"mysql\"]},\"1723\":{\"c\":[\"mysql锁机制\"]},\"1724\":{\"h\":\"锁的优化建议\",\"t\":[\"在能正确完成业务的前提下，为确保效率，尽量使用较低的隔离级别（必须避免脏读）\",\"设计合理的索引并**引访问数据，使加锁更准确，减少锁冲突的机会，提高并发能力**\",\"选择合理的事务大小，发生锁冲突的概率小（事务越大，包含的SQL越多，可能包含更多的表资源和行资源的锁，增大了锁冲突的概率）\",\"不同的程序访问一组表时，应尽量约定以相同的访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会\",\"尽量用访问数据，这样可以避免对并发插入的影响（）\",\"不要申请超过实际需要的锁级别\",\"除非必须，查询时不要显示加锁（）\"]},\"1725\":{\"c\":[\"mysql\"]},\"1726\":{\"c\":[\"mysql锁机制\"]},\"1727\":{\"h\":\"sql优化\"},\"1728\":{\"h\":\"一、大批量插入数据\",\"t\":[\"当使用load 命令导入数据的时候，适当的设置可以提高导入的效率\"]},\"1729\":{\"h\":\"1） 主键顺序插入\",\"t\":[\"load data local infile '/root/data1.log' into table `tb_user` fields terminated by ',' lines terminated by '\\\\n'; \",\"插入ID顺序排列数据：\",\"插入ID无序排列数据：\"]},\"1730\":{\"h\":\"2） 关闭唯一性校验\",\"t\":[\"在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率\"]},\"1731\":{\"h\":\"3） 手动提交事务\",\"t\":[\"如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率\"]},\"1732\":{\"h\":\"二、优化insert\"},\"1733\":{\"h\":\"1.逐条插入改为批量插入\",\"t\":[\"insert into tb_test values(1,'Tom'); insert into tb_test values(2,'Cat'); insert into tb_test values(3,'Jerry'); \",\"优化后的方案为 ：\",\"insert into tb_test values(1,'Tom'),(2,'Cat')，(3,'Jerry'); \"]},\"1734\":{\"h\":\"2.在事务中进行数据插入\",\"t\":[\"start transaction; insert into tb_test values(1,'Tom'); insert into tb_test values(2,'Cat'); insert into tb_test values(3,'Jerry'); commit; \"]},\"1735\":{\"h\":\"3.数据有序插入\",\"t\":[\"insert into tb_test values(1,'Tom'); insert into tb_test values(3,'Jerry'); insert into tb_test values(2,'Cat'); \",\"优化后\",\"insert into tb_test values(1,'Tom'); insert into tb_test values(2,'Cat'); insert into tb_test values(3,'Jerry'); insert into tb_test values(4,'Tim'); insert into tb_test values(5,'Rose'); \"]},\"1736\":{\"h\":\"三、优化order by\",\"t\":[\"MySQL中有两种排序方式：using filesort 和 using index\",\"filesort ：对返回数据进行排序，\",\"index：有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高\",\"我们现在有联合索引A、B，当A相等时，B升序排列，比如：\",\"A：1 1 1 1 2 2 3 3 3 B：2 3 4 5 3 4 5 1 2 \",\"对于Filesort ， MySQL 有两种排序算法：\",\"1） 两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。\",\"2）一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。\",\"通过创建合适的，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作\",\"MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定使用哪种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。\",\"可以\"]},\"1737\":{\"h\":\"四、MySQL5.7优化group by\",\"t\":[\"由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。既然会排序，就可以用到索引\",\"于是我们有两种方式优化group by：\",\"order by null，\",\"给group by字段\"]},\"1738\":{\"h\":\"五、优化子查询\",\"t\":[\"用更高效的连接（JOIN）替代子查询\",\"示例 ，查找有角色的所有的用户信息 :\",\"explain select * from t_user where id in (select user_id from user_role); \",\"#优化1 join SELECT t_user.* FROM t_user JOIN user_role ON t_user.id = user_role.user_id; #优化2 explain select * from t_user u , user_role ur where u.id = ur.user_id; \"]},\"1739\":{\"h\":\"六、优化OR\",\"t\":[\"建议使用 union all替换 or\",\"这就把type字段从range优化为了const\"]},\"1740\":{\"h\":\"七、优化分页查询\",\"t\":[\"一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10 ，此时MySQL需要排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。\",\" -- 耗时2.12s select * from tb_item limit 2000000, 10; \",\"优化思路一：在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容\",\" -- 耗时1.51s select * from tb_item t, (select id from tb_item order by id limit 2000000,10) a where t.id = a.id; \",\"优化思路二：该方案适用于主键自增且连续的表，可以把limit查询转换成某个位置的查询\",\" -- 耗时0.00s select * from tb_item where id > 2000000 limit 10; \"]},\"1741\":{\"c\":[\"mysql\"]},\"1742\":{\"c\":[\"mysql优化\"]},\"1743\":{\"h\":\"SQL和索引优化总结\",\"t\":[\"首先我们需要知道MySQL主要是从以下3个方面进行优化：\",\"SQL语句和索引\",\"应用优化（引入缓存、连接池）\",\"配置参数优化\"]},\"1744\":{\"h\":\"一、SQL语句和索引的优化\",\"t\":[\"当数据量比较大，若SQL语句写的不合适，会导致SQL的执行效率低，我们需要等待很长时间才能拿到结果\",\"针对性优化的时候，\",\"explain分析的时候可能出现以下问题：\",\"用，导致没用到索引\",\"的大小表设置不合理，导致索引没用上（小表是整表查询，）\",\"多表查询不用in（产生中间表），用的过程，合理使用索引\"]},\"1745\":{\"h\":\"二、应用优化\",\"t\":[\"除了优化SQL和索引，在实际生产环境中，由于数据库服务器本身的性能局限，就必须要对上层的应用来进行一些优化，使得上层应用访问数据库的压力能够减到最小\",\"引入数据库连接池；防止客户端不断，耗费网络以及服务器资源，我们可以引入数据库连接池，这是高并发场景下常用的一种优化手段（需要设置初始连接量，最大连接量以及最大空闲时间等参数）\",\"引入缓存；用于，如果客户端的请求来了，先在redis上查一下（redis是基于内存的数据库），如果redis上直接查到就不经过MySQL数据库，如果没有查到就去访问MySQL数据库，访问MySQL完成后，先把当前访问的数据往redis上缓存一下，再把结果返回给用户\",\"引入redis缓存的话，也会有一些附带的问题：等等\"]},\"1746\":{\"h\":\"三、MySQL Server优化\",\"t\":[\"对于MySQL Server端的优化，主要指的是MySQL Server启动时加载的配置文件（my.ini或my.cnf）中配置项的优化\"]},\"1747\":{\"h\":\"自适应哈希索引\",\"t\":[\"[InnoDB自适应哈希索引 | 张威的编程学习笔记 (gitee.io)](https://iszhwei.gitee.io/mysql/04 MYSQL索引/InnoDB自适应哈希索引.html)\",\"由于hash索引的生成和维护也是耗费性能的，通过以下命令查看自适应哈希索引搜索的频率低于使用二级索引树搜索的频率：\",\"show engine innodb status\\\\G \",\"如果使用，可以通过变量innodb_adaptive_hash_index关闭自适应哈希索引\"]},\"1748\":{\"h\":\"redo log\",\"t\":[\"可以根据物理机的条件，，Innodb_buffer_pool_size（缓存的大小），来减少磁盘I/O次数，因为缓存区大了，在缓冲区工作的时间就长了，redo log的效率就高了\",\"my.cnf配置参数如下：\"]},\"1749\":{\"h\":\"MySQL查询缓存\",\"t\":[\"MySQL的查询缓存是把上一次select的查询结果记录下来放在缓存当中，下一次再查询相同内容的时候，直接从缓存中取出来就可以了，不用再进行一遍真正的SQL查询（在内存中划分一块空间用做缓存的地方）\",\"查询缓存适用于更新不频繁的表，查询频繁的表，因为\"]},\"1750\":{\"h\":\"MySQL5.7 支持查询缓存\",\"t\":[\"可以通过以下命令，来查看查询缓存的设置：\",\"如果某个表的查询多而更改少，可以考虑开启查询缓存\",\"通过show status命令，可以查看MySQL查询缓存的使用状况，如下：\",\"可以通过set命令设置上面的缓存参数开启MySQL查询缓存功能，也可以找到MySQL的配置文件（windows是my.ini，linux是my.cnf），修改query_cache_type参数为1就可以了，然后重启MySQL Server就可以使用了，如下：\",\"，如果我们引入redis的话，可以通过redis提供的API精确控制要缓存的数据，以及不缓存的数据\"]},\"1751\":{\"h\":\"MySQL8.0 不支持查询缓存\"},\"1752\":{\"h\":\"索引和数据缓存\",\"t\":[\"主要指的就是innodb_buffer_pool_size配置项，从名字上就能看到，该配置项是针对InnoDB存储引擎起作用的，这个参数定义了InnoDB存储引擎的表数据和索引数据的最大内存缓冲区大小。innodb_buffer_pool_size是同时为数据块和索引块做缓存，这个值设的越高，访问表中数据需要的磁盘I/O就越少\",\"innodb_buffer_pool_size = 402653184 -- 384M \"]},\"1753\":{\"h\":\"MySQL线程缓存\",\"t\":[\"主要指配置文件中thread_cache_size配置项\",\"MySQL Server网络模块采用经典的，之所以引入线程池，主要就是为了在业务执行的过程中，不会因为临时创建和销毁线程，造成系统性能降低，因为线程的创建和销毁是很耗费性能的\",\"配置完thread_cache_size，\"]},\"1754\":{\"h\":\"并发连接数量和超时时间\",\"t\":[\"MySQL Server作为一个服务器，可以设置客户端的**和**，如果数据库连接统计数量比较大，这两个参数的值需要设置大一些\",\"在配置文件（my.cnf或my.ini）最下面，添加配置：max_connections=1000，然后\",\"MySQL Server对于长时间未通信的连接，会主动关闭连接。设置超时时间，超过设置时间，单位是秒，在配置文件中添加配置：wait_timeout = 600\",\"> wait_timeout：服务器在关闭非交互式连接之前等待活动的秒数（空闲连接存活时间）\",\"> connect_timeout：mysqld服务器在响应错误握手之前等待连接数据包的秒数（连接超时时间）\",\"例子\",\">如果wait_timeout为1800(30分钟),如果连接空闲,则DB连接将在30分钟内关闭(由进程列表的命令列中的Sleep指示).\\n>如果connect_timeout是10,那么如果您在10秒内无法登录(验证),mysqld将拒绝您.\"]},\"1755\":{\"c\":[\"mysql\"]},\"1756\":{\"c\":[\"mysql优化\"]},\"1757\":{\"h\":\"MySQL重做日志redo log\",\"t\":[\"在事务的ACID特性中，原子性（A）、一致性（C）、持久性（D）由undo log和redo log实现，隔离性（I）由锁+MVCC实现\",\"undo log：事务还没有commit，中途执行异常，可以使用undo log把数据恢复到事务执行前的状态，确保事务的原子性redo log：事务commit成功，，此时若发生异常，就要使用redo log重新执行这一事务的SQL，确保事务的持久性（只要事务commit成功，不管发生什么异常事件，只要下一次MySQL服务正常进行，那上一次commit的数据一定要恢复回来）\"]},\"1758\":{\"h\":\"一、redo log概念\",\"t\":[\"redo log：被称为物理日志，用于记录事务操作的变化，确保事务的持久性。，无论事务是否commit都会记录，若异常发生，下一次mysqld再启动时，会使用redo log将数据重新写入磁盘，确保事务的持久性。\",\"undo log：被称为逻辑日志，存储的是具体的相应的SQL语句。\",\"redo log默认放在/var/lib/mysql下\",\"![](MySQL重做日志redo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_15,color_FFFFFF,t_70,g_se,x_16.png)\",\"redo log是在事务begin时就开始记录（并不是事务commit时才记录，因为整个事务做的操作可能很多，如果在commit的时候才写redo log，此时一旦发生异常，redo log还没写，这就太晚了，无法确保事务的持久性），不管事务是否提交都会记录下来，在异常发生时（如数据持久化过程中掉电），InnoDB会使用redo log恢复到掉电前的时刻，保证数据的完整性\",\"innodb_log_buffer_size默认是16M，就是redo log缓冲区的大小，它随着事务开始，就开始写redo log，如果事务比较大，为了避免事务执行过程中花费过多磁盘IO，可以设置比较大的redo log缓存，节省磁盘IO。往磁盘上刷是有刷新的时机，达到时机就花费磁盘IO，如果buffer比较大，会更慢的达到刷新的时机，效率更高。\",\"![](MySQL重做日志redo log.assets/f60d9030542748d68ba123288bd2f366.png)\",\"**InnoDB修改操作数据，不是直接修改磁盘上的数据，实际只是修改Buffer Pool中的数据。**InnoDB总是先把Buffer Pool中的数据改变记录到redo log中，用来进行崩溃后的数据恢复。 优先记录redo log，然后会有一个独立的线程找时机慢慢的将Buffer Pool中的脏数据刷新到磁盘上（异步过程）\",\"innodb_log_group_home_dir指定的目录下的两个文件：ib_logfile0，ib_logfile1，该文件被称作重做日志\",\"buffer pool缓存池： 可存放索引缓存、数据缓存等，可加速读写，直接操作数据页，，有专门的线程去做把buffer pool中的dirty page写入磁盘\",\"buffer pool大致结构如图所示：\",\"![](MySQL重做日志redo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16.png)\",\"事务读取，修改都是优先操作缓存池中的数据。在实际项目中，mysqld会单独的跑在一个机器上，可以分配大量的内存专门作为InnoDB的buffer pool，加快CRUD\",\"buffer pool默认大小为128M（MySQL 5.7和8.0一样）\",\"![](MySQL重做日志redo log.assets/e9dcd78f6d444a1d869a00b6bac9028f.png)\"]},\"1759\":{\"h\":\"二、缓存、磁盘结构\",\"t\":[\"![](MySQL重做日志redo log.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-17136210429909.png)\",\"当事务commit的时候，在关系图上的操作就是，写成功的话，在磁盘上的redo log会记录状态为commit，如果没有写成功或者写完，则记录状态为prepare\",\"log在写入磁盘的过程中也有可能发生异常，断电等问题，导致在写redo log的时候没有写完（这相当于事务没有commit成功），此时MySQL下次再恢复的时候就没有必要考虑这个事务的完整性，因为状态并不是commit，都写入磁盘上才表示redo log写成功，状态才变成commit，状态变成commit后需要维护事务的ACID特性。\"]},\"1760\":{\"h\":\"是不是commit的时候，buffer pool里面的脏数据（数据有被修改）同步被写入磁盘？\",\"t\":[\"并不需要等commit的时候才开始。事务可能修改的数据量比较大，而缓存容量有限，对于buffer pool缓存的数据，会有专门的线程在合适的时间，往磁盘上去刷新，如果出现掉电，下一次MySQL启动后，会根据redo log里面记录的数据，对数据进行恢复。所以当事务commit后，最重要的是redo log要写成功\"]},\"1761\":{\"h\":\"undo log本身也是记录在redo log中\",\"t\":[\"undo log支持事务回滚，也不是一瞬间就能完整，font>，回滚过程也会出现异常，下次服务重启时，需要使用undo log重新回滚，所以undo log要记录在redo log里面。事务commit成功或者rollback成功，对于底层，都是成功的把操作写到磁盘上的redo log里面\"]},\"1762\":{\"h\":\"什么是真正的事务commit成功？\",\"t\":[\"不是把数据全部刷到磁盘，而是把记录事务完整操作的redo log从log buffer写入磁盘，再把被修改数据的状态置为commit才算是实现了事务commit成功。此时虽然数据还在buffer pool，但只要我们的redo log保存完整，数据就可以恢复，会有专门的线程去负责把buffer pool里的数据写入磁盘\",\"一个事务commit成功通常涉及以下几个关键步骤：\",\"Redo Log的写入：在事务执行过程中，所有对数据的修改操作都会被记录在redo log中。这些redo log首先被写入log buffer，然后在事务提交时，会被刷新（flush）到磁盘上的redo log文件中。这一步是确保事务持久性的关键，因为如果系统崩溃，redo log可以用来恢复数据到事务提交时的状态。\",\"数据页状态的更改：在InnoDB存储引擎中（以MySQL为例），数据通常保存在buffer pool中，这是一个内存缓存，用于加速数据的读取和写入。当事务提交时，被修改的数据页的状态会被标记为“commit”。这意味着这些页上的修改是持久的，即使它们还没有被刷新到磁盘上的数据文件中。\",\"后台的I/O操作：尽管数据页可能还在buffer pool中，但后台的I/O线程会异步地将这些页刷新到磁盘。这个过程是异步的，它不会影响事务的提交。即使刷新过程中发生了错误，由于有redo log的存在，数据仍然可以恢复。\"]},\"1763\":{\"h\":\"什么叫事务commit成功？（和上面的问题一样）\",\"t\":[\"事务执行commit命令后，mysqld将记录了数据修改的Log Buffer写入磁盘上的redo log，然后将这部分数据的状态修改为commit，写完redo log后才算是事务提交成功，MySQL Server需要保持commit状态的数据的持久性。如果写redo log失败，数据的状态还是prepare，尽管事务执行了commit命令，这依然不算commit成功\",\"事务进行操作的时候，永远是先写log buffer，然后才是写buffer pool；事务成功commit，就是要保证redo log完整记录到磁盘上\",\"至于表数据的更改，buffer pool的脏数据页是不是刷新到磁盘上，我们根本不用担心，只要redo log完整的写到磁盘上，我们可以随时通过redo log重做日志来恢复事务成功commit的数据状态（数据库最重要的是日志，而不是数据）\"]},\"1764\":{\"c\":[\"mysql\"]},\"1765\":{\"c\":[\"mysql日志\"]},\"1766\":{\"h\":\"Server层四个日志\"},\"1767\":{\"h\":\"一、MySQL Server层日志简介\",\"t\":[\"一个mysql client发起一个连接请求，处理请求的过程如下图所示：\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16.png)\",\"MySQL日志是在MySQL server上生成的，不管更改哪个存储引擎，这些日志都是需要有的，包括：\",\"错误日志：记录mysqld服务运行过程中出现的等\",\"查询日志：记录MySQL Server收到的。由于上线项目的SQL太多了，开启查询日志IO太多导致MySQL效率低下，我们一般都不会开启查询日志，只有调试时才开启\",\"二进制日志：，非常重要，可用于数据恢复，主从复制。，\",\"慢查询日志：，可供开发人员分析耗时SQL，从而针对性优化\"]},\"1768\":{\"h\":\"查看日志相关变量\",\"t\":[\"mysql> show variables like 'log%'; \",\"![](Server 层四个日志.assets/image-20240421014049849.png)\",\"show variables #查看变量 show status #查看状态 \"]},\"1769\":{\"h\":\"二、配置文件参数\",\"t\":[\"my.cnf\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_19,color_FFFFFF,t_70,g_se,x_16.png)\",\"linux下重启mysqld服务的命令：sudo service mysqld restart\",\"我们查看一下配置文件 /etc/mysql/mysql.conf.d/mysqld.cnf \",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_16,color_FFFFFF,t_70,g_se,x_16.png)\",\"给出log-error的路径就是开启了log-error，如果不自定义log-error的路径，默认在data_dir\",\"expire_log_days=7; \"]},\"1770\":{\"h\":\"三、错误日志\",\"t\":[\"错误日志是 MySQL 中最重要的日志之一，它记录了mysqld 启动和停止，以及服务器在运行过程中发生任何严重错误（coredump，error，exception…）时的相关信息。当数据库出现故障导致无法正常使用时，可以首先查看此日志\",\"mysqld 使用的错误日志名为 host_name.err(host_name 为主机名) ，并默认在参数data_dir(数据目录)指定的目录中写入日志文件\",\"![](Server 层四个日志.assets/image-20240421114121369.png)\",\"![](Server 层四个日志.assets/image-20240421114020759.png)\"]},\"1771\":{\"h\":\"四、查询日志\",\"t\":[\"查询日志记录了client发送的所有SQL语句\",\"由于上线项目sql特别多，开启查询日志IO太多导致MySQL效率低，我们一般都不会开启，只有在调试时才开启，比如通过从而可以进行缓存\",\"show global variables like '%genera%'; \",\"![](Server 层四个日志.assets/01caeb58b8a141a390482e91923d36bc.png)\",\"打开全局变量general_log开关：\",\"![](Server 层四个日志.assets/d76e9880719c4ff181c3b1841cf71a97.png)\"]},\"1772\":{\"h\":\"五、二进制日志\",\"t\":[\"不是明文(记录数据库的详细内容，明文不安全)，不能直接查看，需要通过mysqlbinlog工具（mysql原生自带）解析binlog日志文件\",\"二进制日志(BINLOG)记录了所有的 DDL(数据定义语言)语句和 DML(数据操纵语言) 语句，但是不包括数据查询语句（）\",\"语句以“事件”的形式保存，它描述了数据的更改过程。二进制日志对于灾难时的数据恢复起着极其重要的作用。\",\"两个重要的应用场景：\",\"主从复制：主库所有的更新操作（update、delete、insert、alter …）都记录在binlog中，从库读主库的binlog，把binlog的所有操作在从库上在进行一遍\",\"查看当前的binlog：\",\"show binary logs; -- show master logs; \",\"![](Server 层四个日志.assets/d508ea09b0b44e77a66982dbe8894d08.png)\",\"binlog默认在MySQL的配置文件/etc/mysql/my.cnf配置的data_dir下\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171363507402613.png)\"]},\"1773\":{\"h\":\"1. 演示binlog记录更改\",\"t\":[\"我们先刷新一下，生成一个新的binlog\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_11,color_FFFFFF,t_70,g_se,x_16.png)\",\"切换数据库\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_18,color_FFFFFF,t_70,g_se,x_16.png)\",\"更改一下数据\",\"![](Server 层四个日志.assets/58acce702aa9441a86491432ea8315c3.png)\",\"再次查看binlog\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_11,color_FFFFFF,t_70,g_se,x_16-171363514679822.png)\",\"我们发现日志的filesize从154字节—>710字节，肯定记录我们刚才的数据更改操作\",\"如果我们直接cat日志查看，会发现不是明文，无法直接查看\",\"![](Server 层四个日志.assets/9c810ccb629b445eaa9205e384e5e415.png)\",\"我们需要通过mysqlbinlog进行查看，如下：\",\"mysqlbinlog --no-defaults --database=school --base64-output=decode-rows -v --start-datetime='2022-03-01 00:00:00' --stop-datetime='2022-03-31 00:00:00' mysql-bin.000003 | more \",\"database：指定查看某个库的更改\",\"base64-output：binlog解码方式\",\"start-datetime & stop-datetime：指定查看某个时间段内的更改，不写则查看所有的更改\",\"mysql-bin.000003：查看的二进制日志文件路径\",\"我们查看一下binlog\",\"![](Server 层四个日志.assets/0aff49012e1e4ad5ba404436fed4022e.png)\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171363526798929.png)\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171363528522132.png)\",\"@1、@2、@3、@4：表示数据库表的4个字段\",\"server id：表示我们在my.cnf中设置的id，用于标识当前MySQL的身份\",\"at 565、at 621：指的是当前事件在binlog记录的位置，数据恢复的时候使用\"]},\"1774\":{\"h\":\"2. 演示binlog数据恢复\",\"t\":[\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_11,color_FFFFFF,t_70,g_se,x_16-171363531440435.png)\",\"现在创建数据库mytest，并创建表，添加数据\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_16,color_FFFFFF,t_70,g_se,x_16-171363533193338.png)\",\"假如现在有人把库删除了：\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_14,color_FFFFFF,t_70,g_se,x_16.png)\",\"我们现在知道，我们建库、建表、插入数据的操作都记录在mysql-bin.00003文件中\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_12,color_FFFFFF,t_70,g_se,x_16.png)\",\"我们现在，这就可以让我们接下来数据恢复的操作被记录在mysql-bin.00004文件中，而不会在追加到mysql-bin.00003\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_10,color_FFFFFF,t_70,g_se,x_16.png)\",\"我们先查看mysql-bin.00003，找需要恢复的区间\",\"![](Server 层四个日志.assets/image-20240421015016270.png)\",\"从mysql-bin.000003中拿出区间内所有的操作，通过管道放到MySQL shell上执行\",\"mysqlbinlog --start-position=775 --stop-position=1410 binlog.000003 | mysql -uroot -p \",\"![](Server 层四个日志.assets/d3b2c91361144652ae6c23c89c4b300e.png)\",\"start-position和stop-position表示左闭右开区间：[start-position, stop-position)\",\"查看一下当前的库\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_9,color_FFFFFF,t_70,g_se,x_16.png)\",\"再查看一下表和数据\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171363548398851.png)\",\"到这里，数据已经全部恢复了\",\"我们不仅可以通过binlog记录的位置，得到需要恢复的区间，也可以通过binlog记录的时间得到需要恢复的区间\",\"![](Server 层四个日志.assets/808c1b4abe9b4249acdb95968b5c7109.png)\",\"mysqlbinlog --start-datetime='2021-05-06 04:34:32' --stop-datetime='2022-04-24 04:36:02' binlog.000003 | mysql -uroot -p \",\"参数为：start-datetime、stop-datetime，也是左闭右开区间\",\"，没有过期的数据可以直接通过binlog恢复，如果，通过以下命令即可：\",\"mysql> source ~/data.sql #备份文件的恢复 $cat ~/data.sql | mysql -u root -p #shell命令恢复备份数据 \"]},\"1775\":{\"h\":\"MysqL数据恢复小结\",\"t\":[\"![](Server 层四个日志.assets/image-20240421115737534.png)\",\"MySQL数据恢复分为两部分，一部分由数据备份完成，另一部分由bin-log完成\",\"如果设置日志过期时间为7天，那么我们可以每七天备份一次\",\"七天以内的数据恢复由bin-log完成\",\"超过七天的数据备份在sql脚本，如备份在~/data.sql中\",\"恢复备份文件 source ~/data.sql \"]},\"1776\":{\"h\":\"六、慢查询日志\",\"t\":[\"MySQL可以设置慢查询日志，当SQL执行的时间超过我们设定的时间，那么这些SQL就会被记录在慢查询日志当中\",\"我们通过查看日志，用explain分析这些SQL的执行计划，来判定为什么效率低下，是没有使用到索引？还是索引本身创建的有问题？或者是索引使用到了，但是由于表的数据量太大，花费的时间就是很长，那么此时我们可以把表分成n个小表，比如订单表按年份分成多个小表等\",\"慢查询日志相关的参数如下所示：\",\"![](Server 层四个日志.assets/46a5eb2d893d4b059475252bb4a70b69.png)\",\"慢查询日志记录了包含所有执行时间超过参数 long_query_time（单位：秒）所设置值的 SQL语句的日志，在MySQL上用命令可以查看，如下：\",\"![](Server 层四个日志.assets/eb0bab49501445e3aaf1c8251a48515e.png)\",\"这个值是可以修改的：\",\"![](Server 层四个日志.assets/14ba37259316444580233aac35698e7b.png)\",\"现在修改成执行时间超过1秒的SQL都会被记录在慢查询日志当中！可以设置为0.01秒，表示10毫秒\",\"慢查询日志，默认名称是host_name-slow.log，存放在MySQL的配置文件/etc/mysql/my.cnf配置的data_dir下，内容格式显示大致如下：\",\"![](Server 层四个日志.assets/9433aa85c0e746a89a74883d5a0daa01.png)\",\"show profiles命令可有查看sql详细的运行时间，全局变量的名字是：profiling\",\"首先需要：set profiling=on\",\"![](Server 层四个日志.assets/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQnVnTWFrZXItc2hlbg==,size_20,color_FFFFFF,t_70,g_se,x_16-171363566787064.png)\"]},\"1777\":{\"c\":[\"mysql\"]},\"1778\":{\"c\":[\"mysql日志\",\"数据备份\"]},\"1779\":{\"h\":\"主从复制原理\",\"t\":[\"在实际生产环境中，如果对MySQL数据库的读和写都在一台数据库服务器中操作，无论是在安全性、高可用性，还是高并发等各个方面都是不能满足实际需求的，一般要通过数据库集群的主从复制机制来数据，再通过读写分离来提升数据库的负载能力\"]},\"1780\":{\"h\":\"主从复制概念\",\"t\":[\"主库对外提供数据的增删改查服务，主库中涉及到数据的修改都会写binlog\",\"从库用来数据的同步和备份，，相当于就是主库的所有修改通过主从复制机制体现在从库上\",\"好处是做数据备份以后，通过MySQL中间件mycat，可以实现容灾\",\"容灾：如果主库挂了，由中间件代理mycat自动把服务的请求映射到从库，由从库继续对外提供服务，体现出了 高可用性（）\"]},\"1781\":{\"h\":\"读写分离概念\",\"t\":[\"可以支持更大的并发，提高后端和，基于技术实现。我们读操作多，写操作少，主库专门处理写请求，数据的更新会记录在binlog，然后通过binlog同步到从库，客户端读数据的请求最终会转发到从库上（）\",\"上图中的binlog，即使没有主从复制，也会写binlog，只不过**就是通过来复制的**\"]},\"1782\":{\"h\":\"主库介绍\",\"t\":[\"主库master服务器创建一个，将二进制日志内容发送到从服务器\"]},\"1783\":{\"h\":\"从库介绍\",\"t\":[\"从库专门有一个，专门读取接收主库发过来的binlog的内容，并写到中继日志relay log，中继日志充当，并不是把主库的binlog读过来直接执行，这样 master 就不必等待 slave 执行完成才发送下一个事件\",\"relay log的作用： 。可以把binlog的内容写入relay log，作为缓冲区，等待SQL线程逐条执行。这样SQL线程就不用和dump线程进行读写同步了\",\"从库还会启一个，专门从中继日志读取相应的操作，所有的SQL都执行一遍，这样就实现了从库内容和主库内容的同步\"]},\"1784\":{\"h\":\"主从复制流程\",\"t\":[\"两个log：binlog(master)、relay log(slave)，三个thread：dump(master)、IO(slave)、SQL(slave)\",\"主库的更新操作写入binlog二进制日志中（）\",\"master服务器创建一个binlog转储线程，将binlog内容发送到从服务器\",\"slave执行START SLAVE命令会在从服务器创建一个IO线程，接收master的binary log复制到其中继日志（）。 \",\"首先slave开始一个工作线程（I/O线程），I/O线程会主动连接master ，然后主库会开启dump线程，dump线程从master的binlog中读取事件并发送给slave的I/O线程，如果dump线程已经跟上master（主库上的dump线程已经把binlog的内容发完了，而且主库上binlog没有产生更多的内容），dump线程会睡眠并等待binlog产生新的事件，slave的I/O线程接收的事件写入中继日志\",\"slave的SQL线程处理该过程的最后一步，SQL线程从relay log中读取事件，并执行其中的事件更新slave的数据，使其与master的数据同步。只要SQL线程与I/O线程保持一致，中继日志通常会位于os缓存中，所以中继日志的开销很小\"]},\"1785\":{\"h\":\"主从复制效果展示\",\"t\":[\"我们把linux作为一个主库，Win10上的MySQL Server作为从库\",\"主从复制是，master的更改（binlog）往slave同步。配置好主从复制的时候，两个库的数据可能是不一样的，，主库所有的更改都会同步到从库\",\"master创建mytest数据库\",\"查看slave，发现mytest同步过来了\",\"master创建user表，slave也同步了user表\",\"现在linux端的MySQL（master）删除mytest库\",\"此时slave的mytest也不存在了\"]},\"1786\":{\"h\":\"查看master当前环境下的工作线程\",\"t\":[\"show processlist; \",\"查看slave当前环境下的工作线程\"]},\"1787\":{\"c\":[\"mysql\"]},\"1788\":{\"c\":[\"mysql集群\"]},\"1789\":{\"h\":\"读写分离原理\"},\"1790\":{\"h\":\"读写分离概念\",\"t\":[\"基于主从复制的读写分离，是我们在单机环境下，数据库的性能到瓶颈了，可以通过读写分离，提高后台服务性能。存储这一块的增删改查的并发的处理能力，主库专门负责相对少的写操作，从库专门负责相对多的读操作，主库的数据更改通过主从复制同步到从库\",\"读写分离就是在主服务器上修改，数据会同步到从服务器，从服务器只能提供读取数据，不能写入，实现备份的同时也实现了数据库性能的优化，以及提升了服务器安全\",\"MySQL client通过mysql 提供的API，用mysql自定义的基于TCP的数据协议（简称mysql协议）与MySQL Server通信，访问MySQL Server数据库\",\"最初，我们只有一台MySQL服务器，所有数据的增删改查都是在一台机器上进行，随着服务越来越多的人使用，流量越来越大，需要并发能力的不断提升，如果数据库的性能到瓶颈了，我们就要进行读写分离的操作\",\"图中的MySQL主服务器专门做写操作，下面连着2个MySQL从服务器专门做读操作，读请求转发到B、C，写请求转发到A\",\"如果我们在客户端上直接用代码写死，insert、update等写操作，在A上做，show、select等读操作在B、C上做，相当于代码和主从环境就是强绑定的。\",\"这就导致代码的稳定性不太好，因为和环境强相关了，我们写代码得时候必须得知道哪个机器是负责写操作的主库，哪个机器是负责读操作的从库。而这时如果有某个机器挂掉了，代码也不会知道，还是按照原来的方式转发请求，通信就会出现问题，所以把读写分离用代码实现肯定不合适\"]},\"1791\":{\"h\":\"引入中间件MyCat\",\"t\":[\"这时候就需要引入数据库中间件了，实际上，读写分离，分库分表都是需要依赖数据库中间件（mycat），mycat就是反向代理服务器\",\"客户端实际上区分不出来连的是MyCat还是MySQL，因为通信都是遵守的是MySQL通信协议，之前怎么和MySQL通信，现在就怎么和MyCat通信，所以不用进行区分\",\"在MyCat上配置读写分离，我们在客户端上的代码不用做任何变更，代码上不需要区分哪个请求是读，哪个请求是写，代码直接访问的是MyCat，由MyCat解析请求，根据SQL的读写性质转发到负责相应操作的服务器，实现读写分离\",\"在MyCat上就是要配置主服务器和从服务器的信息，有3种情况：一主一从、一主多从、多主多从\",\"一主多从场景：当写库（master）挂了，MyCat还可以马上把一个从库（slave）直接变成一个写库（master），然后变成写库的从库还要和其他从库之间配置一下主从复制\",\"多主多从场景：\",\"可以看到图中，MyCat服务器挂了两套环境，如果其中1套的主库宕机了（它对应的从库也就不能用了），此时MyCat会自动切到另一套环境，因为M1和M2之间也是配置成互为主从的，所以M2可以同步M1的数据，提供与M1环境完全相同的服务\"]},\"1792\":{\"h\":\"MyCat服务端口和管理端口\",\"t\":[\"MySQL的服务端口是3306，MyCat服务端口是8066（这个端口也是可以改的），也就是MySQL Client连接的是8066端口，登录8066端口看到的界面就和登录MySQL Server的3306端口一样\",\"MyCat还有一个管理端口9066，登录这个管理端口可以查看MyCat正在工作的所有状态以及和后端服务器的连接，以及连接数据源的状态等\"]},\"1793\":{\"c\":[\"mysql\"]},\"1794\":{\"c\":[\"mysql集群\"]},\"1795\":{\"h\":\"读写分离配置实践\"},\"1796\":{\"h\":\"一、环境准备\",\"t\":[\"master（虚拟机centos7，NAT模式，固定ip）：192.168.131.129 slave（win10，路由器局域网，DHCP协议）：192.168.31.27\",\"由于MyCat是用Java写的，需要JDK1.7版本以上 MySQL的root账户有远程访问权限\"]},\"1797\":{\"h\":\"1.查看主从复制状态\",\"t\":[\"读写分离基于主从复制，查看主从复制状态\"]},\"1798\":{\"h\":\"2. 查看JDK版本\",\"t\":[\"java -version \"]},\"1799\":{\"h\":\"3. 打开root的远程连接权限\",\"t\":[\"一般MySQL Server和代理中间件是不在一台机器上的，涉及数据库的远程访问和连接\",\"我们可以拿root进行连接，也可以创建新的用户进行连接\",\"root用户默认是localhost，只能本地连接，不支持远程连接，所以需要root远程连接的权限打开。%表示允许任意地址连接，如果缩小权限，写成MyCat所在机器的ip地址就可以，用root连接MySQL服务器\",\"mysql> grant all privileges on *.* to 'root'@'%' identified by '123456' with grant option; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql> flush privileges; Query OK, 0 rows affected (0.00 sec) mysql> quit Bye \",\"[root@localhost Downloads]# service mysqld restart # 若服务不存在，可尝试使用service mysql restart Redirecting to /bin/systemctl restart mysqld.service \",\"我们的MyCat和主库跑在同一台Linux上\"]},\"1800\":{\"h\":\"4. 安装MyCat\",\"t\":[\"安装lrzsz，用于windows和Linux传输文件（xftp也行）\",\"用rz命令将MyCat包传输到Linux\",\"Linux上的文件上传到Windows：sz+文件路径\",\"解压MyCat包放到合适的目录下，可以放到/usr/local下\",\"mycat/bin：放的是可执行文件\",\"mycat/conf：放的MyCat的配置文件\",\"mycat/logs：放的MyCat的日志文件\",\"wrapper.log：记录启动过程中遇到的错误\",\"mycat.log：记录运行过程中遇到的错误\",\"由于我们是直接解压的，没有安装，为了不用手动指定mycat的路径，我们 在/usr/bin下建立软连接，连接用户目录下的mycat和我们解压路径下的mycat\",\"这样就不用指定路径，直接使用mycat\"]},\"1801\":{\"h\":\"二、配置文件\",\"t\":[\"配置文件在mycat/conf下\"]},\"1802\":{\"h\":\"1. server.xml\",\"t\":[\"用于配置client登录Mycat的账号密码，还可以配置白名单黑名单，限制客户的连接等\",\"用户配置\",\"不需要和MySQL的账号密码一样，因为我们的MySQL Client直接访问的是MyCat，再由MyCat登录MySQL Server，这里设置的用户、密码都是用来登录MyCat的\",\"USERDB是给客户端操作的逻辑库，由于MySQL Client访问的是MyCat，在MyCat上直接操作USERDB这个库即可，这个库其实是不存在的，这个库最终会映射到MySQL Server真实的MySQL库表上\",\"这个逻辑库看起来好像在MyCat一台机器上，实际上经过分库分表操作可能分配在不同的机器上，我们只需要操作这个逻辑库就可以，其他的不用关心。多个逻辑库的话，在标签schemas中间，用逗号分隔开即可\",\"防火墙配置\"]},\"1803\":{\"h\":\"2.schema.xml\",\"t\":[\"schema.xml用于配置逻辑库和数据源、读写分离、分库分表信息等\",\"schema.xml配置以下三点：\",\"逻辑库和逻辑表：MySQL Client都是操作的MyCat上的逻辑库（schema）和逻辑表\",\"数据节点：这个库或者表的内容放在哪个节点（dataNode）上，这个节点对应具体的物理机器叫dataHost\",\"逻辑库、数据节点以及数据库主机名称都可以随便取，但以下地方需要保持相同\",\"maxCon、minCon：MyCat内置连接池的最大、最小连接量\",\"balance： 0：不开启读写分离 1：全部的readHost和stand by writeHost参与读操作的负载 ，比如2套1主2从，M1叫做writeHost，S1、S2、S3、S4 叫做readHost，M2叫做stand by writeHost 2：所有读操作随机在readHost和writeHost上分发（少用） 3：所有读请求随机分发到writeHost对应的readHost上执行（最常使用，所有的select操作都在slave上执行，master库只做写操作）\",\"writeType=0： 表示所有写操作发送到配置的第一个writeHost，第一个挂掉切换到还在的第二个 writeHost\",\"switchType（切换的类型，当一个master挂了，切换到另一个master上）： -1：不自动切换 1：根据心跳select user()自动切换 2：基于MySQL的主从同步状态决定是否进行切换，即MyCat发送show slave status给MySQL Server\",\"writeHost、readHost：配置写服务器（master）和读服务器（slave），readHost标签在writeHost内，表示读服务器是slave，图中黄色框中是配置了一个一主一从，嵌套多个readHost标签就是配置一主多从。图中并列的writeHost标签表示备份的写库，当master宕机后，slave也将无法和master配合工作，会切换到备份的写库继续工作。其实图中配置的是多主多从\",\"heartbeat：MyCat定时发送指定语句给MySQL Server，如果能正常返回数据，则表示正常工作；若不能正常返回数据，则表示机器故障，MyCat需要进行容灾切换\",\"如果slave有问题，master是正常，就会在master上做读和写操作 如果master有问题，slave是正常，此时slave是没法单独使用的，它会在多主多从的配置中找下一套主从配置来使用 如果主从都正常，master做写操作，slave做读操作\"]},\"1804\":{\"h\":\"三、启动服务\",\"t\":[\"查看配置文件mycat/conf/schema.xml\",\"启动MyCat服务\",\"查看端口\",\"这表示mycat正常监听8066和9066端口\"]},\"1805\":{\"h\":\"1. 配置文件问题一\",\"t\":[\"mycat/schema.xml中备份的主库没有结束标签\",\"配置好后，我们重启mycat程序\",\"查看mycat/logs/wrapper.log，记录了mycat启动过程中的错误\"]},\"1806\":{\"h\":\"2. 配置文件问题二\",\"t\":[\"mycat/schema.xml中读库的端口出错\",\"配置好后，我们重启mycat程序\",\"查看mycat/logs/wrapper.log，记录了mycat启动过程中的错误\",\"我们看到心跳不成功了，就应该判断是网络原因，或者是ip:port配置原因，于是我们看到了3309端口，就知道是配置的端口错误\"]},\"1807\":{\"h\":\"四、MyCat 9066端口和8066端口\",\"t\":[\"我们开启MyCat后台服务\"]},\"1808\":{\"h\":\"1. 9066管理端口\",\"t\":[\"在Linux Shell下登录MyCat的9066端口（使用mycat/conf/server.xml中配置的登录用户名和密码登录）\",\"登录MyCat后也是进入了一个MySQL Shell，monitor表示状态监控\",\"show @@help显示mycat支持的命令\",\"查看逻辑库：show @@database\",\"查看逻辑节点和真实库的映射关系show @@datanode\",\"查看数据源show @@datasource\",\"M2是我们配置的备用的第二套写库，这种情况下，还要配置M2为M1的从，需要同步数据\"]},\"1809\":{\"h\":\"2.8066数据端口\",\"t\":[\"在Linux Shell下登录mycat的8066端口（使用mycat/conf/server.xml中配置的登录用户名和密码登录）\",\"OpenCloundDB表示我们看到的是一个云状数据库，云后面是如何提供的库表的服务能力，我们是不知道的。mycat就是云DB，把后端所有的细节给客户端隐藏了，客户端只需要去处理代理服务器上的DB就可以了。可以看作一个反向代理服务器\",\"查看数据库\",\"这个逻辑库USERDB对应的就是真实库mytest\"]},\"1810\":{\"h\":\"五、验证读写分离\",\"t\":[\"查看查询日志general_log，这个日志记录了MySQL Server收到的所有SQL语句\"]},\"1811\":{\"h\":\"1. 打开查询日志general_log\",\"t\":[\"打开windows从库上的general_log\",\"在Linux下的MySQL Server中也打开一下查询日志\"]},\"1812\":{\"h\":\"2. 验证读操作在slave\",\"t\":[\"我们现在登录MyCat 8066数据端口，查询user表\",\"在Linux下的master服务器查看general_log，我们只看见了mycat发送的心跳包，并没有看见查询user表的SQL\",\"在windows下的slave服务器中查看general_log，看到了mycat发送的查询user表的SQL\",\"没有问题，现在读操作是正确发送给了slave\"]},\"1813\":{\"h\":\"3. 验证写操作在master\",\"t\":[\"我们现在登录MyCat 8066数据端口，给user表insert一条数据\",\"在Linux下的master服务器查看general_log，我们看见了insert数据的SQL\",\"在windows下的slave服务器中查看general_log，没有发现insert数据的SQL\",\"没有问题，写操作正确发送给了master\"]},\"1814\":{\"h\":\"验证容灾功能\",\"t\":[\"我们在mycat/conf/schema.xml中配置的是多住多从，M1挂了，读写操作会全部转发到M2\",\"在我们当前环境中，就是Linux上的MySQL Server挂了，所有的读写操作都会转发给Windows上的MySQL Server\",\"关闭Linux的mysqld服务，相当于关闭了master\",\"我们现在登录MyCat 8066数据端口，对user表分别读写操作\",\"查看我们多主多从中备用系统的general_log，即Windows上的MySQL Server的general_log\",\"可以看见，由于master挂了，读写操作都被转发到了备用的Windows上的MySQL Server，证明容灾没有问题\"]},\"1815\":{\"c\":[\"mysql\"]},\"1816\":{\"c\":[\"mysql集群\"]},\"1817\":{\"h\":\"配置主从复制实践\"},\"1818\":{\"h\":\"一、检测通信\",\"t\":[\"查看master（centos7）和slave（win10）的ip地址，并检测是否可以相互通信\",\"我自己用的是ubuntu 18.04(192.168.216.135)和ubuntu 22.04(192.168.216.136)\",\"到这里我们知道，master的ip为192.168.131.129，slave的ip为192.168.0.6，并且可以相互通信\",\"如果物理机可以ping通虚拟机，而虚拟机无法ping通物理机，需要在控制面板的网络中心启用网络发现\",\"虚拟机无法ping通物理机解决方案\",\"sudo apt install firewalld \",\"查看防火墙状态\",\"systemctl status firewalld.service \",\"临时手动启动、停止防火墙\",\"systemctl start firewalld.service systemctl stop firewalld.service \",\"持久打开、关闭防火墙（重启服务生效）\",\"systemctl enable firewalld.service systemctl disable firewalld.service \",\"开启防火墙3306端口\",\"sudo firewall-cmd --zone=public --add-port=3306/tcp --permanent # 开放3306端口 sudo firewall-cmd --reload # 重启防护墙 sudo firewall-cmd --list-port # 查看当前开放的端口列表 \",\"用哪个端口就开放哪个端口，直接关闭防火墙虽然方便，但是实际工作却不能这样\",\"image-20240421225335827\"]},\"1819\":{\"h\":\"二、master配置\"},\"1820\":{\"h\":\"1. 开启二进制日志\",\"t\":[\"sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf \",\"配置log_bin和，和slave区分开，不能配置成一样的（）\",\"我在/etc/mysql/mysql.conf.d/mysqld.cnf中进行配置\",\"开启二进制日志后需要重启mysql服务\",\"# 重启mysql，如果mysql报错，就改成mysqld systemctl restart mysql systemctl start mysql systemctl stop mysql # 查看mysql状态 systemctl status mysql \",\"root@ubuntu-vm:/usr/bin# systemctl start mysql root@ubuntu-vm:/usr/bin# systemctl status mysql ● mysql.service - MySQL Community Server Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: enabled) Active: active (running) since Wed 2022-11-16 16:50:56 CST; 5s ago Process: 8333 ExecStartPre=/usr/share/mysql/mysql-systemd-start pre (code=exited, status=0/SUCCESS) Main PID: 8341 (mysqld) Status: \\\"Server is operational\\\" Tasks: 39 (limit: 4582) Memory: 367.3M CGroup: /system.slice/mysql.service └─8341 /usr/sbin/mysqld # 这是mysqld路径 11月 16 16:50:55 ubuntu-vm systemd[1]: Starting MySQL Community Server... 11月 16 16:50:56 ubuntu-vm systemd[1]: Started MySQL Community Server. root@ubuntu-vm:/usr/bin# netstat -tanp | grep 3306 tcp 0 0 0.0.0.0:3306 0.0.0.0:* LISTEN 9538/mysqld tcp 0 0 127.0.0.1:33060 0.0.0.0:* LISTEN 9538/mysqld root@ubuntu-vm:/usr/bin# \"]},\"1821\":{\"h\":\"2.创建一个用于主从库通信用的账号\",\"t\":[\"从库要连接主库，涉及到账号登陆和身份验证，虽然可以继续使用root账号，但是我们选择重新创建一个新的账号\",\"即在master中创建一个账号，用于slave登录master读取binlog\",\"虽然我们在Linux上查看的ip地址是192.168.131.129，但我们创建账户登录时不写这个ip，写的是192.168.131.1。因为我这里虚拟机用的是NAT模式（桥接模式是虚拟机直连物理网络，和物理机的网络地位相同），虚拟机（master）和物理机（slave）通信的时候，虚拟机先把数据发送到网关192.168.131.1（默认与VMnet8通信），192.168.131.1再转发到物理机，所以物理机接收到的是192.168.131.1的数据，故我们在master上为slave创建账户的时候，应该写192.168.131.1\",\"如果给slave配置的不是网关192.168.131.1地址，错误日志（可在my.cnf中指定）中会有如下信息：\",\"意思是从192.168.131.1的mslave用户权限不够，那是因为我们在master上配置的是允许从其他地址登录，并不是允许从192.168.131.1地址登录，这就导致权限不够。\",\"由于master这边收到的就是来自192.168.131.1的请求，所以错误日志显示的是192.168.131.1\",\"所以创建账户的命令应如下：\",\"mysql> CREATE USER 'mslave'@'%' IDENTIFIED BY '14ds@EGBFV'; # “%”表示任意ip都可以通过这个账号登录 mysql> CREATE USER 'mslave'@'192.168.131.1' IDENTIFIED BY '14ds@EGBFV'; #为了权限最小化，权限收缩，我们指定ip才能登录 mysql> GRANT REPLICATION SLAVE ON *.* to 'mslave'@'192.168.131.1' IDENTIFIED BY '14ds@EGBFV'; -- 给mslave用户主从同步的权限（REPLICATION SLAVE） mysql> FLUSH PRIVILEGES; -- 刷新权限，使权限生效 \",\"开启主从复制的权限，从库可以通过这个账户和密码，从这个IP来请求访问这个主库上的任意库，同步这个主库的任意库里的任意表\",\"*.*表示任意库任意表，当然也可以指定库指定表，如school.user\",\"（）\"]},\"1822\":{\"h\":\"3.获取binlog文件名和position\",\"t\":[\"查看当前二进制日志的名字，主库的更新是往哪个binlog写的，以及当前写日志的位置，font>\",\"show master status; \"]},\"1823\":{\"h\":\"三、slave配置\"},\"1824\":{\"h\":\"1. 配置全局唯一的server-id\",\"t\":[\"找到my.ini\",\"配置全局唯一的server-id\",\"重启MySQL服务\"]},\"1825\":{\"h\":\"2. 使用master创建的账户读取binlog同步数据\",\"t\":[\"这一步配置主要是给IO线程读取binlog使用\",\"mysql> CHANGE MASTER TO MASTER_HOST='192.168.131.129', MASTER_PORT=3306, MASTER_USER='mslave', MASTER_PASSWORD='1qaz@WSX', MASTER_LOG_FILE='mysql-bin.000007', MASTER_LOG_POS=1262; \",\"MASTER_HOST：指定master的ip MASTER_LOG_FILE：binlog文件名 MASTER_LOG_POS：binlog的position\"]},\"1826\":{\"h\":\"3. 启动slave服务\",\"t\":[\"mysql> start slave; mysql> stop slave; \",\"通过show slave status命令查看主从复制状态，show processlist查看master和salve相关线程的运行状态\",\"自己配置的时候不知道为什么，slave总是连接不上master，重新在mysql.user表中设置一下密码，就能连接上了\"]},\"1827\":{\"h\":\"四、配置中可能出现的问题\"},\"1828\":{\"h\":\"1. 网络连接问题\",\"t\":[\"[mysql] 主从同步错误Last_IO_Errno: 2061_last_io_errno:2061-CSDN博客\",\"Mysql主从同步配置字符集问题解决_mysqlbinlog: character set '#255' is not a compile-CSDN博客\",\"技术分享 | 从 MySQL 8.0 复制到 MySQL 5.7 - 知乎 (zhihu.com)\",\"MySQL 复制仅在连续主版本之间支持，并且仅从主低到从高之间支持。\",\"master 5.7 - > slave 8.0 支持\",\"master 8.0 - > slave 5.7\",\"通过show slave status命令查看主从复制状态\",\"连接connection错误，先考虑是否网络互通，ping一下\",\"然后再检查从库里面的配置信息是否正确\",\"如果都正确，还可以检查一下master的3306端口是否可以连接\",\"telnet xxx.xxx.xxx.xxx 3306 \",\"最重要的是，自己玩的时候，如果虚拟机是NAT模式，则需要写成VMnet8网关ip。如果都是物理机通信，那直接写正确的ip即可\",\"可以在MySQL数据库下的mysql库的user表中更改允许登录的ip\",\"然后重新赋予权限\",\"mysql> GRANT REPLICATION SLAVE ON *.* to 'mslave'@'xxx.xxx.xxx.xxx' IDENTIFIED BY '1qaz@WSX'; \",\"出现错误后还可以查看错误日志中提示的ip是否和自己允许slave登录的ip一致\"]},\"1829\":{\"h\":\"2. binlog的position问题\",\"t\":[\"在master中查看show master status一下binlog日志文件名以及position，然后用命令重新配置slave，比如：\",\"mysql> CHANGE MASTER TO MASTER_HOST='192.168.131.129',MASTER_PORT=3306,MASTER_USER='mslave',MASTER_PASSWORD='1qaz@WSX', MASTER_LOG_FILE='mysql-bin.000006',MASTER_LOG_POS=1262; \",\"配置slave前需要stop slave，配置完成再start slave\"]},\"1830\":{\"h\":\"3.SQL线程出错\",\"t\":[\"问题发生原因如下：\",\"首先配置主从复制的时候，slave的mytest库中没有user表，而master的mytest库已经有user表了\",\"配置好主从复制后直接drop table mytest.user，这就会写到binlog里面，然后在通过dump线程和IO线程将这个操作发送到从库的relay log，然后从库的SQL线程从relay log里把drop table mytest.user捞出来在从库执行这个SQL，可从库的mytest根本就没有user表，这就是删除一个不存在的表，于是出现错误了\",\"一般我们不会做这样的操作，一般都是主从配置以后，slave从数据开始增量进行同步，先做数据的增量，然后做数据的增删改查\",\"不会配置好主从复制后，一开始就删主库的东西，如果真的出现这样的问题，随时可以在从库 show slave status，来查看主从同步的状态，有什么错误，就相应解决\",\"要么stop slave，把position重新设置一下，start slave，即重新开启主从同步，从最新的位置，这个drop操作不需要在从库上同步\",\"要么就是stop，跳过该个错误，然后start\",\"mysql> stop slave; mysql> set global sql_slave_skip_counter=1; mysql> start slave; \",\"可以通过show slave status查看以下标识，IO线程出错一般是网络问题，SQL线程出错一般是SQL在slave库执行出现了问题\"]},\"1831\":{\"h\":\"总结\",\"t\":[\"在网络互通的前提下，进行配置\"]},\"1832\":{\"h\":\"master配置\",\"t\":[\"配置文件配置server-id，开启binlog\",\"创建slave账户，用于登录主库取数据\",\"查看当前binlog文件以及位置\"]},\"1833\":{\"h\":\"slave配置\",\"t\":[\"配置server-id\",\"使用CHANGE MASTER TO 命令，将master的ip、port、账号、密码、binlog位置等告诉slave\",\"start slave\",\"出错后可以查看错误日志\"]},\"1834\":{\"c\":[\"mysql\"]},\"1835\":{\"c\":[\"mysql集群\"]},\"1836\":{\"h\":\"mysqldump数据备份\",\"t\":[\"在远程服务器，所以我们一般都是通过命令mysqldump进行备份\",\"导出建库建表的SQL：\",\"mysqldump -u 用户名 -p111111 --all-databases > ~/all.sql # 导出所有的库 mysqldump -u 用户名 -p111111 --databases school > ~/school.sql # 导出school库 mysqldump -u 用户名 -p111111 --databases db1 db2 db3 > ~/dbs.sql # 导出多个库 mysqldump -u 用户名 -p111111 school stu > ~/stu.sql # 导出school库下的stu表 \",\"导出纯数据：\",\"mysql -u 用户名 -p111111 -D school -e 'select * from user where age>10' > ~/user.txt \",\"在mysql终端执行source命令，导入数据，建库建表：\",\"mysql> source ~/school.sql \",\"在linux shell下执行以下命令，即可把mytest库的user表的数据导出到.sql文件中（）\",\"user.sql文件内容如下：\",\"现在user.sql是root的文件，我们变更一下属主，使得普通用户也可以操作\",\"我们现在把mytest库下的user表删除\",\"然后我们source，相当于把.sql脚本重新执行一遍\",\"user表和数据全部恢复出来了，有了.sql的脚本，可以在任意的mysql库上去重建库表及数据\",\"我们还可以直接导出****\",\"mysql -u root -p -D school -e 'select * from user where age>10' > ~/user.txt \",\"user.txt内容如下：\"]},\"1837\":{\"c\":[\"mysql\"]},\"1838\":{\"c\":[\"数据备份\"]},\"1839\":{\"h\":\"加载配置项\",\"t\":[\"#ifndef _CONNECTIONPOOL_H #define _CONNECTIONPOOL_H #include <string> #include <queue> #include <mutex> #include <atomic> //atomic_int 原子类型 #include \\\"connection.h\\\" using std::string; using std::queue; using std::mutex; class ConnectionPool { public: static ConnectionPool* getConnectionPool(); private: ConnectionPool(); ~ConnectionPool(); public: //测试的时候可以先变成共有的 bool loadConfigFile(); private: string _ip; // mysql的ip地址 unsigned short _port; // mysql的端口号 3306 string _username; // mysql登录用户名 string _password; // mysql登录密码 string _dbname; // 连接的数据库名称 int _initSize; // 连接池的初始连接量 int _maxSize; // 连接池的最大连接量 int _maxIdleTime; // 连接池最大空闲时间 int _connectionTimeout; // 连接池获取连接的超时时间 queue<Connection*> _connectionQue; // 存储mysql连接的队列 mutex _queueMutex; // 维护连接队列的线程安全互斥锁 std::atomic_int _connectionCnt; // 记录连接所创建的connection连接的总数量 }; #endif //_CONNECTIONPOOL_H \",\"#include \\\"connectionPool.h\\\" #include <iostream> #include \\\"public.h\\\" using std::cout; using std::endl; // 线程安全的懒汉单例函数接口 ConnectionPool* ConnectionPool::getConnectionPool() { //静态函数的实现，不写static static ConnectionPool pool; //静态局部变量的初始化，编译器会生成lock和unlock return &pool; } // 从配置文件中加载配置项 bool ConnectionPool::loadConfigFile() { FILE* pf = fopen(\\\"mysql.cnf\\\",\\\"r\\\"); if(pf == nullptr) { LOG(\\\"mysql.cnf file is not exit!\\\"); return false; } while(!feof(pf)) { //文件不为空 char line[1024] = {0}; fgets(line, sizeof(line), pf); string str = line; int idx = str.find('=', 0); //从第0位开始找'='的下标 if(idx == -1) { //无效的配置项 continue; } // password=123456\\\\n int endidx = str.find('\\\\n', idx); //从第idx位开始找'\\\\n'的下标 string key = str.substr(0,idx); //从第0位开始idx个字符 string value = str.substr(idx + 1, endidx - (idx + 1)); //cout << key << '=' << value << endl; if(key == \\\"ip\\\") { _ip = value; } else if(key == \\\"port\\\") { _port = atoi(value.c_str()); //string->const char* ->int } else if(key == \\\"username\\\") { _username = value; } else if(key == \\\"password\\\") { _password = value; } else if(key == \\\"dbname\\\") { _dbname = value; } else if(key == \\\"initSize\\\") { _initSize = atoi(value.c_str()); } else if(key == \\\"maxSize\\\") { _maxSize = atoi(value.c_str()); } else if(key == \\\"maxIdleTime\\\") { _maxIdleTime = atoi(value.c_str()); } else if(key == \\\"connectionTimeOut\\\") { _connectionTimeout = atoi(value.c_str()); } } return true; } ConnectionPool::ConnectionPool() { if(!loadConfigFile()) { //配置文件加载失败 return; } //创建初始的数量连接 //这一块是在连接池启动的时候做的，不用考虑线程安全 for(int i = 0; i < _initSize; ++i) { Connection* conn = new Connection(); conn->connection(_ip, _port, _username, _password, _dbname); _connectionQue.push(conn); _connectionCnt++; } //启动一个新的线程作为生产者线程 } ConnectionPool::~ConnectionPool() {} \"]},\"1840\":{\"c\":[\"mysql\"]},\"1841\":{\"c\":[\"mysql连接池\"]},\"1842\":{\"h\":\"连接池压力测试\"},\"1843\":{\"h\":\"连接池代码\"},\"1844\":{\"h\":\"mysql.cnf 配置文件\",\"t\":[\"#数据库连接池的配置文件，下面和宏一样就不要加多余的空格了 ip=127.0.0.1 port=3306 username=root password=147258 dbname=chat initSize=10 maxSize=1024 // 连接池最大空闲时间默认单位是秒 maxIdleTime=60 // 连接池获取连接的超时时间单位是毫秒 connectionTimeOut=100 \"]},\"1845\":{\"h\":\"public.h 公共头文件\",\"t\":[\"/* * 这是一个公共的头文件 */ #ifndef _PUBLIC_H #define _PUBLIC_H #define LOG(str) \\\\ cout << __FILE__ << \\\":\\\" << __LINE__ << \\\" \\\" << \\\\ __TIMESTAMP__ << \\\":\\\" << str << endl; #endif //_PUBLIC_H \"]},\"1846\":{\"h\":\"connection.h 数据库操作头文件\",\"t\":[\"/* * 实现MySQL数据库的操作 */ #ifndef _CONNECTION_H #define _CONNECTION_H #include <string> #include <mysql/mysql.h> #include <ctime> using std::string; class Connection { public: Connection(); ~Connection(); //数据库的连接操作 bool connection(string ip, unsigned short port, string user, string passward, string dbname); //更新操作 insert delete update bool update(string sql); //查询操作select MYSQL_RES* query(string sql); // 刷新一下连接的起始的空闲时间点 void refreshAliveTime() { _aliveTime = clock(); } // 返回存活的时间 clock_t getAliveTime() { return clock() - _aliveTime; } private: MYSQL* _conn; //表示和MySQL的一条连接 clock_t _aliveTime; // 记录进入空闲状态后的起始存活时间 }; #endif // _CONNECTION_H \"]},\"1847\":{\"h\":\"connection.cc 数据库操作的封装实现\",\"t\":[\"#include <iostream> #include \\\"connection.h\\\" #include \\\"public.h\\\" using std::cout; using std::endl; Connection::Connection() { //初始化 _conn = mysql_init(nullptr); } //释放资源 Connection::~Connection() { if(_conn != nullptr) { mysql_close(_conn); } } bool Connection::connection(string ip, unsigned short port, string user, string passward, string dbname) { //建立连接 MYSQL* p = mysql_real_connect(_conn, ip.c_str(), user.c_str(), passward.c_str(),dbname.c_str(), port, nullptr, 0); return p != nullptr; } bool Connection::update(string sql) { //更新操作 insert delete update if(mysql_query(_conn, sql.c_str())) { LOG(\\\"更新失败:\\\" + sql); return false; } return true; } MYSQL_RES* Connection::query(string sql) { if(mysql_query(_conn, sql.c_str())) { LOG(\\\"查询失败\\\" + sql); } return mysql_use_result(_conn); } \"]},\"1848\":{\"h\":\"connectionPool.h 连接池的头文件\",\"t\":[\"#ifndef _CONNECTIONPOOL_H #define _CONNECTIONPOOL_H #include <string> #include <queue> #include <mutex> #include <atomic> //atomic_int 原子类型 #include <memory> //shared_ptr #include <thread> #include <condition_variable> #include <functional> //bind #include \\\"connection.h\\\" using std::string; using std::queue; using std::mutex; using std::thread; using std::atomic_int; using std::shared_ptr; using std::bind; using std::condition_variable; using std::unique_lock; class ConnectionPool { public: // 获取连接池对象实例 static ConnectionPool* getConnectionPool(); // 给外部提供接口，从连接池中获取一个可用的空闲连接 shared_ptr<Connection> getConnection(); private: ConnectionPool(); ~ConnectionPool(); #ifdef TEST_LOAD_CONFIG_FILE public: //测试的时候可以先变成共有的 #endif //TEST_LOAD_CONFIG_FILE bool loadConfigFile(); // 运行在独立的线程中，专门负责生产新连接 //之所以写成成员函数而不是全局函数，是因为可以更好访问成员变量 void produceConnectionTask(); // 扫描超过maxIdleTime时间的空闲连接，进行对于的连接回收 void scannerConnectionTask(); private: string _ip; // mysql的ip地址 unsigned short _port; // mysql的端口号 3306 string _username; // mysql登录用户名 string _password; // mysql登录密码 string _dbname; // 连接的数据库名称 int _initSize; // 连接池的初始连接量 int _maxSize; // 连接池的最大连接量 int _maxIdleTime; // 连接池最大空闲时间 int _connectionTimeout; // 连接池获取连接的超时时间 queue<Connection*> _connectionQue; // 存储mysql连接的队列 mutex _queueMutex; // 维护连接队列的线程安全互斥锁 atomic_int _connectionCnt; // 记录连接所创建的connection连接的总数量 condition_variable cond; // 设置条件变量，用于连接生产线程和连接消费线程的通信 }; #endif //_CONNECTIONPOOL_H \"]},\"1849\":{\"h\":\"connectionPool.cc 连接池的实现\",\"t\":[\"#include \\\"connectionPool.h\\\" #include \\\"public.h\\\" #include <iostream> using std::cout; using std::endl; // 线程安全的懒汉单例函数接口 ConnectionPool *ConnectionPool::getConnectionPool() { // 静态函数的实现，不写static static ConnectionPool pool; // 静态局部变量的初始化，编译器会生成lock和unlock return &pool; } // 从配置文件中加载配置项 bool ConnectionPool::loadConfigFile() { FILE *pf = fopen(\\\"mysql.cnf\\\", \\\"r\\\"); if (pf == nullptr) { LOG(\\\"mysql.cnf file is not exit!\\\"); return false; } while (!feof(pf)) { // 文件不为空 char line[1024] = {0}; fgets(line, sizeof(line), pf); string str = line; int idx = str.find('=', 0); // 从第0位开始找'='的下标 if (idx == -1) { // 无效的配置项 continue; } // password=123456\\\\n int endidx = str.find('\\\\n', idx); // 从第idx位开始找'\\\\n'的下标 string key = str.substr(0, idx); // 从第0位开始idx个字符 string value = str.substr(idx + 1, endidx - (idx + 1)); #ifdef DEBUG cout << key << '=' << value << endl; #endif // DEBUG if (key == \\\"ip\\\") { _ip = value; } else if (key == \\\"port\\\") { _port = atoi(value.c_str()); // string->const char* ->int } else if (key == \\\"username\\\") { _username = value; } else if (key == \\\"password\\\") { _password = value; } else if (key == \\\"dbname\\\") { _dbname = value; } else if (key == \\\"initSize\\\") { _initSize = atoi(value.c_str()); } else if (key == \\\"maxSize\\\") { _maxSize = atoi(value.c_str()); } else if (key == \\\"maxIdleTime\\\") { _maxIdleTime = atoi(value.c_str()); } else if (key == \\\"connectionTimeOut\\\") { _connectionTimeout = atoi(value.c_str()); } } return true; } ConnectionPool::ConnectionPool() { if (!loadConfigFile()) { // 配置文件加载失败 return; } // 创建初始的数量连接 // 这一块是在连接池启动的时候做的，不用考虑线程安全 for (int i = 0; i < _initSize; ++i) { Connection *conn = new Connection(); conn->connection(_ip, _port, _username, _password, _dbname); conn->refreshAliveTime(); // 刷新一下开始空闲的起始时间 _connectionQue.push(conn); _connectionCnt++; } // 启动一个新的线程，作为连接的生产者 linux thread => pthread_create // 因为本身还是c接口，所以线程处理函数void* (*)(void*)类型，需要使用bind thread produce(bind(&ConnectionPool::produceConnectionTask, this)); // 线程对象 produce.detach(); // 设置成分离线程 // 启动一个新的定时线程，扫描超过maxIdleTime时间的空闲连接，进行对于的连接回收 thread scanner(bind(&ConnectionPool::scannerConnectionTask, this)); scanner.detach(); } void ConnectionPool::produceConnectionTask() { while (1) { unique_lock<mutex> lock(_queueMutex); while (!_connectionQue.empty()) { // 队列不为空 cond.wait(lock); } if (_connectionCnt < _maxSize) { Connection *conn = new Connection(); conn->connection(_ip, _port, _username, _password, _dbname); conn->refreshAliveTime(); // 刷新一下开始空闲的起始时间 _connectionQue.push(conn); _connectionCnt++; } // 通知消费者线程，可以消费连接了 cond.notify_all(); } } // 扫描超过maxIdleTime时间的空闲连接，进行对于的连接回收 void ConnectionPool::scannerConnectionTask() { while (1) { // 通过sleep模拟定时效果 std::this_thread::sleep_for(std::chrono::seconds(_maxIdleTime)); // 扫描整个队列，释放多余的连接 while (_connectionCnt > _initSize) { Connection *p = _connectionQue.front(); if (p->getAliveTime() > _maxIdleTime) { _connectionQue.pop(); delete p; --_connectionCnt; // 调用~Connection()释放连接 } else { break; // 队头的连接没有超过_maxIdleTime，其它连接肯定没有 } } } } ConnectionPool::~ConnectionPool() { //{ std::unique_lock<mutex> lock(_queueMutex); while(!_connectionQue.empty()) { delete _connectionQue.front(); _connectionQue.pop(); } //} } // 消费者线程函数，从队列中获取连接 shared_ptr<Connection> ConnectionPool::getConnection() { unique_lock<mutex> lock(_queueMutex); while (_connectionQue.empty()) { if (std::cv_status::timeout == cond.wait_for(lock, std::chrono::milliseconds(_connectionTimeout))) { if (_connectionQue.empty()) { LOG(\\\"获取空闲连接超时了...获取连接失败!\\\"); return nullptr; } } } /* shared_ptr智能指针析构时，会把connection资源直接delete掉，相当于 调用connection的析构函数，connection就被close掉了。 这里需要自定义shared_ptr的释放资源的方式，把connection直接归还到queue当中 */ shared_ptr<Connection> sp(_connectionQue.front(), [&](Connection *pconn) { // 这里是在服务器应用线程中调用的，所以一定要考虑队列的线程安全操作 unique_lock<mutex> lock(_queueMutex); pconn->refreshAliveTime(); _connectionQue.push(pconn); }); _connectionQue.pop(); if (_connectionQue.empty()) { cond.notify_all(); } return sp; } \"]},\"1850\":{\"h\":\"压力测试\",\"t\":[\"压力测试是设计优化类项目所必须的\"]},\"1851\":{\"h\":\"单线程\",\"t\":[\"const int M = 5000; clock_t begin = clock(); for (int i = 0; i < M; ++i) { // 不使用连接池的测试 Connection conn; conn.connection(\\\"127.0.0.1\\\", 3306, \\\"root\\\", \\\"147258\\\", \\\"chat\\\"); conn.update(sql); } clock_t end = clock(); cout << \\\"1. 未使用连接池耗时：\\\" << end - begin << \\\" ms\\\" << endl; // 使用连接池的测试 begin = clock(); ConnectionPool* pool = ConnectionPool::getConnectionPool(); for (size_t i = 0; i < M; i++) { shared_ptr<Connection> conn = pool->getConnection(); conn->update(sql); } end = clock(); cout << \\\"2. 使用连接池耗时：\\\" << end - begin << \\\" ms\\\" << endl; \",\"void func1() { char sql[1024] = {0}; sprintf(sql, \\\"insert into user(name, age, sex) values('%s', %d, '%s')\\\", \\\"guan yu1\\\", 34, \\\"M\\\"); for (int i = 0; i < 250; ++i) { // 不使用连接池的测试 Connection conn; conn.connection(\\\"127.0.0.1\\\", 3306, \\\"root\\\", \\\"147258\\\", \\\"chat\\\"); conn.update(sql); } } void func2() { char sql[1024] = {0}; sprintf(sql, \\\"insert into user(name, age, sex) values('%s', %d, '%s')\\\", \\\"guan yu1\\\", 34, \\\"M\\\"); ConnectionPool* pool = ConnectionPool::getConnectionPool(); for (size_t i = 0; i < 250; i++) { shared_ptr<Connection> conn = pool->getConnection(); conn->update(sql); } } int main() { // Connection conn; conn.connection(\\\"127.0.0.1\\\", 3306, \\\"root\\\", \\\"147258\\\", \\\"chat\\\"); clock_t begin = clock(); thread t1(func1); thread t2(func1); thread t3(func1); thread t4(func1); t1.join(); t2.join(); t3.join(); t4.join(); clock_t end = clock(); cout << end - begin << endl; return 0; } \"]},\"1852\":{\"c\":[\"mysql\"]},\"1853\":{\"c\":[\"mysql连接池\"]},\"1854\":{\"h\":\"数据库编程部分的实现\"},\"1855\":{\"h\":\"在VS上使用MySQL的头文件和库文件的配置\",\"t\":[\"右键项目 - C/C++ - 常规 - 附加包含目录，填写mysql.h头文件的路径\",\"右键项目 - 链接器 - 常规 - 附加库目录，填写libmysql.lib的路径\",\"右键项目 - 链接器 - 输入 - 附加依赖项，填写libmysql.lib库的名字\",\"把libmysql.dll动态链接库（Linux下后缀名是.so库）放在工程目录下\"]},\"1856\":{\"h\":\"代码\",\"t\":[\"//public.h /* * 这是一个公共的头文件 */ #ifndef _PUBLIC_H #define _PUBLIC_H //日志 #define LOG(str) \\\\ cout << __FILE__ << \\\":\\\" << __LINE__ << \\\" \\\" << \\\\ __TIMESTAMP__ << \\\":\\\" << str << endl; #endif //_PUBLIC_H \",\"下面是对MySQL操作的封装\",\"//connection.h /* * 实现MySQL数据库的操作 */ #ifndef _CONNECTION_H #define _CONNECTION_H #include <string> #include <mysql/mysql.h> using std::string; class Connection { public: Connection(); ~Connection(); //数据库的连接操作 bool connection(string ip, unsigned short port, string user, string passward, string dbname); //更新操作 insert delete update bool update(string sql); //查询操作select MYSQL_RES* query(string sql); private: MYSQL* _conn; //表示和MySQL的一条连接 }; #endif // _CONNECTION_H \",\"//connection.cc #include <iostream> #include \\\"connection.h\\\" #include \\\"public.h\\\" using std::cout; using std::endl; Connection::Connection() { //初始化 _conn = mysql_init(nullptr); } //释放资源 Connection::~Connection() { if(_conn != nullptr) { mysql_close(_conn); } } bool Connection::connection(string ip, unsigned short port, string user, string passward, string dbname) { //建立连接 MYSQL* p = mysql_real_connect(_conn, ip.c_str(), user.c_str(), passward.c_str(),dbname.c_str(), port, nullptr, 0); return p != nullptr; } bool Connection::update(string sql) { //更新操作 insert delete update if(mysql_query(_conn, sql.c_str())) { LOG(\\\"更新失败:\\\" + sql); return false; } return true; } MYSQL_RES* Connection::query(string sql) { if(mysql_query(_conn, sql.c_str())) { LOG(\\\"查询失败\\\" + sql); } return mysql_use_result(_conn); } \",\"//main.cc #include <iostream> #include \\\"connection.h\\\" #include \\\"public.h\\\" using std::cout; using std::endl; int main() { Connection conn; char sql[1024] = {0}; sprintf(sql, \\\"insert into user(name, age, sex) values('%s', %d, '%s')\\\", \\\"guan yu\\\", 33, \\\"male\\\"); bool ret = conn.connection(\\\"127.0.0.1\\\", 3306, \\\"root\\\", \\\"147258\\\", \\\"school\\\"); if(!ret) { LOG(\\\"连接失败\\\"); } conn.update(sql); } \",\"$g++ connection.cc main.cc -o main -I /usr/include/ -lmysqlclient \"]},\"1857\":{\"c\":[\"mysql\"]},\"1858\":{\"c\":[\"mysql连接池\"]},\"1859\":{\"h\":\"最大空闲时间回收连接扫描线程的实现\",\"t\":[\"给对象添加一个属性-记录时间\",\"/* * 实现MySQL数据库的操作 */ #ifndef _CONNECTION_H #define _CONNECTION_H #include <string> #include <mysql/mysql.h> #include <ctime> using std::string; class Connection { public: ... // 刷新一下连接的起始的空闲时间点 void refreshAliveTime() { _aliveTime = clock(); } // 返回存活的时间 clock_t getAliveTime() { return clock() - _aliveTime; } private: MYSQL* _conn; //表示和MySQL的一条连接 clock_t _aliveTime; // 记录进入空闲状态后的起始存活时间 }; #endif // _CONNECTION_H \",\"空闲时间-也就是进入队列了\",\"#ifndef _CONNECTIONPOOL_H #define _CONNECTIONPOOL_H #include <string> #include <queue> #include <mutex> #include <atomic> //atomic_int 原子类型 #include <memory> //shared_ptr #include <thread> #include <condition_variable> #include <functional> //bind #include \\\"connection.h\\\" using std::string; using std::queue; using std::mutex; using std::thread; using std::atomic_int; using std::shared_ptr; using std::bind; using std::condition_variable; using std::unique_lock; class ConnectionPool { public: // 获取连接池对象实例 static ConnectionPool* getConnectionPool(); // 给外部提供接口，从连接池中获取一个可用的空闲连接 shared_ptr<Connection> getConnection(); private: ConnectionPool(); ~ConnectionPool(); // 运行在独立的线程中，专门负责生产新连接 //之所以写成成员函数而不是全局函数，是因为可以更好访问成员变量 void produceConnectionTask(); // 扫描超过maxIdleTime时间的空闲连接，进行对于的连接回收 void scannerConnectionTask(); private: string _ip; // mysql的ip地址 unsigned short _port; // mysql的端口号 3306 string _username; // mysql登录用户名 string _password; // mysql登录密码 string _dbname; // 连接的数据库名称 int _initSize; // 连接池的初始连接量 int _maxSize; // 连接池的最大连接量 int _maxIdleTime; // 连接池最大空闲时间 int _connectionTimeout; // 连接池获取连接的超时时间 queue<Connection*> _connectionQue; // 存储mysql连接的队列 mutex _queueMutex; // 维护连接队列的线程安全互斥锁 atomic_int _connectionCnt; // 记录连接所创建的connection连接的总数量 condition_variable cond; // 设置条件变量，用于连接生产线程和连接消费线程的通信 }; #endif //_CONNECTIONPOOL_H \",\"加入队列的连接需要刷新时间\",\"初始化时创建_initSize个连接\",\"生产者创建连接\",\"智能指针析构函数放回队列\",\"线程处理函数则定时检查队头元素（FIFO，最先加入队列的元素）是否超时\",\"#include \\\"connectionPool.h\\\" #include \\\"public.h\\\" #include <iostream> using std::cout; using std::endl; ConnectionPool::ConnectionPool() { if (!loadConfigFile()) { // 配置文件加载失败 return; } // 创建初始的数量连接 // 这一块是在连接池启动的时候做的，不用考虑线程安全 for (int i = 0; i < _initSize; ++i) { Connection *conn = new Connection(); conn->connection(_ip, _port, _username, _password, _dbname); conn->refreshAliveTime(); // 刷新一下开始空闲的起始时间 _connectionQue.push(conn); _connectionCnt++; } // 启动一个新的线程，作为连接的生产者 linux thread => pthread_create // 因为本身还是c接口，所以线程处理函数void* (*)(void*)类型，需要使用bind thread produce(bind(&ConnectionPool::produceConnectionTask, this)); // 线程对象 produce.detach(); // 设置成分离线程 // 启动一个新的定时线程，扫描超过maxIdleTime时间的空闲连接，进行对于的连接回收 thread scanner(bind(&ConnectionPool::scannerConnectionTask, this)); scanner.detach(); } void ConnectionPool::produceConnectionTask() { while (1) { unique_lock<mutex> lock(_queueMutex); while (!_connectionQue.empty()) { // 队列不为空 cond.wait(lock); } if (_connectionCnt < _maxSize) { Connection *conn = new Connection(); conn->connection(_ip, _port, _username, _password, _dbname); conn->refreshAliveTime(); // 刷新一下开始空闲的起始时间 _connectionQue.push(conn); _connectionCnt++; } // 通知消费者线程，可以消费连接了 cond.notify_all(); } } // 扫描超过maxIdleTime时间的空闲连接，进行对于的连接回收 void ConnectionPool::scannerConnectionTask() { while (1) { // 通过sleep模拟定时效果 std::this_thread::sleep_for(std::chrono::seconds(_maxIdleTime)); // 扫描整个队列，释放多余的连接 while (_connectionCnt > _initSize) { Connection *p = _connectionQue.front(); if (p->getAliveTime() > _maxIdleTime) { _connectionQue.pop(); delete p; --_connectionCnt; // 调用~Connection()释放连接 } else { break; // 队头的连接没有超过_maxIdleTime，其它连接肯定没有 } } } } // 消费者线程函数，从队列中获取连接 shared_ptr<Connection> ConnectionPool::getConnection() { unique_lock<mutex> lock(_queueMutex); while (_connectionQue.empty()) { if (std::cv_status::timeout == cond.wait_for(lock, std::chrono::milliseconds(_connectionTimeout))) { if (_connectionQue.empty()) { LOG(\\\"获取空闲连接超时了...获取连接失败!\\\"); return nullptr; } } } /* shared_ptr智能指针析构时，会把connection资源直接delete掉，相当于 调用connection的析构函数，connection就被close掉了。 这里需要自定义shared_ptr的释放资源的方式，把connection直接归还到queue当中 */ shared_ptr<Connection> sp(_connectionQue.front(), [&](Connection *pconn) { // 这里是在服务器应用线程中调用的，所以一定要考虑队列的线程安全操作 unique_lock<mutex> lock(_queueMutex); pconn->refreshAliveTime(); _connectionQue.push(pconn); }); _connectionQue.pop(); if (_connectionQue.empty()) { cond.notify_all(); } return sp; } \",\"C++ 多线程detach()操作的坑以及传参_c++ thread detach-CSDN博客\"]},\"1860\":{\"c\":[\"mysql\"]},\"1861\":{\"c\":[\"mysql连接池\"]},\"1862\":{\"h\":\"概述\"},\"1863\":{\"h\":\"关键技术点\",\"t\":[\"MySQL数据库编程、单例模式、queue队列容器、C++11多线程编程、线程互斥、线程同步通信和 unique_lock、基于CAS的原子整形、智能指针shared_ptr、lambda表达式、生产者-消费者线程模型\"]},\"1864\":{\"h\":\"项目背景\",\"t\":[\"索引和数据都是存储在磁盘上，提高MySQL数据库（基于C/S设计，服务器应用相当于MySQL Client，通过既定的API将SQL语句发送给MySQL Server，然后执行处理流程CRUD,然后再通过结果返回给服务器应用）的访问瓶颈：\",\"热点数据（访问量比较大）可以放在缓存（redis、memory cache）内，\",\"增加连接池，在高并发的情况下，减少**、(用户是否合法、密码是否正确)、和**所带来的性能损耗。\",\"常见的连接池括阿里的druid，c3p0以及apache dbcp连接池，，全部由Java实现的\",\"本项目为了在C/C++项目中，提供MySQL Server的访问效率，实现基于C++代码的数据库连接池模块\"]},\"1865\":{\"h\":\"连接池功能点介绍\",\"t\":[\"连接池一般包含了数据库连接所用的ip地址、port端口号、用户名和密码以及其它的性能参数，例如初始连接量，最大连接量，最大空闲时间、连接超时时间等，该项目是基于C++语言实现的连接池，主要也是实现以上几个所有连接池都支持的通用基础功能。\",\"初始连接量（initSize）：表示连接池事先会和MySQL Server创建initSize个数的connection连接，当应用发起MySQL访问时，不用再创建和MySQL Server新的连接，直接从连接池中获取一个可用的连接就可以，使用完成后，并不去释放connection，而是把当前connection再归还到连接池当中。\",\"最大连接量（maxSize）：当并发访问MySQL Server的请求增多时，初始连接量已经不够使用了，此时会根据新的请求数量去创建更多的连接给应用去使用，但是新创建的连接数量上限是maxSize，不能无限制的创建连接，因为每一个连接都会占用一个socket资源，一般连接池和服务器程序是部署在一台主机上的，(都是网络连接)。当这些连接使用完成后，再次归还到连接池当中来维护。\",\"最大空闲时间（maxIdleTime）：当访问MySQL的并发请求多了以后，连接池里面的连接数量会动态增加，上限是maxSize个，当这些连接用完再次归还到连接池当中。如果在指定的maxIdleTime里面，这些新增加的连接都没有被再次使用过，那么新增加的这些连接资源就要被回收掉，只需要保持初始连接量initSize个连接就可以了。\",\"连接超时时间（connectionTimeout）：当MySQL的并发请求量过大，连接池中的连接数量已经到达maxSize了，而此时没有空闲的连接可供使用，那么此时应用从连接池获取连接无法成功，它通过阻塞的方式获取连接的时间如果超过connectionTimeout时间，那么获取连接失败，无法访问数据库。\"]},\"1866\":{\"h\":\"功能实现设计\",\"t\":[\"ConnectionPool.cpp和ConnectionPool.h：连接池代码实现 Connection.cpp和Connection.h：数据库操作代码、增删改查代码实现\",\"连接池主要包含了以下功能点：\",\"连接池只需要一个实例，所以ConnectionPool以单例模式进行设计\",\"从ConnectionPool中可以获取和MySQL的连接Connection\",\"空闲连接Connection全部维护在一个线程安全的Connection队列中，使用线程互斥锁保证队列的线程安全\",\"如果Connection队列为空，还需要再获取连接，此时需要动态创建连接，上限数量是maxSize\",\"队列中空闲连接时间超过maxIdleTime的就要被释放掉，只保留初始的initSize个连接就可以了，这个功能点肯定需要放在独立的线程中去做\",\"如果Connection队列为空，而此时连接的数量已达上限maxSize，那么等待connectionTimeout时间如果还获取不到空闲的连接，那么获取连接失败，此处从Connection队列获取空闲连接，可以使用带超时时间的mutex互斥锁来实现连接超时时间\",\"用户获取的连接用shared_ptr智能指针来管理，用lambda表达式定制连接释放的功能（不真正释放连接，而是把连接归还到连接池中）\",\"连接的生产和连接的消费采用生产者-消费者线程模型来设计，使用了线程间的同步通信机制条件变量和互斥锁\",\"做项目一定先把功能点想清楚再进行开发，不要边写边删\"]},\"1867\":{\"c\":[\"mysql\"]},\"1868\":{\"c\":[\"mysql连接池\"]},\"1869\":{\"h\":\"消费者线程的实现\",\"t\":[\"//消费者线程函数，从队列中获取连接 shared_ptr<Connection> ConnectionPool::getConnection() { unique_lock<mutex> lock(_queueMutex); while(_connectionQue.empty()) { cond.wait_for(lock, std::chrono::milliseconds(_connectionTimeout)); if(_connectionQue.empty()) { LOG(\\\"获取空闲连接超时了...获取连接失败!\\\"); return nullptr; } } shared_ptr<Connection> sp(_connectionQue.front()); _connectionQue.pop(); if(_connectionQue.empty()) { cond.notify_all(); } } \",\"再也不被时间束缚：C++ stdchrono时间库全面解析 - 知乎 (zhihu.com)\"]},\"1870\":{\"h\":\"重置智能指针析构\",\"t\":[\"shared_ptr<Connection> sp(_connectionQue.front(), [&](Connection *pconn) { // 这里是在服务器应用线程中调用的，所以一定要考虑队列的线程安全操作 unique_lock<mutex> lock(_queueMutex); _connectionQue.push(pconn); }); \",\"智能指针第二个参数传入函数对象可以重置析构函数，这里使用lambda表达式，但是要注意线程安全问题\"]},\"1871\":{\"h\":\"wait_for() 优化\",\"t\":[\"wait_for() 返回值是一个类，包含了 timeout和no_timeout\",\"wait_for() 可能会出现这种情况：生产者发出信号，该线程no_timeout退出wait_for() ，但是手慢没有抢到队列中的连接_connectionQue.empty()\",\" while (_connectionQue.empty()) { if (std::cv_status::timeout == cond.wait_for(lock, std::chrono::milliseconds(_connectionTimeout))) { if (_connectionQue.empty()) { LOG(\\\"获取空闲连接超时了...获取连接失败!\\\"); return nullptr; } } } \"]},\"1872\":{\"h\":\"最终版 消费者线程处理函数\",\"t\":[\"// 消费者线程函数，从队列中获取连接 shared_ptr<Connection> ConnectionPool::getConnection() { unique_lock<mutex> lock(_queueMutex); while (_connectionQue.empty()) { if (std::cv_status::timeout == cond.wait_for(lock, std::chrono::milliseconds(_connectionTimeout))) { if (_connectionQue.empty()) { LOG(\\\"获取空闲连接超时了...获取连接失败!\\\"); return nullptr; } } } /* shared_ptr智能指针析构时，会把connection资源直接delete掉，相当于 调用connection的析构函数，connection就被close掉了。 这里需要自定义shared_ptr的释放资源的方式，把connection直接归还到queue当中 */ shared_ptr<Connection> sp(_connectionQue.front(), [&](Connection *pconn) { // 这里是在服务器应用线程中调用的，所以一定要考虑队列的线程安全操作 unique_lock<mutex> lock(_queueMutex); _connectionQue.push(pconn); }); _connectionQue.pop(); if (_connectionQue.empty()) { cond.notify_all(); } } \"]},\"1873\":{\"c\":[\"mysql\"]},\"1874\":{\"c\":[\"mysql连接池\"]},\"1875\":{\"h\":\"生产者线程的实现\",\"t\":[\"#ifndef _CONNECTIONPOOL_H #define _CONNECTIONPOOL_H #include <string> #include <queue> #include <mutex> #include <atomic> //atomic_int 原子类型 #include <memory> //shared_ptr #include <thread> #include <condition_variable> #include <functional> //bind #include \\\"connection.h\\\" using std::string; using std::queue; using std::mutex; using std::thread; using std::atomic_int; using std::shared_ptr; using std::bind; using std::condition_variable; using std::unique_lock; class ConnectionPool { public: // 获取连接池对象实例 static ConnectionPool* getConnectionPool(); // 给外部提供接口，从连接池中获取一个可用的空闲连接 shared_ptr<Connection> getConnection(); private: ConnectionPool(); ~ConnectionPool(); #ifdef TEST_LOAD_CONFIG_FILE public: //测试的时候可以先变成共有的 #endif //TEST_LOAD_CONFIG_FILE bool loadConfigFile(); // 运行在独立的线程中，专门负责生产新连接 //之所以写成成员函数而不是全局函数，是因为可以更好访问成员变量 void produceConnectionTask(); private: string _ip; // mysql的ip地址 unsigned short _port; // mysql的端口号 3306 string _username; // mysql登录用户名 string _password; // mysql登录密码 string _dbname; // 连接的数据库名称 int _initSize; // 连接池的初始连接量 int _maxSize; // 连接池的最大连接量 int _maxIdleTime; // 连接池最大空闲时间 int _connectionTimeout; // 连接池获取连接的超时时间 queue<Connection*> _connectionQue; // 存储mysql连接的队列 mutex _queueMutex; // 维护连接队列的线程安全互斥锁 atomic_int _connectionCnt; // 记录连接所创建的connection连接的总数量 condition_variable cond; // 设置条件变量，用于连接生产线程和连接消费线程的通信 }; #endif //_CONNECTIONPOOL_H \",\"C++多线程pthread和thread-CSDN博客\",\"#include \\\"connectionPool.h\\\" #include <iostream> #include \\\"public.h\\\" using std::cout; using std::endl; // 线程安全的懒汉单例函数接口 ConnectionPool* ConnectionPool::getConnectionPool() { //静态函数的实现，不写static static ConnectionPool pool; //静态局部变量的初始化，编译器会生成lock和unlock return &pool; } // 从配置文件中加载配置项 bool ConnectionPool::loadConfigFile() { FILE* pf = fopen(\\\"mysql.cnf\\\",\\\"r\\\"); if(pf == nullptr) { LOG(\\\"mysql.cnf file is not exit!\\\"); return false; } while(!feof(pf)) { //文件不为空 char line[1024] = {0}; fgets(line, sizeof(line), pf); string str = line; int idx = str.find('=', 0); //从第0位开始找'='的下标 if(idx == -1) { //无效的配置项 continue; } // password=123456\\\\n int endidx = str.find('\\\\n', idx); //从第idx位开始找'\\\\n'的下标 string key = str.substr(0,idx); //从第0位开始idx个字符 string value = str.substr(idx + 1, endidx - (idx + 1)); #ifdef DEBUG cout << key << '=' << value << endl; #endif //DEBUG if(key == \\\"ip\\\") { _ip = value; } else if(key == \\\"port\\\") { _port = atoi(value.c_str()); //string->const char* ->int } else if(key == \\\"username\\\") { _username = value; } else if(key == \\\"password\\\") { _password = value; } else if(key == \\\"dbname\\\") { _dbname = value; } else if(key == \\\"initSize\\\") { _initSize = atoi(value.c_str()); } else if(key == \\\"maxSize\\\") { _maxSize = atoi(value.c_str()); } else if(key == \\\"maxIdleTime\\\") { _maxIdleTime = atoi(value.c_str()); } else if(key == \\\"connectionTimeOut\\\") { _connectionTimeout = atoi(value.c_str()); } } return true; } ConnectionPool::ConnectionPool() { if(!loadConfigFile()) { //配置文件加载失败 return; } //创建初始的数量连接 //这一块是在连接池启动的时候做的，不用考虑线程安全 for(int i = 0; i < _initSize; ++i) { Connection* conn = new Connection(); conn->connection(_ip, _port, _username, _password, _dbname); _connectionQue.push(conn); _connectionCnt++; } // 启动一个新的线程，作为连接的生产者 linux thread => pthread_create // 因为本身还是c接口，所以线程处理函数void* (*)(void*)类型，需要使用bind thread produce(bind(&ConnectionPool::produceConnectionTask,this)); //线程对象 } //线程处理函数，生产连接池 void ConnectionPool::produceConnectionTask() { while(1) { unique_lock<mutex> lock(_queueMutex); while(!_connectionQue.empty()) { //队列不为空 cond.wait(lock); } if(_connectionCnt < _maxSize) { Connection* conn = new Connection(); conn->connection(_ip, _port, _username, _password, _dbname); _connectionQue.push(conn); _connectionCnt++; } // 通知消费者线程，可以消费连接了 cond.notify_all(); } } ConnectionPool::~ConnectionPool() {} shared_ptr<Connection> ConnectionPool::getConnection() { } \"]},\"1876\":{\"c\":[\"mysql\"]},\"1877\":{\"c\":[\"mysql连接池\"]},\"1878\":{\"h\":\"连接池单例模式实践\",\"t\":[\"//饿汉式 线程安全的单例 class ConnectionPool { public: static ConnectionPool* getConnectionPool(); private: ConnectionPool(); ~ConnectionPool(); }; // 线程安全的懒汉单例函数接口 ConnectionPool* ConnectionPool::getConnectionPool() { //静态函数的实现，不写static static ConnectionPool pool; //静态局部变量的初始化，编译器会生成lock和unlock return &pool; } \",\"#ifndef _CONNECTIONPOOL_H #define _CONNECTIONPOOL_H #include <string> #include <queue> #include <mutex> #include \\\"connection.h\\\" using std::string; using std::queue; using std::mutex; class ConnectionPool { public: static ConnectionPool* getConnectionPool(); private: ConnectionPool(); ~ConnectionPool(); public: //测试的时候可以先变成共有的 bool loadConfigFile(); private: string _ip; // mysql的ip地址 unsigned short _port; // mysql的端口号 3306 string _username; // mysql登录用户名 string _password; // mysql登录密码 string _dbname; // 连接的数据库名称 int _initSize; // 连接池的初始连接量 int _maxSize; // 连接池的最大连接量 int _maxIdleTime; // 连接池最大空闲时间 int _connectionTimeout; // 连接池获取连接的超时时间 queue<Connection*> _connectionQue; // 存储mysql连接的队列 mutex _queueMutex; // 维护连接队列的线程安全互斥锁 }; #endif //_CONNECTIONPOOL_H \",\"#include \\\"connectionPool.h\\\" #include <iostream> #include \\\"public.h\\\" using std::cout; using std::endl; ConnectionPool::ConnectionPool() {} ConnectionPool::~ConnectionPool() {} // 线程安全的懒汉单例函数接口 ConnectionPool* ConnectionPool::getConnectionPool() { //静态函数的实现，不写static static ConnectionPool pool; //静态局部变量的初始化，编译器会生成lock和unlock return &pool; } bool ConnectionPool::loadConfigFile() { FILE* pf = fopen(\\\"mysql.cnf\\\",\\\"r\\\"); if(pf == nullptr) { LOG(\\\"mysql.cnf file is not exit!\\\"); return false; } while(!feof(pf)) { //文件不为空 char line[1024] = {0}; fgets(line, sizeof(line), pf); string str = line; int idx = str.find('=', 0); //从第0位开始找'='的下标 if(idx == -1) { //无效的配置项 continue; } // password=123456\\\\n int endidx = str.find('\\\\n', idx); //从第idx位开始找'\\\\n'的下标 string key = str.substr(0,idx); //从第0位开始idx个字符 string value = str.substr(idx + 1, endidx - (idx + 1)); cout << key << '=' << value << endl; } return true; } \",\"feof()原理和用法-CSDN博客\",\"feof()如果文件结束，则返回非0值，否则返回0\",\"[fgets()函数的详解-使用技巧-C语言基础_fgets函数用法-CSDN博客](https://blog.csdn.net/Devour_/article/details/110955333#:~:text=一般用法： char a %3D {0}%3B fgets,(a%2C 100%2C stdin)%3B 通俗来讲的话，fgets()函数的作用就是用来读取一行数据的。 但要详细且专业的说的话，fgets()函数的作用可以这么解释：从第三个参数指定的流中读取最多第二个参数大小的字符到第一个参数指定的容器地址中。 在这个过程中，在还没读取够第二个参数指定大小的字符前，读取到换行符'n'或者需要读取的流中已经没有数据了。)\",\"char *fgets(char *restrict str, int size, FILE *restrict stream) \",\"fgets()函数的作用就是用来读取一行数据的,读取出错或读取文件时文件为空，则返回一个空指针\",\"fgets()函数的最大读取大小是其“第二个参数减1”，\",\"这是由于字符串是以’\\\\0’为结束符的，fgets()为了保证输入内容的字符串格式，当输入的数据大小超过了第二个参数指定的大小的时候，fgets()会仅仅读取前面的“第二个参数减1”个字符，而预留1个字符的空间来存储字符串结束符’\\\\0’。\",\"C++String中的find用法_c++ string find-CSDN博客\",\"C++string类中substr()函数的使用方法_c++ string substr-CSDN博客\",\"string x=s.substr() //默认时的长度为从开始位置到尾 string y=s.substr(5) //获得字符串s中 从第5位开始到尾的字符串 string z=s.substr(5,3); //获得字符串s中 从第5位开始的长度为3的字符串\",\"#include <iostream> #include \\\"connection.h\\\" #include \\\"connectionPool.h\\\" #include \\\"public.h\\\" using std::cout; using std::endl; int main() { // Connection conn; // char sql[1024] = {0}; // sprintf(sql, \\\"insert into user(name, age, sex) values('%s', %d, '%s')\\\", // \\\"guan yu\\\", 33, \\\"male\\\"); // bool ret = conn.connection(\\\"127.0.0.1\\\", 3306, \\\"root\\\", \\\"147258\\\", \\\"school\\\"); // if(!ret) { // LOG(\\\"连接失败\\\"); // } // conn.update(sql); ConnectionPool::getConnectionPool()->loadConfigFile(); } \",\"#数据库连接池的配置文件，下面和宏一样就不要加多余的空格了 ip=127.0.0.1 port=3306 username=root password=147258 initSize=10 maxSize=1024 // 连接池最大空闲时间默认单位是秒 maxIdleTime=60 // 连接池获取连接的超时时间单位是毫秒 connectionTimeOut=100 \",\"image-20240408210426812\"]},\"1879\":{\"c\":[\"mysql\"]},\"1880\":{\"c\":[\"mysql连接池\"]},\"1881\":{\"h\":\"SQL的完整处理流程\",\"t\":[\"mysql client和 mysql server进行通信的时候，如果走完所有的MySQL Server模块，需要依次经过连接器、解析器、优化器、执行器、存储引擎\",\"连接器：使用TCP加密的ssl通信协议，管理连接，控制最大连接量，检测连接时长（长时间不通信会断开，释放连接资源），权限验证（账号密码等），查询缓存（两次同样的select之间有更新操作，缓存会清空）\",\"解析器：生成语法树，解析SQL词法以及语法分析\",\"优化器：生成执行计划，选择索引（explain可查看）\",\"执行器：调用存储引擎提供的相应API接口进行数据的读写\",\"存储引擎：读写磁盘数据，构建B+树索引，事务日志（undo log/redo log），锁机制，隔离级别…\",\"class BaseEngine{} class MyISAM : public BaseEngine{} class InnoDB : public BaseEngine{} \",\"基类向外提供统一的接口，基类指针指向哪个对象，就调用哪个存储引擎类的方法\",\"MySQL server相当于可以划分成3个模块（红色框）：\",\"如果单纯的一次通信，client拿到结果，会。MySQL Server这边由负责关闭这个连接，回收这个连接的资源\"]},\"1882\":{\"c\":[\"mysql\"]},\"1883\":{\"c\":[\"mysql拓展\"]},\"1884\":{\"h\":\"分库分表实践\"},\"1885\":{\"h\":\"一、为什么要分库分表\",\"t\":[\"数据库架构演变\",\"刚开始多数项目用单机数据库就够了，随着服务器流量越来越大，面对的请求也越来越多，我们做了数据库读写分离， 使用多个从库副本（Slave）负责读，使用主库（Master）负责写，master和slave通过主从复制实现数据同步更新，保持数据一致。slave 从库可以水平扩展，所以更多的读请求不成问题\",\"但是当用户量级上升，写请求越来越多，怎么保证数据库的负载足够？增加一个Master是不能解决问题的， 因为数据要保存一致性，写操作需要2个master之间同步，相当于是重复了，而且架构设计更加复杂\",\"这时需要用到分库分表（sharding），把库和表存放在不同的MySQL Server上，每台服务器可以均衡写请求的次数\"]},\"1886\":{\"h\":\"二、库表太大产生的问题\",\"t\":[\"单库太大：单库处理能力有限、所在服务器上的磁盘空间不足、遇到IO瓶颈，需要把单库切分成更多更小的库\",\"单表太大：CRUD效率都很低，数据量太大导致索引文件过大，磁盘IO加载索引花费时间，导致查询超时。所以只用索引还是不行的，需要把单表切分成多个数据集更小的表。MyCat提供的分表算法都在rule.xml，可以根据不同的分表算法进行拆分，比如根据时间拆分、一致性哈希、直接用主键对分表的个数取模等\",\"拆分策略\",\"单个库太大，先考虑是表多还是数据多：\",\"如果因为表多而造成数据过多，则使用垂直拆分，即根据业务拆分成不同的库 如果因为单张表的数据量太大，则使用水平拆分，即把表的数据按照某种规则（mycat/conf/rule.xml定义的分表算法）拆分成多张表 分库分表的原则应该是先考虑垂直拆分，再考虑水平拆分\"]},\"1887\":{\"h\":\"三、垂直拆分\",\"t\":[\"分库分表和读写分离可以共同进行\"]},\"1888\":{\"h\":\"1.垂直分库\",\"t\":[\"server.xml\",\"<user name=\\\"root\\\"> <property name=\\\"password\\\">123456</property> <property name=\\\"schemas\\\">USERDB1,USERDB2</property> </user> \",\"配置了USERDB1、USERDB2这两个逻辑库\",\"schema.xml\",\"<?xml version=\\\"1.0\\\"?> <!DOCTYPE mycat:schema SYSTEM \\\"schema.dtd\\\"> <mycat:schema xmlns:mycat=\\\"http://io.mycat/\\\"> <!-- 逻辑数据库 --> <schema name=\\\"USERDB1\\\" checkSQLschema=\\\"false\\\" sqlMaxLimit=\\\"100\\\" dataNode=\\\"dn1\\\" /> <!-- 两个逻辑库对应两个不同的数据节点 --> <schema name=\\\"USERDB2\\\" checkSQLschema=\\\"false\\\" sqlMaxLimit=\\\"100\\\"dataNode=\\\"dn2\\\" /> <!-- 存储节点 --> <dataNode name=\\\"dn1\\\" dataHost=\\\"node1\\\" database=\\\"mytest1\\\" /> <!-- 两个数据节点对应两个不同的物理机器 --> <dataNode name=\\\"dn2\\\" dataHost=\\\"node2\\\" database=\\\"mytest2\\\" /> <!-- USERDB1对应mytest1，USERDB2对应mytest2 --> <!-- 数据库主机 --> <dataHost name=\\\"node1\\\" maxCon=\\\"1000\\\" minCon=\\\"10\\\" balance=\\\"0\\\" writeType=\\\"0\\\" dbType=\\\"mysql\\\" dbDriver=\\\"native\\\"> <heartbeat>select user()</heartbeat> <writeHost host=\\\"192.168.131.129\\\" url=\\\"192.168.131.129:3306\\\" user=\\\"root\\\" password=\\\"123456\\\" /> </dataHost> <dataHost name=\\\"node2\\\" maxCon=\\\"1000\\\" minCon=\\\"10\\\" balance=\\\"0\\\"writeType=\\\"0\\\" dbType=\\\"mysql\\\" dbDriver=\\\"native\\\"> <heartbeat>select user()</heartbeat> <writeHost host=\\\"192.168.0.6\\\" url=\\\"192.168.0.6:3306\\\" user=\\\"root\\\" password=\\\"123456\\\" /> </dataHost> </mycat:schema> \",\"两个逻辑库对应两个不同的数据节点，两个数据节点对应两个不同的物理机器\",\"mytest1和mytest2分成了不同机器上的不同的库，各包含一部分表，它们原来是合在一块的，在一台机器上，现在做了垂直的拆分。 客户端就需要去连接不同的逻辑库了，根据业务操作不同的逻辑库\",\"然后配置了两个写库，两台机器把库平分了，分担了原来单机的压力。分库伴随着分表，从业务上对表拆分\"]},\"1889\":{\"h\":\"2.垂直分表\",\"t\":[\"垂直分表，基于列字段进行。一般是针对几百列的这种大表，也避免查询时，数据量太大造成的“跨页”问题。\",\"一般是表中的字段较多，将不常用的， 数据较大，长度较长（比如text类型字段）的拆分到扩展表。访问频率较高的字段单独放在一张表\"]},\"1890\":{\"h\":\"四、水平分表\",\"t\":[\"针对数据量巨大的单张表（比如订单表），按照某种规则（RANGE、HASH取模等），切分到多张表里面去。 但是这些表还是在同一个库中，所以库级别的数据库操作还是有IO瓶颈，不建议采用\",\"将单张表的数据切分到多个服务器上去，每个服务器具有一部分库与表，只是表中数据集合不同。 水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源等的瓶颈\",\"分库分表可以和主从复制同时进行，但不基于主从复制；读写分离才基于主从复制\"]},\"1891\":{\"h\":\"1.配置水平分表\",\"t\":[\"server.xml\",\"<user name=\\\"root\\\"> <property name=\\\"password\\\">123456</property> <property name=\\\"schemas\\\">USERDB</property> </user> \",\"schema.xml\",\"<?xml version=\\\"1.0\\\"?> <!DOCTYPE mycat:schema SYSTEM \\\"schema.dtd\\\"> <mycat:schema xmlns:mycat=\\\"http://io.mycat/\\\"> <!-- 逻辑数据库 --> <schema name=\\\"USERDB\\\" checkSQLschema=\\\"false\\\" sqlMaxLimit=\\\"100\\\"> <table name=\\\"user\\\" dataNode=\\\"dn1\\\" /> <!-- 这里的user和student都是实际存在的物理表名 --> <table name=\\\"student\\\" primaryKey=\\\"id\\\" autoIncrement=\\\"true\\\" dataNode=\\\"dn1,dn2\\\" rule=\\\"mod-long\\\"/> <!-- student表按照id取模拆分 --> </schema> <!-- 存储节点 --> <dataNode name=\\\"dn1\\\" dataHost=\\\"node1\\\" database=\\\"mytest1\\\" /> <dataNode name=\\\"dn2\\\" dataHost=\\\"node2\\\" database=\\\"mytest2\\\" /> <!-- 数据库主机 --> <dataHost name=\\\"node1\\\" maxCon=\\\"1000\\\" minCon=\\\"10\\\" balance=\\\"0\\\" writeType=\\\"0\\\" dbType=\\\"mysql\\\" dbDriver=\\\"native\\\"> <heartbeat>select user()</heartbeat> <writeHost host=\\\"192.168.131.129\\\" url=\\\"192.168.131.129:3306\\\" user=\\\"root\\\" password=\\\"123456\\\" /> </dataHost> <dataHost name=\\\"node2\\\" maxCon=\\\"1000\\\" minCon=\\\"10\\\" balance=\\\"0\\\" writeType=\\\"0\\\" dbType=\\\"mysql\\\" dbDriver=\\\"native\\\"> <heartbeat>select user()</heartbeat> <writeHost host=\\\"192.168.0.6\\\" url=\\\"192.168.0.6:3306\\\" user=\\\"root\\\" password=\\\"123456\\\" /> </dataHost> </mycat:schema> \",\"user表示一个普通的表，直接放在数据节点dn1上，放在一台机器上，这张表不用进行拆分\",\"student表的primaryKey是id，根据id拆分，放在dn1和dn2上，最终这个表要分在两台机器上，在物理上分开了，但是在逻辑上还是一个，往哪张表里增加，在2台机器上查询然后如何合并这些操作都是由mycat完成的\",\"拆分的规则是取模（mod - long)，每次插入用id模上存在的机器数（2）\",\"此外还需要在rule.xml中配置以下拆分算法\",\"找到算法mod-long，因为我们将逻辑表student分开映射到两台主机上，所以修改数据节点的数量为2\"]},\"1892\":{\"h\":\"2. 测试水平分表\",\"t\":[\"Linux主机\",\"Windows主机\",\"登录到mycat的8066端口\",\"使用MyCat给user表插入两条数据\",\"由于schema.xml配置文件中，逻辑表user只在Linux主机的mytest1库中存在，mycat操作的逻辑表user会影响Linux主机上的物理表，而不会影响Windows主机上的表。我们分别查看一下Linux和Windows主机的user表：\",\"我们再通过MyCat给student表插入两条数据\",\"我们知道schema.xml配置文件中，逻辑表student对应两台主机上的两个库mytest1、mytest2中的两张表，所以对逻辑表插入的两条数据，会实际影响到两张物理表（用id%机器数，决定插入到哪张物理表）。我们分别查看一下Linux和Windows主机的student表：\",\"再通过MyCat插入id=3和id=4的数据，应该插入不同主机上的不同物理表\",\"这就相当于把student表进行水平拆分了\",\"通过MyCat查询的时候只需要正常输入就行，我们配置的是表拆分后放在这2个数据节点上，MyCat会根据配置在两个库上查询并进行数据合并\"]},\"1893\":{\"c\":[\"mysql\"]},\"1894\":{\"c\":[\"mysql拓展\"]},\"1895\":{\"h\":\"Json简介及使用\"},\"1896\":{\"h\":\"一、Json简介\",\"t\":[\"：是一种轻量级的)，采用完全独立于编程语言的来存储和表示数据。 简洁和清晰的层次结构使得 Json 成为理想的数据交换语言，易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。\",\"例如：聊天软件的业务，消息种类分为很多种，例如：登录消息、注册消息、聊天消息、加好友消息等等，。而网络中TCP传输数据时为字节流，因此我们需要数据序列化将其转为字节流发送到对端主机，对端主机读取字节流上报应用服务，再将数据反序列化出来解析使用。\",\"image-20240413100255722\",\"优秀的Json开源库JSON for Modern C++：由德国大牛 nlohmann 编写的在 C++ 下使用的 Json 库，具有以下优点：\",\"直观的语法；\",\"整个代码由一个头文件组成 json.hpp，没有子项目、依赖关系、复杂的构建系统，使用起来非常方便；\",\"使用 C++ 11 标准编写，使用 Json 像使用 STL 容器一样；\",\"STL 和 Json 容器之间可以相互转换；\",\"所有类都经过严格的单元测试，覆盖了 100％ 的代码，包括所有特殊的行为。此外，还检查了 Valgrind 是否有内存泄漏。为了保持高质量，该项目遵循核心基础设施倡议(CII)的最佳实践。\"]},\"1897\":{\"h\":\"二、Json语法\"},\"1898\":{\"h\":\"2.1 Json语法\",\"t\":[\"：它是，主要有以下特点：\",\"在名称/值对的；\",\"数据由逗号 ,；\",\"使用反斜杆 \\\\ 来字符；\",\"大括号 {} 保存；\",\"中括号 [] 保存，数组可以包含多个对象；\"]},\"1899\":{\"h\":\"2.2 Json的两种结构：\",\"t\":[\"对象：\",\"大括号 {} 保存的对象是一个无序的名称/值对集合。一个对象以左括号 { 开始， 右括号 } 结束。每个\\\"键\\\"后跟一个冒号 :，名称/值对使用逗号 , 分隔。\",\"数组：\",\"中括号 [] 保存的数组是值(value)的有序集合。一个数组以左中括号[开始， 右中括号 ]结束，值之间使用逗号 , 分隔。可以是括起来的或者，也可以是他们的。\"]},\"1900\":{\"h\":\"2.3 书写格式\",\"t\":[\"key : value格式，类似于我们C++中的map容器，十分简洁清晰，例如：\",\"json js; js[\\\"name\\\"] = \\\"xiaoming\\\"; \"]},\"1901\":{\"h\":\"三、数据序列化实例\",\"t\":[\"Json序列化： 在网络中，常用的数据传输序列化格式有XML、Json、ProtoBuf，在公司级别的项目中，大量的在使用ProtoBuf作为数据序列化的方式，它数据压缩编码传输，占用带宽小，同样的数据信息，是Json的1/10，XML的1/20，但是使用起来比Json稍复杂一些，学习成本较高，所以项目中我们选择常用的Json格式来打包传输数据。\",\"#include \\\"json.hpp\\\" using json = nlohmann::json; \"]},\"1902\":{\"h\":\"3.1 普通数据序列化\",\"t\":[\"//1、Json普通数据序列化 void test1() { json js; //添加Json对象 js[\\\"msg_type\\\"] = 2; js[\\\"from\\\"] = \\\"zhangsan\\\"; js[\\\"to\\\"] = \\\"lisi\\\"; js[\\\"msg\\\"] = \\\"hello, good morning!\\\"; cout << js << endl; } \",\"序列化输出Json字符串：\"]},\"1903\":{\"h\":\"利用 dump() 方法，将dict类型的数据转成str。\",\"t\":[\"void test1() { json js; js[\\\"msg_type\\\"] = 2; js[\\\"from\\\"] = \\\"zhangsan\\\"; js[\\\"to\\\"] = \\\"lisi\\\"; js[\\\"msg\\\"] = \\\"hello, good morning!\\\"; string sendBuf = js.dump();//Json数据对象 =》 Json字符串 cout << sendBuf.c_str() << endl; } \",\"输出**，可以在网络中进行**：\",\"在这里插入图片描述\"]},\"1904\":{\"h\":\"3.2 Json添加数组类型\",\"t\":[\"//2、Json添加数组类型 void test2() { json js; js[\\\"id\\\"] = {1, 2, 3, 4, 5} //添加数组 js[\\\"name\\\"] = \\\"zhangsan\\\"; //添加key-value js[\\\"msg\\\"][\\\"zhangsan\\\"] = \\\"good noon!\\\"; js[\\\"msg\\\"][\\\"lisi\\\"] = \\\"good night!\\\"; //添加Json对象,上面两句等同于此句一次性添加数组对象 js[\\\"msg\\\"] = {{\\\"zhangsan\\\", \\\"good noon!\\\"}, {\\\"lisi\\\", \\\"good night!\\\"}}; cout << js << endl; } \",\"在这里插入图片描述\",\"数组尽量使用vector可以动态地调整大小\"]},\"1905\":{\"h\":\"3.3 容器序列化：\",\"t\":[\"//3、容器序列化 void test3() { json js; //直接序列化一个vector容器 vector<int> vec; vec.push_pack(1); vec.push_pack(2); vec.push_pack(3); js[\\\"list\\\"] = vec; //直接序列化一个map容器 map<int, string> m; m.insert({1, \\\"黄山\\\"}); m.insert({2, \\\"华山\\\"}); m.insert({3, \\\"泰山\\\"}); js[\\\"local\\\"] = m; cout << js << endl; } \"]},\"1906\":{\"h\":\"四、 json::parse() 数据反序列化实例\",\"t\":[\"parse : 解析\",\"Json反序列化： 当我们从网络接收到字符串为Json格式时，可以用JSON for Modern C++ 直接反序列化取得数据或者直接反序列化出对象，甚至是容器。\"]},\"1907\":{\"h\":\"4.1 普通数据反序列化\",\"t\":[\"string test4() { json js; js[\\\"msg_type\\\"] = 2; js[\\\"form\\\"] = \\\"zhangsan\\\"; js[\\\"to\\\"] = \\\"lisi\\\"; js[\\\"msg\\\"] = \\\"good morning!\\\"; string sendBuf = js.dump() return sendBuf; } int main() { string recvBuf = test4(); //反序列化,Json字符串 => 数据对象 json jsBuf = json::parse(recvBuf); cout << jsbuf[\\\"msg_type\\\"] << endl; cout << jsbuf[\\\"from\\\"] << endl; cout << jsbuf[\\\"to\\\"] << endl; cout << jsbuf[\\\"msg\\\"] << endl; return 0; } \",\"反序列化输出结果如下，还保留了相应数据类型。\"]},\"1908\":{\"h\":\"4.2 数组类型数据反序列化：\",\"t\":[\"string test5() { json js; js[\\\"id\\\"] = { 1,2,3,4,5 }; js[\\\"name\\\"] = \\\"zhangsan\\\"; js[\\\"msg\\\"] = {{\\\"zhangsan\\\", \\\"good noon!\\\"}, {\\\"lisi\\\", \\\"good night!\\\"}}; return js.dump(); } int main() { string recvBuf = test5(); json jsBuf = json::parse(recvBuf); cout << jsBuf[\\\"id\\\"] << endl; auto jsMsg = jsBuf[\\\"msg\\\"]; cout << jsMsg[\\\"zhangsan\\\"] << endl; cout << jsMsg[\\\"lisi\\\"] << endl; return 0; } \"]},\"1909\":{\"h\":\"容器反序列化\",\"t\":[\"string test6() { vector<int> vec = {1, 2, 3}; json js; js[\\\"list\\\"] = vec; map<int, string> m = {{1, \\\"黄山\\\"}, {2, \\\"华山\\\"}, {3, \\\"泰山\\\"}}; js[\\\"local\\\"] = m; return js.dump(); } int main() { string recvBuf = test6(); json jsBuf = json::parse(recvBuf); //将js对象中数组类型直接放入vector容器中 vector<int> vec = jsBuf[\\\"list\\\"]; for(int v : vec) { cout << v << \\\" \\\"; } cout << endl; //将js对象中数组类型直接放入map容器中 map<int, string> mp = jsBuf[\\\"local\\\"]; for(auto it : mp) { cout << it.first << \\\" \\\" << it.second << endl; } cout << endl; return 0; } \"]},\"1910\":{\"c\":[\"network\"]},\"1911\":{\"c\":[\"数据序列化\"]},\"1912\":{\"h\":\"Protobuf简介及使用\"},\"1913\":{\"h\":\"一、Protobuf简介\",\"t\":[\"Protobuf(protocol buffer)：是google 的一种数据交换的格式，它独立于平台语言。 google 提供了protobuf多种语言的实现：java、c#、c++、go 和 python，每一种实现都包含了相应语言的编译器以及库文件。它是一种，网络传输时，而且它，比使用xml、json进行数据交换许多，用protobuf序列化后的大是json的10分之一，xml格式的20分之一，是二进制序列化的10分之一。 可以把它用于分布式应用之间的数据通信或者异构环境下的数据交换。作为一种效率和兼容性都很优秀的二进制数据传输格式，可以用于诸如网络传输、配置文件、数据存储等诸多领域。\"]},\"1914\":{\"h\":\"二、Protobuf语法\",\"t\":[\"使用protobuf前需要先进行安装\",\"ubuntu下protobuf安装使用（详解）_ubuntu protobuf-CSDN博客\",\"Centos 7安装protobuf3.6.1 - Boblim - 博客园 (cnblogs.com)\",\"1、对于普通单个成员变量，设置方法为set成员变量名()；读取值为实例化对象.成员变量名()； 2、对于一个消息类型里成员变量本身又是一个对象，利用mutable成员变量名()获取相应成员对象的指针，然后使用该指针修改成员数据。 3、对于列表类型，调用add_成员变量名()获取列表所管理的对象的指针，然后使用该指针修改成员数据。\"]},\"1915\":{\"h\":\"三、protobuf简单使用实例\",\"t\":[\"1、先创建xxx.proto文件，然后在xxx.proto配置文件定义好消息类型，消息类型存储的为简单类型。\",\"syntax = \\\"proto3\\\"; //声明了protobuf版本 package fixbug; //声明代码所在的包(类似于C++的namespace) //定义登录请求消息类型:name、pwd message LoginRequest { string name = 1; //表示name为LoginRequest类型的第一个字段 实际此处使用bytes更常见 string pwd = 2; //表示pwd为LoginRequest类型的第二个字段 } //定义登录响应消息类型:errcpde、errmsg、success message LoginResponse { int32 errcode = 1; //错误码 string errmsg = 2; //错误信息 bool success = 3; //是否登录成功 } \",\"2、执行protoc xxx.proto --cpp_out=OUT_DIR(指定的目录)，在当前目录下生成相应的.cc与.h文件。\",\"3、我们打开.cc与.h发现，实际上我们刚才的配置文件自动生成了对应的类代码。\",\"在这里插入图片描述\",\"4、我们在main.cc中测试一下，注意要链接protobuf动态库。 main.cc代码：\",\"#include \\\"test.pb.h\\\" #include <iostream> #include <string> using namespace fixbug; int main() { LoginRequest req; req.set_name(\\\"zhang san\\\"); req.set_pwd(\\\"123456\\\"); //数据序列化 => char*:调用SerializeToString方法 std::string send_str; if (req.SerializeToString(&send_str)) { std::cout << \\\"序列化后数据: \\\"<< send_str.c_str() << std::endl; } //反序列化数据 => login登录请求对象 LoginRequest reqB; if (reqB.LoginRequest::ParseFromString(send_str)) { std::cout << \\\"反序列化后数据: \\\" << req.name() << std::endl; std::cout << \\\"反序列化后数据: \\\" << req.pwd() << std::endl; } return 0; } \"]},\"1916\":{\"c\":[\"network\"]},\"1917\":{\"c\":[\"Protobuf简介及使用\"]},\"1918\":{\"h\":\"01 数组\"},\"1919\":{\"h\":\"堆\"},\"1920\":{\"h\":\"03 哈希算法\"},\"1921\":{\"h\":\"队\"},\"1922\":{\"h\":\"04 排序算法\"},\"1923\":{\"h\":\"栈\"},\"1924\":{\"h\":\"00 基础必备\"},\"1925\":{\"h\":\"01 C语言基础\"},\"1926\":{\"h\":\"04 模板\"},\"1927\":{\"h\":\"03 类和对象\"},\"1928\":{\"h\":\"02 C 基础\"},\"1929\":{\"h\":\"06 继承\"},\"1930\":{\"h\":\"05 运算符重载\"},\"1931\":{\"h\":\"02 链表\"},\"1932\":{\"h\":\"10 设计模式\"},\"1933\":{\"h\":\"07 多态\"},\"1934\":{\"h\":\"09 标准库 S T L\"},\"1935\":{\"h\":\"12 日志\"},\"1936\":{\"h\":\"11 资源管理\"},\"1937\":{\"h\":\"16 智能指针\"},\"1938\":{\"h\":\"14 面试题\"},\"1939\":{\"h\":\"19 S G I S T L二级空间配置器内存池源码\"},\"1940\":{\"h\":\"15 对象的优化\"},\"1941\":{\"h\":\"02 Vim\"},\"1942\":{\"h\":\"17 Bind绑定器和function函数对象\"},\"1943\":{\"h\":\"18 C 11知识汇总\"},\"1944\":{\"h\":\"01 工具和基本命令\"},\"1945\":{\"h\":\"04 文件操作\"},\"1946\":{\"h\":\"03 编译工具\"},\"1947\":{\"h\":\"01 My S Q L基础\"},\"1948\":{\"h\":\"02 My S Q L核心 S Q L\"},\"1949\":{\"h\":\"03 My S Q L存储引擎\"},\"1950\":{\"h\":\"04 M Y S Q L索引\"},\"1951\":{\"h\":\"05 My S Q L事务\"},\"1952\":{\"h\":\"06 My S Q L的锁机制\"},\"1953\":{\"h\":\"07 My S Q L优化\"},\"1954\":{\"h\":\"08 My S Q L日志\"},\"1955\":{\"h\":\"10 My S Q L集群\"},\"1956\":{\"h\":\"09 数据备份\"},\"1957\":{\"h\":\"12 连接池\"},\"1958\":{\"h\":\"11 拓展\"},\"1959\":{\"h\":\"序列化\"}},\"dirtCount\":0,\"index\":[[\"拓展\",{\"0\":{\"1958\":1}}],[\"博客园\",{\"1\":{\"1914\":1}}],[\"博客主页\",{\"0\":{\"1\":1}}],[\"详解\",{\"1\":{\"1914\":1}}],[\"详细模式\",{\"1\":{\"1334\":1}}],[\"详细请看wd\",{\"1\":{\"300\":1}}],[\"详细的数据结构如下\",{\"1\":{\"285\":1}}],[\"甚至是容器\",{\"1\":{\"1906\":1}}],[\"甚至无法分出一个size\",{\"1\":{\"1102\":1}}],[\"泰山\",{\"1\":{\"1905\":1,\"1909\":1}}],[\"华山\",{\"1\":{\"1905\":1,\"1909\":1}}],[\"华南师范大学\",{\"1\":{\"0\":1}}],[\"黄山\",{\"1\":{\"1905\":1,\"1909\":1}}],[\"黄色箭头就是直接等值查询搜索哈希表\",{\"1\":{\"1569\":1}}],[\"黄色\",{\"1\":{\"29\":1}}],[\"序列化\",{\"0\":{\"1959\":1}}],[\"序列化后数据\",{\"1\":{\"1915\":1}}],[\"序列化输出json字符串\",{\"1\":{\"1902\":1}}],[\"序里一大堆\",{\"1\":{\"628\":1}}],[\"像使用\",{\"1\":{\"1896\":1}}],[\"聊天消息\",{\"1\":{\"1896\":1}}],[\"聊天软件的业务\",{\"1\":{\"1896\":1}}],[\"易于人阅读和编写\",{\"1\":{\"1896\":1}}],[\"易泄露信息\",{\"1\":{\"1494\":1}}],[\"决定插入到哪张物理表\",{\"1\":{\"1892\":1}}],[\"决定的\",{\"1\":{\"651\":1}}],[\"硬件资源等的瓶颈\",{\"1\":{\"1890\":1}}],[\"硬链接\",{\"0\":{\"1267\":1},\"1\":{\"1271\":1}}],[\"突破io\",{\"1\":{\"1890\":1}}],[\"突破typora的iframe登录限制\",{\"0\":{\"58\":1}}],[\"突破typora的\",{\"0\":{\"55\":1}}],[\"水平分库分表能够有效的缓解单机和单库的性能瓶颈和压力\",{\"1\":{\"1890\":1}}],[\"水平分表\",{\"0\":{\"1890\":1}}],[\"水平方向上拆分当前窗口\",{\"1\":{\"1139\":1}}],[\"跨页\",{\"1\":{\"1889\":1}}],[\"垂直分表\",{\"0\":{\"1889\":1},\"1\":{\"1889\":1}}],[\"垂直分库\",{\"0\":{\"1888\":1}}],[\"垂直拆分\",{\"0\":{\"1887\":1}}],[\"拆分的规则是取模\",{\"1\":{\"1891\":1}}],[\"拆分成多张表\",{\"1\":{\"1886\":1}}],[\"拆分策略\",{\"1\":{\"1886\":1}}],[\"拆成一对一\",{\"1\":{\"1463\":1}}],[\"长时间不通信会断开\",{\"1\":{\"1881\":1}}],[\"长度较长\",{\"1\":{\"1889\":1}}],[\"长度\",{\"1\":{\"1407\":1}}],[\"长度运算符\",{\"1\":{\"728\":1}}],[\"长度最小的子数组\",{\"0\":{\"73\":1},\"1\":{\"73\":1}}],[\"获得字符串s中\",{\"1\":{\"1878\":2}}],[\"获取列表所管理的对象的指针\",{\"1\":{\"1914\":1}}],[\"获取相应成员对象的指针\",{\"1\":{\"1914\":1}}],[\"获取连接失败\",{\"1\":{\"1849\":1,\"1859\":1,\"1869\":1,\"1871\":1,\"1872\":1}}],[\"获取连接池对象实例\",{\"1\":{\"1848\":1,\"1859\":1,\"1875\":1}}],[\"获取空闲连接超时了\",{\"1\":{\"1849\":1,\"1859\":1,\"1869\":1,\"1871\":1,\"1872\":1}}],[\"获取binlog文件名和position\",{\"0\":{\"1822\":1}}],[\"获取的顺序不同而导致的死锁问题\",{\"1\":{\"1706\":1}}],[\"获取对应行记录的排他锁\",{\"1\":{\"1700\":1}}],[\"获取排它锁\",{\"1\":{\"1698\":1}}],[\"获取这张表的写锁\",{\"1\":{\"1671\":1}}],[\"获取这张表的读锁\",{\"1\":{\"1671\":1}}],[\"获取c++高级课程超过九十分的人数\",{\"1\":{\"1538\":2}}],[\"获取每一门课超过九十分的人数并排序\",{\"1\":{\"1538\":1}}],[\"获取每一门课超过九十分的人数\",{\"1\":{\"1538\":1}}],[\"获取每一门课考试人数\",{\"1\":{\"1538\":1}}],[\"获取记录条数以及属性个数\",{\"1\":{\"1385\":1}}],[\"获取结果集\",{\"1\":{\"1385\":1}}],[\"获取结果集中的行数\",{\"1\":{\"1378\":1}}],[\"获取结果集中有多少行\",{\"0\":{\"1378\":1}}],[\"获取错误信息\",{\"0\":{\"1382\":1}}],[\"获取8进制参数\",{\"1\":{\"1299\":1}}],[\"获取线程id\",{\"1\":{\"1207\":1}}],[\"获取src的数组长度\",{\"1\":{\"1127\":2}}],[\"获取到源代码后\",{\"1\":{\"1029\":1}}],[\"获取汽车剩余油量还能跑的公里数\",{\"1\":{\"900\":1}}],[\"获取了一辆奥迪汽车\",{\"1\":{\"862\":1,\"864\":1,\"867\":1}}],[\"获取了一辆宝马汽车\",{\"1\":{\"862\":1,\"864\":1,\"867\":1}}],[\"获取单实例\",{\"1\":{\"851\":1}}],[\"获取单实例对象\",{\"1\":{\"848\":1,\"850\":1}}],[\"获取链表中第\",{\"1\":{\"790\":1}}],[\"获取地址\",{\"1\":{\"614\":1}}],[\"获取异常信息\",{\"1\":{\"601\":1}}],[\"获取队头元素\",{\"1\":{\"406\":1}}],[\"获取\",{\"1\":{\"148\":1,\"1093\":1}}],[\"获取指定路径的绝对路径\",{\"1\":{\"60\":1}}],[\"获取指定路径的父目录\",{\"1\":{\"60\":1}}],[\"获取指定路径下的所有图片文件\",{\"1\":{\"60\":1}}],[\"获取指定路径下的所有文件\",{\"1\":{\"60\":1}}],[\"获取md文件中使用到的所有图片名称\",{\"1\":{\"60\":1}}],[\"热点数据\",{\"1\":{\"1864\":1}}],[\"热键标记\",{\"1\":{\"30\":1}}],[\"附加依赖项\",{\"1\":{\"1855\":1}}],[\"附加库目录\",{\"1\":{\"1855\":1}}],[\"附加包含目录\",{\"1\":{\"1855\":1}}],[\"刷新一下开始空闲的起始时间\",{\"1\":{\"1849\":2,\"1859\":2}}],[\"刷新一下连接的起始的空闲时间点\",{\"1\":{\"1846\":1,\"1859\":1}}],[\"刷新权限\",{\"1\":{\"1408\":1,\"1821\":1}}],[\"└─8341\",{\"1\":{\"1820\":1}}],[\"└──\",{\"1\":{\"1313\":3,\"1316\":5,\"1318\":2}}],[\"●\",{\"1\":{\"1820\":1}}],[\"停止防火墙\",{\"1\":{\"1818\":1}}],[\"停下\",{\"1\":{\"78\":1}}],[\"证明容灾没有问题\",{\"1\":{\"1814\":1}}],[\"证明可能是你的电脑cpu计算能力不行了\",{\"1\":{\"66\":1}}],[\"云后面是如何提供的库表的服务能力\",{\"1\":{\"1809\":1}}],[\"云和开放平台\",{\"1\":{\"0\":1}}],[\"少用\",{\"1\":{\"1803\":1}}],[\"少写代码\",{\"1\":{\"359\":1}}],[\"防火墙配置\",{\"1\":{\"1802\":1}}],[\"防止客户端不断\",{\"1\":{\"1745\":1}}],[\"防止其他事务在加了间隙锁的区间进行增加或删除数据\",{\"1\":{\"1688\":1}}],[\"防止其它事务在表的末尾增加数据\",{\"1\":{\"1686\":1}}],[\"防止事务回滚恢复修改前的状态\",{\"1\":{\"1681\":1}}],[\"防止脏读\",{\"1\":{\"1631\":1}}],[\"防止线程对数据缓存\",{\"1\":{\"1082\":1}}],[\"防止和枚举的名称重复\",{\"1\":{\"864\":1}}],[\"防止自己给自己赋值\",{\"1\":{\"735\":1}}],[\"防止自赋值\",{\"1\":{\"405\":1,\"406\":1}}],[\"防止了c中低级别的类型强转任意的转换指针的类型导致一些不确定的错误\",{\"1\":{\"630\":1}}],[\"防止该头文件被重复引用\",{\"1\":{\"577\":1}}],[\"防止野指针的出现\",{\"1\":{\"405\":1}}],[\"密码是否正确\",{\"1\":{\"1864\":1}}],[\"密码\",{\"1\":{\"1833\":1}}],[\"密码都是用来登录mycat的\",{\"1\":{\"1802\":1}}],[\"密码设置一直不符合要求\",{\"1\":{\"1407\":1}}],[\"密码设置问题error\",{\"0\":{\"1407\":1}}],[\"限制客户的连接等\",{\"1\":{\"1802\":1}}],[\"限定的函数或变量是extern类型的\",{\"1\":{\"577\":1}}],[\"挂了\",{\"1\":{\"1791\":1}}],[\"挂起\",{\"1\":{\"1219\":1}}],[\"体现出了\",{\"1\":{\"1780\":1}}],[\"备份文件的恢复\",{\"1\":{\"1774\":1}}],[\"备用内存池使用的干干净净\",{\"1\":{\"1105\":1}}],[\"备用内存中可用内存大小\",{\"1\":{\"1102\":1}}],[\"备用的内存池还可以继续分配\",{\"1\":{\"1102\":1}}],[\"演示binlog数据恢复\",{\"0\":{\"1774\":1}}],[\"演示binlog记录更改\",{\"0\":{\"1773\":1}}],[\"明文不安全\",{\"1\":{\"1772\":1}}],[\"明显\",{\"1\":{\"528\":2}}],[\"层四个日志\",{\"1\":{\"1767\":1,\"1768\":1,\"1769\":2,\"1770\":2,\"1771\":2,\"1772\":2,\"1773\":8,\"1774\":10,\"1775\":1,\"1776\":5}}],[\"永远是先写log\",{\"1\":{\"1763\":1}}],[\"永远让最后一个智能指针管理资源\",{\"1\":{\"1044\":1}}],[\"状态变成commit后需要维护事务的acid特性\",{\"1\":{\"1759\":1}}],[\"状态才变成commit\",{\"1\":{\"1759\":1}}],[\"状态则表示安装成功\",{\"1\":{\"1398\":1}}],[\"断电等问题\",{\"1\":{\"1759\":1}}],[\"断点续传\",{\"0\":{\"1252\":1}}],[\"断点单步调试\",{\"1\":{\"306\":1}}],[\"异步过程\",{\"1\":{\"1758\":1}}],[\"异常规范可以分为两类\",{\"1\":{\"607\":1}}],[\"异常规范\",{\"0\":{\"607\":1}}],[\"异常的父类\",{\"1\":{\"604\":1}}],[\"异常的处理流程\",{\"1\":{\"599\":1}}],[\"异常\",{\"1\":{\"601\":1,\"604\":1,\"605\":1,\"607\":1}}],[\"异常可以发生在当前的\",{\"1\":{\"600\":1}}],[\"异常发生位置\",{\"1\":{\"599\":1}}],[\"异常一旦抛出\",{\"1\":{\"599\":1}}],[\"异常类型\",{\"1\":{\"599\":1,\"601\":1}}],[\"异常机制来捕获上面的异常\",{\"1\":{\"599\":1}}],[\"异常出现之前\",{\"0\":{\"598\":1}}],[\"异常安全有时间再看\",{\"1\":{\"607\":1}}],[\"异常安全\",{\"0\":{\"597\":1}}],[\"往哪张表里增加\",{\"1\":{\"1891\":1}}],[\"往slave同步\",{\"1\":{\"1785\":1}}],[\"往磁盘上去刷新\",{\"1\":{\"1760\":1}}],[\"往磁盘上刷是有刷新的时机\",{\"1\":{\"1758\":1}}],[\"往往一个文件还没有下载完\",{\"1\":{\"1252\":1}}],[\"往往链表进行insert\",{\"1\":{\"970\":1}}],[\"往往还需要我们对它进行稍许的\",{\"1\":{\"509\":1}}],[\"验证容灾功能\",{\"0\":{\"1814\":1}}],[\"验证写操作在master\",{\"0\":{\"1813\":1}}],[\"验证读操作在slave\",{\"0\":{\"1812\":1}}],[\"验证读写分离\",{\"0\":{\"1810\":1}}],[\"验证\",{\"1\":{\"1754\":1}}],[\"服务器应用相当于mysql\",{\"1\":{\"1864\":1}}],[\"服务器在关闭非交互式连接之前等待活动的秒数\",{\"1\":{\"1754\":1}}],[\"服务器处理请求慢时\",{\"1\":{\"1569\":1}}],[\"七天以内的数据恢复由bin\",{\"1\":{\"1775\":1}}],[\"七\",{\"0\":{\"1740\":1}}],[\"六\",{\"0\":{\"1739\":1,\"1776\":1}}],[\"替代子查询\",{\"1\":{\"1738\":1}}],[\"替换\",{\"1\":{\"504\":1}}],[\"五\",{\"0\":{\"1738\":1,\"1772\":1,\"1810\":1}}],[\"逐条插入改为批量插入\",{\"0\":{\"1733\":1}}],[\"导入数据\",{\"1\":{\"1836\":1}}],[\"导入结束后再执行\",{\"1\":{\"1731\":1}}],[\"导出纯数据\",{\"1\":{\"1836\":1}}],[\"导出多个库\",{\"1\":{\"1836\":1}}],[\"导出school库下的stu表\",{\"1\":{\"1836\":1}}],[\"导出school库\",{\"1\":{\"1836\":1}}],[\"导出所有的库\",{\"1\":{\"1836\":1}}],[\"导出建库建表的sql\",{\"1\":{\"1836\":1}}],[\"导致查询超时\",{\"1\":{\"1886\":1}}],[\"导致在写redo\",{\"1\":{\"1759\":1}}],[\"导致索引没用上\",{\"1\":{\"1744\":1}}],[\"导致没用到索引\",{\"1\":{\"1744\":1}}],[\"导致sql执行异常\",{\"1\":{\"1650\":1}}],[\"导致当前线程占用的锁无法释放\",{\"1\":{\"1636\":1}}],[\"导致业务超时出错\",{\"1\":{\"1609\":1}}],[\"导致\",{\"1\":{\"1040\":1}}],[\"导致工厂类太多了\",{\"1\":{\"867\":1}}],[\"导致编译器不会去外面找别的compare定义\",{\"1\":{\"563\":1}}],[\"导致程序异常或崩溃\",{\"1\":{\"531\":1}}],[\"导致程序运行异常或崩溃\",{\"1\":{\"531\":1}}],[\"导致内存资源泄漏\",{\"1\":{\"1040\":1}}],[\"导致内存占用不断增加\",{\"1\":{\"531\":1}}],[\"导致内存泄漏\",{\"1\":{\"523\":1}}],[\"导致数据覆盖或程序崩溃\",{\"1\":{\"531\":1}}],[\"导致else分支没有对应的if\",{\"1\":{\"273\":1}}],[\"恢复备份文件\",{\"1\":{\"1775\":1}}],[\"恢复唯一性校验\",{\"1\":{\"1730\":1}}],[\"恢复链表\",{\"1\":{\"756\":1}}],[\"型的\",{\"1\":{\"1719\":10}}],[\"图中并列的writehost标签表示备份的写库\",{\"1\":{\"1803\":1}}],[\"图中黄色框中是配置了一个一主一从\",{\"1\":{\"1803\":1}}],[\"图中的mysql主服务器专门做写操作\",{\"1\":{\"1790\":1}}],[\"图中的地方都上了\",{\"1\":{\"1688\":1}}],[\"图中\",{\"1\":{\"1719\":1}}],[\"任由这些线程并发操作数据库\",{\"1\":{\"1712\":1}}],[\"任何业务场景下都必须杜绝\",{\"1\":{\"1639\":1}}],[\"任何非零值都将转换为true\",{\"1\":{\"473\":1}}],[\"任何数字或指针值都可以隐式转换为bool值\",{\"1\":{\"473\":1}}],[\"任何该类对象都可对其进行访问\",{\"1\":{\"435\":1}}],[\"任何的编程语言都会产生两种东西\",{\"1\":{\"267\":1}}],[\"奇怪的是\",{\"1\":{\"1693\":1}}],[\"辅助索引树加锁区间如下\",{\"1\":{\"1689\":1}}],[\"场景3\",{\"0\":{\"1690\":1}}],[\"场景2\",{\"0\":{\"1689\":1}}],[\"场景1\",{\"0\":{\"1688\":1}}],[\"∞\",{\"1\":{\"1688\":1,\"1719\":1}}],[\"∪\",{\"1\":{\"1688\":3}}],[\"间隙锁是给不存在的数据记录的范围加锁\",{\"1\":{\"1694\":1}}],[\"间隙锁的范围\",{\"1\":{\"1689\":1}}],[\"间隙锁\",{\"1\":{\"1686\":1}}],[\"间隙锁专用于串行化隔离级别\",{\"1\":{\"1686\":1}}],[\"间隙锁概念\",{\"0\":{\"1686\":1}}],[\"间隙\",{\"1\":{\"1686\":3}}],[\"间接基类d有多份ma属性\",{\"1\":{\"688\":1}}],[\"间接寻址\",{\"1\":{\"614\":1}}],[\"间接修改常量值\",{\"1\":{\"485\":1}}],[\"吕颂贤\",{\"1\":{\"1681\":1}}],[\"笑傲江湖\",{\"1\":{\"1681\":2}}],[\"协调表锁和行锁的共存关系\",{\"1\":{\"1673\":1}}],[\"活跃事务\",{\"1\":{\"1656\":3}}],[\"核心逻辑就是判断版本链中的哪个版本是当前事务可见可处理的\",{\"1\":{\"1656\":1}}],[\"核心是用new与delete运算符重载接管整个应用的内存管理\",{\"1\":{\"716\":1}}],[\"阻塞了\",{\"1\":{\"1699\":1}}],[\"阻塞其他操作事务修改记录\",{\"1\":{\"1656\":1}}],[\"阻塞状态变为运行状态\",{\"1\":{\"1221\":1}}],[\"部分解决了幻读\",{\"1\":{\"1677\":1}}],[\"部分失败的结果\",{\"1\":{\"1649\":1}}],[\"部分的两个构造函数中的\",{\"1\":{\"422\":1}}],[\"业务都成功\",{\"1\":{\"1652\":1}}],[\"业务上不可能让用户去等那么长时间\",{\"1\":{\"1645\":1}}],[\"业务可以接受的慢查询时间上限long\",{\"0\":{\"1578\":1}}],[\"业务可以接受的慢查询时间上限\",{\"1\":{\"1573\":1}}],[\"持久打开\",{\"1\":{\"1818\":1}}],[\"持久性是通过\",{\"1\":{\"1645\":1}}],[\"持久性\",{\"1\":{\"1644\":1,\"1757\":1}}],[\"持续列出网络状态\",{\"1\":{\"1237\":1}}],[\"隔离越严格\",{\"1\":{\"1644\":1}}],[\"隔离性是通过\",{\"1\":{\"1645\":1}}],[\"隔离性\",{\"1\":{\"1644\":1,\"1757\":1}}],[\"隔离级别\",{\"0\":{\"1633\":1},\"1\":{\"1644\":1,\"1881\":1}}],[\"隔离级别概念\",{\"0\":{\"1631\":1}}],[\"余额为100\",{\"1\":{\"1639\":1}}],[\"幻读就是同一事务两次用相同的条件查询数据\",{\"1\":{\"1689\":1}}],[\"幻读就肯定可以发生了\",{\"1\":{\"1634\":1}}],[\"幻读问题表现为\",{\"1\":{\"1686\":1}}],[\"幻读解决原理\",{\"0\":{\"1685\":1}}],[\"幻读也是在某些业务场景下是可以允许的\",{\"1\":{\"1639\":1}}],[\"幻读举例\",{\"1\":{\"1639\":1}}],[\"幻读\",{\"1\":{\"1639\":1,\"1665\":3,\"1693\":1,\"1712\":1}}],[\"脏读和不可重复读解决原理\",{\"0\":{\"1655\":1},\"1\":{\"1656\":1,\"1658\":2,\"1660\":1,\"1663\":2,\"1664\":2,\"1665\":5}}],[\"脏读举例\",{\"1\":{\"1639\":1}}],[\"脏读必须杜绝\",{\"1\":{\"1639\":1}}],[\"脏读\",{\"0\":{\"1639\":1},\"1\":{\"1633\":1,\"1639\":1,\"1665\":1}}],[\"串行执行\",{\"1\":{\"1631\":1}}],[\"串行化隔离级别测试\",{\"0\":{\"1701\":1}}],[\"串行化隔离级别通过和解决\",{\"1\":{\"1694\":1}}],[\"串行化隔离级别通过给select的部分加间隙锁\",{\"1\":{\"1688\":1}}],[\"串行化\",{\"1\":{\"1631\":1,\"1665\":1}}],[\"事件\",{\"1\":{\"1772\":1}}],[\"事务日志\",{\"1\":{\"1881\":1}}],[\"事务日志分为undo\",{\"1\":{\"1677\":1}}],[\"事务成功commit\",{\"1\":{\"1763\":1}}],[\"事务进行操作的时候\",{\"1\":{\"1763\":1}}],[\"事务可能修改的数据量比较大\",{\"1\":{\"1760\":1}}],[\"事务读取\",{\"1\":{\"1758\":1}}],[\"事务还没有commit\",{\"1\":{\"1757\":1}}],[\"事务越大\",{\"1\":{\"1724\":1}}],[\"事务在执行\",{\"1\":{\"1718\":1}}],[\"事务在给一行记录加排他锁前\",{\"1\":{\"1673\":1}}],[\"事务在给一行记录加共享锁前\",{\"1\":{\"1673\":1}}],[\"事务并发情况下两次查询的数据量不同\",{\"1\":{\"1686\":1}}],[\"事务并发存在的问题\",{\"0\":{\"1639\":1}}],[\"事务id\",{\"1\":{\"1681\":1}}],[\"事务发生错误时回滚rollback\",{\"1\":{\"1680\":1}}],[\"事务提交或者回滚\",{\"1\":{\"1671\":1}}],[\"事务涉及多个表\",{\"1\":{\"1670\":1}}],[\"事务需要更新大部分或全部数据\",{\"1\":{\"1670\":1}}],[\"事务1再次获取id=8的排他锁\",{\"1\":{\"1708\":1}}],[\"事务1获取id=7的排他锁\",{\"1\":{\"1708\":1}}],[\"事务1无法获取行锁2\",{\"1\":{\"1707\":1}}],[\"事务1成功获取行锁1\",{\"1\":{\"1707\":1}}],[\"事务1用表的无索引字段age作为过滤条件\",{\"1\":{\"1700\":1}}],[\"事务1插入age=21\",{\"1\":{\"1693\":1}}],[\"事务1插入一个新的数据\",{\"1\":{\"1692\":1}}],[\"事务1插入的age=18和age=19都不在事务2上锁的范围\",{\"1\":{\"1689\":1}}],[\"事务1现在插入新的数据是可以成功的\",{\"1\":{\"1692\":1}}],[\"事务1\",{\"1\":{\"1665\":2}}],[\"事务第一次select就产生数据快照\",{\"1\":{\"1662\":1}}],[\"事务2获取id=8的排他锁\",{\"1\":{\"1708\":1}}],[\"事务2无法获取行锁1\",{\"1\":{\"1707\":1}}],[\"事务2成功获取行锁2\",{\"1\":{\"1707\":1}}],[\"事务2可以获取共享锁\",{\"1\":{\"1701\":1}}],[\"事务2在辅助索引树上找zhangsan\",{\"1\":{\"1701\":1}}],[\"事务2插入数据\",{\"1\":{\"1701\":1}}],[\"事务2现在同样想获取这条记录的排它锁\",{\"1\":{\"1700\":1}}],[\"事务2等值查询\",{\"1\":{\"1693\":1}}],[\"事务2进行等值查询时\",{\"1\":{\"1692\":1}}],[\"事务2再次获取id=7的排他锁\",{\"1\":{\"1708\":1}}],[\"事务2再次select依然是两条\",{\"1\":{\"1665\":1}}],[\"事务2再用age>20查询\",{\"1\":{\"1689\":1}}],[\"事务2的select操作只给三行数据加了共享锁\",{\"1\":{\"1688\":1}}],[\"事务2第一次select是两条数据\",{\"1\":{\"1665\":1}}],[\"事务2第二次select的时候\",{\"1\":{\"1658\":1}}],[\"事务2\",{\"1\":{\"1663\":1}}],[\"事务2又去select\",{\"1\":{\"1658\":1}}],[\"事务手动提交\",{\"1\":{\"1652\":1}}],[\"事务执行commit命令后\",{\"1\":{\"1763\":1}}],[\"事务执行\",{\"1\":{\"1671\":1}}],[\"事务执行过程中看到的数据\",{\"1\":{\"1717\":1}}],[\"事务执行过程中\",{\"1\":{\"1649\":1}}],[\"事务执行之前和执行之后\",{\"1\":{\"1644\":1}}],[\"事务是一组sql语句的执行\",{\"1\":{\"1649\":1}}],[\"事务是一个不可分割的整体\",{\"1\":{\"1644\":1}}],[\"事务要么全部执行成功\",{\"1\":{\"1649\":1}}],[\"事务隔离机制的选择\",{\"0\":{\"1712\":1}}],[\"事务隔离级别的实现原理\",{\"1\":{\"1711\":1}}],[\"事务隔离级别越高\",{\"1\":{\"1631\":1,\"1677\":1}}],[\"事务隔离性越好\",{\"1\":{\"1645\":1}}],[\"事务commit成功或者rollback成功\",{\"1\":{\"1761\":1}}],[\"事务commit成功\",{\"1\":{\"1644\":1,\"1757\":1}}],[\"事务完成\",{\"1\":{\"1644\":1}}],[\"事务必须具有原子特性\",{\"1\":{\"1644\":1}}],[\"事务的所有sql语句全部执行成功\",{\"1\":{\"1649\":1}}],[\"事务的概念\",{\"0\":{\"1648\":1}}],[\"事务的i特性由事务的锁机制来保证\",{\"1\":{\"1645\":1}}],[\"事务的acd特性由redo\",{\"1\":{\"1645\":1}}],[\"事务的acid特性\",{\"0\":{\"1643\":1}}],[\"事务的隔离级别就是对事务并发的控制\",{\"1\":{\"1631\":1}}],[\"事务只回滚到保存点point1\",{\"1\":{\"1640\":1}}],[\"事务相关命令\",{\"0\":{\"1640\":1}}],[\"事务a插入或删除了年龄为20的记录\",{\"1\":{\"1639\":1}}],[\"事务a完成转账50\",{\"1\":{\"1639\":1}}],[\"事务a现对张三的余额减50\",{\"1\":{\"1639\":1}}],[\"事务a转账50\",{\"1\":{\"1639\":1}}],[\"事务a或者了一条满足事务b查询条件的记录\",{\"1\":{\"1639\":1}}],[\"事务a\",{\"1\":{\"1639\":1}}],[\"事务a已经插入并且提交了\",{\"1\":{\"1635\":1}}],[\"事务b再次查询年龄为20的人\",{\"1\":{\"1639\":1}}],[\"事务b再次查询余额\",{\"1\":{\"1639\":1}}],[\"事务b查询年龄为20的人\",{\"1\":{\"1639\":1}}],[\"事务b查询读取到a尚未提交的数据\",{\"1\":{\"1639\":1}}],[\"事务b购买水杯前先读取余额\",{\"1\":{\"1639\":1}}],[\"事务b购买价格为80的水杯\",{\"1\":{\"1639\":1}}],[\"事务b读取了事务a新增加的数据或者读到事务a删除的数据\",{\"1\":{\"1639\":1}}],[\"事务b读取了事务a已commit的数据\",{\"1\":{\"1639\":1}}],[\"事务b并没有发生脏读\",{\"1\":{\"1634\":1}}],[\"事务处理如果\",{\"1\":{\"1639\":1}}],[\"事务\",{\"0\":{\"1719\":1,\"1720\":1},\"1\":{\"1649\":1},\"2\":{\"1638\":1,\"1642\":1,\"1647\":1,\"1654\":1}}],[\"事实上\",{\"1\":{\"432\":1}}],[\"事实是这样的\",{\"1\":{\"283\":1}}],[\"叶子节点被串在一个链表当中\",{\"1\":{\"1626\":1}}],[\"叶子节点上存储了所有的索引值以及对应的data\",{\"1\":{\"1626\":1}}],[\"叶子节点都在同一层\",{\"1\":{\"1623\":1}}],[\"离根节点远的数据\",{\"1\":{\"1627\":1}}],[\"离根节点远\",{\"1\":{\"1626\":1}}],[\"离根节点近\",{\"1\":{\"1626\":1}}],[\"树上如果做区间查找\",{\"1\":{\"1627\":1}}],[\"树由于每个节点都存储关键字和数据\",{\"1\":{\"1627\":1}}],[\"树\",{\"1\":{\"1627\":1}}],[\"树的\",{\"1\":{\"1627\":1}}],[\"树的每一个节点\",{\"1\":{\"1627\":1}}],[\"树的节点大小一般设置为和磁盘块大小一致\",{\"1\":{\"1623\":1}}],[\"树的层数是非常低的\",{\"1\":{\"1623\":1}}],[\"树的层数=log2n=log10n\",{\"1\":{\"1622\":1}}],[\"树存储索引的时候\",{\"1\":{\"1623\":1}}],[\"树节点\",{\"1\":{\"1623\":1}}],[\"树是一种m阶平衡树\",{\"1\":{\"1623\":1}}],[\"树和哈希表在数据查询时的效率是非常高的\",{\"1\":{\"1623\":1}}],[\"树索引\",{\"1\":{\"1623\":1}}],[\"缓存会清空\",{\"1\":{\"1881\":1}}],[\"缓存的大小\",{\"1\":{\"1748\":1}}],[\"缓存\",{\"0\":{\"1759\":1},\"1\":{\"1622\":1}}],[\"矮胖\",{\"1\":{\"1621\":1}}],[\"越\",{\"1\":{\"1621\":1}}],[\"ﬁlesort\",{\"1\":{\"1618\":1}}],[\"ﬁxbug\",{\"1\":{\"1523\":1}}],[\"花费的\",{\"1\":{\"1626\":1}}],[\"花费的时间就是很长\",{\"1\":{\"1573\":1,\"1776\":1}}],[\"花费磁盘io\",{\"1\":{\"1617\":1}}],[\"尽可能以固定的顺序存取表中的行\",{\"1\":{\"1724\":1}}],[\"尽量用访问数据\",{\"1\":{\"1724\":1}}],[\"尽量使用较低的隔离级别\",{\"1\":{\"1724\":1}}],[\"尽量规定索引的长度\",{\"1\":{\"1615\":1}}],[\"尽管事务执行了commit命令\",{\"1\":{\"1763\":1}}],[\"尽管数据页可能还在buffer\",{\"1\":{\"1762\":1}}],[\"尽管c++支持c风格字符串\",{\"1\":{\"536\":1}}],[\"尽管null在c++编译器下就是0\",{\"1\":{\"527\":1}}],[\"尽管在大多数教科书中内联函数的声明\",{\"1\":{\"504\":1}}],[\"经常作为where条件过滤的字段考虑添加索引\",{\"1\":{\"1615\":1}}],[\"经过函数计算之后就成为了另外的值\",{\"1\":{\"1593\":1}}],[\"经过编译后\",{\"1\":{\"310\":1}}],[\"经过⼀次变化之后的最⼤值\",{\"1\":{\"147\":1}}],[\"评论字符串搜索\",{\"1\":{\"1610\":1}}],[\"聚集索引\",{\"1\":{\"1610\":1}}],[\"聚合查询\",{\"0\":{\"1502\":1}}],[\"聚合函数\",{\"0\":{\"1444\":1}}],[\"物理\",{\"1\":{\"1610\":1}}],[\"物理内存和虚拟内存映射🍗🍗🍗\",{\"0\":{\"263\":1}}],[\"过程中加了什么锁\",{\"1\":{\"1719\":1,\"1720\":1}}],[\"过多的磁盘i\",{\"1\":{\"1609\":1}}],[\"过多的索引会\",{\"1\":{\"1609\":1}}],[\"过滤条件全写在where后\",{\"1\":{\"1544\":1}}],[\"过滤条件写在where的后面和on连接条件里面\",{\"1\":{\"1541\":1}}],[\"过滤右表数据\",{\"1\":{\"1500\":3,\"1501\":1}}],[\"过滤左表数据\",{\"1\":{\"1500\":3,\"1501\":1}}],[\"过滤数据\",{\"1\":{\"1491\":1}}],[\"过滤器\",{\"1\":{\"1031\":3}}],[\"降低了sql的查询效率\",{\"1\":{\"1609\":1}}],[\"降序排序查询\",{\"1\":{\"1496\":1}}],[\"究竟用不用\",{\"1\":{\"1594\":1}}],[\"究竟把运算符重载作为类的成员函数好\",{\"0\":{\"730\":1}}],[\"搜狗的workﬂow\",{\"1\":{\"1610\":1}}],[\"搜的非常快\",{\"1\":{\"1590\":1}}],[\"搜索效率比较高\",{\"1\":{\"1626\":1}}],[\"搜索每一个索引对应的值data\",{\"1\":{\"1626\":1}}],[\"搜索就慢\",{\"1\":{\"1626\":1}}],[\"搜索就快\",{\"1\":{\"1626\":1}}],[\"搜索的效率会更好一些\",{\"1\":{\"1626\":1}}],[\"搜索的效率要高\",{\"1\":{\"1602\":1}}],[\"搜索的时间复杂度\",{\"1\":{\"100\":1}}],[\"搜索与查找\",{\"0\":{\"546\":1}}],[\"搜索high\",{\"1\":{\"38\":1}}],[\"影响效率\",{\"1\":{\"1588\":1}}],[\"耗费网络以及服务器资源\",{\"1\":{\"1745\":1}}],[\"耗费的排序性能差的越大\",{\"1\":{\"1586\":1}}],[\"耗时0\",{\"1\":{\"1740\":1}}],[\"耗时1\",{\"1\":{\"1740\":1}}],[\"耗时2\",{\"1\":{\"1740\":1}}],[\"耗性能的sql\",{\"1\":{\"1572\":1}}],[\"展示sql语句精细的耗时时间\",{\"1\":{\"1582\":1}}],[\"展开后如下\",{\"1\":{\"274\":1}}],[\"展开的时候不会出错\",{\"0\":{\"272\":1}}],[\"秒\",{\"1\":{\"1574\":1,\"1776\":1}}],[\"慢查询日志\",{\"0\":{\"1776\":1},\"1\":{\"1767\":1,\"1776\":1}}],[\"慢查询日志实践\",{\"0\":{\"1575\":1}}],[\"慢查询日志记录了包含所有执行时间超过参数\",{\"1\":{\"1574\":1,\"1776\":1}}],[\"慢查询日志的路径\",{\"1\":{\"1574\":1}}],[\"慢查询日志开关默认是关闭的\",{\"1\":{\"1574\":1}}],[\"慢查询日志相关的参数如下所示\",{\"1\":{\"1776\":1}}],[\"慢查询日志相关的参数\",{\"0\":{\"1574\":1}}],[\"慢查询使用方法\",{\"0\":{\"1573\":1}}],[\"慢指针走一步\",{\"1\":{\"765\":1,\"768\":1}}],[\"蓝色的箭头表搜索二级索引树然后回表的过程\",{\"1\":{\"1569\":1}}],[\"蓝色blue\",{\"1\":{\"29\":1}}],[\"置末\",{\"1\":{\"1552\":1}}],[\"置空\",{\"1\":{\"751\":1}}],[\"旧字段名\",{\"1\":{\"1552\":1}}],[\"旧的数据\",{\"1\":{\"1492\":1}}],[\"练习\",{\"0\":{\"1538\":1,\"1566\":1}}],[\"练习题\",{\"0\":{\"1531\":1}}],[\"索引和数据都是存储在磁盘上\",{\"1\":{\"1864\":1}}],[\"索引和数据缓存\",{\"0\":{\"1752\":1}}],[\"索引+数据内容\",{\"1\":{\"1626\":1}}],[\"索引底层选择b+树而不是b树呢\",{\"0\":{\"1626\":1}}],[\"索引整个b\",{\"1\":{\"1623\":1}}],[\"索引都是存放在磁盘上\",{\"1\":{\"1622\":1}}],[\"索引树越低\",{\"1\":{\"1621\":1}}],[\"索引全表扫描\",{\"1\":{\"1618\":1}}],[\"索引范围扫描\",{\"1\":{\"1618\":1}}],[\"索引就用不上了\",{\"1\":{\"1615\":1}}],[\"索引名\",{\"1\":{\"1614\":2}}],[\"索引看\",{\"1\":{\"1610\":1}}],[\"索引太少\",{\"1\":{\"1609\":1}}],[\"索引不是越多越好\",{\"1\":{\"1609\":1}}],[\"索引的底层实现原理\",{\"0\":{\"1621\":1}}],[\"索引的好处是\",{\"1\":{\"1617\":1}}],[\"索引的好处和坏处\",{\"0\":{\"1609\":1}}],[\"索引的执行过程\",{\"0\":{\"1617\":1}}],[\"索引的优化\",{\"0\":{\"1615\":1}}],[\"索引的创建和删除\",{\"0\":{\"1614\":1}}],[\"索引的使用和分析\",{\"0\":{\"1613\":1}}],[\"索引的分类\",{\"0\":{\"1610\":1}}],[\"索引的核心\",{\"1\":{\"1608\":1}}],[\"索引\",{\"1\":{\"1608\":1,\"1626\":1,\"1720\":1}}],[\"索引是什么\",{\"0\":{\"1608\":1}}],[\"索引是否用到和select没有关系\",{\"1\":{\"1537\":1}}],[\"索引基础\",{\"0\":{\"1607\":1}}],[\"索引字段涉及类型强转\",{\"1\":{\"1615\":1}}],[\"索引字段涉及等\",{\"1\":{\"1593\":1}}],[\"索引字段涉及\",{\"0\":{\"1593\":1}}],[\"索引等数据库对象的定义\",{\"1\":{\"1548\":1}}],[\"索引查询是const常量级的时间\",{\"1\":{\"1521\":1}}],[\"别\",{\"1\":{\"1663\":1}}],[\"别名as\",{\"1\":{\"1537\":1}}],[\"别忘了第六步s的析构\",{\"1\":{\"1066\":1}}],[\"月\",{\"1\":{\"1537\":1}}],[\"月份左右趁着其妻子探亲的时间\",{\"1\":{\"301\":1}}],[\"考试结果\",{\"1\":{\"1537\":1}}],[\"考虑连等情况\",{\"1\":{\"467\":1}}],[\"考虑每一圈的四条边按左闭右开进行处理\",{\"1\":{\"81\":1}}],[\"概述\",{\"0\":{\"1536\":1,\"1862\":1}}],[\"缴费网点\",{\"1\":{\"1531\":1}}],[\"金额\",{\"1\":{\"1531\":1}}],[\"金融行业使用的db2\",{\"1\":{\"1452\":1}}],[\"账号密码等\",{\"1\":{\"1881\":1}}],[\"账号\",{\"1\":{\"1531\":1,\"1833\":1}}],[\"流量越来越大\",{\"1\":{\"1790\":1}}],[\"流水号\",{\"1\":{\"1531\":1}}],[\"流程分析\",{\"0\":{\"1221\":1}}],[\"赋初值也可以这样写declare\",{\"1\":{\"1523\":1}}],[\"赋值的变量被称为直接展开变量\",{\"1\":{\"1357\":1}}],[\"赋值的变量被称为递归展开变量\",{\"1\":{\"1357\":1}}],[\"赋值是两个对象都存在\",{\"1\":{\"1115\":1}}],[\"赋值给t4\",{\"1\":{\"1112\":1}}],[\"赋值操作\",{\"1\":{\"463\":1}}],[\"赋值运算是一种很常见的运算\",{\"1\":{\"463\":1}}],[\"赋值运算符函数的返回类型可以是void\",{\"0\":{\"467\":1}}],[\"赋值运算符函数\",{\"0\":{\"462\":1},\"1\":{\"463\":1,\"468\":1,\"469\":1}}],[\"赋值运算符重载\",{\"1\":{\"355\":1,\"385\":1,\"704\":1}}],[\"赋值\",{\"1\":{\"433\":1,\"497\":1,\"515\":1}}],[\"赋值函数\",{\"1\":{\"406\":1}}],[\"赋值重载函数\",{\"1\":{\"405\":1,\"1114\":1}}],[\"扫描整个队列\",{\"1\":{\"1849\":1,\"1859\":1}}],[\"扫描超过maxidletime时间的空闲连接\",{\"1\":{\"1848\":1,\"1849\":2,\"1859\":3}}],[\"扫地多效率就低\",{\"1\":{\"1519\":1}}],[\"扫的少效率就高\",{\"1\":{\"1519\":1}}],[\"项目背景\",{\"0\":{\"1864\":1}}],[\"项目中如果遇到并发量很大\",{\"1\":{\"1569\":1}}],[\"项目中很少使用select\",{\"1\":{\"1511\":1}}],[\"项目一般只有几个或十几个人可以不用连接池\",{\"1\":{\"1476\":1}}],[\"删\",{\"1\":{\"1719\":1,\"1721\":1}}],[\"删drop\",{\"1\":{\"1552\":1}}],[\"删dorp\",{\"1\":{\"1507\":1}}],[\"删delete\",{\"0\":{\"1491\":1}}],[\"删除mytest库\",{\"1\":{\"1785\":1}}],[\"删除索引\",{\"1\":{\"1614\":1}}],[\"删除email字段\",{\"1\":{\"1552\":1}}],[\"删除字段\",{\"1\":{\"1552\":1}}],[\"删除一个表\",{\"1\":{\"1552\":1}}],[\"删除一个数据库\",{\"1\":{\"1507\":1}}],[\"删除表\",{\"1\":{\"1551\":1}}],[\"删除表中所有数据\",{\"1\":{\"1491\":1}}],[\"删除数据库\",{\"1\":{\"1485\":1,\"1486\":1}}],[\"删除权限\",{\"1\":{\"1485\":1,\"1486\":1}}],[\"删除用户\",{\"1\":{\"1447\":1}}],[\"删除的程序\",{\"0\":{\"1384\":1}}],[\"删除的图片名为\",{\"1\":{\"60\":1}}],[\"删除断点\",{\"1\":{\"1340\":1}}],[\"删除旧的软链接\",{\"1\":{\"1332\":1}}],[\"删除多行\",{\"1\":{\"1142\":1}}],[\"删除it迭代器指向的元素\",{\"1\":{\"965\":1}}],[\"删除链表的倒数第\",{\"0\":{\"774\":1},\"1\":{\"774\":2}}],[\"删除结点后记得释放结点\",{\"1\":{\"759\":1}}],[\"删除所有值为val的节点\",{\"1\":{\"759\":1}}],[\"删除成功\",{\"1\":{\"747\":1}}],[\"删除当前迭代器节点\",{\"1\":{\"747\":1}}],[\"删除点的迭代器进行更新操作\",{\"1\":{\"744\":1}}],[\"删除\",{\"0\":{\"742\":1},\"1\":{\"965\":1,\"969\":1,\"970\":1,\"999\":1,\"1000\":1,\"1356\":1,\"1459\":1,\"1548\":1,\"1622\":1}}],[\"删除时\",{\"1\":{\"520\":1}}],[\"删除元素需要进行大量的数据移动o\",{\"1\":{\"100\":1}}],[\"删除元素时间复杂度是o\",{\"1\":{\"100\":1}}],[\"删除指定文件\",{\"1\":{\"60\":1}}],[\"删除锚点记录\",{\"1\":{\"59\":1}}],[\"删除锚点\",{\"1\":{\"59\":1}}],[\"删除线和顶划线\",{\"1\":{\"50\":1}}],[\"增删改查代码实现\",{\"1\":{\"1866\":1}}],[\"增删改查的时间复杂度都是\",{\"1\":{\"1601\":1}}],[\"增大了锁冲突的概率\",{\"1\":{\"1724\":1}}],[\"增create\",{\"1\":{\"1507\":1,\"1552\":1}}],[\"增insert\",{\"0\":{\"1490\":1}}],[\"增加一个master是不能解决问题的\",{\"1\":{\"1885\":1}}],[\"增加连接池\",{\"1\":{\"1864\":1}}],[\"增加了其它字段\",{\"1\":{\"1656\":1}}],[\"增加资源的引用计数\",{\"1\":{\"1055\":1}}],[\"增加\",{\"0\":{\"1384\":1},\"1\":{\"965\":1,\"969\":1,\"970\":1,\"999\":1,\"1622\":1}}],[\"增加新的子类不影响已存在类的多态性\",{\"1\":{\"882\":1}}],[\"增加类的功能\",{\"1\":{\"831\":1}}],[\"增加快捷键修改颜色功能\",{\"0\":{\"47\":1}}],[\"操纵数据\",{\"1\":{\"1489\":1}}],[\"操作的坑以及传参\",{\"1\":{\"1859\":1}}],[\"操作的原子特性就足够了\",{\"1\":{\"1232\":1}}],[\"操作效率高\",{\"1\":{\"1736\":1}}],[\"操作哈希表是只有一把锁的\",{\"1\":{\"1569\":1}}],[\"操作名\",{\"1\":{\"1497\":1}}],[\"操作代码\",{\"1\":{\"1172\":1}}],[\"操作引用与操作变量本身是一样的\",{\"1\":{\"618\":1}}],[\"操作符和vector\",{\"1\":{\"354\":1}}],[\"操作系统内核kernel花费磁盘io\",{\"1\":{\"1626\":1}}],[\"操作系统保存程序执行时的内存映像的文件\",{\"1\":{\"1338\":1}}],[\"操作系统的原型\",{\"1\":{\"301\":1}}],[\"操作系统中有一个记录空闲内存地址的链表\",{\"1\":{\"282\":1}}],[\"操作系统\",{\"1\":{\"301\":2},\"2\":{\"242\":1,\"266\":1,\"269\":1}}],[\"操作\",{\"0\":{\"1708\":1},\"1\":{\"182\":1,\"970\":1}}],[\"操作是合法的\",{\"1\":{\"182\":1}}],[\"操作完\",{\"1\":{\"101\":1}}],[\"操作也很简单\",{\"1\":{\"6\":1}}],[\"权限验证\",{\"1\":{\"1881\":1}}],[\"权限收缩\",{\"1\":{\"1821\":1}}],[\"权限才能查看\",{\"1\":{\"1580\":1}}],[\"权限回收不能越级\",{\"1\":{\"1486\":1}}],[\"权限\",{\"1\":{\"1485\":1,\"1486\":1}}],[\"授予权限grant\",{\"0\":{\"1485\":1}}],[\"授权用户对那些数据库的那些表可以进行操作\",{\"1\":{\"1447\":1}}],[\"稍微有点流量必须使用连接池减少数据操作时的网络握手和挥手的过程\",{\"1\":{\"1476\":1}}],[\"稍微设置复杂点即可\",{\"1\":{\"1407\":1}}],[\"逻辑表student对应两台主机上的两个库mytest1\",{\"1\":{\"1892\":1}}],[\"逻辑表user只在linux主机的mytest1库中存在\",{\"1\":{\"1892\":1}}],[\"逻辑数据库\",{\"1\":{\"1888\":1,\"1891\":1}}],[\"逻辑库\",{\"1\":{\"1803\":1}}],[\"逻辑库和逻辑表\",{\"1\":{\"1803\":1}}],[\"逻辑\",{\"1\":{\"1610\":1}}],[\"逻辑运算符\",{\"0\":{\"1470\":1}}],[\"逻辑错误是说我们编写的代码思路有问题\",{\"1\":{\"597\":1}}],[\"逻辑错误和运行时错误\",{\"1\":{\"597\":1}}],[\"算数运算符\",{\"0\":{\"1469\":1}}],[\"算法思想\",{\"1\":{\"202\":1}}],[\"算法与数据结构\",{\"0\":{\"7\":1}}],[\"视情况拆分成一对一\",{\"1\":{\"1465\":1}}],[\"候选键\",{\"1\":{\"1463\":1}}],[\"姓名\",{\"1\":{\"1461\":2,\"1462\":1,\"1531\":1}}],[\"学习成本较高\",{\"1\":{\"1901\":1}}],[\"学习c语言的目标\",{\"0\":{\"305\":1}}],[\"学生表\",{\"1\":{\"1537\":1}}],[\"学生表和学院表\",{\"1\":{\"1462\":1}}],[\"学生关系表为student\",{\"1\":{\"1462\":1}}],[\"学院电话\",{\"1\":{\"1462\":1}}],[\"学院地点\",{\"1\":{\"1462\":1}}],[\"学分\",{\"1\":{\"1461\":2,\"1537\":1}}],[\"学号是主键\",{\"1\":{\"1462\":1}}],[\"学号\",{\"1\":{\"1461\":3,\"1462\":1}}],[\"市\",{\"1\":{\"1460\":1}}],[\"范围\",{\"1\":{\"1719\":10}}],[\"范围搜索使用索引\",{\"0\":{\"1591\":1}}],[\"范围查询\",{\"1\":{\"1563\":1,\"1686\":1,\"1688\":1}}],[\"范围从2\",{\"1\":{\"1299\":1}}],[\"范式越高表越多\",{\"1\":{\"1535\":1}}],[\"范式设计好处\",{\"0\":{\"1459\":1}}],[\"范式设计\",{\"0\":{\"1458\":1}}],[\"知乎\",{\"1\":{\"1828\":1,\"1869\":1}}],[\"知识拓展\",{\"0\":{\"1450\":1}}],[\"知道关键字有哪些\",{\"1\":{\"296\":1}}],[\"触发器\",{\"1\":{\"1437\":1}}],[\"昵称\",{\"1\":{\"1437\":1}}],[\"距离1970\",{\"1\":{\"1427\":1}}],[\"汉字也占用2个字节\",{\"1\":{\"1426\":1}}],[\"括号内数字是一个显示时显示的宽度\",{\"1\":{\"1424\":1}}],[\"精度是否足够\",{\"1\":{\"1423\":1}}],[\"减少\",{\"1\":{\"1864\":1}}],[\"减少锁冲突的机会\",{\"1\":{\"1724\":1}}],[\"减少mysql的压力\",{\"1\":{\"1437\":1}}],[\"减轻mysql压力\",{\"1\":{\"1415\":1}}],[\"减小编译依赖\",{\"1\":{\"826\":1}}],[\"身份信息\",{\"1\":{\"1415\":2}}],[\"父表\",{\"1\":{\"1415\":3}}],[\"父类\",{\"1\":{\"684\":1}}],[\"卸载命令\",{\"1\":{\"1405\":1}}],[\"卸载mysql\",{\"0\":{\"1405\":1}}],[\"登录消息\",{\"1\":{\"1896\":1}}],[\"登录到mycat的8066端口\",{\"1\":{\"1892\":1}}],[\"登录mycat后也是进入了一个mysql\",{\"1\":{\"1808\":1}}],[\"登录mysql\",{\"0\":{\"1403\":1}}],[\"登录这个管理端口可以查看mycat正在工作的所有状态以及和后端服务器的连接\",{\"1\":{\"1792\":1}}],[\"登录8066端口看到的界面就和登录mysql\",{\"1\":{\"1792\":1}}],[\"登录限制\",{\"0\":{\"55\":1}}],[\"逗号分隔\",{\"1\":{\"1356\":1}}],[\"逗号表达式\",{\"1\":{\"459\":1}}],[\"日\",{\"1\":{\"1537\":1}}],[\"日期和时间类型\",{\"0\":{\"1427\":1}}],[\"日期新于目标文件的所有相关文件列表\",{\"1\":{\"1356\":1}}],[\"日志\",{\"0\":{\"1935\":1},\"1\":{\"1856\":1},\"2\":{\"1034\":1}}],[\"日志记录器\",{\"1\":{\"1031\":3}}],[\"日志种类\",{\"1\":{\"1031\":3}}],[\"日志的目的地\",{\"1\":{\"1031\":3}}],[\"日志的格式\",{\"1\":{\"1031\":3}}],[\"日志的多线程支持主要是在category里做的处理\",{\"1\":{\"1019\":1}}],[\"日志文件最多存储3个文件\",{\"1\":{\"1026\":1}}],[\"日志级别\",{\"0\":{\"1023\":1}}],[\"日志布局\",{\"0\":{\"1021\":1}}],[\"日志追加器\",{\"0\":{\"1019\":1}}],[\"日志输出主体类\",{\"1\":{\"1018\":1}}],[\"日志类别\",{\"0\":{\"1018\":1}}],[\"伪目标\",{\"0\":{\"1355\":1},\"1\":{\"1365\":1}}],[\"伪装代理名称下载\",{\"0\":{\"1255\":1}}],[\"书写格式\",{\"0\":{\"1900\":1},\"1\":{\"1353\":1}}],[\"书写规则\",{\"0\":{\"1353\":1}}],[\"书写的时候使用多少个占位符\",{\"1\":{\"1155\":1}}],[\"八个字节\",{\"1\":{\"1347\":1}}],[\"八进制整数\",{\"1\":{\"1347\":1}}],[\"八进制\",{\"1\":{\"1299\":1}}],[\"八进制数通常是无符号数\",{\"1\":{\"349\":1}}],[\"八进制字面值\",{\"1\":{\"349\":1}}],[\"巨字\",{\"1\":{\"1347\":1}}],[\"扩展名\",{\"1\":{\"1334\":1,\"1335\":1}}],[\"扩容之后的数组的大小\",{\"1\":{\"1127\":1}}],[\"扩容拷贝\",{\"1\":{\"1076\":1}}],[\"扩容效率低\",{\"1\":{\"973\":1,\"974\":1}}],[\"扩容操作\",{\"1\":{\"406\":1}}],[\"扩容\",{\"1\":{\"100\":1,\"101\":1,\"355\":1,\"385\":1,\"704\":1,\"965\":1,\"969\":1,\"970\":1}}],[\"版本链\",{\"1\":{\"1656\":1}}],[\"版本链找到事务开始时的数据\",{\"1\":{\"1656\":1}}],[\"版本已commit\",{\"1\":{\"1656\":2}}],[\"版本未commit\",{\"1\":{\"1656\":1}}],[\"版本号决定了新旧程序\",{\"1\":{\"1332\":1}}],[\"版本管理\",{\"1\":{\"0\":1}}],[\"几个目录\",{\"0\":{\"1322\":1}}],[\"几乎能满足所有的需求\",{\"1\":{\"536\":1}}],[\"警告\",{\"1\":{\"1318\":2}}],[\"路由器局域网\",{\"1\":{\"1796\":1}}],[\"路径\",{\"1\":{\"1580\":1}}],[\"路径之间用空格分隔\",{\"1\":{\"1314\":1}}],[\"路归并\",{\"1\":{\"202\":1}}],[\"│\",{\"1\":{\"1313\":4,\"1316\":4}}],[\"├──\",{\"1\":{\"1313\":4,\"1316\":7,\"1318\":5}}],[\"构建b+树索引\",{\"1\":{\"1881\":1}}],[\"构建成b树\",{\"1\":{\"1623\":1}}],[\"构建链式哈希表\",{\"1\":{\"1603\":1}}],[\"构建项目编译环境\",{\"1\":{\"1303\":1}}],[\"构造tmp对象\",{\"1\":{\"1115\":1}}],[\"构造派生类部分\",{\"1\":{\"908\":1}}],[\"构造基类部分\",{\"1\":{\"908\":1}}],[\"构造和析构顺序\",{\"0\":{\"648\":1,\"649\":1}}],[\"构造一个myexception类\",{\"1\":{\"606\":2}}],[\"构造参数\",{\"1\":{\"435\":1}}],[\"构造函数加锁\",{\"1\":{\"1096\":1}}],[\"构造函数才能知道在哪里初始化\",{\"1\":{\"1073\":1}}],[\"构造函数会生成一个this指针存放对象的起始地址\",{\"1\":{\"1073\":1}}],[\"构造函数中调用其他函数\",{\"1\":{\"927\":1}}],[\"构造函数中添加了接收外面传进容器对象的地址\",{\"1\":{\"747\":1}}],[\"构造函数即新生成当前元素某一个位置的迭代器\",{\"1\":{\"747\":1}}],[\"构造函数不为私有\",{\"1\":{\"717\":1}}],[\"构造函数和析构函数是特殊的成员函数\",{\"1\":{\"925\":1}}],[\"构造函数和析构函数是不能继承的\",{\"1\":{\"665\":1}}],[\"构造函数和析构函数中访问\",{\"0\":{\"925\":1}}],[\"构造函数和析构函数为私有类型\",{\"1\":{\"841\":1}}],[\"构造函数和析构函数\",{\"1\":{\"673\":1}}],[\"构造函数调用顺序和派生列表一致\",{\"1\":{\"649\":1}}],[\"构造函数可以接收参数\",{\"1\":{\"421\":1}}],[\"构造函数是\",{\"1\":{\"421\":1}}],[\"构造函数在对象创建时自动调用\",{\"1\":{\"420\":1}}],[\"构造函数的特点\",{\"0\":{\"420\":1}}],[\"构造函数\",{\"0\":{\"418\":1,\"419\":1},\"1\":{\"406\":1,\"516\":2,\"685\":1,\"848\":1,\"850\":1,\"851\":1,\"876\":1,\"1114\":1}}],[\"构造\",{\"1\":{\"355\":1,\"385\":1,\"704\":1,\"1056\":4,\"1057\":4,\"1073\":1}}],[\"至于表数据的更改\",{\"1\":{\"1763\":1}}],[\"至于背后到底发生了什么\",{\"1\":{\"653\":1}}],[\"至36\",{\"1\":{\"1299\":1}}],[\"美化vim\",{\"0\":{\"1286\":1}}],[\"美国贝尔实验室的\",{\"1\":{\"301\":1}}],[\"速度\",{\"1\":{\"1284\":1}}],[\"速度也比数组慢\",{\"1\":{\"104\":1,\"107\":1,\"110\":1}}],[\"镜像站使用帮助\",{\"1\":{\"1284\":1}}],[\"网关和dns\",{\"1\":{\"1279\":1}}],[\"网络传输时\",{\"1\":{\"1913\":1}}],[\"网络连接问题\",{\"0\":{\"1828\":1}}],[\"网络掩码\",{\"1\":{\"1278\":1}}],[\"网络设置\",{\"0\":{\"1276\":1}}],[\"网络通信等\",{\"1\":{\"303\":1}}],[\"网络通信\",{\"1\":{\"17\":1}}],[\"宿主机充当虚拟路由器\",{\"1\":{\"1276\":1}}],[\"桥接模式是虚拟机直连物理网络\",{\"1\":{\"1821\":1}}],[\"桥接\",{\"1\":{\"1276\":1}}],[\"哈夫曼编码树的方法\",{\"1\":{\"1261\":1}}],[\"哈希值对桶的长度取模得到桶的序号\",{\"1\":{\"1603\":1}}],[\"哈希索引没办法减少磁盘i\",{\"1\":{\"1604\":1}}],[\"哈希索引只适用于小数据量的\",{\"1\":{\"1603\":1}}],[\"哈希索引是基于的支持\",{\"1\":{\"1601\":1}}],[\"哈希索引\",{\"0\":{\"1598\":1,\"1601\":1}}],[\"哈希表只能进行等值查找\",{\"1\":{\"1603\":1}}],[\"哈希表是最快的\",{\"1\":{\"1601\":1}}],[\"哈希表\",{\"0\":{\"137\":1,\"149\":1,\"178\":1},\"2\":{\"157\":1,\"160\":1,\"165\":1}}],[\"哈希\",{\"0\":{\"125\":1,\"141\":1},\"2\":{\"112\":1,\"128\":1,\"131\":1,\"139\":1,\"145\":1,\"151\":1,\"168\":1,\"173\":1,\"176\":1,\"181\":1}}],[\"哈希算法\",{\"0\":{\"1920\":1},\"1\":{\"110\":1}}],[\"侦听来自远方的tcp端口的连接请求\",{\"1\":{\"1240\":1}}],[\"°\",{\"1\":{\"1239\":1}}],[\"éåå¾çæè\",{\"1\":{\"1239\":1}}],[\"è\",{\"1\":{\"1239\":1}}],[\"端口\",{\"1\":{\"1238\":1}}],[\"列表中\",{\"1\":{\"1656\":2}}],[\"列表\",{\"1\":{\"1656\":1}}],[\"列\",{\"1\":{\"1548\":1}}],[\"列出源代码\",{\"1\":{\"1340\":1}}],[\"列出所有监听\",{\"1\":{\"1238\":1}}],[\"列出该网络类型连线中的相关地址\",{\"1\":{\"1237\":1}}],[\"列号不变\",{\"1\":{\"81\":1}}],[\"列号从\",{\"1\":{\"81\":2}}],[\"马上均能反应到另一个线程上\",{\"1\":{\"1233\":1}}],[\"共加了两种不同粒度的锁\",{\"1\":{\"1719\":1}}],[\"共享锁和排他锁说的是锁的性质\",{\"1\":{\"1702\":1}}],[\"共享库\",{\"0\":{\"1335\":1}}],[\"共享的变量\",{\"1\":{\"1233\":1}}],[\"共10次\",{\"1\":{\"519\":1}}],[\"启动一个新的定时线程\",{\"1\":{\"1849\":1,\"1859\":1}}],[\"启动一个新的线程\",{\"1\":{\"1849\":1,\"1859\":1,\"1875\":1}}],[\"启动一个新的线程作为生产者线程\",{\"1\":{\"1839\":1}}],[\"启动slave服务\",{\"0\":{\"1826\":1}}],[\"启动mycat服务\",{\"1\":{\"1804\":1}}],[\"启动服务\",{\"0\":{\"1804\":1}}],[\"启动和停止\",{\"1\":{\"1770\":1}}],[\"启动了但还没提交的事务\",{\"1\":{\"1656\":1}}],[\"启动事务时生成一个快照\",{\"1\":{\"1656\":1}}],[\"启动10个线程\",{\"1\":{\"1233\":1}}],[\"启动程序\",{\"1\":{\"306\":1}}],[\"票的数量count不正确\",{\"1\":{\"1232\":1}}],[\"收到通知\",{\"1\":{\"1229\":1}}],[\"收返回值是对象的函数调用的时候\",{\"1\":{\"1116\":1}}],[\"造成系统性能降低\",{\"1\":{\"1753\":1}}],[\"造成大量事务回滚\",{\"1\":{\"1670\":1}}],[\"造成锁没有释放掉\",{\"1\":{\"1225\":1}}],[\"造成问题\",{\"1\":{\"1056\":1}}],[\"赶紧生产吧\",{\"1\":{\"1219\":1}}],[\"处作为整数\",{\"1\":{\"1344\":1}}],[\"处于等待状态\",{\"1\":{\"1219\":1}}],[\"处理请求的过程如下图所示\",{\"1\":{\"1767\":1}}],[\"处理不在磁盘的数据\",{\"1\":{\"1603\":1}}],[\"处理完数据后\",{\"1\":{\"1381\":1}}],[\"处理消息的接口\",{\"1\":{\"871\":1}}],[\"处理\",{\"1\":{\"599\":1}}],[\"处理异常的语句\",{\"1\":{\"599\":3}}],[\"处理错误的方式\",{\"0\":{\"598\":1}}],[\"处理器需要作两次内存访问\",{\"1\":{\"553\":1}}],[\"处理下划线显示\",{\"1\":{\"48\":1}}],[\"信号量也可以做\",{\"1\":{\"1219\":1}}],[\"号物品\",{\"1\":{\"1219\":4}}],[\"号成员起开始计数\",{\"1\":{\"812\":1}}],[\"难\",{\"1\":{\"1331\":1}}],[\"难以复现\",{\"1\":{\"1218\":1}}],[\"难点在于\",{\"1\":{\"784\":1}}],[\"消息类型存储的为简单类型\",{\"1\":{\"1915\":1}}],[\"消息种类分为很多种\",{\"1\":{\"1896\":1}}],[\"消息传递是对象之间动态联系的唯一形式\",{\"1\":{\"445\":1}}],[\"消除表中的多值依赖\",{\"1\":{\"1464\":1}}],[\"消费\",{\"1\":{\"1219\":2}}],[\"消费物品\",{\"1\":{\"1219\":2}}],[\"消费完了\",{\"1\":{\"1219\":3}}],[\"消费者消费完了\",{\"1\":{\"1219\":1}}],[\"消费者消费10个物品\",{\"1\":{\"1219\":2}}],[\"消费者\",{\"1\":{\"1219\":2}}],[\"消费者再通知生产者继续生产物品\",{\"1\":{\"1219\":3}}],[\"消费者线程处理函数\",{\"0\":{\"1872\":1}}],[\"消费者线程的实现\",{\"0\":{\"1869\":1}}],[\"消费者线程函数\",{\"1\":{\"1849\":1,\"1859\":1,\"1869\":1,\"1872\":1}}],[\"消费者线程消费完之后\",{\"1\":{\"1221\":1}}],[\"消费者线程拿到锁了\",{\"1\":{\"1221\":1}}],[\"消费者线程发现que队列是空的\",{\"1\":{\"1221\":1}}],[\"消费者线程发现que是空的\",{\"1\":{\"1219\":1}}],[\"消费者线程\",{\"1\":{\"1219\":2}}],[\"消费者线程模型来设计\",{\"1\":{\"1866\":1}}],[\"消费者线程模型\",{\"0\":{\"1219\":1},\"1\":{\"1863\":1}}],[\"消费者模型\",{\"0\":{\"1215\":1}}],[\"支持查询缓存\",{\"0\":{\"1750\":1}}],[\"支持外键一致性约束\",{\"1\":{\"1557\":1}}],[\"支持事务\",{\"1\":{\"1557\":1}}],[\"支持\",{\"1\":{\"1211\":1,\"1828\":1}}],[\"支持带右值引用参数的拷贝构造函数和赋值重载函数\",{\"1\":{\"1211\":1}}],[\"锁机制\",{\"1\":{\"1881\":1}}],[\"锁范围内插入了一条记录\",{\"1\":{\"1717\":1}}],[\"锁定粒度最小\",{\"1\":{\"1713\":1}}],[\"锁定读就是读取的时候加锁\",{\"1\":{\"1677\":1}}],[\"锁定读和非锁定读\",{\"1\":{\"1677\":1}}],[\"锁粒度大\",{\"1\":{\"1713\":1}}],[\"锁粒度越大\",{\"1\":{\"1645\":1}}],[\"锁是串行化的原理\",{\"1\":{\"1712\":1}}],[\"锁是逐步获得的\",{\"1\":{\"1706\":1}}],[\"锁\",{\"1\":{\"1697\":2,\"1719\":13}}],[\"锁的优化建议\",{\"0\":{\"1724\":1}}],[\"锁的粒度减小\",{\"1\":{\"1569\":1}}],[\"锁的粒度太大\",{\"1\":{\"1569\":1}}],[\"锁的开销毕竟还是有点大的\",{\"1\":{\"848\":1}}],[\"锁+双重判断\",{\"1\":{\"1209\":2}}],[\"竞态条件\",{\"1\":{\"1208\":1,\"1217\":1}}],[\"涉及到账号登陆和身份验证\",{\"1\":{\"1821\":1}}],[\"涉及到效率的问题\",{\"0\":{\"1672\":1}}],[\"涉及数据库的远程访问和连接\",{\"1\":{\"1799\":1}}],[\"涉及一些的过程\",{\"1\":{\"1474\":1}}],[\"涉及\",{\"1\":{\"1208\":1}}],[\"卖出第\",{\"1\":{\"1208\":1,\"1209\":3,\"1210\":1}}],[\"睡到哪一个时间点\",{\"1\":{\"1207\":1}}],[\"睡眠100毫秒\",{\"1\":{\"1219\":4}}],[\"睡眠多长时间\",{\"1\":{\"1207\":1}}],[\"睡眠\",{\"1\":{\"1202\":1}}],[\"识别当前的操作系统来适配通过语言层面编写thread底层自动调用相应的函数\",{\"1\":{\"1202\":1}}],[\"识别的是\",{\"1\":{\"695\":1}}],[\"固定ip\",{\"1\":{\"1796\":1}}],[\"固定的\",{\"1\":{\"1197\":1}}],[\"固态硬盘\",{\"1\":{\"17\":1}}],[\"老版本\",{\"1\":{\"1168\":1}}],[\"老板\",{\"1\":{\"830\":1}}],[\"老板的助理\",{\"1\":{\"830\":1}}],[\"综合运用function和bind\",{\"1\":{\"1154\":1}}],[\"综合上面的知识\",{\"1\":{\"285\":1}}],[\"库表太大产生的问题\",{\"0\":{\"1886\":1}}],[\"库操作小结\",{\"0\":{\"1507\":1}}],[\"库操作\",{\"0\":{\"1506\":1}}],[\"库名\",{\"1\":{\"1485\":1,\"1486\":1,\"1507\":6}}],[\"库选项\",{\"1\":{\"1356\":1}}],[\"库文件会被拷贝到可执行程序中\",{\"1\":{\"1331\":1}}],[\"库文件输出位置\",{\"1\":{\"1310\":1}}],[\"库\",{\"0\":{\"1315\":1},\"1\":{\"1896\":1}}],[\"库里面提供的函数对象\",{\"1\":{\"1148\":1}}],[\"库中的shared\",{\"1\":{\"1055\":1}}],[\"库中定义的vector\",{\"1\":{\"355\":1}}],[\"配色设置\",{\"0\":{\"1143\":1}}],[\"配置水平分表\",{\"0\":{\"1891\":1}}],[\"配置了userdb1\",{\"1\":{\"1888\":1}}],[\"配置server\",{\"1\":{\"1833\":1}}],[\"配置slave前需要stop\",{\"1\":{\"1829\":1}}],[\"配置完成再start\",{\"1\":{\"1829\":1}}],[\"配置完thread\",{\"1\":{\"1753\":1}}],[\"配置中可能出现的问题\",{\"0\":{\"1827\":1}}],[\"配置全局唯一的server\",{\"0\":{\"1824\":1},\"1\":{\"1824\":1}}],[\"配置log\",{\"1\":{\"1820\":1}}],[\"配置layout为patternlayout\",{\"1\":{\"1026\":1}}],[\"配置主从复制实践\",{\"0\":{\"1817\":1}}],[\"配置好主从复制后直接drop\",{\"1\":{\"1830\":1}}],[\"配置好主从复制的时候\",{\"1\":{\"1785\":1}}],[\"配置好后\",{\"1\":{\"1805\":1,\"1806\":1}}],[\"配置写服务器\",{\"1\":{\"1803\":1}}],[\"配置文件加载失败\",{\"1\":{\"1839\":1,\"1849\":1,\"1859\":1,\"1875\":1}}],[\"配置文件配置server\",{\"1\":{\"1832\":1}}],[\"配置文件问题二\",{\"0\":{\"1806\":1}}],[\"配置文件问题一\",{\"0\":{\"1805\":1}}],[\"配置文件在mycat\",{\"1\":{\"1801\":1}}],[\"配置文件\",{\"0\":{\"1801\":1,\"1844\":1},\"1\":{\"1913\":1}}],[\"配置文件参数\",{\"0\":{\"1769\":1}}],[\"配置参数优化\",{\"1\":{\"1743\":1}}],[\"配置mysql\",{\"0\":{\"1400\":1}}],[\"配置一台ubuntu\",{\"0\":{\"1275\":1}}],[\"配置和配色方案\",{\"1\":{\"1132\":1,\"1290\":1}}],[\"配置\",{\"0\":{\"1132\":1,\"1290\":1},\"2\":{\"1298\":1}}],[\"配置日志文件最大不能超过1m\",{\"1\":{\"1026\":1}}],[\"配置日志文件名为test2\",{\"1\":{\"1026\":1}}],[\"配置日志文件名为test1\",{\"1\":{\"1026\":1}}],[\"配置a1为rollingfileappender\",{\"1\":{\"1026\":1}}],[\"配置子category\",{\"1\":{\"1026\":1}}],[\"配置rootappender为fileappender\",{\"1\":{\"1026\":1}}],[\"配置root\",{\"1\":{\"1026\":1}}],[\"配置有\",{\"1\":{\"831\":3}}],[\"配置如下\",{\"1\":{\"45\":1}}],[\"窗口\",{\"1\":{\"1208\":1,\"1209\":3,\"1210\":1}}],[\"窗口只有一个tab的情况\",{\"1\":{\"1139\":1}}],[\"窗口相关\",{\"0\":{\"1139\":1}}],[\"竖直方向上拆分当前窗口\",{\"1\":{\"1139\":1}}],[\"退出gdb\",{\"1\":{\"1340\":1}}],[\"退出全局字段搜索面板\",{\"1\":{\"1141\":1}}],[\"退出全局文件搜索面板\",{\"1\":{\"1136\":1}}],[\"退出q或quit\",{\"1\":{\"261\":1}}],[\"技术分享\",{\"1\":{\"1828\":1}}],[\"技术博客\",{\"1\":{\"0\":1}}],[\"技巧值得学习\",{\"1\":{\"1135\":1}}],[\"匹配的分区\",{\"1\":{\"1521\":1}}],[\"匹配一个到多个字符\",{\"1\":{\"1471\":1}}],[\"匹配一个字符\",{\"1\":{\"1471\":1}}],[\"匹配右值的push\",{\"1\":{\"1127\":1}}],[\"匹配右值\",{\"1\":{\"1124\":1}}],[\"匹配左值\",{\"1\":{\"1124\":1}}],[\"匹配catch的过程\",{\"0\":{\"603\":1}}],[\"拿银行转账来说\",{\"1\":{\"1644\":1}}],[\"拿t1拷贝构造形参t\",{\"1\":{\"1115\":1}}],[\"拿right去重为例\",{\"1\":{\"136\":1}}],[\"背后调用了哪些方法\",{\"0\":{\"1109\":1}}],[\"背景颜色\",{\"1\":{\"50\":1}}],[\"专门负责生产新连接\",{\"1\":{\"1848\":1,\"1859\":1,\"1875\":1}}],[\"专门从中继日志读取相应的操作\",{\"1\":{\"1783\":1}}],[\"专门读取接收主库发过来的binlog的内容\",{\"1\":{\"1783\":1}}],[\"专门用于分配指定大小的内存\",{\"1\":{\"1102\":1}}],[\"专注的注意与当前目标有关的方面\",{\"1\":{\"448\":1}}],[\"低\",{\"1\":{\"1331\":1}}],[\"低3位永远为0\",{\"1\":{\"1090\":1}}],[\"低于此优先级的类都不再输出\",{\"1\":{\"1018\":1}}],[\"归并思想的实现\",{\"1\":{\"1525\":1}}],[\"归并排序\",{\"0\":{\"202\":1}}],[\"归还\",{\"1\":{\"1093\":2}}],[\"归还分配出去的\",{\"1\":{\"1093\":1}}],[\"归还原来的chunk块到内存池\",{\"1\":{\"1076\":1}}],[\"缩容拷贝\",{\"1\":{\"1076\":1}}],[\"缩小左区间求左边界\",{\"1\":{\"96\":1}}],[\"资源管理\",{\"0\":{\"1936\":1}}],[\"资源锁被别的进程占用\",{\"1\":{\"1296\":1}}],[\"资源还没释放\",{\"1\":{\"1057\":1}}],[\"资源已经释放了\",{\"1\":{\"1057\":1}}],[\"资金短缺\",{\"1\":{\"301\":1}}],[\"弱智能指针需要使用对象\",{\"1\":{\"1057\":1}}],[\"弱智能指针观察的资源有可能被释放\",{\"1\":{\"1057\":1}}],[\"弱智能指针只会观察资源\",{\"1\":{\"1057\":1}}],[\"弱智能指针是无法调用a类的testa函数的\",{\"1\":{\"1057\":1}}],[\"弱智能指针\",{\"1\":{\"1056\":2,\"1057\":1}}],[\"弱类型程序语言设计\",{\"1\":{\"359\":1}}],[\"交易日期\",{\"1\":{\"1531\":1}}],[\"交叉引用\",{\"1\":{\"1056\":1}}],[\"交换\",{\"1\":{\"194\":1}}],[\"交换也发⽣在这两个元素之间\",{\"1\":{\"188\":1}}],[\"尝试提升为shared\",{\"1\":{\"1050\":1}}],[\"箭头运算符的重载\",{\"1\":{\"1041\":1}}],[\"裸指针\",{\"0\":{\"1040\":1}}],[\"超过七天的数据备份在sql脚本\",{\"1\":{\"1775\":1}}],[\"超过设置时间\",{\"1\":{\"1754\":1}}],[\"超过128字节\",{\"1\":{\"1096\":1}}],[\"超过就会删除旧的\",{\"1\":{\"1026\":1}}],[\"超过了\",{\"1\":{\"765\":1}}],[\"帮助类\",{\"0\":{\"1026\":1},\"1\":{\"1026\":1}}],[\"根分类root\",{\"1\":{\"1018\":1}}],[\"根据id拆分\",{\"1\":{\"1891\":1}}],[\"根据业务操作不同的逻辑库\",{\"1\":{\"1888\":1}}],[\"根据心跳select\",{\"1\":{\"1803\":1}}],[\"根据sql的读写性质转发到负责相应操作的服务器\",{\"1\":{\"1791\":1}}],[\"根据辅助索引值相同\",{\"1\":{\"1693\":1}}],[\"根据选定的哈希函数\",{\"1\":{\"1603\":1}}],[\"根据具体的业务和并发量来\",{\"1\":{\"1573\":1}}],[\"根据具体的汽车而定1l油跑的公里数\",{\"1\":{\"900\":1}}],[\"根据目标文件确定所需的依赖文件\",{\"1\":{\"1353\":1}}],[\"根据功能把代码放在不同目录下\",{\"1\":{\"1313\":1}}],[\"根据端口列进程\",{\"1\":{\"1238\":1}}],[\"根据想分配的内存大小\",{\"1\":{\"1096\":1}}],[\"根据偏移的字节就可以找到\",{\"1\":{\"937\":1}}],[\"根据传入的参数\",{\"1\":{\"864\":1}}],[\"根据上述分析\",{\"1\":{\"620\":1}}],[\"根据参数的个数\",{\"1\":{\"572\":1}}],[\"根据参数的\",{\"1\":{\"571\":1}}],[\"根据实体的属性和行为抽象出\",{\"1\":{\"446\":1}}],[\"根据如下两段代码分析\",{\"1\":{\"246\":1}}],[\"根据\",{\"1\":{\"126\":1,\"147\":1,\"826\":1,\"1099\":1,\"1318\":1}}],[\"根据规律找需要循环的次数\",{\"1\":{\"81\":1}}],[\"安卓开发使用的sqlist\",{\"1\":{\"1452\":1}}],[\"安装lrzsz\",{\"1\":{\"1800\":1}}],[\"安装libaio1\",{\"1\":{\"1397\":1}}],[\"安装mycat\",{\"0\":{\"1800\":1}}],[\"安装mysql中常见问题\",{\"0\":{\"1406\":1}}],[\"安装mysql客户端依赖包\",{\"1\":{\"1399\":1}}],[\"安装mysql5\",{\"0\":{\"1397\":1}}],[\"安装mysql\",{\"0\":{\"1392\":1},\"1\":{\"1393\":1,\"1397\":1}}],[\"安装方法\",{\"2\":{\"1413\":1}}],[\"安装方式\",{\"1\":{\"1035\":1}}],[\"安装完成之后\",{\"0\":{\"1398\":1}}],[\"安装开发c\",{\"1\":{\"1371\":1}}],[\"安装新库\",{\"1\":{\"1332\":1}}],[\"安装难度\",{\"1\":{\"1331\":1}}],[\"安装不成功需要删掉重装\",{\"1\":{\"1287\":1}}],[\"安装代码补全工具\",{\"1\":{\"1287\":1}}],[\"安装vimplus\",{\"0\":{\"1287\":1},\"1\":{\"1287\":1}}],[\"安装vmware\",{\"0\":{\"1285\":1}}],[\"安装可用的软件包更新\",{\"1\":{\"1284\":1}}],[\"安装必备工具\",{\"0\":{\"1280\":1}}],[\"安装与使用\",{\"1\":{\"1141\":1}}],[\"安装前先安装插件\",{\"0\":{\"1131\":1,\"1289\":1}}],[\"安装低版本的g++及gcc\",{\"1\":{\"1016\":1}}],[\"安装\",{\"0\":{\"1015\":1,\"1304\":1}}],[\"安全性越高\",{\"1\":{\"1644\":1,\"1645\":1}}],[\"安全的向下转型\",{\"1\":{\"678\":1}}],[\"安全\",{\"1\":{\"359\":1}}],[\"❌\",{\"1\":{\"1011\":1}}],[\"李亚鹏\",{\"1\":{\"1681\":1}}],[\"李广\",{\"1\":{\"1002\":2}}],[\"李四\",{\"1\":{\"1000\":4}}],[\"红黑树的中序遍历\",{\"1\":{\"1002\":1}}],[\"红色框\",{\"1\":{\"1881\":1}}],[\"红色red\",{\"1\":{\"29\":1}}],[\"红色\",{\"1\":{\"29\":2}}],[\"海量数据去重\",{\"1\":{\"1001\":1}}],[\"海伦公式计算三角形的面积\",{\"1\":{\"898\":1}}],[\"刘帅\",{\"1\":{\"1000\":1}}],[\"王五\",{\"1\":{\"1000\":8,\"1477\":1}}],[\"张票\",{\"1\":{\"1208\":1,\"1209\":3,\"1210\":1}}],[\"张文\",{\"1\":{\"1002\":2}}],[\"张三的账户还剩100块\",{\"1\":{\"1639\":1}}],[\"张三2\",{\"1\":{\"1000\":1}}],[\"张三\",{\"1\":{\"1000\":4}}],[\"张威的编程学习笔记\",{\"1\":{\"110\":1,\"496\":1,\"678\":1,\"692\":1,\"707\":1,\"750\":1,\"965\":1,\"1063\":1,\"1087\":1,\"1121\":1,\"1610\":1,\"1747\":1}}],[\"张威\",{\"1\":{\"0\":1}}],[\"映射表\",{\"1\":{\"1000\":1}}],[\"映射到下标0~19\",{\"1\":{\"191\":1}}],[\"集合\",{\"1\":{\"999\":1}}],[\"谁后出队\",{\"1\":{\"992\":1}}],[\"谁优先级小\",{\"1\":{\"992\":1}}],[\"谁优先级大谁先出队\",{\"1\":{\"992\":1}}],[\"产品中打包了库文件\",{\"1\":{\"1331\":1}}],[\"产看队尾元素\",{\"1\":{\"991\":1}}],[\"产生中间表\",{\"1\":{\"1744\":1}}],[\"产生的数据快照还是undo\",{\"1\":{\"1658\":1}}],[\"产生的问题\",{\"1\":{\"1056\":1}}],[\"产生了菱形继承同样的问题\",{\"1\":{\"688\":1}}],[\"产生几个问题\",{\"1\":{\"267\":1}}],[\"称作\",{\"1\":{\"979\":1}}],[\"称为临界区代码段\",{\"1\":{\"1217\":1}}],[\"称为动态多态\",{\"1\":{\"883\":1}}],[\"称为\",{\"1\":{\"740\":1,\"1451\":1}}],[\"称为const成员\",{\"1\":{\"440\":1}}],[\"称为模板函数或者模板类\",{\"1\":{\"361\":1}}],[\"称为文件映射区域的地方\",{\"1\":{\"281\":1}}],[\"称为2\",{\"1\":{\"202\":1}}],[\"拥有operator\",{\"1\":{\"978\":1}}],[\"拥有纯虚函数的类称为抽象类\",{\"1\":{\"901\":1}}],[\"四位\",{\"1\":{\"1407\":1}}],[\"四\",{\"0\":{\"971\":1,\"992\":1,\"1737\":1,\"1771\":1,\"1807\":1,\"1827\":1,\"1890\":1,\"1906\":1}}],[\"⑤swap\",{\"1\":{\"965\":1}}],[\"⑤malloc开辟单个元素内存与数组内存是一样的\",{\"1\":{\"708\":1}}],[\"⑤malloc开辟单个元素内存与数组内存都是给字节数\",{\"1\":{\"513\":1}}],[\"④swap\",{\"1\":{\"969\":1,\"970\":1}}],[\"④resize\",{\"1\":{\"965\":1}}],[\"④foreach\",{\"1\":{\"965\":1}}],[\"④malloc开辟内存失败返回nullptr指针\",{\"1\":{\"513\":1,\"708\":1}}],[\"寄存器放的地址\",{\"1\":{\"959\":1}}],[\"绑定器和函数对象\",{\"0\":{\"1195\":1}}],[\"绑定器出了语句\",{\"1\":{\"1155\":1}}],[\"绑定器问题\",{\"1\":{\"1154\":1}}],[\"绑定器是函数对象的一个应用\",{\"1\":{\"1148\":1}}],[\"绑定器\",{\"0\":{\"1008\":1},\"1\":{\"1008\":1,\"1148\":1,\"1161\":1,\"1195\":1}}],[\"绑定指的是函数调用\",{\"1\":{\"959\":1}}],[\"绑定即函数调用\",{\"1\":{\"953\":1}}],[\"地址\",{\"1\":{\"1347\":2}}],[\"地址放入ecx\",{\"1\":{\"954\":1}}],[\"地址相同\",{\"1\":{\"633\":2}}],[\"什么叫事务commit成功\",{\"0\":{\"1763\":1}}],[\"什么叫事务启动呢\",{\"1\":{\"1656\":1}}],[\"什么情况下能用到这个知识\",{\"1\":{\"1711\":1}}],[\"什么意思\",{\"0\":{\"1424\":1}}],[\"什么作用\",{\"0\":{\"1333\":1}}],[\"什么结果\",{\"1\":{\"1056\":1}}],[\"什么时候需要把基类的析构函数必须实现成虚函数\",{\"0\":{\"947\":1}}],[\"什么是真正的事务commit成功\",{\"0\":{\"1762\":1}}],[\"什么是关系型数据库\",{\"0\":{\"1451\":1}}],[\"什么是函数对象呢\",{\"0\":{\"979\":1}}],[\"什么是线程安全\",{\"0\":{\"839\":1}}],[\"什么是单例模式\",{\"0\":{\"836\":1}}],[\"什么是引用\",{\"0\":{\"612\":1}}],[\"什么是命名空间\",{\"0\":{\"583\":1}}],[\"什么是多态\",{\"0\":{\"564\":1}}],[\"什么是内联函数\",{\"0\":{\"501\":1}}],[\"什么是oop思想\",{\"0\":{\"445\":1}}],[\"什么是容器适配器\",{\"1\":{\"989\":1}}],[\"什么是容器\",{\"0\":{\"353\":1}}],[\"含虚函数的内存分布\",{\"0\":{\"938\":1}}],[\"受限制的指针\",{\"1\":{\"922\":1}}],[\"表支持行级锁定\",{\"1\":{\"1713\":1}}],[\"表级锁\",{\"0\":{\"1713\":1},\"1\":{\"1713\":1}}],[\"表级锁和行级锁\",{\"0\":{\"1711\":1}}],[\"表级锁还是行级锁说的是锁的粒度\",{\"1\":{\"1702\":1}}],[\"表锁\",{\"1\":{\"1719\":1}}],[\"表锁是\",{\"1\":{\"1706\":1}}],[\"表锁而非行锁\",{\"0\":{\"1673\":1}}],[\"表格中的x\",{\"1\":{\"1673\":1}}],[\"表格的数据应该是这样的\",{\"1\":{\"1665\":1}}],[\"表索的相关命令\",{\"0\":{\"1671\":1}}],[\"表又比较大\",{\"1\":{\"1670\":1}}],[\"表数据和表索引\",{\"1\":{\"1557\":1}}],[\"表数据清空了\",{\"1\":{\"1480\":1}}],[\"表中只有\",{\"1\":{\"1686\":1}}],[\"表中新添加一个字段\",{\"1\":{\"1552\":1}}],[\"表中存放的就是各虚函数的入口地址\",{\"1\":{\"914\":1}}],[\"表操作小结\",{\"0\":{\"1552\":1}}],[\"表\",{\"1\":{\"1548\":2}}],[\"表名\",{\"1\":{\"1490\":3,\"1491\":2,\"1492\":2,\"1494\":3,\"1495\":1,\"1496\":3,\"1497\":1,\"1552\":12,\"1614\":3}}],[\"表的权限\",{\"1\":{\"1485\":2,\"1486\":2}}],[\"表2\",{\"1\":{\"1461\":1,\"1502\":2}}],[\"表1\",{\"1\":{\"1461\":1,\"1502\":2}}],[\"表达式计算等\",{\"1\":{\"1615\":1}}],[\"表达式根据变量内容生成新的内容\",{\"1\":{\"1360\":1}}],[\"表达式\",{\"1\":{\"1360\":1}}],[\"表达式n\",{\"1\":{\"1114\":1}}],[\"表达式2\",{\"1\":{\"1114\":1}}],[\"表达式1\",{\"1\":{\"1114\":1}}],[\"表现出动态多态特性\",{\"1\":{\"922\":1}}],[\"表示pwd为loginrequest类型的第二个字段\",{\"1\":{\"1915\":1}}],[\"表示name为loginrequest类型的第一个字段\",{\"1\":{\"1915\":1}}],[\"表示连接池事先会和mysql\",{\"1\":{\"1865\":1}}],[\"表示和mysql的一条连接\",{\"1\":{\"1846\":1,\"1856\":1,\"1859\":1}}],[\"表示读服务器是slave\",{\"1\":{\"1803\":1}}],[\"表示所有写操作发送到配置的第一个writehost\",{\"1\":{\"1803\":1}}],[\"表示允许任意地址连接\",{\"1\":{\"1799\":1}}],[\"表示10毫秒\",{\"1\":{\"1776\":1}}],[\"表示我们在my\",{\"1\":{\"1773\":1}}],[\"表示数据库表的4个字段\",{\"1\":{\"1773\":1}}],[\"表示行级锁\",{\"1\":{\"1719\":1}}],[\"表示生成该版本记录的活跃事务已经被提交\",{\"1\":{\"1656\":1}}],[\"表示生成该版本记录的活跃事务依然活跃着\",{\"1\":{\"1656\":1}}],[\"表示这个版本的记录是在创建\",{\"1\":{\"1656\":2}}],[\"表示这个结果来自于union查询的id为m\",{\"1\":{\"1618\":1}}],[\"表示结果来自于这个查询产生的\",{\"1\":{\"1618\":1}}],[\"表示按什么连接\",{\"1\":{\"1537\":1}}],[\"表示查询时扫描的行数\",{\"1\":{\"1521\":1}}],[\"表示查询中执行select子句或操作表的顺序\",{\"1\":{\"1521\":1}}],[\"表示索引中使用的字节数\",{\"1\":{\"1521\":1}}],[\"表示通匹表中所有字段\",{\"1\":{\"1494\":1}}],[\"表示任意库任意表\",{\"1\":{\"1821\":1}}],[\"表示任意ip都可以通过这个账号登录\",{\"1\":{\"1821\":1}}],[\"表示任意地址\",{\"1\":{\"1447\":1}}],[\"表示任意所有库\",{\"1\":{\"1447\":1}}],[\"表示不需要union操作或者不包含子查询的简单select语句\",{\"1\":{\"1618\":1}}],[\"表示不管哪个位置查询效率\",{\"1\":{\"1521\":1}}],[\"表示不使用unix套接字或者管道\",{\"1\":{\"1374\":1}}],[\"表示不捕获任何外部变量\",{\"1\":{\"1172\":1}}],[\"表示等待120秒连接不上就算超时\",{\"1\":{\"1252\":1}}],[\"表示本机上所有地址的135端口\",{\"1\":{\"1239\":1}}],[\"表示参数可能会很多\",{\"1\":{\"1194\":1}}],[\"表示参数都是已知的\",{\"1\":{\"1187\":1}}],[\"表示可变参\",{\"1\":{\"1194\":1}}],[\"表示可以接受任意多个参数作为模板参数\",{\"1\":{\"376\":1}}],[\"表示将的形参a\",{\"1\":{\"1174\":1}}],[\"表示一组形参变量\",{\"1\":{\"1158\":1}}],[\"表示挂载第一个chunk的地址\",{\"1\":{\"1102\":1}}],[\"表示节点是否支持线程安全\",{\"1\":{\"1081\":1}}],[\"表示\",{\"1\":{\"1030\":1,\"1099\":1}}],[\"表示该虚函数表是由什么类类型产生的\",{\"1\":{\"957\":1}}],[\"表示的是虚函数指针vfptr在虚函数表里的偏移量\",{\"1\":{\"954\":1}}],[\"表示指针指向的类型\",{\"1\":{\"953\":1}}],[\"表示指针地址大小64位为8\",{\"1\":{\"535\":1}}],[\"表示有好几个对象\",{\"1\":{\"715\":1}}],[\"表示容器中最后一个元素的后继位置\",{\"1\":{\"698\":1}}],[\"表示创建变量或分配存储单元\",{\"1\":{\"574\":1}}],[\"表示存储字符的个数\",{\"1\":{\"535\":1}}],[\"表示实体的抽象数据类型\",{\"1\":{\"447\":1}}],[\"表示立即展开该参数\",{\"1\":{\"377\":1}}],[\"表示函数可以接受多个任意类型的参数\",{\"1\":{\"377\":1}}],[\"表示优化级别\",{\"1\":{\"244\":1}}],[\"表示栈扩大12byte\",{\"1\":{\"233\":1}}],[\"表示栈减小12byte\",{\"1\":{\"233\":1}}],[\"表示还有最后一个数需处理\",{\"1\":{\"78\":1}}],[\"准备分配出一整个\",{\"1\":{\"1102\":1}}],[\"准备工作做完之后\",{\"1\":{\"908\":1}}],[\"准确的说是至少是这么多\",{\"1\":{\"285\":1}}],[\"道理与前面相同\",{\"1\":{\"907\":1}}],[\"泛指\",{\"1\":{\"905\":1}}],[\"泛型算法参数传递\",{\"1\":{\"1171\":1}}],[\"泛型算法的参数还可以接受\",{\"1\":{\"1007\":1}}],[\"泛型算法的参数接受的都是\",{\"1\":{\"1007\":1}}],[\"泛型算法与绑定器\",{\"0\":{\"1006\":1}}],[\"泛型算法\",{\"0\":{\"1007\":1},\"1\":{\"704\":1,\"965\":1}}],[\"猫狗叫声问题\",{\"0\":{\"905\":1}}],[\"猫具有动物属性\",{\"1\":{\"901\":1}}],[\"却不能创建自己对象的类是另一种形式的抽象类\",{\"1\":{\"900\":1}}],[\"却只能被本文件空间内的函数等访问\",{\"1\":{\"591\":1}}],[\"宝马\",{\"1\":{\"900\":1}}],[\"奥迪\",{\"1\":{\"900\":1}}],[\"奔驰\",{\"1\":{\"900\":1}}],[\"公共头文件\",{\"0\":{\"1845\":1}}],[\"公里\",{\"1\":{\"900\":1}}],[\"公有\",{\"1\":{\"657\":1}}],[\"公有数据成员和成员函数\",{\"1\":{\"449\":1}}],[\"汽车类中获取汽车剩余油量还能跑的公里数\",{\"1\":{\"924\":1}}],[\"汽车的基类\",{\"1\":{\"900\":1}}],[\"汽车等相同点的提取与抽象\",{\"1\":{\"449\":1}}],[\"纯虚函数的格式如下\",{\"1\":{\"898\":1}}],[\"纯虚函数是一种特殊的虚函数\",{\"1\":{\"898\":1}}],[\"纯虚函数\",{\"0\":{\"898\":1},\"1\":{\"900\":1,\"905\":1}}],[\"纯虚函数和抽象类\",{\"0\":{\"897\":1}}],[\"真实存在的\",{\"1\":{\"1610\":1}}],[\"真实的被覆盖的函数的地址\",{\"1\":{\"889\":1}}],[\"真正调用时不管是静态还是动态绑定\",{\"1\":{\"906\":1}}],[\"真正插入或者删除的元素是pcur\",{\"1\":{\"792\":1}}],[\"真正要插入位置pcur\",{\"1\":{\"791\":1}}],[\"达到时机就花费磁盘io\",{\"1\":{\"1758\":1}}],[\"达到锁定左侧边界的目的\",{\"1\":{\"96\":1}}],[\"达不到高内聚低耦合\",{\"1\":{\"886\":1}}],[\"动物实体类\",{\"1\":{\"886\":1,\"905\":1}}],[\"动物基类\",{\"1\":{\"886\":1,\"905\":1}}],[\"动多态\",{\"0\":{\"886\":1}}],[\"动态\",{\"1\":{\"1331\":1}}],[\"动态库的好处\",{\"1\":{\"1332\":1}}],[\"动态库\",{\"1\":{\"1331\":1}}],[\"动态库都编译出来了\",{\"1\":{\"1303\":1}}],[\"动态是运行时期\",{\"1\":{\"959\":1}}],[\"动态内存\",{\"0\":{\"949\":1}}],[\"动态内存管理\",{\"0\":{\"518\":1}}],[\"动态联编\",{\"1\":{\"883\":2,\"920\":1}}],[\"动态绑定一定是对虚函数的绑定\",{\"1\":{\"959\":1}}],[\"动态绑定pb\",{\"1\":{\"948\":1}}],[\"动态绑定\",{\"0\":{\"954\":1},\"1\":{\"631\":2,\"900\":1,\"908\":2,\"927\":1,\"959\":1}}],[\"动态异常规范\",{\"1\":{\"607\":1}}],[\"动态多态\",{\"1\":{\"564\":1}}],[\"案例3\",{\"0\":{\"886\":1}}],[\"案例2\",{\"0\":{\"885\":1},\"1\":{\"1001\":1}}],[\"案例1\",{\"0\":{\"884\":1},\"1\":{\"1001\":1}}],[\"静多态\",{\"0\":{\"884\":1,\"885\":1}}],[\"静态函数的实现\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":2}}],[\"静态函数发生在\",{\"1\":{\"876\":1}}],[\"静态\",{\"1\":{\"1331\":1}}],[\"静态库\",{\"1\":{\"1303\":1,\"1331\":1}}],[\"静态ip配置之nat模式\",{\"0\":{\"1279\":1}}],[\"静态ip配置之桥接模式\",{\"0\":{\"1278\":1}}],[\"静态指的是编译时期\",{\"1\":{\"953\":1,\"959\":1}}],[\"静态绑定会生成一个指令\",{\"1\":{\"959\":1}}],[\"静态绑定和🍔动态绑定\",{\"0\":{\"952\":1}}],[\"静态绑定\",{\"0\":{\"953\":1},\"1\":{\"923\":1,\"953\":2}}],[\"静态局部变量的初始化\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":2}}],[\"静态局部变量的懒汉单例\",{\"0\":{\"850\":1}}],[\"静态局部变量只在第一次被调用的时候初始化\",{\"1\":{\"850\":1}}],[\"静态局部变量只在当前函数内有效\",{\"1\":{\"850\":1}}],[\"静态异常规范\",{\"1\":{\"607\":1}}],[\"静态多态\",{\"1\":{\"564\":1}}],[\"静态的成员函数不能访问非静态的数据成员和非静态的成员函数\",{\"1\":{\"439\":1}}],[\"静态的成员函数的第一个参数位置没有this指针\",{\"1\":{\"439\":1}}],[\"静态区\",{\"1\":{\"435\":1}}],[\"静态存储\",{\"1\":{\"435\":1}}],[\"静态数据成员要放在全局静态位置进行初始化\",{\"1\":{\"435\":1}}],[\"静态数据成员存储在全局\",{\"1\":{\"435\":1}}],[\"静态数据成员和之前介绍的静态变量一样\",{\"1\":{\"435\":1}}],[\"静态数据成员\",{\"0\":{\"435\":1}}],[\"静态成员类外初始化\",{\"1\":{\"1082\":1}}],[\"静态成员函数对于每个类都只有一份代码\",{\"1\":{\"876\":1}}],[\"静态成员函数的特殊用法\",{\"1\":{\"439\":1}}],[\"静态成员函数的特点\",{\"1\":{\"439\":1}}],[\"静态成员函数可以使用类名加作用符的形式进行调用\",{\"1\":{\"439\":1}}],[\"静态成员函数\",{\"0\":{\"439\":1},\"1\":{\"876\":1}}],[\"静态成员函数和\",{\"1\":{\"438\":1}}],[\"静态成员变量\",{\"0\":{\"413\":1},\"1\":{\"413\":2}}],[\"静态成员方法\",{\"1\":{\"410\":1,\"413\":1}}],[\"静态变量\",{\"1\":{\"267\":2}}],[\"维护连接队列的线程安全互斥锁\",{\"1\":{\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"维护代码时修改一个地方会牵连到很多地方\",{\"1\":{\"882\":1}}],[\"维持结构的清晰\",{\"1\":{\"359\":1}}],[\"维持窗口大小为k\",{\"1\":{\"162\":1}}],[\"哪个请求是写\",{\"1\":{\"1791\":1}}],[\"哪个机器是负责读操作的从库\",{\"1\":{\"1790\":1}}],[\"哪怕是15和16\",{\"1\":{\"1603\":1}}],[\"哪些列或常量被用于查找索引列上的值\",{\"1\":{\"1521\":1}}],[\"哪些函数不能被设置为虚函数\",{\"0\":{\"874\":1,\"876\":1}}],[\"哪一个迭代器指针指向的迭代器迭代元素的指针在检查范围内\",{\"1\":{\"747\":1}}],[\"哪一个迭代器增加或删除要让其失效并重新更新\",{\"1\":{\"747\":1}}],[\"主从同步错误last\",{\"1\":{\"1828\":1}}],[\"主从复制是\",{\"1\":{\"1785\":1}}],[\"主从复制效果展示\",{\"0\":{\"1785\":1}}],[\"主从复制流程\",{\"0\":{\"1784\":1}}],[\"主从复制概念\",{\"0\":{\"1780\":1}}],[\"主从复制原理\",{\"0\":{\"1779\":1}}],[\"主从复制\",{\"1\":{\"1767\":1,\"1772\":1}}],[\"主库的更新是往哪个binlog写的\",{\"1\":{\"1822\":1}}],[\"主库的更新操作写入binlog二进制日志中\",{\"1\":{\"1784\":1}}],[\"主库的数据更改通过主从复制同步到从库\",{\"1\":{\"1790\":1}}],[\"主库专门负责相对少的写操作\",{\"1\":{\"1790\":1}}],[\"主库专门处理写请求\",{\"1\":{\"1781\":1}}],[\"主库所有的更改都会同步到从库\",{\"1\":{\"1785\":1}}],[\"主库所有的更新操作\",{\"1\":{\"1772\":1}}],[\"主库上的dump线程已经把binlog的内容发完了\",{\"1\":{\"1784\":1}}],[\"主库master服务器创建一个\",{\"1\":{\"1782\":1}}],[\"主库介绍\",{\"0\":{\"1782\":1}}],[\"主库中涉及到数据的修改都会写binlog\",{\"1\":{\"1780\":1}}],[\"主库对外提供数据的增删改查服务\",{\"1\":{\"1780\":1}}],[\"主键顺序插入\",{\"0\":{\"1729\":1}}],[\"主键和唯一键是不能重复的\",{\"1\":{\"1692\":1}}],[\"主键树中叶子节点key是主键值\",{\"1\":{\"1563\":1}}],[\"主键id是自增的有上限\",{\"0\":{\"1481\":1}}],[\"主键可以是单列或多列的组合\",{\"1\":{\"1451\":1}}],[\"主键\",{\"0\":{\"1563\":1,\"1688\":1},\"1\":{\"1451\":1}}],[\"主键索引就隶属于唯一性索引\",{\"1\":{\"1610\":1}}],[\"主键索引\",{\"1\":{\"1437\":1,\"1610\":1}}],[\"主键约束\",{\"0\":{\"1432\":1}}],[\"主cmakelists\",{\"1\":{\"1309\":1}}],[\"主线程睡眠3秒\",{\"1\":{\"1233\":1}}],[\"主线程等待两个子线程都执行完再结束\",{\"1\":{\"1219\":2}}],[\"主线程等待子线程结束\",{\"1\":{\"1207\":1}}],[\"主线程才继续往下运行\",{\"1\":{\"1207\":1}}],[\"主线程\",{\"1\":{\"1207\":1}}],[\"主线程继续往下运行t1\",{\"1\":{\"1207\":1}}],[\"主线程运行完成\",{\"1\":{\"1207\":2}}],[\"主线程会等待子线程运行结束\",{\"1\":{\"1206\":1}}],[\"主线程结束的时候查看其他线程\",{\"1\":{\"1207\":1}}],[\"主线程结束\",{\"1\":{\"1206\":1}}],[\"主线程如何处理子线程\",{\"0\":{\"1206\":1}}],[\"主题名配置每次vim默认打开的文件\",{\"1\":{\"1143\":1}}],[\"主题检测发生改变\",{\"1\":{\"871\":1}}],[\"主题类\",{\"1\":{\"871\":1}}],[\"主题有更改\",{\"1\":{\"871\":1}}],[\"主题\",{\"1\":{\"871\":1}}],[\"主要有以下特点\",{\"1\":{\"1898\":1}}],[\"主要也是实现以上几个所有连接池都支持的通用基础功能\",{\"1\":{\"1865\":1}}],[\"主要就是为了在业务执行的过程中\",{\"1\":{\"1753\":1}}],[\"主要指配置文件中thread\",{\"1\":{\"1753\":1}}],[\"主要指的就是innodb\",{\"1\":{\"1752\":1}}],[\"主要指的是mysql\",{\"1\":{\"1746\":1}}],[\"主要只是多了排序之后的分组操作\",{\"1\":{\"1737\":1}}],[\"主要因为insert\",{\"1\":{\"1665\":1}}],[\"主要的语句关键字包括\",{\"1\":{\"1548\":1}}],[\"主要针对联合主键\",{\"1\":{\"1461\":1}}],[\"主要用于生成位置无关代码\",{\"1\":{\"1333\":1}}],[\"主要用于1个模板比对n个测序结果\",{\"1\":{\"3\":1}}],[\"主要干的什么\",{\"1\":{\"1105\":1}}],[\"主要是相对于主键索引和唯一索引的说法\",{\"1\":{\"1610\":1}}],[\"主要是为了减少数据冗余\",{\"1\":{\"1459\":1}}],[\"主要是通过外键实现\",{\"1\":{\"1415\":1}}],[\"主要是使用代码的方式\",{\"1\":{\"1026\":1}}],[\"主要是使用patternlayout对日志做格式输出\",{\"1\":{\"1021\":1}}],[\"主要是用来确定日志输出行为\",{\"1\":{\"1019\":1}}],[\"主要是派生类对象\",{\"1\":{\"898\":1}}],[\"主要目的是显示事务正在锁定某行或者试图锁定某行\",{\"1\":{\"1673\":1}}],[\"主要目的\",{\"1\":{\"901\":1}}],[\"主要从语义上考虑\",{\"1\":{\"876\":1}}],[\"主要关注的是对象的一对多的关系\",{\"1\":{\"871\":2}}],[\"主要关注的是对象之间的通信\",{\"1\":{\"871\":2}}],[\"主要解决了上面使用简单工厂遇到的问题\",{\"1\":{\"866\":1}}],[\"主要功能实现\",{\"1\":{\"747\":1}}],[\"主要原因是cat的vfptr存放dog的vftable地址\",{\"1\":{\"905\":1}}],[\"主要原因是c++代码在产生函数符号时候\",{\"1\":{\"562\":1}}],[\"主要原因是\",{\"1\":{\"616\":1}}],[\"主要原因是用户空间是私有的\",{\"1\":{\"267\":1}}],[\"圆饼图\",{\"1\":{\"871\":1}}],[\"柱状图\",{\"1\":{\"871\":1}}],[\"曲线图\",{\"1\":{\"871\":1}}],[\"订阅模式\",{\"1\":{\"871\":1}}],[\"订阅\",{\"1\":{\"871\":1}}],[\"监测对象的生存状态\",{\"1\":{\"1050\":1}}],[\"监听者\",{\"1\":{\"871\":1}}],[\"监视结构体成员\",{\"0\":{\"1346\":1}}],[\"监视表达式的结果\",{\"0\":{\"1345\":1}}],[\"监视内存地址的内容\",{\"0\":{\"1344\":1}}],[\"监视指针指向的内容\",{\"0\":{\"1343\":1}}],[\"监视变量值\",{\"0\":{\"1342\":1}}],[\"监视功能\",{\"0\":{\"1341\":1}}],[\"监视\",{\"1\":{\"306\":1}}],[\"观察\",{\"1\":{\"1056\":1}}],[\"观察者抽象类\",{\"1\":{\"871\":1}}],[\"观察者模式observer\",{\"1\":{\"871\":1}}],[\"观察者模式又叫做观察者\",{\"1\":{\"871\":1}}],[\"观察者模式是行为型模式\",{\"1\":{\"871\":1}}],[\"观察者observer模式\",{\"0\":{\"871\":1}}],[\"观看vip电影\",{\"1\":{\"830\":1}}],[\"观看免费电影\",{\"1\":{\"830\":1}}],[\"系列产品2\",{\"1\":{\"867\":1}}],[\"系列产品1\",{\"1\":{\"867\":1}}],[\"系统版本号和事务版本号\",{\"1\":{\"1656\":1}}],[\"系统默认加升序查询\",{\"1\":{\"1496\":1}}],[\"系统不会因文件大小限制而截断\",{\"1\":{\"1338\":1}}],[\"系统可能不生成\",{\"1\":{\"1338\":1}}],[\"系统中用于设置\",{\"1\":{\"1338\":1}}],[\"系统中的一个工具\",{\"1\":{\"1334\":1}}],[\"系统中默认的优先级等级如下\",{\"0\":{\"1025\":1}}],[\"系统中可以有多个category\",{\"1\":{\"1022\":1}}],[\"系统中一切事物皆为对象\",{\"1\":{\"445\":1}}],[\"系统将先执行派生类对象的析构函数\",{\"1\":{\"949\":1}}],[\"系统运行中\",{\"1\":{\"843\":1}}],[\"系统首先通过派生类的构造函数来调用\",{\"1\":{\"665\":1}}],[\"系统还会调用类中的拷贝构造函数来构造形参对象\",{\"1\":{\"615\":1}}],[\"系统会在内存中开辟空间用来存储形参变量\",{\"1\":{\"615\":1}}],[\"系统会提供一个默认构造函数\",{\"1\":{\"420\":1}}],[\"系统调用terminate后退出程序\",{\"1\":{\"608\":1}}],[\"系统调用实现\",{\"1\":{\"282\":1}}],[\"系统就会执行默认的操作\",{\"1\":{\"597\":1}}],[\"系统能够区分它们\",{\"1\":{\"582\":1}}],[\"系统也会自动调用point类的默认构造函数\",{\"1\":{\"434\":1}}],[\"系统也会提供一个默认的析构函数\",{\"1\":{\"425\":1}}],[\"系统把一个浮点型数据分成小数部分和指数部分\",{\"1\":{\"339\":1}}],[\"智能锁\",{\"1\":{\"1202\":1}}],[\"智能指针第二个参数传入函数对象可以重置析构函数\",{\"1\":{\"1870\":1}}],[\"智能指针shared\",{\"1\":{\"1863\":1}}],[\"智能指针析构函数放回队列\",{\"1\":{\"1859\":1}}],[\"智能指针的思想\",{\"1\":{\"1210\":1}}],[\"智能指针案例\",{\"0\":{\"1182\":1}}],[\"智能指针ps出函数作用域自动析构\",{\"1\":{\"1057\":1}}],[\"智能指针ps提升成功\",{\"1\":{\"1057\":1}}],[\"智能指针使用时\",{\"1\":{\"1042\":1}}],[\"智能指针初始化的是一个对象\",{\"1\":{\"1041\":1}}],[\"智能指针体现在把裸指针进行了一次面向对象的封装\",{\"1\":{\"1041\":1}}],[\"智能指针就是对普通指针的一个封装\",{\"1\":{\"1041\":1}}],[\"智能指针本身是一个类模板\",{\"1\":{\"1041\":1}}],[\"智能指针\",{\"0\":{\"1041\":1,\"1196\":1,\"1937\":1},\"1\":{\"1171\":1},\"2\":{\"1049\":1,\"1052\":1,\"1059\":1,\"1062\":1}}],[\"智能插座等等相关的小米产品簇\",{\"1\":{\"866\":1}}],[\"智能手环\",{\"1\":{\"866\":1}}],[\"肯定记录我们刚才的数据更改操作\",{\"1\":{\"1773\":1}}],[\"肯定不大于\",{\"1\":{\"1102\":1}}],[\"肯定都有自己的汽车生产工厂\",{\"1\":{\"866\":1}}],[\"肯定无法分配虚拟地址\",{\"1\":{\"249\":1}}],[\"传不进来\",{\"1\":{\"1219\":1,\"1227\":1}}],[\"传给了\",{\"1\":{\"1167\":1}}],[\"传递时按\",{\"1\":{\"1067\":1}}],[\"传入一个互斥锁\",{\"1\":{\"1219\":1}}],[\"传入一个线程函数\",{\"1\":{\"1207\":1}}],[\"传入线程所需要的线程函数和参数\",{\"1\":{\"1204\":1}}],[\"传入的是起始和末尾的后继的迭代器\",{\"1\":{\"1147\":1}}],[\"传入函数对象greater\",{\"1\":{\"1007\":1}}],[\"传入工厂的参数不正确\",{\"1\":{\"864\":1}}],[\"传输丢失的这个分片即可\",{\"1\":{\"22\":1}}],[\"工程编译生成的版本\",{\"1\":{\"1310\":1}}],[\"工程的根目录\",{\"1\":{\"1310\":1}}],[\"工厂方法为每一种产品提供相应的实例工厂进行对象创建\",{\"1\":{\"866\":1}}],[\"工厂方法主要是封装了对象的创建\",{\"1\":{\"861\":1}}],[\"工厂方法和抽象工厂是属于标准的23种设计模式的\",{\"1\":{\"861\":1}}],[\"工厂方法\",{\"0\":{\"860\":1,\"865\":1,\"868\":1},\"1\":{\"867\":3}}],[\"工具和基本命令\",{\"0\":{\"1944\":1}}],[\"工具启动时先处理主cmakelist\",{\"1\":{\"1309\":1}}],[\"工具\",{\"1\":{\"309\":1}}],[\"工具内容\",{\"0\":{\"4\":1}}],[\"工具分享\",{\"0\":{\"2\":1}}],[\"懒汉模式\",{\"1\":{\"856\":1,\"857\":1}}],[\"懒汉式\",{\"0\":{\"843\":1},\"1\":{\"842\":1}}],[\"饱汉模式\",{\"1\":{\"856\":1,\"857\":1}}],[\"饿汉模式\",{\"1\":{\"856\":1,\"857\":1}}],[\"饿汉实现\",{\"1\":{\"851\":1}}],[\"饿汉式单例\",{\"0\":{\"851\":1}}],[\"饿汉式\",{\"0\":{\"844\":1},\"1\":{\"842\":1,\"1878\":1}}],[\"好象是数据库可以提供同一数据的多个版本\",{\"1\":{\"1656\":1}}],[\"好不容易从内存上跑到cpu上\",{\"1\":{\"1233\":1}}],[\"好处\",{\"1\":{\"982\":1,\"1609\":1}}],[\"好处是做数据备份以后\",{\"1\":{\"1780\":1}}],[\"好处是\",{\"1\":{\"848\":1,\"1148\":1}}],[\"好好相处\",{\"1\":{\"876\":1}}],[\"好吧\",{\"1\":{\"528\":1}}],[\"浪费内存\",{\"1\":{\"844\":1}}],[\"浪费大量时间和人力\",{\"1\":{\"3\":1}}],[\"线上项目支持专门的搜索功能\",{\"1\":{\"1610\":1}}],[\"线程处理函数\",{\"1\":{\"1875\":1}}],[\"线程处理函数则定时检查队头元素\",{\"1\":{\"1859\":1}}],[\"线程同步通信和\",{\"1\":{\"1863\":1}}],[\"线程互斥\",{\"1\":{\"1863\":1}}],[\"线程对象\",{\"1\":{\"1849\":1,\"1859\":1,\"1875\":1}}],[\"线程获取多个相同资源锁的时候应该\",{\"1\":{\"1707\":1}}],[\"线程缓存可以加快线程运行的效率\",{\"1\":{\"1233\":1}}],[\"线程相当于还是就绪状态\",{\"1\":{\"1233\":1}}],[\"线程出让当前的cpu时间片\",{\"1\":{\"1233\":1}}],[\"线程\",{\"1\":{\"1233\":1}}],[\"线程没有做完的话\",{\"1\":{\"1232\":1}}],[\"线程继续往下执行\",{\"1\":{\"1229\":1}}],[\"线程继续执行下面的指令\",{\"1\":{\"1208\":1}}],[\"线程函数代码和后面的main函数代码都是不会变的\",{\"1\":{\"1219\":1}}],[\"线程2就可以继续向下执行了\",{\"1\":{\"1218\":1}}],[\"线程2要做的事情必须先依赖于线程1完成部分的事情\",{\"1\":{\"1218\":1}}],[\"线程1和线程2一起运行\",{\"1\":{\"1218\":1}}],[\"线程1和线程2是根据cpu调度算法来的\",{\"1\":{\"1218\":1}}],[\"线程阻塞住\",{\"1\":{\"1208\":1}}],[\"线程在运行完每个指令的时候\",{\"1\":{\"1208\":1}}],[\"线程间不通信的话\",{\"1\":{\"1218\":1}}],[\"线程间的运行顺序是不确定的\",{\"1\":{\"1218\":1}}],[\"线程间的同步通信\",{\"0\":{\"1218\":1}}],[\"线程间的互斥\",{\"0\":{\"1217\":1}}],[\"线程间的通信\",{\"1\":{\"1202\":1}}],[\"线程间互斥\",{\"0\":{\"1208\":1}}],[\"线程就结束了\",{\"1\":{\"1205\":1}}],[\"线程自动开启\",{\"1\":{\"1204\":1}}],[\"线程内容\",{\"1\":{\"1203\":1}}],[\"线程池\",{\"2\":{\"1153\":1}}],[\"线程池类\",{\"1\":{\"1151\":1}}],[\"线程类\",{\"1\":{\"1151\":1,\"1202\":1}}],[\"线程id\",{\"1\":{\"1021\":1}}],[\"线程不安全\",{\"0\":{\"846\":1}}],[\"线程安全的单例\",{\"1\":{\"1878\":1}}],[\"线程安全的懒汉单例函数接口\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":2}}],[\"线程安全的\",{\"1\":{\"1202\":1}}],[\"线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行\",{\"1\":{\"839\":1}}],[\"线程安全\",{\"0\":{\"838\":1,\"847\":1,\"851\":1},\"1\":{\"844\":1,\"1032\":1}}],[\"线性顺序结构\",{\"1\":{\"354\":1}}],[\"线性搜索o\",{\"1\":{\"100\":1}}],[\"线性表是有序表\",{\"1\":{\"91\":1}}],[\"确定是否有某些数据被加了行锁\",{\"1\":{\"1672\":1}}],[\"确保事务的原子性redo\",{\"1\":{\"1757\":1}}],[\"确保事务的持久性\",{\"1\":{\"1679\":1,\"1757\":1,\"1758\":2}}],[\"确保clean总是被执行\",{\"1\":{\"1365\":1}}],[\"确保实例的唯一性\",{\"1\":{\"841\":1}}],[\"确保该类的唯一性\",{\"1\":{\"836\":1}}],[\"确认\",{\"1\":{\"60\":1}}],[\"买一个转换头\",{\"1\":{\"832\":1}}],[\"刚开始多数项目用单机数据库就够了\",{\"1\":{\"1885\":1}}],[\"刚开始也是不行\",{\"1\":{\"45\":1}}],[\"刚才的第二维移动到第一维中间部分\",{\"1\":{\"968\":1}}],[\"刚好\",{\"1\":{\"832\":1}}],[\"投影仪也是vga接口\",{\"1\":{\"832\":2}}],[\"投影仪上\",{\"1\":{\"832\":2}}],[\"投影到\",{\"1\":{\"832\":2}}],[\"装饰器1\",{\"1\":{\"831\":1}}],[\"装饰器模式属于结构型设计模式\",{\"1\":{\"829\":1}}],[\"装饰器模式\",{\"0\":{\"829\":1,\"831\":1},\"1\":{\"831\":1}}],[\"太麻烦\",{\"1\":{\"831\":1}}],[\"您目前没有券\",{\"1\":{\"830\":2}}],[\"您目前只是普通游客\",{\"1\":{\"830\":1}}],[\"您实际上是在尝试将一个指向非const指针的指针赋值给一个指向const指针的指针\",{\"1\":{\"490\":1}}],[\"免费电影\",{\"1\":{\"830\":4}}],[\"委托类\",{\"1\":{\"830\":2}}],[\"助理proxy\",{\"1\":{\"830\":1}}],[\"客户端就需要去连接不同的逻辑库了\",{\"1\":{\"1888\":1}}],[\"客户端只需要去处理代理服务器上的db就可以了\",{\"1\":{\"1809\":1}}],[\"客户端实际上区分不出来连的是mycat还是mysql\",{\"1\":{\"1791\":1}}],[\"客户端读数据的请求最终会转发到从库上\",{\"1\":{\"1781\":1}}],[\"客户直接访问代理对象\",{\"1\":{\"830\":1}}],[\"客户\",{\"1\":{\"830\":1}}],[\"客户是直接访问代理类的\",{\"1\":{\"830\":1}}],[\"客户是不能直接使用委托类的\",{\"1\":{\"830\":1}}],[\"适当的设置可以提高导入的效率\",{\"1\":{\"1728\":1}}],[\"适合使用表索的情况\",{\"0\":{\"1670\":1}}],[\"适得其反\",{\"1\":{\"1609\":1}}],[\"适配器底层没有自己的数据结构\",{\"1\":{\"989\":1}}],[\"适配器\",{\"1\":{\"832\":1}}],[\"适配器模式\",{\"0\":{\"829\":1,\"832\":1},\"1\":{\"829\":1,\"832\":2}}],[\"适用于所有同学\",{\"0\":{\"1279\":1}}],[\"适用于使用路由器连接网络的同学\",{\"0\":{\"1278\":1}}],[\"适用于\",{\"1\":{\"95\":1}}],[\"末尾可以没有分号\",{\"1\":{\"1376\":1}}],[\"末尾节点的next指向头节点\",{\"1\":{\"823\":1}}],[\"末尾节点的next是null\",{\"1\":{\"820\":1}}],[\"末尾节点的指针域指向了头节点\",{\"1\":{\"818\":1}}],[\"末尾节点的指针域是null\",{\"1\":{\"816\":1}}],[\"末尾位置增加\",{\"1\":{\"100\":1}}],[\"排它锁\",{\"1\":{\"1697\":1}}],[\"排它锁和共享锁\",{\"0\":{\"1697\":1}}],[\"排在第\",{\"1\":{\"812\":1}}],[\"排序时内存开销较大\",{\"1\":{\"1736\":1}}],[\"排序时无法用到索引\",{\"1\":{\"1618\":1}}],[\"排序order\",{\"0\":{\"1525\":1}}],[\"排序查询\",{\"0\":{\"1496\":1}}],[\"排序算法\",{\"0\":{\"1922\":1},\"2\":{\"190\":1,\"193\":1,\"198\":1,\"201\":1,\"204\":1,\"207\":1,\"216\":1,\"219\":1,\"222\":1}}],[\"排序\",{\"0\":{\"179\":1},\"1\":{\"194\":1}}],[\"排序之后如果第一个元素已经大于零\",{\"1\":{\"133\":1}}],[\"排序的时间复杂度是\",{\"1\":{\"126\":1}}],[\"社长抽取一个数字\",{\"1\":{\"812\":1}}],[\"社团共有\",{\"1\":{\"812\":1}}],[\"破冰游戏\",{\"1\":{\"812\":1}}],[\"问怎样排法\",{\"1\":{\"811\":1}}],[\"问题发生原因如下\",{\"1\":{\"1830\":1}}],[\"问题来了\",{\"1\":{\"1718\":1}}],[\"问题9\",{\"0\":{\"1594\":1}}],[\"问题8\",{\"0\":{\"1593\":1}}],[\"问题7\",{\"0\":{\"1592\":1}}],[\"问题6\",{\"0\":{\"1591\":1}}],[\"问题5\",{\"0\":{\"1590\":1}}],[\"问题4\",{\"0\":{\"1589\":1}}],[\"问题3\",{\"0\":{\"1588\":1}}],[\"问题就是main线程中的isready改成true后\",{\"1\":{\"1233\":1}}],[\"问题的四种方法及详解注释\",{\"1\":{\"811\":1}}],[\"问题\",{\"0\":{\"716\":1},\"1\":{\"1148\":1,\"1207\":1,\"1208\":1,\"1209\":1,\"1232\":1,\"1511\":1,\"1686\":1,\"1889\":1}}],[\"问题二\",{\"0\":{\"716\":1,\"980\":1,\"994\":1}}],[\"问题一\",{\"0\":{\"712\":1,\"979\":1,\"993\":1}}],[\"问题分析\",{\"0\":{\"383\":1}}],[\"问题2\",{\"0\":{\"1587\":1},\"1\":{\"234\":2}}],[\"问题1\",{\"0\":{\"1586\":1},\"1\":{\"234\":2}}],[\"围坐在一张圆桌周围\",{\"1\":{\"810\":1}}],[\"情景三\",{\"0\":{\"812\":1}}],[\"情景二\",{\"0\":{\"811\":1}}],[\"情景一\",{\"0\":{\"810\":1}}],[\"情况4\",{\"1\":{\"511\":1}}],[\"情况3\",{\"1\":{\"511\":1}}],[\"情况2\",{\"0\":{\"714\":1},\"1\":{\"511\":1}}],[\"情况1\",{\"0\":{\"713\":1},\"1\":{\"511\":1}}],[\"情况下\",{\"1\":{\"440\":1}}],[\"情况⼆\",{\"1\":{\"147\":2}}],[\"情况⼀\",{\"1\":{\"147\":2}}],[\"恰好是链表的头节点和尾节点时\",{\"1\":{\"802\":1}}],[\"截取链表\",{\"1\":{\"802\":1}}],[\"截取子串\",{\"1\":{\"536\":1}}],[\"切分到多张表里面去\",{\"1\":{\"1890\":1}}],[\"切换到另一个master上\",{\"1\":{\"1803\":1}}],[\"切换的类型\",{\"1\":{\"1803\":1}}],[\"切换数据库\",{\"1\":{\"1773\":1}}],[\"切换窗口\",{\"1\":{\"1139\":1}}],[\"切断出一个子链表\",{\"1\":{\"802\":1}}],[\"切记不要写=\",{\"1\":{\"783\":1}}],[\"步\",{\"1\":{\"802\":7}}],[\"步骤\",{\"0\":{\"213\":1},\"1\":{\"756\":1}}],[\"步骤如下\",{\"1\":{\"46\":1,\"1573\":1}}],[\"穿针引线\",{\"0\":{\"802\":1,\"803\":1}}],[\"半字\",{\"1\":{\"1347\":1}}],[\"半圆锥以及半球体的多态基础上\",{\"1\":{\"882\":1}}],[\"半圆形继承问题\",{\"1\":{\"688\":1}}],[\"半\",{\"1\":{\"792\":1}}],[\"倒数第k+1\",{\"1\":{\"787\":1}}],[\"倒叙遍历序列\",{\"1\":{\"213\":1}}],[\"拼接子链表和原链表\",{\"1\":{\"787\":1}}],[\"旋转链表\",{\"0\":{\"787\":1},\"1\":{\"787\":2}}],[\"`tb\",{\"1\":{\"1729\":1}}],[\"`auto\",{\"1\":{\"1481\":1}}],[\"`wget\",{\"1\":{\"1253\":1}}],[\"`\",{\"1\":{\"784\":1}}],[\"翻转\",{\"1\":{\"777\":1}}],[\"暂且不管记不记得住\",{\"1\":{\"861\":1}}],[\"暂存p1的下一个结点的位置\",{\"1\":{\"777\":1}}],[\"暂时没必要\",{\"1\":{\"6\":1}}],[\"借书\",{\"1\":{\"1168\":2}}],[\"借助pre和next指针完成插入和删除\",{\"1\":{\"792\":1}}],[\"借助重载\",{\"1\":{\"560\":1}}],[\"借用2\",{\"1\":{\"774\":1}}],[\"走的是虚函数机制还是非虚函数机制\",{\"1\":{\"890\":1}}],[\"走一步\",{\"1\":{\"771\":2}}],[\"走位自己的链表后返回走另一个\",{\"1\":{\"771\":1}}],[\"环境准备\",{\"0\":{\"1796\":1}}],[\"环境变量如搜索头文件或库文件时默认的路径\",{\"1\":{\"267\":1}}],[\"环境变量\",{\"1\":{\"267\":1}}],[\"环形链表\",{\"0\":{\"765\":1,\"768\":1},\"1\":{\"765\":1,\"768\":1}}],[\"链地址法\",{\"1\":{\"1603\":1}}],[\"链表增加删除一个结点本身为o\",{\"1\":{\"974\":1}}],[\"链表容器\",{\"1\":{\"970\":1}}],[\"链表设计\",{\"1\":{\"822\":1}}],[\"链表搜索效率不高\",{\"1\":{\"815\":1}}],[\"链表基础知识\",{\"0\":{\"815\":1}}],[\"链表的分解\",{\"0\":{\"795\":1},\"1\":{\"795\":1}}],[\"链表的中间结点\",{\"0\":{\"798\":1},\"1\":{\"756\":1,\"798\":1}}],[\"链表末尾\",{\"1\":{\"771\":2}}],[\"链表并返回\",{\"1\":{\"762\":1}}],[\"链表\",{\"0\":{\"1931\":1},\"1\":{\"771\":2},\"2\":{\"758\":1,\"761\":1,\"764\":1,\"767\":1,\"770\":1,\"773\":1,\"776\":1,\"779\":1,\"786\":1,\"789\":1,\"794\":1,\"797\":1,\"800\":1,\"805\":1,\"808\":1,\"814\":1,\"825\":1}}],[\"链表长度若为偶数\",{\"1\":{\"756\":1}}],[\"链接目标文件生成最终程序\",{\"1\":{\"1365\":1}}],[\"链接器\",{\"1\":{\"1855\":2}}],[\"链接器接受\",{\"1\":{\"1335\":1}}],[\"链接器通常接受一些选项来控制它应该优先链接到哪种类型的库\",{\"1\":{\"1335\":1}}],[\"链接器选项\",{\"1\":{\"1335\":1}}],[\"链接器默认会优先链接到\",{\"1\":{\"1335\":1}}],[\"链接动态库\",{\"1\":{\"1331\":1}}],[\"链接静态库\",{\"1\":{\"1331\":1}}],[\"链接指定的库\",{\"1\":{\"1328\":1}}],[\"链接到其他文件夹\",{\"1\":{\"1271\":1}}],[\"链接时会产生链接错误\",{\"1\":{\"562\":1}}],[\"链接时就是在符号表中找对应的符号是否只出现于\",{\"1\":{\"255\":1}}],[\"链接成目标二进制文件之后即可运\",{\"1\":{\"302\":1}}],[\"链接过程\",{\"1\":{\"255\":1}}],[\"链接的核心\",{\"1\":{\"255\":1}}],[\"链接的过程🍔🍔🍔\",{\"0\":{\"255\":1}}],[\"链接的两个步骤做的是什么事情\",{\"1\":{\"244\":1}}],[\"链接阶段\",{\"0\":{\"254\":1}}],[\"链接主要工作🍔\",{\"0\":{\"245\":1}}],[\"额外空间的方法就是改变输入\",{\"1\":{\"756\":1}}],[\"头节点的pre指向末尾节点\",{\"1\":{\"823\":1}}],[\"头节点的pre是null\",{\"1\":{\"820\":1}}],[\"头插法\",{\"0\":{\"803\":1}}],[\"头插法归还空间\",{\"1\":{\"751\":1}}],[\"头插\",{\"1\":{\"777\":1}}],[\"头文件\",{\"1\":{\"850\":1,\"851\":1,\"1315\":1}}],[\"头文件只有接口和一个数据指针\",{\"1\":{\"826\":1}}],[\"头文件中只存放\",{\"1\":{\"574\":1}}],[\"头文件包含\",{\"1\":{\"311\":1}}],[\"插入数据的操作都记录在mysql\",{\"1\":{\"1774\":1}}],[\"插入id无序排列数据\",{\"1\":{\"1729\":1}}],[\"插入id顺序排列数据\",{\"1\":{\"1729\":1}}],[\"插入\",{\"1\":{\"1693\":2}}],[\"插入权限\",{\"1\":{\"1485\":1,\"1486\":1}}],[\"插入成功\",{\"1\":{\"1008\":1}}],[\"插入和删除节点不需要移动其它节点\",{\"1\":{\"815\":1}}],[\"插入后\",{\"1\":{\"790\":1}}],[\"插入后要返回下一个位置\",{\"1\":{\"746\":1}}],[\"插入排序\",{\"0\":{\"205\":1}}],[\"插入排序的gap\",{\"1\":{\"199\":1}}],[\"失败为null\",{\"1\":{\"1374\":1}}],[\"失败返回\",{\"1\":{\"84\":1}}],[\"失效问题2\",{\"0\":{\"743\":1}}],[\"失效问题1\",{\"0\":{\"742\":1}}],[\"条记录\",{\"1\":{\"1686\":1}}],[\"条件限制不能让filesort消失\",{\"1\":{\"1736\":1}}],[\"条件过滤\",{\"0\":{\"1541\":1}}],[\"条件成立了\",{\"1\":{\"1229\":1}}],[\"条件变量cv\",{\"1\":{\"1227\":1}}],[\"条件变量的头文件\",{\"1\":{\"1219\":1}}],[\"条件变量\",{\"1\":{\"1202\":1,\"1219\":1}}],[\"条件运算符\",{\"1\":{\"728\":1}}],[\"条款\",{\"1\":{\"503\":1}}],[\"域运算符\",{\"1\":{\"728\":1}}],[\"格式化日期时间等\",{\"1\":{\"1443\":1}}],[\"格式\",{\"1\":{\"727\":1,\"1347\":2,\"1361\":1}}],[\"格式如下\",{\"1\":{\"435\":1}}],[\"友元实现单例对象的自动释放\",{\"1\":{\"854\":1}}],[\"友元的声明是不受public\",{\"1\":{\"724\":1}}],[\"友元的性质\",{\"0\":{\"724\":1}}],[\"友元的形式可以分为友元函数和友元类\",{\"1\":{\"721\":1}}],[\"友元类\",{\"0\":{\"723\":1}}],[\"友元函数\",{\"0\":{\"722\":1},\"1\":{\"876\":1}}],[\"友元之友元类\",{\"1\":{\"721\":1}}],[\"友元之成员函数\",{\"1\":{\"721\":1}}],[\"友元之普通函数\",{\"1\":{\"721\":1}}],[\"友元\",{\"0\":{\"721\":1}}],[\"友元关系是单向的\",{\"1\":{\"724\":1}}],[\"友元关系\",{\"1\":{\"685\":1}}],[\"咱们只需要\",{\"1\":{\"717\":1}}],[\"测试水平分表\",{\"0\":{\"1892\":1}}],[\"测试的时候可以先变成共有的\",{\"1\":{\"1839\":1,\"1848\":1,\"1875\":1,\"1878\":1}}],[\"测试行锁加在索引项上\",{\"0\":{\"1700\":1}}],[\"测试不同事务之间排它锁和共享锁的兼容性\",{\"0\":{\"1699\":1}}],[\"测试不能重复的主键索引\",{\"0\":{\"1692\":1}}],[\"测试能重复的辅助索引\",{\"0\":{\"1693\":1}}],[\"测试等值间隙锁\",{\"0\":{\"1691\":1}}],[\"测试辅助索引树上\",{\"1\":{\"1689\":1}}],[\"测试间隙锁\",{\"0\":{\"1689\":1}}],[\"测试间隙锁范围加锁\",{\"0\":{\"1687\":1}}],[\"测试幻读\",{\"1\":{\"1635\":1}}],[\"测试transaction\",{\"0\":{\"1634\":1,\"1635\":1,\"1636\":1}}],[\"测试read\",{\"0\":{\"1633\":1}}],[\"测试用例\",{\"0\":{\"1031\":1}}],[\"测试虚表的存在\",{\"0\":{\"894\":1}}],[\"测试6\",{\"1\":{\"747\":1}}],[\"测试5\",{\"1\":{\"747\":1}}],[\"测试4\",{\"1\":{\"747\":1}}],[\"测试3\",{\"1\":{\"747\":1}}],[\"测试2\",{\"1\":{\"747\":1}}],[\"测试成功\",{\"1\":{\"747\":4,\"999\":2,\"1000\":5,\"1002\":2,\"1011\":1}}],[\"测试1\",{\"1\":{\"747\":1}}],[\"测试sizeof是运算符\",{\"0\":{\"729\":1},\"1\":{\"729\":1}}],[\"测试结果\",{\"1\":{\"714\":2,\"747\":5,\"1007\":3,\"1008\":1,\"1206\":1}}],[\"测试一下\",{\"1\":{\"713\":1}}],[\"混用\",{\"1\":{\"714\":1}}],[\"平衡了数据的安全性\",{\"1\":{\"1712\":1}}],[\"平台相关性的函数\",{\"1\":{\"857\":1}}],[\"平台原因\",{\"1\":{\"553\":1}}],[\"平常我们new与delete都是正常使用的\",{\"0\":{\"712\":1}}],[\"剖析new和delete实现原理\",{\"0\":{\"707\":1}}],[\"返沪容器末尾元素后继位置的迭代器的表示\",{\"1\":{\"699\":1}}],[\"返回存活的时间\",{\"1\":{\"1846\":1,\"1859\":1}}],[\"返回当前读的记录\",{\"1\":{\"1656\":1}}],[\"返回当前的日期和时间\",{\"1\":{\"1443\":1}}],[\"返回数据不唯一的等值查找也会出现\",{\"1\":{\"1618\":1}}],[\"返回数组中第一个小于被查数的值\",{\"1\":{\"163\":1}}],[\"返回数组中第一个小于或等于被查数的值\",{\"1\":{\"163\":1}}],[\"返回数组中第一个大于被查数的值\",{\"1\":{\"163\":1}}],[\"返回数组中第一个大于或等于被查数的值\",{\"1\":{\"163\":1}}],[\"返回记录一定是1行记录的等值where条件时\",{\"1\":{\"1618\":1}}],[\"返回不满足条件的部分\",{\"1\":{\"1470\":1}}],[\"返回日期date的unix时间戳\",{\"1\":{\"1443\":1}}],[\"返回错误信息描述\",{\"1\":{\"1382\":1}}],[\"返回错误码\",{\"1\":{\"1382\":1}}],[\"返回为null\",{\"1\":{\"1379\":1}}],[\"返回为const\",{\"1\":{\"699\":1}}],[\"返回end\",{\"1\":{\"1148\":1}}],[\"返回临时对象\",{\"1\":{\"1116\":1}}],[\"返回对象是\",{\"1\":{\"1067\":1}}],[\"返回key为15的元素的个数\",{\"1\":{\"999\":2}}],[\"返回元素值为val的个数\",{\"1\":{\"999\":1}}],[\"返回元素个数\",{\"1\":{\"990\":1,\"992\":1}}],[\"返回智能指针\",{\"0\":{\"849\":1}}],[\"返回普通指针\",{\"0\":{\"848\":1}}],[\"返回合并后的链表\",{\"1\":{\"780\":1}}],[\"返回链表开始入环的第一个节点\",{\"1\":{\"768\":1}}],[\"返回新的头节点\",{\"1\":{\"759\":1}}],[\"返回新数组\",{\"1\":{\"87\":1}}],[\"返回新数组长度\",{\"1\":{\"76\":1}}],[\"返回第一个结点\",{\"1\":{\"756\":1}}],[\"返回第二个结点\",{\"1\":{\"756\":1}}],[\"返回结果\",{\"1\":{\"756\":1}}],[\"返回字符串底层管理的char\",{\"1\":{\"699\":1}}],[\"返回它底层的迭代器的表示\",{\"1\":{\"698\":1}}],[\"返回nullptr\",{\"1\":{\"631\":2}}],[\"返回derive2对象地址\",{\"1\":{\"631\":2}}],[\"返回dest\",{\"1\":{\"535\":1}}],[\"返回非0表示出错\",{\"1\":{\"598\":1}}],[\"返回一个c风格字符串\",{\"1\":{\"538\":1}}],[\"返回空指针\",{\"1\":{\"535\":2}}],[\"返回负数\",{\"1\":{\"535\":1}}],[\"返回正数\",{\"1\":{\"535\":1}}],[\"返回0表示出错\",{\"1\":{\"598\":1}}],[\"返回0\",{\"1\":{\"535\":1}}],[\"返回str的长度\",{\"1\":{\"535\":1}}],[\"返回的结果是绑定器\",{\"1\":{\"1154\":2}}],[\"返回的结果还是一个函数对象\",{\"1\":{\"1154\":1}}],[\"返回的结果还是一个\",{\"1\":{\"1154\":1}}],[\"返回的变量其生命周期一定是要大于函数的生命周期的\",{\"1\":{\"616\":1}}],[\"返回的地址再往前移4个字节便可以拿到要析构的对象个数了\",{\"1\":{\"520\":1}}],[\"返回的是分配的\",{\"1\":{\"1099\":1}}],[\"返回的是首元素前驱位置的迭代器的表示\",{\"1\":{\"1011\":1}}],[\"返回的是最后一个元素的反向迭代器的表示\",{\"1\":{\"1011\":1}}],[\"返回的是成员属性的记得加const\",{\"1\":{\"449\":1}}],[\"返回的是查找到的第一个元素位置的迭代器\",{\"1\":{\"162\":1}}],[\"返回类型是指针的函数\",{\"1\":{\"493\":1}}],[\"返回类型\",{\"1\":{\"362\":1,\"449\":1,\"463\":1,\"898\":1,\"912\":2}}],[\"返回容器底层有效元素的个数\",{\"1\":{\"965\":1,\"969\":1,\"970\":1}}],[\"返回容器底层首元素迭代器的表示\",{\"1\":{\"699\":1}}],[\"返回容器中元素个数\",{\"1\":{\"355\":1,\"385\":1,\"704\":1,\"999\":1}}],[\"返回容器末尾元素值\",{\"1\":{\"355\":1,\"385\":1,\"704\":1}}],[\"返回值是一个类\",{\"1\":{\"1871\":1}}],[\"返回值是void\",{\"1\":{\"1154\":1}}],[\"返回值为string目的是为了可以连等于操作\",{\"1\":{\"736\":1}}],[\"返回值不要求\",{\"1\":{\"694\":1}}],[\"返回值不同不能区分函数\",{\"1\":{\"692\":1}}],[\"返回值自动转为指定的类型的指针\",{\"1\":{\"513\":1,\"708\":1}}],[\"返回值\",{\"1\":{\"286\":1,\"287\":1,\"915\":1,\"1189\":1,\"1374\":1,\"1376\":1}}],[\"返回下标为pos的元素\",{\"1\":{\"539\":2}}],[\"返回下标\",{\"1\":{\"214\":1}}],[\"返回队列元素个数\",{\"1\":{\"991\":1}}],[\"返回队列是否为空\",{\"1\":{\"182\":1}}],[\"返回队列首部的元素\",{\"1\":{\"182\":1}}],[\"返回其中的多数元素\",{\"1\":{\"113\":1}}],[\"返回该值第一个出现或者最后一个出现的下标\",{\"1\":{\"95\":1}}],[\"返回该矩阵\",{\"1\":{\"81\":1}}],[\"返回\",{\"1\":{\"59\":1,\"158\":2,\"161\":2,\"169\":1,\"174\":1,\"182\":3,\"464\":1,\"548\":1,\"735\":1,\"754\":2,\"771\":1,\"801\":1,\"1090\":2}}],[\"迭代器iterator\",{\"0\":{\"1011\":1}}],[\"迭代器it就失效了\",{\"1\":{\"742\":1}}],[\"迭代器删除元素\",{\"1\":{\"999\":1}}],[\"迭代器遍历容器\",{\"1\":{\"999\":1}}],[\"迭代器指向的位置进行元素删除\",{\"1\":{\"969\":1,\"970\":1}}],[\"迭代器指向的位置添加元素\",{\"1\":{\"969\":1,\"970\":1}}],[\"迭代器进行遍历\",{\"1\":{\"965\":1,\"966\":4,\"969\":1,\"970\":1}}],[\"迭代器为空或迭代两个不同容器\",{\"1\":{\"747\":1}}],[\"迭代器失效\",{\"1\":{\"747\":3}}],[\"迭代器失效情况\",{\"0\":{\"741\":1}}],[\"迭代器失效问题\",{\"0\":{\"740\":1}}],[\"迭代器失效的底层核心原理\",{\"0\":{\"739\":1},\"1\":{\"965\":2}}],[\"迭代器一般实现成容器的嵌套类型\",{\"1\":{\"704\":1}}],[\"迭代器\",{\"1\":{\"1007\":1},\"2\":{\"703\":1,\"706\":1,\"749\":1}}],[\"迭代器前置++\",{\"1\":{\"699\":1}}],[\"迭代器解引用访问的就是容器底层数据\",{\"1\":{\"698\":1}}],[\"迭代器还需要提供\",{\"1\":{\"698\":1}}],[\"迭代器名\",{\"1\":{\"698\":4}}],[\"迭代器按照定义方式分成以下四种\",{\"1\":{\"698\":1}}],[\"迭代器和指针类似\",{\"1\":{\"698\":1}}],[\"迭代器可以指向容器中的某个元素\",{\"1\":{\"698\":1}}],[\"迭代器是一个变量\",{\"1\":{\"698\":1}}],[\"⽽\",{\"1\":{\"695\":1}}],[\"⽽基类指针只能调⽤基类的被隐藏函数\",{\"1\":{\"695\":1}}],[\"⽆法识别⼦类\",{\"1\":{\"695\":1}}],[\"⽆法识别派⽣类中的隐藏函数\",{\"1\":{\"695\":1}}],[\"⽆法修改\",{\"1\":{\"489\":1}}],[\"⽆论基类函数是不是虚函数\",{\"1\":{\"695\":1}}],[\"派⽣类中的函数屏蔽了基类中的\",{\"1\":{\"695\":1}}],[\"派生\",{\"1\":{\"657\":1}}],[\"派生方式对基类成员的访问权限\",{\"0\":{\"656\":1}}],[\"派生列表\",{\"1\":{\"651\":1}}],[\"派生类重写的函数的入口地址应该在基类的函数入口地址的下面\",{\"1\":{\"958\":1}}],[\"派生类重定义\",{\"1\":{\"916\":1}}],[\"派生类虚函数表\",{\"1\":{\"954\":1}}],[\"派生类引用调用派生类对象\",{\"1\":{\"920\":1}}],[\"派生类指针调用派生类对象\",{\"1\":{\"920\":1}}],[\"派生类对虚函数的重定义\",{\"0\":{\"913\":1}}],[\"派生类对象越多\",{\"1\":{\"886\":1}}],[\"派生类对象的指针和引用也适应于基类对象的指针和引用\",{\"1\":{\"678\":1}}],[\"派生类对象的销毁\",{\"0\":{\"675\":1}}],[\"派生类对象间的复制控制\",{\"0\":{\"662\":1}}],[\"派生类中会将vfptr<\",{\"1\":{\"908\":1}}],[\"派生类中也有一个vfptr\",{\"1\":{\"908\":1}}],[\"派生类会覆盖基类的虚函数\",{\"1\":{\"889\":1}}],[\"派生类如果有自己的虚函数\",{\"1\":{\"889\":1}}],[\"派生类为24字节\",{\"1\":{\"684\":1}}],[\"派生类适应于基类\",{\"1\":{\"678\":1}}],[\"派生类和基类都有构造函数\",{\"0\":{\"672\":1}}],[\"派生类有构造函数\",{\"0\":{\"671\":1}}],[\"派生类有显式定义构造函数\",{\"0\":{\"669\":1}}],[\"派生类相应的构造函数会被自动调用\",{\"1\":{\"669\":1}}],[\"派生类构造函数体执行\",{\"1\":{\"674\":1}}],[\"派生类构造函数调用顺序\",{\"0\":{\"674\":1}}],[\"派生类构造函数初始化列表不写时\",{\"0\":{\"649\":1}}],[\"派生类构造调用基类构造\",{\"0\":{\"668\":1}}],[\"派生类从基类继承来的成员的初始化和清理由基类的构造函数和析构函数负责\",{\"1\":{\"667\":1}}],[\"派生类名\",{\"1\":{\"666\":1}}],[\"派生类必须\",{\"1\":{\"665\":1}}],[\"派生类定义了后\",{\"1\":{\"662\":1}}],[\"派生类的放在基类后\",{\"1\":{\"958\":1}}],[\"派生类的虚函数表中\",{\"1\":{\"948\":1}}],[\"派生类的析构函数也将自动成为虚析构函数\",{\"1\":{\"949\":1}}],[\"派生类的析构函数自动成为虚函数\",{\"1\":{\"948\":1}}],[\"派生类的析构函数被执行\",{\"1\":{\"675\":1}}],[\"派生类的内存就由这几部分来构成\",{\"1\":{\"937\":1}}],[\"派生类的方法写成私有的可以正常调用吗\",{\"0\":{\"907\":1}}],[\"派生类的生成过程包含3个步骤\",{\"0\":{\"684\":1}}],[\"派生类的对象适应于基类对象\",{\"1\":{\"678\":1}}],[\"派生类的构造函数和析构函数\",{\"1\":{\"667\":1}}],[\"派生类的构造和销毁过程\",{\"0\":{\"665\":1}}],[\"派生类的数据部分\",{\"1\":{\"662\":1}}],[\"派生类的拷贝构造函数或者派生类的赋值函数中\",{\"1\":{\"662\":2}}],[\"派生类的访问权限规则如下\",{\"0\":{\"658\":1}}],[\"派生类初始化列表顺序和派生列表顺序不一致时\",{\"0\":{\"650\":1}}],[\"派生类\",{\"1\":{\"646\":1,\"683\":1}}],[\"⼦类\",{\"1\":{\"693\":1,\"695\":3}}],[\"⽗类\",{\"1\":{\"693\":1,\"695\":3}}],[\"覆盖了\",{\"1\":{\"1896\":1}}],[\"覆盖函数\",{\"1\":{\"695\":1}}],[\"覆盖\",{\"0\":{\"691\":1,\"693\":1},\"1\":{\"695\":1,\"916\":1}}],[\"覆写what成员函数\",{\"1\":{\"606\":1}}],[\"虚析构\",{\"0\":{\"946\":1}}],[\"虚继承与继承的区别\",{\"1\":{\"940\":1}}],[\"虚继承就可以解决多重继承中的菱形继承与半圆形继承出现的问题了\",{\"1\":{\"688\":1}}],[\"虚基类部分会在存在的多个继承链上被多次初始化\",{\"1\":{\"943\":1}}],[\"虚基类位于派生类存储空间的最末尾\",{\"1\":{\"940\":1}}],[\"虚基类的数据一定要在派生类数据最后面\",{\"1\":{\"937\":1}}],[\"虚基类指针\",{\"1\":{\"937\":2}}],[\"虚基类\",{\"1\":{\"931\":1}}],[\"虚基类和虚继承\",{\"0\":{\"930\":1}}],[\"虚基指针的第二条内容表示的是该虚基指针距离虚基类子对象的首地址的偏移\",{\"1\":{\"891\":1}}],[\"虚基指针的第一条内容表示的是该虚基指针距离所在的子对象的首地址的偏移\",{\"1\":{\"891\":1}}],[\"虚基指针所指向的虚基表的内容\",{\"1\":{\"891\":1}}],[\"虚表的地址\",{\"1\":{\"894\":4}}],[\"虚表存在于只读段\",{\"1\":{\"894\":1}}],[\"虚表是存在的\",{\"1\":{\"894\":1}}],[\"虚函数表的地址vfptr\",{\"1\":{\"954\":1}}],[\"虚函数表里的\",{\"1\":{\"954\":1}}],[\"虚函数表中主要存储的内容就是和\",{\"1\":{\"915\":1}}],[\"虚函数名\",{\"1\":{\"925\":1}}],[\"虚函数一样可以通过对象名来调用\",{\"1\":{\"923\":1}}],[\"虚函数机制是如何被激活的呢\",{\"0\":{\"916\":1}}],[\"虚函数描述\",{\"0\":{\"915\":1}}],[\"虚函数就是在基类中被声明为virtual\",{\"1\":{\"912\":1}}],[\"虚函数的调用一定就是动态绑定吗\",{\"0\":{\"927\":1}}],[\"虚函数的访问\",{\"0\":{\"919\":1}}],[\"虚函数的实现是怎样的呢\",{\"1\":{\"914\":1}}],[\"虚函数的实现机制🍗🍗🍗\",{\"0\":{\"914\":1}}],[\"虚函数的定义\",{\"0\":{\"912\":1}}],[\"虚函数的地址\",{\"1\":{\"894\":2}}],[\"虚函数指针也变为0地址\",{\"1\":{\"908\":1}}],[\"虚函数体现多态发生在运行时\",{\"1\":{\"876\":1}}],[\"虚函数\",{\"0\":{\"911\":1},\"1\":{\"695\":1,\"883\":1,\"916\":1,\"923\":2,\"954\":2}}],[\"虚拟机先把数据发送到网关192\",{\"1\":{\"1821\":1}}],[\"虚拟机\",{\"1\":{\"1821\":1}}],[\"虚拟机无法ping通物理机解决方案\",{\"1\":{\"1818\":1}}],[\"虚拟机centos7\",{\"1\":{\"1796\":1}}],[\"虚拟机和电脑在同一网络\",{\"1\":{\"1276\":1}}],[\"虚拟继承时派生类对象的构造和析构\",{\"0\":{\"943\":1}}],[\"虚拟头结点+头插法\",{\"1\":{\"777\":1}}],[\"虚拟头结点\",{\"2\":{\"761\":1,\"764\":1}}],[\"虚拟地址到物理地址\",{\"1\":{\"290\":1}}],[\"虚拟内存\",{\"2\":{\"269\":1}}],[\"虚拟内存空间中\",{\"1\":{\"233\":1}}],[\"虚拟如何理解\",{\"1\":{\"267\":1}}],[\"虚拟\",{\"1\":{\"267\":1,\"283\":1}}],[\"菱形继承内存分布\",{\"0\":{\"939\":1}}],[\"菱形继承\",{\"0\":{\"891\":1}}],[\"菱形继承问题\",{\"0\":{\"688\":1}}],[\"菱形继承的二义性问题\",{\"0\":{\"653\":1}}],[\"吸收基类的成员\",{\"1\":{\"684\":1}}],[\"组成的事务外\",{\"1\":{\"1706\":1}}],[\"组成\",{\"1\":{\"1451\":1}}],[\"组合的方式\",{\"1\":{\"830\":2}}],[\"组合\",{\"1\":{\"682\":1}}],[\"组织对象\",{\"1\":{\"496\":1}}],[\"完整性约束\",{\"0\":{\"1431\":1},\"1\":{\"1610\":2}}],[\"完整的\",{\"1\":{\"1338\":1}}],[\"完成排序之后\",{\"1\":{\"1736\":1}}],[\"完成以后只需要在文件所在目录使用make命令就能运行编译命令\",{\"1\":{\"1352\":1}}],[\"完成对象所占整块内存的开辟\",{\"1\":{\"674\":1}}],[\"完美的解决了智能指针的浅拷贝\",{\"1\":{\"1054\":1}}],[\"完全可以保证两次查询的结果是一样的\",{\"1\":{\"1631\":1}}],[\"完全可以string当成是c++的内置数据类型\",{\"1\":{\"536\":1}}],[\"完全特例化\",{\"1\":{\"1186\":1}}],[\"完全足够\",{\"1\":{\"1102\":1}}],[\"完全一致\",{\"1\":{\"360\":1}}],[\"拷贝数据\",{\"1\":{\"1127\":1}}],[\"拷贝赋值\",{\"1\":{\"662\":1}}],[\"拷贝构造和赋值函数删除掉\",{\"1\":{\"1210\":1}}],[\"拷贝构造和赋值重载的实践\",{\"0\":{\"404\":1}}],[\"拷贝构造函数和赋值构造函数是私有类型\",{\"1\":{\"841\":1}}],[\"拷贝构造函数的调用时机\",{\"0\":{\"398\":1}}],[\"拷贝构造函数\",{\"0\":{\"395\":1,\"400\":1},\"1\":{\"405\":1,\"406\":1,\"463\":2,\"468\":1,\"469\":1,\"1114\":1}}],[\"拷贝构造\",{\"0\":{\"399\":1},\"1\":{\"355\":1,\"385\":2,\"662\":1,\"704\":2,\"1080\":1,\"1087\":1}}],[\"访问频率较高的字段单独放在一张表\",{\"1\":{\"1889\":1}}],[\"访问量比较大\",{\"1\":{\"1864\":1}}],[\"访问mysql\",{\"1\":{\"1790\":1}}],[\"访问mysql完成后\",{\"1\":{\"1745\":1}}],[\"访问表中数据需要的磁盘i\",{\"1\":{\"1752\":1}}],[\"访问不到\",{\"1\":{\"908\":1}}],[\"访问的类型\",{\"1\":{\"1521\":1}}],[\"访问的dog的前4个字节\",{\"1\":{\"905\":1}}],[\"访问的cat的前4个字节\",{\"1\":{\"905\":1}}],[\"访问类中的私有成员\",{\"1\":{\"721\":1}}],[\"访问迭代器所迭代元素的值\",{\"1\":{\"698\":1}}],[\"访问限定表\",{\"0\":{\"657\":1}}],[\"访问元素前后相邻位置的元素非常方便\",{\"1\":{\"100\":1}}],[\"待我们学了多态的知识后一起做讲解\",{\"1\":{\"653\":1}}],[\"待插入的值\",{\"1\":{\"121\":1}}],[\"待插入的下标\",{\"1\":{\"121\":1}}],[\"待插入的数组\",{\"1\":{\"121\":1}}],[\"各包含一部分表\",{\"1\":{\"1888\":1}}],[\"各基类构造函数的执行顺序与其在初始化表中的顺序无关\",{\"1\":{\"651\":1}}],[\"各种各样的函数定义\",{\"1\":{\"447\":1}}],[\"需求更改\",{\"1\":{\"631\":1}}],[\"需要把单表切分成多个数据集更小的表\",{\"1\":{\"1886\":1}}],[\"需要把单库切分成更多更小的库\",{\"1\":{\"1886\":1}}],[\"需要把lambda表达式作为优先队列参数进行初始化\",{\"1\":{\"784\":1}}],[\"需要依次经过连接器\",{\"1\":{\"1881\":1}}],[\"需要同步数据\",{\"1\":{\"1808\":1}}],[\"需要jdk1\",{\"1\":{\"1796\":1}}],[\"需要并发能力的不断提升\",{\"1\":{\"1790\":1}}],[\"需要通过mysqlbinlog工具\",{\"1\":{\"1772\":1}}],[\"需要设置初始连接量\",{\"1\":{\"1745\":1}}],[\"需要找到表中相应的记录\",{\"1\":{\"1713\":1}}],[\"需要了解知识点出现的原因\",{\"1\":{\"1711\":1}}],[\"需要了解当前系统开放了哪些端口\",{\"1\":{\"1236\":1}}],[\"需要sudo\",{\"1\":{\"1580\":1}}],[\"需要创建age\",{\"1\":{\"1566\":1}}],[\"需要注意\",{\"1\":{\"1469\":1}}],[\"需要注意的是\",{\"1\":{\"1338\":1,\"1617\":1}}],[\"需要注意的是操作符\",{\"1\":{\"539\":1}}],[\"需要修改多项数值\",{\"1\":{\"1417\":1}}],[\"需要在控制面板的网络中心启用网络发现\",{\"1\":{\"1818\":1}}],[\"需要在链接时指定库名\",{\"1\":{\"1372\":1}}],[\"需要在远程连接的工程根路径下建立一个主cmakelists\",{\"1\":{\"1309\":1}}],[\"需要链接一个名为\",{\"1\":{\"1315\":1}}],[\"需要有线程间的通信机制\",{\"1\":{\"1219\":1}}],[\"需要有一些状态\",{\"1\":{\"22\":1}}],[\"需要多加一个模板的完全特例化\",{\"1\":{\"1186\":1}}],[\"需要定义一个类\",{\"1\":{\"1171\":1}}],[\"需要接受外部传进来的函数类型\",{\"1\":{\"1158\":1}}],[\"需要调用该方法释放存放结果集的内存空间\",{\"1\":{\"1381\":1}}],[\"需要调用它的\",{\"1\":{\"1154\":1}}],[\"需要调用的是赋值运算符函数\",{\"1\":{\"463\":1}}],[\"需要的线程函数都是c函数\",{\"1\":{\"1151\":1}}],[\"需要的是一元函数对象\",{\"1\":{\"1008\":2}}],[\"需要申请内存\",{\"1\":{\"1102\":1}}],[\"需要返回的内存大小\",{\"1\":{\"1102\":1}}],[\"需要从一个观察者提升为强智能指针\",{\"1\":{\"1057\":1}}],[\"需要从0开始2倍扩容\",{\"1\":{\"993\":1}}],[\"需要判断\",{\"1\":{\"1057\":1,\"1656\":1}}],[\"需要加上\",{\"1\":{\"1035\":1}}],[\"需要加上头文件<queue>\",{\"1\":{\"991\":1,\"992\":1}}],[\"需要加上头文件<stack>\",{\"1\":{\"990\":1}}],[\"需要进行以下设置\",{\"1\":{\"1030\":1}}],[\"需要包含\",{\"1\":{\"1008\":1}}],[\"需要支持\",{\"1\":{\"993\":1}}],[\"需要使用bind\",{\"1\":{\"1849\":1,\"1859\":1,\"1875\":1}}],[\"需要使用undo\",{\"1\":{\"1761\":1}}],[\"需要使用insert\",{\"1\":{\"969\":1,\"970\":1}}],[\"需要使用参数加类型\",{\"1\":{\"388\":1}}],[\"需要清理和释放的时候\",{\"0\":{\"949\":1},\"1\":{\"946\":1}}],[\"需要增加6个类\",{\"1\":{\"831\":1}}],[\"需要购买电影券\",{\"1\":{\"830\":2}}],[\"需要升级成vip\",{\"1\":{\"830\":1}}],[\"需要遍历一次\",{\"1\":{\"802\":1}}],[\"需要前驱结点\",{\"1\":{\"791\":1}}],[\"需要说明的是\",{\"1\":{\"599\":1}}],[\"需要用nm查看\",{\"1\":{\"572\":1}}],[\"需要对bar函数进行扩展\",{\"1\":{\"528\":1}}],[\"需要对符号进行解析\",{\"1\":{\"245\":1}}],[\"需要读取磁盘\",{\"1\":{\"290\":1}}],[\"需要实现条件转移\",{\"1\":{\"277\":1}}],[\"需要关注的\",{\"1\":{\"251\":1}}],[\"需要\",{\"1\":{\"244\":1}}],[\"需要指定待比较数据的位置\",{\"1\":{\"217\":1}}],[\"需要考虑边界条件\",{\"1\":{\"185\":1}}],[\"需要去重\",{\"1\":{\"170\":1}}],[\"需要比较负数平方与正数平方\",{\"1\":{\"87\":1}}],[\"需要将最初的数据存放在undo\",{\"1\":{\"1681\":1}}],[\"需要将它安装到系统中合适的位置\",{\"1\":{\"1332\":1}}],[\"需要将指针\",{\"1\":{\"1188\":1}}],[\"需要将\",{\"0\":{\"36\":1}}],[\"尤其是类内有申请的动态内存\",{\"1\":{\"946\":1}}],[\"尤其是向下转型的用法中\",{\"1\":{\"631\":1}}],[\"尤其是栈\",{\"1\":{\"553\":1}}],[\"才是事务真正启动的时机\",{\"1\":{\"1656\":1}}],[\"才可以调用该方法\",{\"1\":{\"1378\":1}}],[\"才可以进行合理的类型转换\",{\"1\":{\"630\":1}}],[\"才继续执行\",{\"1\":{\"1206\":1}}],[\"才析构对象\",{\"1\":{\"1114\":1}}],[\"才会执行命令\",{\"1\":{\"1354\":1}}],[\"才会填写chunk块头的\",{\"1\":{\"1099\":1}}],[\"才会去创建并使用实例\",{\"1\":{\"843\":1}}],[\"才能提交\",{\"1\":{\"1649\":1}}],[\"才能用到多列索引\",{\"1\":{\"1610\":1}}],[\"才能把剩余的时间片给到这个线程\",{\"1\":{\"1208\":1}}],[\"才能顺利的编译通过\",{\"1\":{\"1030\":1}}],[\"才能观看电影\",{\"1\":{\"830\":2}}],[\"才能观看vip电影\",{\"1\":{\"830\":1}}],[\"才能使每次投入大海的都是非教徒\",{\"1\":{\"811\":1}}],[\"才能检测到\",{\"1\":{\"599\":1}}],[\"才能为我们所用\",{\"1\":{\"509\":1}}],[\"才能决定在新数组中的位置\",{\"1\":{\"87\":1}}],[\"引访问数据\",{\"1\":{\"1724\":1}}],[\"引入中间件mycat\",{\"0\":{\"1791\":1}}],[\"引入redis缓存的话\",{\"1\":{\"1745\":1}}],[\"引入数据库连接池\",{\"1\":{\"1745\":1}}],[\"引入缓存\",{\"1\":{\"1743\":1,\"1745\":1}}],[\"引入\",{\"0\":{\"1677\":1}}],[\"引入了右值引用的概念\",{\"1\":{\"620\":1}}],[\"引擎的默认隔离级别虽然是\",{\"1\":{\"1717\":1}}],[\"引擎通过什么技术来保证事务的这四个特性的呢\",{\"0\":{\"1645\":1}}],[\"引擎是插件式的\",{\"1\":{\"1453\":1}}],[\"引进了4个新的类型转换操作符\",{\"1\":{\"628\":1}}],[\"引用折叠\",{\"1\":{\"1127\":1}}],[\"引用传递\",{\"0\":{\"1175\":1},\"1\":{\"1116\":1}}],[\"引用传递====变量本身\",{\"1\":{\"618\":1}}],[\"引用一个临时对象\",{\"1\":{\"1113\":1}}],[\"引用一经声明后\",{\"1\":{\"922\":1}}],[\"引用相当于给临时对象起了一个名字\",{\"1\":{\"1113\":1}}],[\"引用指向临时对象\",{\"1\":{\"1113\":1}}],[\"引用计数从2减到1\",{\"1\":{\"1057\":1}}],[\"引用计数为0的话\",{\"1\":{\"1055\":1}}],[\"引用技术加1到2\",{\"1\":{\"1057\":1}}],[\"引用对象的地方使用\",{\"1\":{\"1056\":2,\"1057\":1}}],[\"引用对象是个常量\",{\"1\":{\"624\":1}}],[\"引用对象是int\",{\"1\":{\"624\":1}}],[\"引用访问\",{\"0\":{\"922\":1}}],[\"引用变量是这个函数的局部变量\",{\"1\":{\"1113\":1}}],[\"引用变量都可以\",{\"1\":{\"901\":1}}],[\"引用变量会占据存储空间\",{\"1\":{\"614\":1}}],[\"引用不会产生副本\",{\"1\":{\"619\":1}}],[\"引用不能独立存在\",{\"1\":{\"618\":1}}],[\"引用只有一级引用\",{\"1\":{\"619\":1}}],[\"引用必须初始化\",{\"1\":{\"619\":1}}],[\"引用和指针的区别\",{\"0\":{\"619\":1}}],[\"引用和取地址的区别\",{\"0\":{\"613\":1}}],[\"引用是变量的别名\",{\"1\":{\"618\":1,\"619\":1}}],[\"引用是一个已定义变量的别名\",{\"1\":{\"612\":1}}],[\"引用与指针的区别是\",{\"1\":{\"617\":1}}],[\"引用总结\",{\"0\":{\"617\":1}}],[\"引用作为函数返回类型\",{\"1\":{\"618\":1}}],[\"引用作为函数的返回值\",{\"0\":{\"616\":1}}],[\"引用作为函数参数\",{\"0\":{\"615\":1},\"1\":{\"618\":1}}],[\"引用作为参数\",{\"1\":{\"615\":1}}],[\"引用的实质\",{\"1\":{\"618\":1}}],[\"引用的提出就是为了减少指针的使用\",{\"1\":{\"618\":1}}],[\"引用的目的主要用于在函数参数传递中\",{\"1\":{\"617\":1}}],[\"引用的本质是指针常量\",{\"1\":{\"619\":1}}],[\"引用的本质就是\",{\"1\":{\"614\":1}}],[\"引用的本质\",{\"0\":{\"614\":1}}],[\"引用的类型必须和其绑定的变量的类型相同\",{\"1\":{\"612\":1}}],[\"引用的概念油然而生\",{\"1\":{\"612\":1}}],[\"引用名\",{\"1\":{\"612\":1}}],[\"引用\",{\"0\":{\"611\":1,\"948\":1},\"1\":{\"832\":1,\"883\":2,\"948\":1,\"1121\":2}}],[\"引用数据成员\",{\"0\":{\"433\":1}}],[\"引用成员也必须在构造函数初始化列表中进行初始化\",{\"1\":{\"433\":1}}],[\"引用成员\",{\"1\":{\"431\":1}}],[\"引用符号可以去掉吗\",{\"0\":{\"465\":1}}],[\"引用符号\",{\"0\":{\"399\":1}}],[\"引用sum\",{\"1\":{\"246\":1}}],[\"得出如下结论\",{\"1\":{\"620\":1}}],[\"得到需要恢复的区间\",{\"1\":{\"1774\":1}}],[\"得到的数据量也不会改变\",{\"1\":{\"1689\":1}}],[\"得到的数据内容不一样\",{\"1\":{\"1658\":1}}],[\"得到返回的结果集\",{\"1\":{\"1381\":1}}],[\"得到一个指向成员方法的函数指针类型\",{\"1\":{\"1189\":1}}],[\"得到新的备用内存\",{\"1\":{\"1102\":1}}],[\"得到下面两个图\",{\"1\":{\"518\":1}}],[\"得到该块的地址\",{\"1\":{\"286\":1}}],[\"得到完全有序的序列\",{\"1\":{\"202\":1}}],[\"得到找到数字在数组中的下标\",{\"1\":{\"163\":4}}],[\"跟变量绑定到一起\",{\"1\":{\"618\":1}}],[\"强制获取共享锁\",{\"1\":{\"1698\":1}}],[\"强制转换\",{\"0\":{\"628\":1},\"1\":{\"678\":1}}],[\"强智能指针循环引用\",{\"1\":{\"1056\":1}}],[\"强智能指针观察\",{\"1\":{\"1056\":1}}],[\"强弱智能指针在线程中\",{\"1\":{\"1050\":1}}],[\"强烈建议使用引用作为函数的形参\",{\"1\":{\"615\":1}}],[\"强类型语言程序设计\",{\"1\":{\"359\":1}}],[\"占用带宽小\",{\"1\":{\"1901\":1}}],[\"占用1个字节\",{\"1\":{\"1426\":1}}],[\"占据的大小就是一个指针的大小\",{\"1\":{\"614\":1}}],[\"占位符\",{\"1\":{\"60\":8,\"700\":1}}],[\"改时导致幻读的问题\",{\"1\":{\"1721\":1}}],[\"改操作的时候都会被阻塞\",{\"1\":{\"1719\":1}}],[\"改为int\",{\"1\":{\"1552\":1}}],[\"改为typeinfo\",{\"1\":{\"614\":1}}],[\"改alter\",{\"1\":{\"1552\":1}}],[\"改later\",{\"1\":{\"1507\":1}}],[\"改update\",{\"0\":{\"1492\":1}}],[\"改成\",{\"1\":{\"1318\":1}}],[\"改变排序顺序\",{\"0\":{\"1147\":1}}],[\"改变容器元素比较方式\",{\"1\":{\"1007\":1}}],[\"改变sort排序方式\",{\"1\":{\"1007\":1}}],[\"改造基类的成员\",{\"1\":{\"684\":1}}],[\"改写之后要保存再退出\",{\"1\":{\"61\":1}}],[\"拋出\",{\"1\":{\"605\":1}}],[\"理解\",{\"0\":{\"1664\":1,\"1665\":1}}],[\"理解运行的逻辑\",{\"1\":{\"305\":1}}],[\"理论上不可以通过读取代码来检测到的异常\",{\"1\":{\"604\":1}}],[\"理论上可以通过读取代码来检测到的异常\",{\"1\":{\"604\":1}}],[\"描述\",{\"1\":{\"604\":1,\"1531\":1}}],[\"抓取\",{\"1\":{\"601\":1}}],[\"抓住\",{\"1\":{\"599\":1}}],[\"垃圾值\",{\"1\":{\"599\":1}}],[\"检测连接时长\",{\"1\":{\"1881\":1}}],[\"检测通信\",{\"0\":{\"1818\":1}}],[\"检测安装\",{\"1\":{\"1397\":1}}],[\"检测到异常后程序的执行流会发生跳转\",{\"1\":{\"599\":1}}],[\"检测到\",{\"1\":{\"599\":1,\"600\":1,\"601\":1}}],[\"检测到了异常\",{\"1\":{\"599\":1}}],[\"检测到的异常\",{\"1\":{\"599\":1}}],[\"检测\",{\"1\":{\"599\":3}}],[\"检查mysql的服务状态\",{\"0\":{\"1402\":1}}],[\"检查可用的软件包更新\",{\"1\":{\"1284\":1}}],[\"检查当前能否ping同百度\",{\"1\":{\"1279\":1}}],[\"检查自己原先指向的资源\",{\"1\":{\"1055\":1}}],[\"检查迭代器有效性\",{\"1\":{\"747\":1}}],[\"检查迭代器的有效性\",{\"1\":{\"747\":1}}],[\"检查内存泄露\",{\"1\":{\"716\":1}}],[\"检查内训泄露\",{\"0\":{\"716\":1}}],[\"检查要访问的虚拟地址是否合法\",{\"1\":{\"290\":1}}],[\"检查该块大小是否满足\",{\"1\":{\"286\":1}}],[\"检查是否遍历到堆顶了\",{\"1\":{\"286\":1}}],[\"检查是否是此原因的方法为\",{\"1\":{\"240\":1}}],[\"捕获外部的this指针\",{\"1\":{\"1172\":1}}],[\"捕获外部变量\",{\"1\":{\"1172\":2}}],[\"捕获\",{\"1\":{\"599\":2,\"601\":1}}],[\"捕获异常的语法为\",{\"1\":{\"599\":1}}],[\"捕获异常\",{\"0\":{\"599\":1}}],[\"机制\",{\"1\":{\"597\":1}}],[\"机器数\",{\"1\":{\"1892\":1}}],[\"机器数运算高位舍弃了\",{\"0\":{\"334\":1}}],[\"机器数运算修改了符号位\",{\"0\":{\"333\":1}}],[\"机器指令\",{\"1\":{\"1347\":1}}],[\"机器语言和汇编语言都不具有移植性\",{\"1\":{\"302\":1}}],[\"终止所有处理过程\",{\"1\":{\"1318\":1}}],[\"终止程序运行\",{\"1\":{\"597\":1}}],[\"终止循环\",{\"1\":{\"194\":1}}],[\"符合该条件的删除\",{\"1\":{\"1491\":1}}],[\"符合软件设计的开\",{\"1\":{\"866\":1}}],[\"符合语法规则的代码才能生成可执行程序\",{\"1\":{\"597\":1}}],[\"符号补全\",{\"1\":{\"1135\":1}}],[\"符号只由函数名决定\",{\"1\":{\"562\":1}}],[\"符号常量\",{\"1\":{\"323\":1}}],[\"符号什么时候分配虚拟地址\",{\"1\":{\"255\":1}}],[\"符号重定向\",{\"1\":{\"255\":1}}],[\"符号重定义\",{\"1\":{\"255\":2}}],[\"符号解析成功后\",{\"1\":{\"255\":1}}],[\"符号解析\",{\"1\":{\"255\":1}}],[\"符号段\",{\"1\":{\"251\":1}}],[\"符号的虚拟地址是在链接时分配的\",{\"1\":{\"249\":1}}],[\"符号名称\",{\"1\":{\"248\":1}}],[\"符号表属于文件段之一\",{\"1\":{\"255\":1}}],[\"符号表合并后\",{\"1\":{\"255\":2}}],[\"符号表都为0\",{\"1\":{\"249\":1}}],[\"符号表\",{\"1\":{\"248\":1}}],[\"符号表进行合并后\",{\"1\":{\"245\":1}}],[\"符号表中的符号怎么理解\",{\"1\":{\"244\":1}}],[\"符号何时分配虚拟地址\",{\"1\":{\"244\":1}}],[\"符号链接\",{\"0\":{\"1266\":1},\"1\":{\"17\":1}}],[\"带\",{\"0\":{\"1515\":1}}],[\"带去重效果\",{\"1\":{\"1502\":1}}],[\"带右值引用参数的赋值重载函数\",{\"1\":{\"1121\":1,\"1123\":1}}],[\"带右值引用参数的拷贝构造\",{\"1\":{\"1121\":1,\"1123\":1}}],[\"带左值引用参数的赋值重载函数\",{\"1\":{\"1120\":1,\"1123\":1}}],[\"带左值引用参数的拷贝构造\",{\"1\":{\"1120\":1,\"1123\":1}}],[\"带引用计数\",{\"1\":{\"1054\":1}}],[\"带引用计数的好处\",{\"1\":{\"1053\":1}}],[\"带引用计数的智能指针的实现\",{\"0\":{\"1055\":1}}],[\"带引用计数的智能指针是怎么解决多个指针持有一个资源的\",{\"0\":{\"1054\":1}}],[\"带引用计数的智能指针\",{\"0\":{\"1053\":1}}],[\"带虚函数\",{\"1\":{\"889\":1,\"940\":1}}],[\"带虚函数的多基派生\",{\"0\":{\"889\":1}}],[\"带命名空间的函数声明\",{\"1\":{\"594\":1}}],[\"带参数宏定义\",{\"1\":{\"500\":1}}],[\"带参数的宏定义\",{\"1\":{\"359\":1}}],[\"推荐使用unique\",{\"1\":{\"1047\":1}}],[\"推荐使用这种方式\",{\"1\":{\"845\":1}}],[\"推荐使用这种\",{\"1\":{\"594\":1}}],[\"推导出右值的类型\",{\"1\":{\"1194\":1}}],[\"推导的时候也已经确定了\",{\"1\":{\"378\":1}}],[\"推导\",{\"1\":{\"364\":1,\"368\":1}}],[\"统一的都带到cpu的缓存里\",{\"1\":{\"1233\":1}}],[\"统称为实体\",{\"1\":{\"594\":3}}],[\"统计表中缴费的总笔数和总金额\",{\"1\":{\"1531\":1}}],[\"统计哪些数字重复了\",{\"1\":{\"1001\":1}}],[\"统计出现的次数\",{\"1\":{\"213\":1}}],[\"统计单词个数\",{\"1\":{\"11\":1}}],[\"统计单词的个数\",{\"0\":{\"8\":1}}],[\"统计字母\",{\"0\":{\"11\":1}}],[\"课程表\",{\"1\":{\"1537\":1}}],[\"课程id\",{\"1\":{\"1461\":2}}],[\"课程名称\",{\"1\":{\"1461\":3,\"1537\":1}}],[\"课内代码\",{\"0\":{\"594\":1}}],[\"课堂代码\",{\"0\":{\"497\":1,\"506\":1,\"515\":1,\"547\":1,\"571\":1,\"602\":1,\"618\":1,\"633\":1,\"642\":1}}],[\"临键锁\",{\"1\":{\"1665\":2}}],[\"临近使用的地方声明\",{\"1\":{\"593\":1}}],[\"临时手动启动\",{\"1\":{\"1818\":1}}],[\"临时的就是右值\",{\"1\":{\"621\":1}}],[\"临时变量\",{\"1\":{\"400\":1}}],[\"临时对象给另一个对象赋值\",{\"1\":{\"1211\":1}}],[\"临时对象拷贝构造一个新对象\",{\"1\":{\"1211\":1}}],[\"临时对象是右值\",{\"1\":{\"1121\":1}}],[\"临时对象没名字\",{\"1\":{\"1115\":1}}],[\"临时对象的生存周期就变成引用变量的\",{\"1\":{\"1113\":1}}],[\"临时对象的指针和引用\",{\"0\":{\"1113\":1}}],[\"临时对象就是有名字了\",{\"1\":{\"1113\":1}}],[\"临时对象就析构了\",{\"1\":{\"1110\":1,\"1111\":1}}],[\"临时对象出语句析构是因为没有名字\",{\"1\":{\"1113\":1}}],[\"临时对象不析构\",{\"1\":{\"1113\":1}}],[\"临时对象析构\",{\"1\":{\"1111\":2,\"1112\":3,\"1113\":1}}],[\"临时对象生成后\",{\"1\":{\"1111\":1}}],[\"临时对象\",{\"1\":{\"400\":1,\"459\":1,\"1110\":1,\"1111\":1}}],[\"嵌套多个readhost标签就是配置一主多从\",{\"1\":{\"1803\":1}}],[\"嵌套\",{\"1\":{\"592\":1}}],[\"涵义不同\",{\"1\":{\"591\":1}}],[\"新旧都是age\",{\"1\":{\"1552\":1}}],[\"新表名\",{\"1\":{\"1552\":1}}],[\"新字段\",{\"1\":{\"1552\":3}}],[\"新字段名\",{\"1\":{\"1552\":1}}],[\"新字段类型\",{\"1\":{\"1552\":2}}],[\"新的数据不再是prepare状态\",{\"1\":{\"1664\":1}}],[\"新的数据已经符合生成快照的要求了\",{\"1\":{\"1659\":1}}],[\"新的数据已经被事务正确commit\",{\"1\":{\"1658\":1}}],[\"新的数据\",{\"1\":{\"1492\":2}}],[\"新的标准中提倡使用匿名命名空间\",{\"1\":{\"591\":1}}],[\"新线程就开始运行了\",{\"1\":{\"1207\":1}}],[\"新申请的内存只会越来越大\",{\"1\":{\"1102\":1}}],[\"新添加的功能\",{\"1\":{\"831\":1}}],[\"新节点来组成新链表的话\",{\"1\":{\"795\":1}}],[\"新节点将成为链表的第一个节点\",{\"1\":{\"790\":1}}],[\"新链表是通过拼接给定的两个链表的所有节点组成的\",{\"1\":{\"762\":1}}],[\"新生成当前容器某一个位置元素的迭代器\",{\"1\":{\"747\":1}}],[\"新建一个\",{\"1\":{\"1316\":1}}],[\"新建markdown时使用模板\",{\"0\":{\"45\":1}}],[\"新建文件夹\",{\"0\":{\"34\":1}}],[\"啦\",{\"1\":{\"589\":1}}],[\"名称\",{\"1\":{\"1020\":1,\"1899\":1}}],[\"名称空间中的实体作用域是全局的\",{\"1\":{\"586\":1}}],[\"名字\",{\"1\":{\"1137\":1}}],[\"名字空间对全局实体加以域的限制\",{\"1\":{\"583\":1}}],[\"名字冲突就是在同一个作用域中有两个或多个同名的实体\",{\"1\":{\"582\":1}}],[\"互斥锁的头文件\",{\"1\":{\"1219\":1}}],[\"互斥锁\",{\"1\":{\"1202\":1}}],[\"互不干扰\",{\"1\":{\"582\":1}}],[\"互为字母异位词\",{\"1\":{\"166\":1}}],[\"显式加锁\",{\"0\":{\"1698\":1}}],[\"显式指定库文件\",{\"1\":{\"1335\":1}}],[\"显式生成临时对象\",{\"1\":{\"1111\":1,\"1112\":1}}],[\"显式调用a的相应构造函数\",{\"1\":{\"943\":1}}],[\"显式调用\",{\"1\":{\"662\":1}}],[\"显式地使用\",{\"1\":{\"578\":1}}],[\"显然deuqe对于更好一些\",{\"1\":{\"993\":1}}],[\"显然不是\",{\"1\":{\"612\":1}}],[\"显然超出了字符串\",{\"1\":{\"597\":1}}],[\"显示的数据量不一致\",{\"1\":{\"1686\":1}}],[\"显示的调用基类的赋值运算符函数\",{\"1\":{\"662\":1}}],[\"显示查询的表名\",{\"1\":{\"1618\":1}}],[\"显示更详细的时间\",{\"1\":{\"1582\":1}}],[\"显示索引的哪一列被使用了\",{\"1\":{\"1521\":1}}],[\"显示可能应用在这张表中的索引\",{\"1\":{\"1521\":1}}],[\"显示当前时间\",{\"1\":{\"1508\":1}}],[\"显示当前执行点的汇编代码\",{\"1\":{\"261\":1}}],[\"显示如下\",{\"0\":{\"1391\":1},\"1\":{\"1410\":1}}],[\"显示执行过程中的详细信息\",{\"1\":{\"1334\":1}}],[\"显示正在执行的操作的详细信息\",{\"1\":{\"1334\":1}}],[\"显示正在使用socket的程序识别码和程序名称\",{\"1\":{\"1237\":1}}],[\"显示额外的警告信息\",{\"1\":{\"1327\":1}}],[\"显示文件的实际路径\",{\"1\":{\"1271\":1}}],[\"显示目录名称而非内容\",{\"1\":{\"1245\":1}}],[\"显示所有警告信息\",{\"1\":{\"1327\":1}}],[\"显示所有已装的vim插件\",{\"1\":{\"1287\":1}}],[\"显示所有文件和目录\",{\"1\":{\"1245\":1}}],[\"显示所有连线中的socket\",{\"1\":{\"1237\":1}}],[\"显示tcp端口的统计信息\",{\"1\":{\"1238\":1}}],[\"显示tcp传输协议的连线状况\",{\"1\":{\"1237\":1}}],[\"显示raw传输协议的连线状况\",{\"1\":{\"1237\":1}}],[\"显示routing\",{\"1\":{\"1237\":1}}],[\"显示版本信息\",{\"1\":{\"1237\":1}}],[\"显示指令执行过程\",{\"1\":{\"1237\":1}}],[\"显示udp传输协议的连线状况\",{\"1\":{\"1237\":1}}],[\"显示计时器\",{\"1\":{\"1237\":1}}],[\"显示伪装的网络连线\",{\"1\":{\"1237\":1}}],[\"显示监控中的服务器的socket\",{\"1\":{\"1237\":1}}],[\"显示网络工作信息统计表\",{\"1\":{\"1237\":1}}],[\"显示网络硬件外围设备的符号连接名称\",{\"1\":{\"1237\":1}}],[\"显示网络界面信息表单\",{\"1\":{\"1237\":1}}],[\"显示网络其他相关信息\",{\"1\":{\"1237\":1}}],[\"显示多重广播功能群组组员名单\",{\"1\":{\"1237\":1}}],[\"显示fib\",{\"1\":{\"1237\":1}}],[\"显示路由器配置的快取信息\",{\"1\":{\"1237\":1}}],[\"显示生成临时对象和隐式生成临时对象\",{\"0\":{\"1112\":1}}],[\"显示生成临时对象\",{\"1\":{\"1110\":1,\"1111\":1}}],[\"显示调用基类的拷贝构造函数\",{\"1\":{\"662\":1}}],[\"显示实例化\",{\"1\":{\"364\":1}}],[\"显示代码行号\",{\"0\":{\"309\":1}}],[\"显示具体值\",{\"1\":{\"234\":1}}],[\"显示相关联的源代码\",{\"1\":{\"234\":1}}],[\"显示低级的反汇编\",{\"1\":{\"227\":1}}],[\"显示器\",{\"1\":{\"17\":1,\"301\":1}}],[\"外连接就会和内连接查询结果一样\",{\"1\":{\"1544\":1}}],[\"外连接如果on后面只写连接条件\",{\"1\":{\"1544\":1}}],[\"外连接\",{\"0\":{\"1542\":1}}],[\"外排序归并问题的算法思想\",{\"1\":{\"1525\":1}}],[\"外排序\",{\"1\":{\"1525\":1}}],[\"外排序涉及到了磁盘io\",{\"1\":{\"1525\":1}}],[\"外键\",{\"1\":{\"1437\":1}}],[\"外键约束\",{\"0\":{\"1437\":1}}],[\"外\",{\"1\":{\"1426\":1}}],[\"外层的查询为simple且只有一个\",{\"1\":{\"1618\":1}}],[\"外层的\",{\"1\":{\"1318\":1}}],[\"外部接口\",{\"1\":{\"826\":1}}],[\"外部变量\",{\"1\":{\"574\":1}}],[\"外循环\",{\"1\":{\"217\":1}}],[\"外循环表示需要n\",{\"1\":{\"188\":1}}],[\"补成功的数据\",{\"1\":{\"1500\":2}}],[\"补充\",{\"1\":{\"570\":1}}],[\"补码的实现\",{\"0\":{\"345\":1}}],[\"补码\",{\"0\":{\"343\":1}}],[\"顺序合并\",{\"0\":{\"782\":1}}],[\"顺序依然没变\",{\"1\":{\"650\":1}}],[\"顺序\",{\"1\":{\"571\":1,\"572\":1,\"692\":1,\"1475\":1}}],[\"顺序不同\",{\"1\":{\"560\":1,\"563\":1}}],[\"顺序栈的实现\",{\"0\":{\"224\":1}}],[\"允许key值重复\",{\"1\":{\"999\":1}}],[\"允许key重复\",{\"1\":{\"999\":1}}],[\"允许存储key值重复的元素\",{\"1\":{\"999\":1}}],[\"允许函数设置默认参数值\",{\"1\":{\"637\":1}}],[\"允许多个函数拥有相同的名字\",{\"1\":{\"560\":1}}],[\"允许少量额外的辅助变量来转换数据的算法\",{\"1\":{\"67\":1}}],[\"值之间使用逗号\",{\"1\":{\"1899\":1}}],[\"值对使用逗号\",{\"1\":{\"1899\":1}}],[\"值对集合\",{\"1\":{\"1899\":1}}],[\"值对的\",{\"1\":{\"1898\":1}}],[\"值为\",{\"1\":{\"1686\":1}}],[\"值在\",{\"1\":{\"1656\":1}}],[\"值大于等于\",{\"1\":{\"1656\":1}}],[\"值小于\",{\"1\":{\"1656\":1}}],[\"值\",{\"1\":{\"1656\":4}}],[\"值不能够重复\",{\"1\":{\"1610\":1}}],[\"值不同\",{\"1\":{\"633\":1}}],[\"值传递\",{\"0\":{\"1174\":1}}],[\"值传递====地址值\",{\"1\":{\"618\":1}}],[\"值传递====副本\",{\"1\":{\"618\":1}}],[\"值可以修改\",{\"1\":{\"620\":2}}],[\"值和结构\",{\"1\":{\"556\":1}}],[\"值得注意\",{\"0\":{\"523\":1}}],[\"值得注意的是\",{\"1\":{\"470\":1}}],[\"本项目为了在c\",{\"1\":{\"1864\":1}}],[\"本来是按照password排序作为索引的\",{\"1\":{\"1593\":1}}],[\"本地可以使用\",{\"1\":{\"1374\":1}}],[\"本类名\",{\"1\":{\"925\":1}}],[\"本质上也就是智能指针第二参数给函数对象类\",{\"1\":{\"1060\":1}}],[\"本质是相同的\",{\"1\":{\"866\":1}}],[\"本质还是函数重载或函数多态\",{\"1\":{\"727\":1}}],[\"本身自带提交事务\",{\"1\":{\"1671\":1}}],[\"本身就线程安全\",{\"1\":{\"851\":1}}],[\"本身也要进行对齐\",{\"1\":{\"556\":1}}],[\"本例中\",{\"1\":{\"599\":1}}],[\"本例中抛出异常的位置是第\",{\"1\":{\"599\":1}}],[\"本次学习的是遵循posix标准的文件读写的系统调用\",{\"1\":{\"16\":1}}],[\"块一般为16k\",{\"1\":{\"1622\":1}}],[\"块的起始地址\",{\"1\":{\"1099\":1}}],[\"块的数量\",{\"1\":{\"1099\":1}}],[\"块的大小只能是1\",{\"1\":{\"553\":1}}],[\"块\",{\"1\":{\"1082\":1}}],[\"块所调用的某个函数中\",{\"1\":{\"600\":1}}],[\"块所包含的代码后\",{\"1\":{\"599\":1}}],[\"块中调用了某个函数\",{\"1\":{\"601\":1}}],[\"块中调用的某个函数中发生了异常\",{\"1\":{\"601\":1}}],[\"块中被调用\",{\"1\":{\"601\":1}}],[\"块中直接发生的异常\",{\"1\":{\"601\":1}}],[\"块中\",{\"1\":{\"600\":1}}],[\"块后面的代码\",{\"1\":{\"599\":1}}],[\"块内的语句就都不会再执行了\",{\"1\":{\"599\":1}}],[\"块设备文件\",{\"1\":{\"17\":1}}],[\"某字段名\",{\"1\":{\"1552\":1}}],[\"某些系统允许通过设置环境变量\",{\"1\":{\"1335\":1}}],[\"某些情况下\",{\"1\":{\"695\":1}}],[\"某些硬件平台只能在某些地址处取某些特定类型的数据\",{\"1\":{\"553\":1}}],[\"某个类的变量\",{\"1\":{\"449\":1}}],[\"元素值为0\",{\"1\":{\"966\":1}}],[\"元素清空\",{\"0\":{\"544\":1}}],[\"元素删除\",{\"0\":{\"543\":1}}],[\"元素追加和相加\",{\"0\":{\"541\":1}}],[\"元素遍历和存取\",{\"0\":{\"539\":1}}],[\"效果是一样的\",{\"1\":{\"1541\":1}}],[\"效果一致\",{\"1\":{\"538\":1}}],[\"效率更高\",{\"1\":{\"1758\":1}}],[\"效率越低\",{\"1\":{\"1645\":1}}],[\"效率比较低\",{\"1\":{\"1626\":1}}],[\"效率很低\",{\"1\":{\"1569\":1,\"1604\":1}}],[\"效率上比较快\",{\"1\":{\"1541\":1}}],[\"效率的高低取决于扫描表的数据量\",{\"1\":{\"1519\":1}}],[\"效率太低\",{\"0\":{\"1498\":1}}],[\"效率问题\",{\"0\":{\"1122\":1}}],[\"效率高\",{\"1\":{\"982\":1}}],[\"效率就很低了\",{\"1\":{\"1079\":1}}],[\"效率就慢了\",{\"1\":{\"970\":1}}],[\"效率就会降低\",{\"1\":{\"465\":1}}],[\"效率提高\",{\"0\":{\"1499\":1},\"1\":{\"966\":1}}],[\"求取字符串长度\",{\"1\":{\"535\":1,\"536\":1}}],[\"具备相同的inode节点号\",{\"1\":{\"1267\":1}}],[\"具有以下优点\",{\"1\":{\"1896\":1}}],[\"具有全局生存期\",{\"1\":{\"591\":1}}],[\"具有跨平台的作用\",{\"1\":{\"535\":1}}],[\"具体加了什么锁呢\",{\"1\":{\"1718\":1}}],[\"具体来说\",{\"1\":{\"1338\":1}}],[\"具体接收的参数的个数\",{\"1\":{\"1173\":1}}],[\"具体如下\",{\"1\":{\"1020\":1}}],[\"具体地讲\",{\"1\":{\"914\":1}}],[\"具体的车跑到公里不一样\",{\"1\":{\"900\":3}}],[\"具体的规则是\",{\"1\":{\"560\":1}}],[\"具体情况具体研究\",{\"1\":{\"659\":1}}],[\"具体而言\",{\"1\":{\"494\":1}}],[\"悬空指针\",{\"0\":{\"531\":1},\"1\":{\"531\":1}}],[\"采用完全独立于编程语言的来存储和表示数据\",{\"1\":{\"1896\":1}}],[\"采用动态联编\",{\"1\":{\"924\":1}}],[\"采用简单工厂\",{\"0\":{\"863\":1}}],[\"采用new的方式创建对象\",{\"0\":{\"862\":1}}],[\"采用值传递时\",{\"1\":{\"615\":1}}],[\"采用\",{\"1\":{\"530\":1}}],[\"禁止外部赋值操作\",{\"1\":{\"850\":1}}],[\"禁止外部拷贝构造\",{\"1\":{\"850\":1}}],[\"禁止外部拷贝和赋值\",{\"1\":{\"848\":1,\"851\":1}}],[\"禁止外部析构\",{\"1\":{\"850\":1}}],[\"禁止外部构造\",{\"1\":{\"850\":1}}],[\"禁止外部构造和析构\",{\"1\":{\"848\":1,\"851\":1}}],[\"禁止取地址操作符\",{\"1\":{\"530\":1}}],[\"禁用gpu之后\",{\"1\":{\"63\":1}}],[\"私有成员只能自己内部访问或者友元访问\",{\"1\":{\"658\":1}}],[\"私有成员函数\",{\"1\":{\"530\":1}}],[\"私有\",{\"1\":{\"657\":1}}],[\"私有数据成员和成员函数\",{\"1\":{\"449\":1}}],[\"貌似我们现在说道的这些跟c++通常使用0来表示空指针没什么关系\",{\"1\":{\"528\":1}}],[\"注册消息\",{\"1\":{\"1896\":1}}],[\"注册destroy函数\",{\"1\":{\"1032\":1}}],[\"注销\",{\"1\":{\"1168\":2}}],[\"注释掉bind\",{\"1\":{\"1408\":1}}],[\"注释\",{\"1\":{\"1142\":2,\"1353\":1,\"1552\":2}}],[\"注释方法\",{\"1\":{\"594\":1}}],[\"注\",{\"1\":{\"527\":1,\"1677\":1}}],[\"注意要链接protobuf动态库\",{\"1\":{\"1915\":1}}],[\"注意要加单引号\",{\"1\":{\"1633\":1}}],[\"注意是一个列表\",{\"1\":{\"1656\":1}}],[\"注意mysql5\",{\"0\":{\"1600\":1}}],[\"注意select后的字段是否涉及到了回表查询\",{\"1\":{\"1525\":1}}],[\"注意std\",{\"1\":{\"171\":1}}],[\"注意密码强度大小写数字\",{\"1\":{\"1447\":1}}],[\"注意安全性\",{\"1\":{\"1338\":1}}],[\"注意区分一下函数类型和函数指针类型\",{\"1\":{\"1188\":1}}],[\"注意区分偏特化和重载\",{\"0\":{\"370\":1}}],[\"注意test\",{\"1\":{\"1114\":1}}],[\"注意这里为什么是大于等于一个chunk块的大小\",{\"1\":{\"1102\":1}}],[\"注意返回临时对象或用临时对象构造对象时\",{\"1\":{\"1066\":1}}],[\"注意返回的地址不是最顶上的地址\",{\"1\":{\"517\":1}}],[\"注意加一个判断\",{\"1\":{\"821\":1}}],[\"注意需要重置cur\",{\"1\":{\"817\":1}}],[\"注意同时定义两个指针的方法\",{\"1\":{\"792\":1}}],[\"注意重置指针\",{\"1\":{\"771\":1}}],[\"注意事项\",{\"0\":{\"735\":1}}],[\"注意上面的写法中b和c属于私有继承\",{\"1\":{\"647\":1}}],[\"注意2\",{\"1\":{\"630\":1}}],[\"注意1\",{\"1\":{\"630\":1}}],[\"注意和头文件区分\",{\"1\":{\"536\":1}}],[\"注意辨析\",{\"1\":{\"492\":1}}],[\"注意不需要\",{\"1\":{\"293\":1}}],[\"注意从第二个元素开始\",{\"1\":{\"214\":1}}],[\"注意应先判断下标的有效性\",{\"1\":{\"101\":1}}],[\"注意循环条件\",{\"1\":{\"93\":1,\"94\":1}}],[\"注意end\",{\"1\":{\"93\":1,\"94\":1}}],[\"注意==\",{\"1\":{\"84\":1}}],[\"注意left<=right确保合法\",{\"1\":{\"78\":1}}],[\"注意赋值后slow也要往前走一步\",{\"1\":{\"77\":1}}],[\"注意\",{\"0\":{\"363\":1,\"428\":1,\"926\":1,\"1027\":1,\"1477\":1,\"1479\":1,\"1530\":1,\"1702\":1},\"1\":{\"51\":1,\"61\":1,\"66\":1,\"101\":1,\"132\":1,\"166\":1,\"316\":1,\"338\":1,\"360\":1,\"422\":1,\"435\":1,\"449\":1,\"459\":2,\"476\":1,\"489\":1,\"535\":1,\"568\":1,\"570\":1,\"574\":1,\"577\":1,\"603\":1,\"605\":1,\"630\":1,\"762\":1,\"784\":1,\"802\":1,\"848\":1,\"927\":1,\"958\":1,\"965\":1,\"1025\":1,\"1148\":1,\"1209\":1,\"1219\":2,\"1227\":1,\"1315\":1,\"1376\":1,\"1410\":1,\"1480\":1,\"1514\":1,\"1569\":1,\"1603\":2}}],[\"注意内容为fasta格式\",{\"1\":{\"6\":1}}],[\"没加就不用存\",{\"1\":{\"1558\":1}}],[\"没名字\",{\"1\":{\"620\":1}}],[\"没内存\",{\"1\":{\"620\":1}}],[\"没问题\",{\"1\":{\"524\":3}}],[\"没有子项目\",{\"1\":{\"1896\":1}}],[\"没有发现insert数据的sql\",{\"1\":{\"1813\":1}}],[\"没有安装\",{\"1\":{\"1800\":1}}],[\"没有过期的数据可以直接通过binlog恢复\",{\"1\":{\"1774\":1}}],[\"没有更好的办法\",{\"1\":{\"1672\":1}}],[\"没有快慢之分\",{\"1\":{\"1627\":1}}],[\"没有加行锁\",{\"1\":{\"1690\":1}}],[\"没有加主键时\",{\"1\":{\"1610\":1}}],[\"没有加索引就会全文扫描\",{\"1\":{\"1521\":1}}],[\"没有索引就做整表搜索\",{\"1\":{\"1626\":1}}],[\"没有索引只能做整表搜索\",{\"1\":{\"1623\":1}}],[\"没有索引\",{\"0\":{\"1719\":1},\"1\":{\"1563\":1,\"1702\":1}}],[\"没有索引没法存放数据\",{\"1\":{\"1558\":1}}],[\"没有为null\",{\"1\":{\"1544\":2}}],[\"没有用date类型\",{\"1\":{\"1537\":1}}],[\"没有联合搜索和多表的查询\",{\"1\":{\"1521\":1}}],[\"没有查询到信息\",{\"1\":{\"1385\":1}}],[\"没有任何限制条件\",{\"1\":{\"1610\":1}}],[\"没有任何的顺序\",{\"1\":{\"1604\":1}}],[\"没有任何连接状态\",{\"1\":{\"1240\":1}}],[\"没有任何执行上的顺序可言\",{\"1\":{\"1218\":1}}],[\"没有任何问题\",{\"1\":{\"630\":1}}],[\"没有先后顺序\",{\"1\":{\"1207\":1}}],[\"没有办法直接使用\",{\"1\":{\"1148\":1}}],[\"没有区别的\",{\"1\":{\"1110\":1,\"1111\":1}}],[\"没有足够的空间分配了\",{\"1\":{\"1102\":1}}],[\"没有deque好\",{\"1\":{\"993\":1}}],[\"没有机会调用派生类的析构函数\",{\"1\":{\"948\":1}}],[\"没有这个\",{\"1\":{\"908\":1}}],[\"没有多线程的问题\",{\"1\":{\"844\":1}}],[\"没有多级引用\",{\"1\":{\"619\":1}}],[\"没有传递性\",{\"1\":{\"724\":1}}],[\"没有构造函数与析构函数\",{\"1\":{\"713\":1}}],[\"没有才去基类里面去找\",{\"1\":{\"695\":1}}],[\"没有显示定义那就是编译器合成\",{\"1\":{\"670\":1}}],[\"没有显示调用的结果\",{\"1\":{\"662\":1}}],[\"没有显式调用\",{\"1\":{\"662\":1}}],[\"没有const修饰\",{\"1\":{\"621\":1}}],[\"没有名字的\",{\"1\":{\"621\":1}}],[\"没有触及a\",{\"1\":{\"618\":1}}],[\"没有捕获到异常\",{\"1\":{\"599\":1}}],[\"没有异常抛出\",{\"1\":{\"599\":1}}],[\"没有重名\",{\"1\":{\"594\":1}}],[\"没有分配内存\",{\"1\":{\"574\":1}}],[\"没有分配物理内存\",{\"1\":{\"281\":1}}],[\"没有及时置空\",{\"1\":{\"531\":1}}],[\"没有正确释放已经不需要的内存\",{\"1\":{\"531\":1}}],[\"没有报错\",{\"1\":{\"522\":1}}],[\"没有函数调用开销了\",{\"1\":{\"502\":1}}],[\"没有直接的语言支持来实现面向对象编程中的多态性\",{\"1\":{\"494\":1}}],[\"没有约束的可以给有约束的赋值\",{\"0\":{\"491\":1}}],[\"没有问题\",{\"1\":{\"490\":1,\"1812\":1,\"1813\":1}}],[\"没有返回类型\",{\"1\":{\"420\":1}}],[\"没有返回值\",{\"1\":{\"420\":1}}],[\"没有意义\",{\"1\":{\"368\":1}}],[\"没有的话\",{\"1\":{\"1186\":1}}],[\"没有的话才去找函数模板\",{\"1\":{\"366\":1}}],[\"没有的就新建\",{\"1\":{\"45\":1}}],[\"没有明确说明类型\",{\"1\":{\"364\":1}}],[\"没有就新建\",{\"1\":{\"48\":1,\"49\":1,\"51\":1}}],[\"没有边界\",{\"1\":{\"22\":1}}],[\"崩溃卡死\",{\"1\":{\"523\":1}}],[\"探究它\",{\"1\":{\"518\":1}}],[\"深入理解c++\",{\"0\":{\"518\":1}}],[\"深拷贝和浅拷贝问题\",{\"0\":{\"464\":1}}],[\"深拷贝\",{\"1\":{\"397\":1,\"405\":2,\"464\":1,\"548\":1}}],[\"抛出runtime\",{\"1\":{\"600\":1}}],[\"抛出int型的异常类型\",{\"1\":{\"600\":1}}],[\"抛出const\",{\"1\":{\"600\":1,\"601\":2}}],[\"抛出\",{\"1\":{\"599\":1,\"604\":3}}],[\"抛出异常\",{\"1\":{\"517\":1,\"597\":1,\"601\":1}}],[\"抛开名称空间嵌套和内部屏蔽的情况\",{\"1\":{\"586\":1}}],[\"抛异常处理内存开辟失败\",{\"1\":{\"511\":1}}],[\"野指针\",{\"0\":{\"531\":1},\"1\":{\"515\":1,\"531\":1,\"619\":1}}],[\"踩内存\",{\"0\":{\"531\":1},\"1\":{\"515\":1,\"531\":1}}],[\"写请求越来越多\",{\"1\":{\"1885\":1}}],[\"写请求转发到a\",{\"1\":{\"1790\":1}}],[\"写的是192\",{\"1\":{\"1821\":1}}],[\"写操作需要2个master之间同步\",{\"1\":{\"1885\":1}}],[\"写操作正确发送给了master\",{\"1\":{\"1813\":1}}],[\"写操作少\",{\"1\":{\"1781\":1}}],[\"写成mycat所在机器的ip地址就可以\",{\"1\":{\"1799\":1}}],[\"写成功的话\",{\"1\":{\"1759\":1}}],[\"写完redo\",{\"1\":{\"1763\":1}}],[\"写锁共享锁\",{\"1\":{\"1697\":1}}],[\"写代码时需要强转换成int类型\",{\"1\":{\"1622\":1}}],[\"写入file1\",{\"1\":{\"1271\":1}}],[\"写一句代码在内存的0x0018ff44处写一个4字节的10\",{\"0\":{\"624\":1}}],[\"写null这个反而会让你没那么警觉\",{\"1\":{\"528\":1}}],[\"写了相当于执行一句空语句\",{\"1\":{\"584\":1}}],[\"写了反而会报错\",{\"1\":{\"512\":1}}],[\"写了第一个\",{\"1\":{\"301\":1}}],[\"写在数组名前\",{\"1\":{\"512\":1}}],[\"初始连接量已经不够使用了\",{\"1\":{\"1865\":1}}],[\"初始连接量\",{\"1\":{\"1865\":1}}],[\"初始值为0\",{\"1\":{\"1102\":1}}],[\"初始化时创建\",{\"1\":{\"1859\":1}}],[\"初始化配置\",{\"0\":{\"1401\":1}}],[\"初始化连接句柄\",{\"0\":{\"1373\":1}}],[\"初始化自由链表\",{\"1\":{\"1082\":1}}],[\"初始化静态成员变量\",{\"1\":{\"848\":1}}],[\"初始化快慢指针\",{\"1\":{\"765\":1}}],[\"初始化\",{\"1\":{\"515\":1,\"1847\":1,\"1856\":1}}],[\"初始化后不能改变\",{\"1\":{\"619\":1}}],[\"初始化后不可修改\",{\"1\":{\"480\":1}}],[\"初始化后值不能被修改\",{\"1\":{\"482\":1}}],[\"初始化和使用3个步骤\",{\"1\":{\"456\":1}}],[\"初始化表达式是可选的\",{\"1\":{\"455\":1}}],[\"初始化表达式\",{\"1\":{\"435\":1}}],[\"初始化其他自定义类型的成员对象\",{\"1\":{\"423\":1}}],[\"初始化列表\",{\"0\":{\"422\":1}}],[\"初始化列表和析构函数\",{\"0\":{\"418\":1}}],[\"初值为50\",{\"1\":{\"511\":1}}],[\"养成好的习惯\",{\"1\":{\"510\":1}}],[\"总体以age升序\",{\"1\":{\"1525\":1}}],[\"总共16个元素\",{\"1\":{\"1096\":1}}],[\"总参数表\",{\"1\":{\"666\":1}}],[\"总结回答为什么使用b+树构建索引\",{\"0\":{\"1627\":1}}],[\"总结三条对象优化原则\",{\"0\":{\"1116\":1}}],[\"总结\",{\"0\":{\"608\":1,\"622\":1,\"658\":1,\"959\":1,\"1003\":1,\"1105\":1,\"1190\":1,\"1263\":1,\"1595\":1,\"1721\":1,\"1831\":1},\"1\":{\"629\":1}}],[\"总的来说\",{\"1\":{\"578\":1,\"795\":1}}],[\"总线周期来\",{\"1\":{\"553\":1}}],[\"总是会有动态开辟内存的需求\",{\"1\":{\"509\":1}}],[\"总价\",{\"1\":{\"435\":1,\"439\":1}}],[\"谨慎地使用内联\",{\"0\":{\"505\":1}}],[\"又让一个用户的余额增加才能构成一个完整的事务\",{\"1\":{\"1644\":1}}],[\"又想获取多列信息\",{\"1\":{\"1539\":1}}],[\"又称为s锁\",{\"1\":{\"1697\":1}}],[\"又称为x锁\",{\"1\":{\"1697\":1}}],[\"又称为先期联编\",{\"1\":{\"883\":1}}],[\"又称为拷贝构造函数\",{\"1\":{\"395\":1}}],[\"又定义了一个指向下一个iterator\",{\"1\":{\"747\":1}}],[\"又从a继承来了ma\",{\"1\":{\"688\":1}}],[\"又能够保证在调用点能够找到函数定义从而完成内联\",{\"1\":{\"504\":1}}],[\"声明代码所在的包\",{\"1\":{\"1915\":1}}],[\"声明了protobuf版本\",{\"1\":{\"1915\":1}}],[\"声明变量\",{\"1\":{\"1523\":1}}],[\"声明变量i\",{\"1\":{\"575\":1}}],[\"声明纯虚函数的目的在于\",{\"1\":{\"898\":1}}],[\"声明类型\",{\"1\":{\"784\":1}}],[\"声明可以多次\",{\"1\":{\"639\":1}}],[\"声明引用的同时\",{\"1\":{\"612\":1}}],[\"声明机制\",{\"1\":{\"594\":1}}],[\"声明不会导致编译错误\",{\"1\":{\"578\":1}}],[\"声明都在头文件中\",{\"1\":{\"576\":1}}],[\"声明很多很多变量\",{\"1\":{\"576\":2}}],[\"声明\",{\"0\":{\"578\":1},\"1\":{\"569\":1,\"574\":1,\"593\":1,\"700\":1}}],[\"声明与定义不可混为一谈\",{\"1\":{\"504\":1}}],[\"声明函数\",{\"1\":{\"501\":1}}],[\"面对的请求也越来越多\",{\"1\":{\"1885\":1}}],[\"面试回答问题\",{\"1\":{\"1615\":1}}],[\"面试题\",{\"0\":{\"1938\":1},\"1\":{\"515\":1}}],[\"面试中常问的\",{\"1\":{\"515\":1}}],[\"面试中\",{\"1\":{\"502\":1}}],[\"面向对象用的少\",{\"1\":{\"449\":1}}],[\"面向对象基本概念\",{\"0\":{\"447\":1}}],[\"面向对象的程序设计语言必须有描述对象及其相互之间关系的语言成分\",{\"1\":{\"445\":1}}],[\"现代的后端开发中\",{\"1\":{\"1437\":1}}],[\"现代的编译器可以自动识别一个函数是不是内联函数\",{\"1\":{\"500\":1}}],[\"现在做了垂直的拆分\",{\"1\":{\"1888\":1}}],[\"现在user\",{\"1\":{\"1836\":1}}],[\"现在undo\",{\"1\":{\"1681\":2}}],[\"现在读操作是正确发送给了slave\",{\"1\":{\"1812\":1}}],[\"现在就怎么和mycat通信\",{\"1\":{\"1791\":1}}],[\"现在linux端的mysql\",{\"1\":{\"1785\":1}}],[\"现在修改成执行时间超过1秒的sql都会被记录在慢查询日志当中\",{\"1\":{\"1776\":1}}],[\"现在创建数据库mytest\",{\"1\":{\"1774\":1}}],[\"现在有一个id为1002的事务来更改这条数据\",{\"1\":{\"1681\":1}}],[\"现在有一个id为1001的事务来更改这条数据\",{\"1\":{\"1681\":1}}],[\"现在性能瓶颈在于存储层逻辑\",{\"1\":{\"1437\":1}}],[\"现在不在mysql上做\",{\"1\":{\"1415\":1}}],[\"现在整体结构如下\",{\"1\":{\"1318\":1}}],[\"现在优化\",{\"1\":{\"1183\":1}}],[\"现在的\",{\"1\":{\"1102\":1}}],[\"现在可以从队尾入\",{\"1\":{\"968\":1}}],[\"现在考虑产品\",{\"1\":{\"867\":1}}],[\"现在foo\",{\"1\":{\"528\":1}}],[\"现在假设point类中只显式\",{\"1\":{\"421\":1}}],[\"现在要做的是越过内存控制块返回内存块的首地址\",{\"1\":{\"286\":1}}],[\"现在\",{\"1\":{\"177\":1}}],[\"现在把它分享出来\",{\"1\":{\"3\":1}}],[\"阅读和理解函数\",{\"1\":{\"500\":1}}],[\"阅读时好理解\",{\"1\":{\"500\":1}}],[\"例\",{\"1\":{\"966\":2}}],[\"例2\",{\"0\":{\"1148\":1,\"1178\":1},\"1\":{\"625\":1}}],[\"例1\",{\"0\":{\"1147\":1,\"1177\":1},\"1\":{\"625\":1}}],[\"例题\",{\"0\":{\"623\":1}}],[\"例子中属于单表搜索\",{\"1\":{\"1521\":1}}],[\"例子程序stringqueueappenderexam如下\",{\"1\":{\"1020\":1}}],[\"例子\",{\"1\":{\"605\":1,\"1754\":1}}],[\"例六\",{\"1\":{\"492\":1}}],[\"例五\",{\"1\":{\"492\":1}}],[\"例四\",{\"1\":{\"492\":1}}],[\"例三\",{\"1\":{\"492\":1}}],[\"例二\",{\"1\":{\"492\":1}}],[\"例一\",{\"1\":{\"492\":1}}],[\"例如初始连接量\",{\"1\":{\"1865\":1}}],[\"例如当事务a和事务b并发执行时\",{\"1\":{\"1639\":2}}],[\"例如地址字段\",{\"1\":{\"1460\":1}}],[\"例如空格\",{\"1\":{\"1299\":1}}],[\"例如需要重试100次\",{\"1\":{\"1252\":1}}],[\"例如一个category的优先级为101\",{\"1\":{\"1025\":1}}],[\"例如文件\",{\"1\":{\"1022\":1}}],[\"例如可以将void\",{\"1\":{\"629\":1}}],[\"例如有些函数返回1表示成功\",{\"1\":{\"598\":1}}],[\"例如除数为\",{\"1\":{\"597\":1}}],[\"例如上面\",{\"1\":{\"310\":1}}],[\"例如libc\",{\"1\":{\"283\":1}}],[\"例如在\",{\"0\":{\"271\":1}}],[\"例如const\",{\"1\":{\"267\":1}}],[\"例如\",{\"1\":{\"135\":1,\"182\":1,\"261\":1,\"277\":1,\"312\":1,\"470\":1,\"589\":1,\"604\":1,\"607\":2,\"630\":1,\"641\":1,\"882\":1,\"924\":1,\"968\":1,\"979\":1,\"1019\":1,\"1041\":1,\"1252\":2,\"1278\":1,\"1328\":1,\"1330\":1,\"1333\":1,\"1335\":2,\"1340\":5,\"1341\":1,\"1342\":1,\"1461\":1,\"1639\":1,\"1896\":2,\"1900\":1}}],[\"例如socket相关接口\",{\"1\":{\"16\":1}}],[\"习题\",{\"0\":{\"492\":1}}],[\"法二\",{\"1\":{\"490\":1}}],[\"法一\",{\"1\":{\"490\":1}}],[\"执⾏对象拷⻉时有限制\",{\"1\":{\"489\":1}}],[\"执行protoc\",{\"1\":{\"1915\":1}}],[\"执行器\",{\"1\":{\"1881\":2}}],[\"执行了增删查改操作的\",{\"1\":{\"1656\":1}}],[\"执行了\",{\"1\":{\"1656\":2}}],[\"执行了哪些操作\",{\"0\":{\"290\":1}}],[\"执行授权命令\",{\"1\":{\"1408\":1}}],[\"执行以下命令\",{\"0\":{\"1390\":1}}],[\"执行以下操作\",{\"1\":{\"290\":1}}],[\"执行sql语句\",{\"0\":{\"1376\":1}}],[\"执行当前函数\",{\"1\":{\"1340\":1}}],[\"执行下一行代码\",{\"1\":{\"1340\":2}}],[\"执行代码\",{\"1\":{\"1338\":1}}],[\"执行cmake\",{\"1\":{\"1308\":1,\"1317\":1}}],[\"执行call指令\",{\"1\":{\"1063\":1}}],[\"执行call\",{\"0\":{\"238\":1}}],[\"执行命令ldconfig使设置生效即可\",{\"1\":{\"1030\":1}}],[\"执行出现问题\",{\"1\":{\"948\":1}}],[\"执行成功\",{\"1\":{\"908\":1,\"982\":1,\"992\":1}}],[\"执行失败\",{\"1\":{\"908\":1}}],[\"执行动态绑定\",{\"1\":{\"886\":1}}],[\"执行顺序是先执行派生类的析构函数\",{\"1\":{\"675\":1}}],[\"执行用户定义的基类拷贝构造函数\",{\"1\":{\"662\":1}}],[\"执行缺省的行为\",{\"1\":{\"662\":1}}],[\"执行2的时已经知道了1给b赋了默认值\",{\"1\":{\"639\":1}}],[\"执行一个拷贝操作\",{\"1\":{\"618\":1}}],[\"执行完成才发送下一个事件\",{\"1\":{\"1783\":1}}],[\"执行完sql语句\",{\"1\":{\"1381\":1}}],[\"执行完会再跳转到最后一个catch的下一条语句\",{\"1\":{\"608\":1}}],[\"执行完\",{\"1\":{\"599\":1}}],[\"执行构造初始化\",{\"1\":{\"397\":1,\"464\":1}}],[\"执行效率\",{\"1\":{\"304\":1}}],[\"执行地址映射页面异常处理程序\",{\"1\":{\"263\":1}}],[\"执行typora瘦身程序\",{\"1\":{\"60\":2}}],[\"执行单个md文件的图片瘦身\",{\"1\":{\"60\":1}}],[\"执行\",{\"0\":{\"238\":1},\"1\":{\"30\":1,\"277\":1,\"599\":1,\"1310\":1}}],[\"⽤于声明引⽤变量\",{\"1\":{\"489\":2}}],[\"底层结构就是\",{\"1\":{\"1601\":1}}],[\"底层用的还是下面平台的方法\",{\"1\":{\"1202\":1}}],[\"底层用free执行operator\",{\"1\":{\"519\":1}}],[\"底层元素的类型\",{\"1\":{\"1197\":1}}],[\"底层就是通过指针或者迭代器来实现的\",{\"1\":{\"1194\":1}}],[\"底层malloc方法开辟内存\",{\"1\":{\"1096\":1}}],[\"底层定义的对象的构造和析构\",{\"1\":{\"1086\":1,\"1087\":1}}],[\"底层通过malloc分配内存\",{\"1\":{\"1080\":1}}],[\"底层为\",{\"1\":{\"985\":1,\"998\":1,\"1002\":1}}],[\"底层vector\",{\"1\":{\"984\":1}}],[\"底层默认为一个大根堆\",{\"1\":{\"984\":1}}],[\"底层依赖vector容器\",{\"1\":{\"984\":1}}],[\"底层数据结构为\",{\"1\":{\"992\":1}}],[\"底层数据结构为双向循环链表\",{\"1\":{\"970\":1}}],[\"底层数据结构\",{\"1\":{\"973\":1}}],[\"底层有2个维度\",{\"1\":{\"968\":1}}],[\"底层来看指令一定有一个地方将vfptr写入vftable中\",{\"1\":{\"908\":1}}],[\"底层是通过链式哈希表实现的\",{\"1\":{\"1603\":1}}],[\"底层是pthread\",{\"1\":{\"1227\":2}}],[\"底层是迭代器遍历\",{\"1\":{\"1194\":1}}],[\"底层是指针遍历\",{\"1\":{\"1194\":1}}],[\"底层是一个双向循环链表\",{\"1\":{\"974\":1}}],[\"底层是一个动态开辟的数组\",{\"1\":{\"973\":1,\"974\":1}}],[\"底层是malloc按字节开辟\",{\"1\":{\"715\":1}}],[\"底层是数组\",{\"1\":{\"704\":1}}],[\"底层还是通过容器的迭代器来实现遍历的\",{\"1\":{\"704\":1}}],[\"底层无论是数组还是链表什么的\",{\"1\":{\"698\":1}}],[\"底层实现相同\",{\"1\":{\"614\":1}}],[\"底层const\",{\"1\":{\"489\":2}}],[\"底层只是进行空间开辟\",{\"1\":{\"383\":1}}],[\"顶层const\",{\"1\":{\"489\":3}}],[\"顶层const和底层const\",{\"0\":{\"489\":1}}],[\"杜绝\",{\"1\":{\"485\":1}}],[\"答\",{\"1\":{\"484\":1,\"667\":1}}],[\"答案保存到\",{\"1\":{\"782\":1}}],[\"答案就是逐层向外寻找\",{\"1\":{\"603\":1}}],[\"答案是可以的\",{\"1\":{\"802\":1}}],[\"答案是有的\",{\"1\":{\"500\":1}}],[\"答案是从堆里面获得空间\",{\"1\":{\"282\":1}}],[\"答案中不可以包含重复的三元组\",{\"1\":{\"132\":1}}],[\"叫做readhost\",{\"1\":{\"1803\":1}}],[\"叫做\",{\"1\":{\"1686\":1}}],[\"叫容器\",{\"1\":{\"698\":1}}],[\"叫\",{\"1\":{\"484\":1}}],[\"做项目一定先把功能点想清楚再进行开发\",{\"1\":{\"1866\":1}}],[\"做范围查询的时候\",{\"1\":{\"1626\":1}}],[\"做了整表扫描\",{\"1\":{\"1581\":1}}],[\"做硬链接\",{\"1\":{\"1267\":2}}],[\"做线程间的同步通信操作\",{\"1\":{\"1219\":1}}],[\"做线程间的互斥操作\",{\"1\":{\"1219\":2}}],[\"做的是浅拷贝\",{\"1\":{\"1043\":1}}],[\"做不同接口的信号转换的\",{\"1\":{\"832\":1}}],[\"做字符串的替换\",{\"1\":{\"481\":1}}],[\"做内存映射用的\",{\"1\":{\"267\":1}}],[\"运算后的结果如果需要存储在表内\",{\"1\":{\"1469\":1}}],[\"运算符名就是c++已有的运算符\",{\"1\":{\"727\":1}}],[\"运算符名称\",{\"1\":{\"727\":1}}],[\"运算符不仅能实现原有的功能\",{\"1\":{\"727\":1}}],[\"运算符重载资源释放工作\",{\"1\":{\"1060\":1}}],[\"运算符重载查询\",{\"1\":{\"1000\":1}}],[\"运算符重载函数的对象\",{\"1\":{\"979\":1}}],[\"运算符重载函数进行vector遍历\",{\"1\":{\"966\":3}}],[\"运算符重载前检查有效性\",{\"1\":{\"747\":1}}],[\"运算符重载实现string类\",{\"0\":{\"734\":1}}],[\"运算符重载的规则\",{\"0\":{\"728\":1}}],[\"运算符重载\",{\"0\":{\"1930\":1},\"1\":{\"476\":1,\"698\":1,\"727\":1,\"883\":1,\"965\":1,\"982\":1,\"1087\":1},\"2\":{\"703\":1,\"706\":1,\"720\":1,\"733\":1,\"738\":1,\"749\":1,\"753\":1}}],[\"运行在独立的线程中\",{\"1\":{\"1848\":1,\"1859\":1,\"1875\":1}}],[\"运行命令\",{\"1\":{\"1405\":3}}],[\"运行程序时也看不到这个子线程的任何输出打印了\",{\"1\":{\"1207\":1}}],[\"运行程序时的工作大概如下图\",{\"1\":{\"263\":1}}],[\"运行到这里\",{\"1\":{\"1207\":1}}],[\"运行编译当前文件\",{\"1\":{\"1135\":1}}],[\"运行结果\",{\"1\":{\"599\":1,\"601\":2}}],[\"运行代码\",{\"1\":{\"597\":1}}],[\"运行时加载的库文件\",{\"1\":{\"1331\":1}}],[\"运行时就会跟文件\",{\"1\":{\"1319\":1}}],[\"运行时就可以将其加载到指定段中\",{\"1\":{\"257\":1}}],[\"运行时候才发生动态绑定调用派生类的show方法\",{\"1\":{\"906\":1}}],[\"运行时多态\",{\"1\":{\"883\":1}}],[\"运行时错误如果放任不管\",{\"1\":{\"597\":1}}],[\"运行时错误是指程序在运行期间发生的错误\",{\"1\":{\"597\":1}}],[\"运行时\",{\"1\":{\"564\":1,\"1030\":1}}],[\"运行时赋值\",{\"1\":{\"484\":1}}],[\"运行时会在栈上开辟空间存储变量值\",{\"1\":{\"267\":1}}],[\"运行时会把程序从磁盘加载到内存\",{\"1\":{\"267\":1}}],[\"运行时把可执行程序的哪些东西加载到内存中\",{\"1\":{\"267\":1}}],[\"运行时把哪些内容加载到内存中\",{\"1\":{\"262\":1}}],[\"命名空间是可以嵌套的\",{\"1\":{\"594\":1}}],[\"命名空间是可以进行扩展的\",{\"1\":{\"594\":2}}],[\"命名空间中number\",{\"1\":{\"594\":1}}],[\"命名空间中可以定义变量\",{\"1\":{\"594\":3}}],[\"命名空间+作用域限定符的形式\",{\"1\":{\"594\":1}}],[\"命名空间的嵌套及覆盖\",{\"0\":{\"592\":1}}],[\"命名空间的使用方式\",{\"0\":{\"587\":1}}],[\"命名空间还可以不定义名字\",{\"1\":{\"591\":1}}],[\"命名空间一共有三种使用方式\",{\"1\":{\"587\":1}}],[\"命名空间又称为名字空间\",{\"1\":{\"583\":1}}],[\"命名空间\",{\"0\":{\"581\":1},\"1\":{\"476\":1,\"585\":1,\"589\":1,\"594\":3}}],[\"命令导入数据的时候\",{\"1\":{\"1728\":1}}],[\"命令后\",{\"1\":{\"1656\":1}}],[\"命令如下\",{\"1\":{\"1408\":1,\"1410\":1}}],[\"命令会一直执行\",{\"1\":{\"1355\":1}}],[\"命令来查看指定地址的内存值\",{\"0\":{\"1347\":1}}],[\"命令为某个表达式分配了编号1\",{\"1\":{\"1341\":1}}],[\"命令加上这个编号来删除特定的自动显示表达式\",{\"1\":{\"1341\":1}}],[\"命令时\",{\"1\":{\"1341\":1}}],[\"命令的作用如下\",{\"1\":{\"1338\":1}}],[\"命令的目录\",{\"1\":{\"1310\":1}}],[\"命令在\",{\"1\":{\"1338\":1}}],[\"命令完成\",{\"1\":{\"1332\":1}}],[\"命令格式和参数\",{\"1\":{\"1245\":1}}],[\"命令行参数如main函数传参\",{\"1\":{\"267\":1}}],[\"命令行参数\",{\"1\":{\"267\":1}}],[\"命令逐步执行汇编指令\",{\"1\":{\"261\":1}}],[\"命令查看汇编代码\",{\"1\":{\"261\":1}}],[\"命令运行程序\",{\"1\":{\"261\":1}}],[\"命令\",{\"1\":{\"261\":3,\"1410\":1,\"1656\":1,\"1833\":1}}],[\"子查询\",{\"0\":{\"1515\":1}}],[\"子表\",{\"1\":{\"1415\":3}}],[\"子线程和主线程就毫无关系了\",{\"1\":{\"1207\":1}}],[\"子线程睡眠\",{\"0\":{\"1207\":1}}],[\"子线程函数运行完成\",{\"1\":{\"1205\":1}}],[\"子线程如何结束\",{\"0\":{\"1205\":1}}],[\"子线程也不一定终止\",{\"1\":{\"1050\":1}}],[\"子分类subcat1\",{\"1\":{\"1018\":1}}],[\"子分类的输出同时会输出到父分类中\",{\"1\":{\"1018\":1}}],[\"子类\",{\"1\":{\"684\":1}}],[\"子类如果有自己的数据成员\",{\"1\":{\"470\":1}}],[\"子类继承空类后\",{\"1\":{\"470\":1}}],[\"子对象\",{\"1\":{\"434\":1}}],[\"形成了一个有序的链表\",{\"1\":{\"1626\":1}}],[\"形式\",{\"0\":{\"463\":1,\"646\":1,\"666\":1,\"683\":1},\"1\":{\"721\":1}}],[\"形参t对象析构\",{\"1\":{\"1115\":1}}],[\"形参压栈的值都是固定的10\",{\"1\":{\"906\":1}}],[\"形参表\",{\"1\":{\"727\":1}}],[\"形参带默认值的函数\",{\"1\":{\"638\":1}}],[\"形参列表\",{\"1\":{\"616\":1,\"1172\":1}}],[\"形参number\",{\"1\":{\"592\":1,\"594\":1}}],[\"形参是nullptr\",{\"1\":{\"405\":1}}],[\"形参的地址归还给系统\",{\"1\":{\"234\":1}}],[\"生产连接池\",{\"1\":{\"1875\":1}}],[\"生产对象放入que队列中\",{\"1\":{\"1221\":1}}],[\"生产\",{\"1\":{\"1219\":2}}],[\"生产物品\",{\"1\":{\"1219\":2}}],[\"生产者发出信号\",{\"1\":{\"1871\":1}}],[\"生产者创建连接\",{\"1\":{\"1859\":1}}],[\"生产者再继续生产\",{\"1\":{\"1219\":1}}],[\"生产者应该通知消费者去消费\",{\"1\":{\"1219\":1}}],[\"生产者生产一个物品\",{\"1\":{\"1219\":3}}],[\"生产者线程的实现\",{\"0\":{\"1875\":1}}],[\"生产者线程处于阻塞状态\",{\"1\":{\"1221\":1}}],[\"生产者线程没有拿到互斥锁\",{\"1\":{\"1221\":1}}],[\"生产者线程进入\",{\"1\":{\"1219\":1}}],[\"生产者线程\",{\"1\":{\"1219\":2}}],[\"生产者\",{\"0\":{\"1215\":1,\"1219\":1},\"1\":{\"1219\":2,\"1863\":1}}],[\"生产线上也有可能生产轮胎\",{\"1\":{\"866\":1}}],[\"生存周期了\",{\"1\":{\"1113\":1}}],[\"生命周期从第一次被初始化起至程序结束止\",{\"1\":{\"850\":1}}],[\"生命周期只在本行\",{\"1\":{\"459\":1}}],[\"生成执行计划\",{\"1\":{\"1881\":1}}],[\"生成语法树\",{\"1\":{\"1881\":1}}],[\"生成数据快照\",{\"1\":{\"1663\":1}}],[\"生成core\",{\"1\":{\"1338\":1}}],[\"生成目标文件gcc\",{\"1\":{\"1331\":1}}],[\"生成的附带文件就只会待在\",{\"1\":{\"1319\":1}}],[\"生成对象必须要有内存传给this调用构造函数\",{\"1\":{\"1073\":1}}],[\"生成add\",{\"1\":{\"572\":1}}],[\"生成一个新的binlog\",{\"1\":{\"1773\":1}}],[\"生成一个快照\",{\"1\":{\"1656\":1}}],[\"生成一个string对象\",{\"1\":{\"537\":1}}],[\"生成一个空字符串\",{\"1\":{\"537\":1}}],[\"生成了二进制的可重定位的目标文件\",{\"1\":{\"245\":1}}],[\"便不会使用索引\",{\"1\":{\"1617\":1}}],[\"便于调试\",{\"1\":{\"1338\":1}}],[\"便于两头都预留足够的空间\",{\"1\":{\"968\":1}}],[\"便于软件升级\",{\"1\":{\"826\":1}}],[\"便于排版吧\",{\"1\":{\"59\":1}}],[\"便只有\",{\"1\":{\"454\":1}}],[\"作为一种效率和兼容性都很优秀的二进制数据传输格式\",{\"1\":{\"1913\":1}}],[\"作为连接的生产者\",{\"1\":{\"1849\":1,\"1859\":1,\"1875\":1}}],[\"作为缓冲区\",{\"1\":{\"1783\":1}}],[\"作为过滤条件\",{\"1\":{\"1700\":1}}],[\"作为线程入口函数\",{\"1\":{\"1207\":1}}],[\"作用就是快速判断表里是否有记录被加锁\",{\"1\":{\"1672\":1}}],[\"作用\",{\"0\":{\"1334\":1},\"1\":{\"721\":1,\"1060\":1,\"1076\":1,\"1099\":1,\"1102\":1}}],[\"作用域隐藏\",{\"1\":{\"695\":1}}],[\"作用域限定符\",{\"0\":{\"589\":1},\"1\":{\"449\":1,\"587\":1,\"594\":4}}],[\"作用是用来说明\",{\"1\":{\"574\":1}}],[\"作标识符\",{\"1\":{\"316\":1}}],[\"熟悉的计算机来举例\",{\"1\":{\"449\":1}}],[\"功能实现设计\",{\"0\":{\"1866\":1}}],[\"功能实现由嵌套类实现\",{\"1\":{\"826\":1}}],[\"功能\",{\"1\":{\"449\":1,\"1356\":1}}],[\"功能是将参数指向的内存块进行释放\",{\"1\":{\"287\":1}}],[\"功能是动态的分配一块满足参数要求的内存块\",{\"1\":{\"286\":1}}],[\"千万不要忘了这个分号\",{\"1\":{\"449\":1}}],[\"车站有100张车票\",{\"1\":{\"1208\":1}}],[\"车道偏离\",{\"1\":{\"831\":1}}],[\"车\",{\"1\":{\"449\":1}}],[\"继续通过\",{\"1\":{\"1720\":1}}],[\"继续通知生产者\",{\"1\":{\"1221\":1}}],[\"继续运行步骤1中的命令\",{\"1\":{\"1405\":1}}],[\"继续删除剩余依赖项\",{\"1\":{\"1405\":1}}],[\"继续安装依赖\",{\"1\":{\"1397\":1}}],[\"继续执行\",{\"1\":{\"1318\":1}}],[\"继续向下执行\",{\"1\":{\"1221\":1}}],[\"继续判断后面的迭代器节点是否失效\",{\"1\":{\"747\":1}}],[\"继续缩小左区间\",{\"1\":{\"96\":2}}],[\"继承结构中基类派生类同名覆盖方法不同默认值问题\",{\"0\":{\"906\":1}}],[\"继承多态与虚函数案例分析\",{\"0\":{\"904\":1}}],[\"继承纯虚函数\",{\"1\":{\"900\":1}}],[\"继承性\",{\"1\":{\"882\":1}}],[\"继承可以扩展已存在的代码模块\",{\"1\":{\"882\":1}}],[\"继承的概念被用来组合接口和定义组合对象获得新功能的方式\",{\"1\":{\"829\":1}}],[\"继承的本质\",{\"0\":{\"682\":1}}],[\"继承的本质和原理\",{\"0\":{\"681\":1}}],[\"继承基类的成员\",{\"1\":{\"684\":1}}],[\"继承之后\",{\"1\":{\"684\":2}}],[\"继承中的类型转换\",{\"0\":{\"678\":1}}],[\"继承机制下析构函数的调用顺序\",{\"1\":{\"675\":1}}],[\"继承用的多\",{\"1\":{\"449\":1}}],[\"继承是多态的前提\",{\"1\":{\"448\":1}}],[\"继承\",{\"0\":{\"1929\":1},\"1\":{\"448\":1,\"657\":4,\"682\":1,\"684\":1},\"2\":{\"655\":1,\"661\":1,\"664\":1,\"677\":1,\"680\":1,\"687\":1,\"690\":1,\"697\":1,\"942\":1}}],[\"仅看====\",{\"1\":{\"1514\":1}}],[\"仅由决定\",{\"1\":{\"562\":1}}],[\"仅将\",{\"1\":{\"504\":1}}],[\"仅对外提供公共访问方式\",{\"1\":{\"448\":1}}],[\"仅仅返回2000000\",{\"1\":{\"1740\":1}}],[\"仅仅返回类型不同不是函数重载\",{\"1\":{\"563\":1}}],[\"仅仅返回类型不同不足以成为函数的重载\",{\"1\":{\"560\":1}}],[\"仅仅的类的抽象\",{\"1\":{\"388\":1}}],[\"仅仅是sql语句不同\",{\"1\":{\"1384\":1}}],[\"仅仅是将数据和函数捆绑在一起\",{\"1\":{\"881\":1}}],[\"仅仅是个编号\",{\"1\":{\"308\":1}}],[\"仅仅是\",{\"1\":{\"136\":1}}],[\"隐式生成临时对象\",{\"1\":{\"1112\":1}}],[\"隐式转换成相应的类型\",{\"1\":{\"526\":1}}],[\"隐式实例化\",{\"1\":{\"364\":1}}],[\"隐式实例化与显示实例化\",{\"0\":{\"364\":1}}],[\"隐藏⽗类的fun函数\",{\"1\":{\"695\":2}}],[\"隐藏是指的把\",{\"1\":{\"695\":1}}],[\"隐藏\",{\"0\":{\"691\":1,\"695\":1},\"1\":{\"448\":1,\"695\":2}}],[\"封装的queue代码\",{\"1\":{\"1219\":1}}],[\"封装成日志类\",{\"0\":{\"1032\":1}}],[\"封装可以隐藏实现细节\",{\"1\":{\"882\":1}}],[\"封装\",{\"1\":{\"448\":1}}],[\"忽略一个主题中与当前目标无关的东西\",{\"1\":{\"448\":1}}],[\"抽象出来的\",{\"1\":{\"1610\":1}}],[\"抽象一个实体的类型\",{\"1\":{\"905\":1}}],[\"抽象工厂对比\",{\"0\":{\"868\":1}}],[\"抽象工厂其实就是解决设计的\",{\"1\":{\"867\":1}}],[\"抽象工厂\",{\"0\":{\"860\":1,\"867\":1},\"1\":{\"867\":1}}],[\"抽象基类\",{\"1\":{\"831\":1}}],[\"抽象类不能实例化对象\",{\"1\":{\"901\":1}}],[\"抽象类的目的不是为了抽象一个实体的类型\",{\"1\":{\"901\":1}}],[\"抽象类的形式\",{\"0\":{\"900\":1}}],[\"抽象类和普通类的区别\",{\"0\":{\"901\":1}}],[\"抽象类必须重写\",{\"1\":{\"867\":1}}],[\"抽象类\",{\"0\":{\"899\":1},\"1\":{\"830\":1,\"900\":1}}],[\"抽象\",{\"1\":{\"448\":1}}],[\"错误信息\",{\"1\":{\"1915\":1}}],[\"错误码\",{\"1\":{\"1915\":1}}],[\"错误日志是\",{\"1\":{\"1770\":1}}],[\"错误日志\",{\"0\":{\"1770\":1},\"1\":{\"1767\":1,\"1821\":1}}],[\"错误的例子\",{\"1\":{\"490\":1}}],[\"错误\",{\"1\":{\"441\":1,\"563\":1,\"620\":1,\"695\":2,\"1251\":1,\"1318\":2}}],[\"错误写法\",{\"1\":{\"432\":1}}],[\"既可读也可以修改\",{\"1\":{\"1011\":1}}],[\"既可以通过取地址\",{\"1\":{\"455\":1}}],[\"既可以调用const版本的成员函数\",{\"1\":{\"440\":1}}],[\"既解耦了对象的创建\",{\"1\":{\"863\":1}}],[\"既然会排序\",{\"1\":{\"1737\":1}}],[\"既然发生了不可重复读\",{\"1\":{\"1634\":1}}],[\"既然lambda表达式只能使用在语句当中\",{\"1\":{\"1180\":1}}],[\"既然new\",{\"0\":{\"514\":1}}],[\"既然涉及到对象的创建\",{\"1\":{\"395\":1}}],[\"购买第二台电脑总价\",{\"1\":{\"439\":1}}],[\"购买第一台电脑总价\",{\"1\":{\"439\":1}}],[\"除单个\",{\"1\":{\"1706\":1}}],[\"除非必须\",{\"1\":{\"1724\":1}}],[\"除非有新的数据被commit\",{\"1\":{\"1658\":1}}],[\"除非进行强转\",{\"1\":{\"678\":1}}],[\"除此以外还提供了一些帮助类\",{\"1\":{\"1017\":1}}],[\"除此以外\",{\"1\":{\"539\":1,\"900\":1}}],[\"除了优化sql和索引\",{\"1\":{\"1745\":1}}],[\"除了age=21这条数据加了共享锁\",{\"1\":{\"1693\":1}}],[\"除了我们自行设定的字段book\",{\"1\":{\"1681\":1}}],[\"除了挨个检查\",{\"1\":{\"1672\":1}}],[\"除了自己的更新记录总是可见之外\",{\"1\":{\"1656\":1}}],[\"除了第一个表外\",{\"1\":{\"1618\":1}}],[\"除了第一个位置无法处理\",{\"1\":{\"1552\":1}}],[\"除了单独存储索引外\",{\"1\":{\"1557\":1}}],[\"除了主键\",{\"1\":{\"1463\":1}}],[\"除了字符\",{\"1\":{\"1426\":1}}],[\"除了上面的链接命令\",{\"1\":{\"1331\":1}}],[\"除了公有继承基类中的公有成员可以访问外\",{\"1\":{\"658\":1}}],[\"除了基类的私有成员不可以访问外\",{\"1\":{\"658\":1}}],[\"除了static修饰的指针变量\",{\"1\":{\"531\":1}}],[\"除了这种方式可以创建常量外\",{\"1\":{\"480\":1}}],[\"除了去掉point\",{\"1\":{\"458\":1}}],[\"除了可以在类内部实现外\",{\"1\":{\"449\":1}}],[\"除了特殊的数据成员以外\",{\"1\":{\"438\":1}}],[\"除法\",{\"1\":{\"344\":1}}],[\"价格\",{\"1\":{\"435\":1}}],[\"品牌\",{\"1\":{\"435\":1}}],[\"修饰数据成员\",{\"1\":{\"435\":1}}],[\"修改都是优先操作缓存池中的数据\",{\"1\":{\"1758\":1}}],[\"修改query\",{\"1\":{\"1750\":1}}],[\"修改当前数据的事务id\",{\"1\":{\"1682\":1}}],[\"修改之前的数据都是放在undo\",{\"1\":{\"1681\":1}}],[\"修改的数据存放在当前这个表中\",{\"1\":{\"1681\":1}}],[\"修改的是实参\",{\"1\":{\"1175\":1}}],[\"修改提交方式\",{\"0\":{\"1652\":1}}],[\"修改后会影响所有的session\",{\"1\":{\"1577\":1}}],[\"修改表名\",{\"1\":{\"1552\":1}}],[\"修改表中所有数据\",{\"1\":{\"1492\":1}}],[\"修改字段名\",{\"1\":{\"1552\":1}}],[\"修改字段类型方式2\",{\"1\":{\"1552\":1}}],[\"修改字段类型方式1\",{\"1\":{\"1552\":1}}],[\"修改回来\",{\"1\":{\"1523\":1}}],[\"修改语句结束的符号\",{\"1\":{\"1523\":1}}],[\"修改数据\",{\"1\":{\"1492\":1}}],[\"修改权限\",{\"1\":{\"1485\":1,\"1486\":1}}],[\"修改变量的值\",{\"1\":{\"1340\":1}}],[\"修改环境变量\",{\"1\":{\"1335\":1}}],[\"修改和提取静态库文件\",{\"1\":{\"1334\":1}}],[\"修改成alias\",{\"1\":{\"1283\":1}}],[\"修改成功\",{\"1\":{\"688\":1}}],[\"修改ll\",{\"0\":{\"1283\":1}}],[\"修改ps1样式\",{\"0\":{\"1282\":1}}],[\"修改dns让它和windows里面的dns一致\",{\"1\":{\"1278\":1}}],[\"修改ip\",{\"1\":{\"1278\":1}}],[\"修改file2\",{\"1\":{\"1271\":1}}],[\"修改flags\",{\"1\":{\"63\":1}}],[\"修改文件b\",{\"1\":{\"1267\":1}}],[\"修改了\",{\"1\":{\"1102\":1}}],[\"修改归还的\",{\"1\":{\"1093\":1}}],[\"修改\",{\"0\":{\"1281\":1,\"1384\":1},\"1\":{\"1093\":2,\"1102\":3,\"1209\":1}}],[\"修改链表结构\",{\"1\":{\"756\":1}}],[\"修改为catch\",{\"1\":{\"605\":1}}],[\"修改为\",{\"1\":{\"605\":1}}],[\"修改式操作\",{\"1\":{\"535\":1}}],[\"修改函数要比找出并修改每一处等价表达式容易得多\",{\"1\":{\"500\":1}}],[\"修改时好找\",{\"1\":{\"500\":1}}],[\"修改沙箱属性也没办法\",{\"1\":{\"58\":1}}],[\"修改加粗样式\",{\"0\":{\"50\":1},\"1\":{\"50\":1}}],[\"修改代码块的样式\",{\"1\":{\"49\":1}}],[\"修改下划线的颜色和高度\",{\"0\":{\"48\":1}}],[\"性\",{\"1\":{\"432\":1}}],[\"性能原因\",{\"1\":{\"553\":1}}],[\"性能分析\",{\"1\":{\"202\":1}}],[\"性能\",{\"0\":{\"195\":1}}],[\"未使用连接池耗时\",{\"1\":{\"1851\":1}}],[\"未提交时\",{\"1\":{\"1658\":1}}],[\"未提交读\",{\"1\":{\"1631\":1,\"1665\":1}}],[\"未解决可重复读和幻读\",{\"1\":{\"1658\":1}}],[\"未考虑扩容与ptr合法性\",{\"1\":{\"747\":1}}],[\"未写继承方式\",{\"1\":{\"659\":1}}],[\"未定义行为\",{\"1\":{\"633\":1}}],[\"未加extern\",{\"0\":{\"578\":1}}],[\"未初始化\",{\"1\":{\"422\":1}}],[\"未添加事件\",{\"1\":{\"59\":1}}],[\"举例来说\",{\"1\":{\"1686\":1}}],[\"举例说明\",{\"1\":{\"422\":1}}],[\"举个例子\",{\"1\":{\"832\":1}}],[\"举个例子如下\",{\"1\":{\"277\":1}}],[\"方式解决了幻读\",{\"1\":{\"1717\":2}}],[\"方式有3种\",{\"1\":{\"657\":1}}],[\"方便程序的存储与查找\",{\"1\":{\"1426\":1}}],[\"方便任何一边的元素改动\",{\"1\":{\"968\":1}}],[\"方便许多\",{\"1\":{\"886\":1}}],[\"方便控制\",{\"1\":{\"837\":1}}],[\"方便做删除操作\",{\"1\":{\"774\":1}}],[\"方便重用\",{\"1\":{\"500\":1}}],[\"方便扩容\",{\"1\":{\"406\":1}}],[\"方法步骤如下\",{\"1\":{\"1405\":1}}],[\"方法还需要继续增加\",{\"1\":{\"886\":1}}],[\"方法2\",{\"0\":{\"849\":1},\"1\":{\"832\":1}}],[\"方法1\",{\"0\":{\"848\":1},\"1\":{\"832\":1}}],[\"方法后\",{\"1\":{\"741\":2}}],[\"方法\",{\"0\":{\"1903\":1},\"1\":{\"631\":1,\"698\":2,\"906\":1,\"1212\":1}}],[\"方法就好\",{\"1\":{\"631\":1}}],[\"方法是消息的序列\",{\"1\":{\"445\":1}}],[\"方法三\",{\"0\":{\"143\":1},\"1\":{\"1296\":1}}],[\"方法一的缺点是\",{\"1\":{\"802\":1}}],[\"方法一\",{\"0\":{\"114\":1,\"125\":1,\"133\":1,\"141\":1,\"148\":1,\"153\":1,\"178\":1,\"755\":1,\"782\":1,\"802\":1,\"1287\":1,\"1314\":1},\"1\":{\"48\":1,\"771\":1,\"777\":1,\"1296\":1}}],[\"方法二\",{\"0\":{\"115\":1,\"126\":1,\"137\":1,\"142\":1,\"149\":1,\"154\":1,\"179\":1,\"756\":1,\"783\":1,\"803\":1,\"1288\":1,\"1315\":1},\"1\":{\"27\":1,\"48\":1,\"771\":1,\"777\":1,\"1296\":1}}],[\"申请空间\",{\"1\":{\"1127\":2}}],[\"申请成功\",{\"1\":{\"1102\":1}}],[\"申请\",{\"1\":{\"1099\":1}}],[\"申请新的空间然后将数据拷贝进去\",{\"1\":{\"735\":1}}],[\"申请堆空间\",{\"1\":{\"515\":2}}],[\"申请队列的数组空间\",{\"1\":{\"406\":1}}],[\"申请失败\",{\"1\":{\"286\":1,\"1102\":1}}],[\"判空\",{\"1\":{\"406\":1,\"991\":1}}],[\"判满\",{\"1\":{\"406\":1}}],[\"判断条件\",{\"1\":{\"1500\":6,\"1501\":2}}],[\"判断队空\",{\"1\":{\"992\":1}}],[\"判断栈空\",{\"1\":{\"990\":1}}],[\"判断容器是否为空\",{\"1\":{\"965\":1,\"969\":1,\"970\":1}}],[\"判断两个类是否属于同一个类\",{\"1\":{\"957\":1}}],[\"判断语句的技术称为双检锁\",{\"1\":{\"848\":1}}],[\"判断链表是否相交\",{\"0\":{\"771\":1},\"1\":{\"771\":1}}],[\"判断链表是否包含环属于经典问题了\",{\"1\":{\"765\":1}}],[\"判断链表是否有环\",{\"0\":{\"765\":1},\"1\":{\"765\":1}}],[\"判断是否为空\",{\"1\":{\"1471\":1}}],[\"判断是否为自赋值\",{\"1\":{\"1127\":1}}],[\"判断是否回文\",{\"1\":{\"756\":2}}],[\"判断是否存在重复元素\",{\"1\":{\"152\":1}}],[\"判断是否存在三元组\",{\"1\":{\"132\":1}}],[\"判断对错\",{\"0\":{\"625\":1}}],[\"判断打印调试\",{\"1\":{\"306\":1}}],[\"判断该块是否可用\",{\"1\":{\"286\":1}}],[\"判断数组中是否存在两个\",{\"1\":{\"158\":1}}],[\"判断相等时一定要小心\",{\"1\":{\"142\":1}}],[\"判断的逻辑\",{\"1\":{\"136\":1}}],[\"判断\",{\"1\":{\"135\":1,\"174\":1,\"491\":1}}],[\"判断目录是否存在\",{\"1\":{\"60\":1}}],[\"判断字符串是否以指定后缀结尾\",{\"1\":{\"60\":1}}],[\"入优先级队列\",{\"1\":{\"992\":1}}],[\"入队\",{\"1\":{\"991\":1}}],[\"入队操作\",{\"1\":{\"406\":1}}],[\"入栈\",{\"1\":{\"233\":1,\"990\":1}}],[\"让子线程睡眠time秒ace\",{\"1\":{\"1207\":1}}],[\"让子线程睡眠time秒\",{\"1\":{\"1207\":1}}],[\"让用户更加方便使用\",{\"1\":{\"1202\":1}}],[\"让\",{\"1\":{\"1102\":1}}],[\"让所有的派生类类通过继承基类直接复用该属性\",{\"1\":{\"901\":1}}],[\"让派生类进行重写\",{\"1\":{\"883\":1}}],[\"让线程也拥有资源\",{\"1\":{\"840\":1}}],[\"让不兼容的接口可以在一起工作\",{\"1\":{\"832\":2}}],[\"让长的先走m\",{\"1\":{\"771\":1}}],[\"让新链表的指针往前走一位\",{\"1\":{\"762\":1}}],[\"让迭代器知道当前迭代的容器对象\",{\"1\":{\"747\":1}}],[\"让编译器做更多的检查错误工作\",{\"1\":{\"637\":1}}],[\"让我们能够捕获运行时错误\",{\"1\":{\"597\":1}}],[\"让其他文件找不到\",{\"1\":{\"591\":1}}],[\"让他加到前面去\",{\"1\":{\"406\":1}}],[\"让两个指针指向不同堆空间的方式叫深拷贝\",{\"1\":{\"397\":1}}],[\"匿名命名空间的本质是什么\",{\"1\":{\"591\":1}}],[\"匿名命名空间\",{\"0\":{\"591\":1},\"1\":{\"594\":1}}],[\"匿名对象\",{\"1\":{\"400\":1,\"459\":1}}],[\"匿名管道通信就是在内核空间划分一道地址空间进行通信\",{\"1\":{\"267\":1}}],[\"浅拷贝\",{\"1\":{\"397\":1,\"464\":1}}],[\"浅拷贝出错问题\",{\"1\":{\"397\":1}}],[\"浅拷贝和深拷贝\",{\"0\":{\"397\":1}}],[\"浅蓝色\",{\"1\":{\"29\":2}}],[\"释放连接资源\",{\"1\":{\"1881\":1}}],[\"释放连接\",{\"1\":{\"1849\":1,\"1859\":1}}],[\"释放多余的连接\",{\"1\":{\"1849\":1,\"1859\":1}}],[\"释放资源\",{\"1\":{\"1847\":1,\"1856\":1}}],[\"释放线程占用的所有表锁\",{\"1\":{\"1671\":1}}],[\"释放结果集\",{\"1\":{\"1385\":1}}],[\"释放结果集占用的内存\",{\"0\":{\"1381\":1}}],[\"释放锁\",{\"1\":{\"1210\":1}}],[\"释放thread对象占用的堆资源\",{\"1\":{\"1151\":1}}],[\"释放原来对象占用的空间\",{\"1\":{\"1127\":1}}],[\"释放数组\",{\"1\":{\"1127\":1}}],[\"释放内存\",{\"1\":{\"1102\":1}}],[\"释放的方式不是delete\",{\"1\":{\"1060\":1}}],[\"释放单实例\",{\"1\":{\"848\":1,\"851\":1}}],[\"释放之前所占的外部资源\",{\"1\":{\"735\":1}}],[\"释放派生类内存中从基类继承来的成员可能占用的外部资源\",{\"1\":{\"675\":1}}],[\"释放派生类成员可能占用的外部资源\",{\"1\":{\"675\":1}}],[\"释放位置被后移了4字节\",{\"1\":{\"523\":1}}],[\"释放位置也不对\",{\"1\":{\"522\":1}}],[\"释放空间\",{\"1\":{\"519\":1}}],[\"释放堆空间\",{\"1\":{\"515\":2}}],[\"释放堆上的数组内存\",{\"1\":{\"385\":2,\"704\":2}}],[\"释放左操作数\",{\"1\":{\"464\":1,\"548\":1}}],[\"释放当前的外部资源\",{\"1\":{\"405\":1}}],[\"释放由其分配的内存\",{\"1\":{\"282\":1,\"285\":1}}],[\"定速巡航\",{\"1\":{\"831\":2}}],[\"定位new\",{\"1\":{\"385\":1,\"511\":1,\"704\":1,\"1080\":1,\"1087\":1}}],[\"定义登录响应消息类型\",{\"1\":{\"1915\":1}}],[\"定义登录请求消息类型\",{\"1\":{\"1915\":1}}],[\"定义最终目标\",{\"1\":{\"1365\":1}}],[\"定义目标文件\",{\"1\":{\"1365\":1}}],[\"定义源文件\",{\"1\":{\"1365\":1}}],[\"定义编译器\",{\"1\":{\"1365\":1}}],[\"定义了ndebug宏\",{\"1\":{\"1321\":1}}],[\"定义了一些和时间相关的常量\",{\"1\":{\"1207\":1}}],[\"定义条件变量\",{\"1\":{\"1219\":1}}],[\"定义互斥锁\",{\"1\":{\"1219\":1}}],[\"定义相应的参数\",{\"1\":{\"1190\":1}}],[\"定义funtion\",{\"1\":{\"1154\":1}}],[\"定义对象\",{\"1\":{\"1056\":1}}],[\"定义的是base\",{\"1\":{\"953\":1}}],[\"定义虚函数的主要目的是为了重写达到多态\",{\"1\":{\"876\":1}}],[\"定义一下比较函数\",{\"1\":{\"784\":1}}],[\"定义一个char\",{\"1\":{\"1426\":1}}],[\"定义一个test类\",{\"1\":{\"1189\":1}}],[\"定义一个指针指向\",{\"1\":{\"1096\":1}}],[\"定义一个变量只需要内存就行\",{\"1\":{\"1073\":1}}],[\"定义一个全局变量\",{\"1\":{\"575\":1}}],[\"定义一个名为\",{\"1\":{\"530\":1}}],[\"定义一个模板参数列表\",{\"1\":{\"365\":1,\"366\":1,\"368\":1}}],[\"定义一个返回值\",{\"1\":{\"81\":1}}],[\"定义在名称空间中的变量或者函数都称为实体\",{\"1\":{\"586\":1}}],[\"定义体前面都加了\",{\"1\":{\"504\":1}}],[\"定义函数时\",{\"1\":{\"501\":1}}],[\"定义容器的空间配置器对象\",{\"1\":{\"385\":1,\"704\":1}}],[\"定义为\",{\"1\":{\"146\":1}}],[\"定义\",{\"0\":{\"931\":1,\"1649\":1},\"1\":{\"50\":3,\"574\":2,\"1047\":1}}],[\"负责写\",{\"1\":{\"1885\":1}}],[\"负责读\",{\"1\":{\"1885\":1}}],[\"负责对象的析构\",{\"1\":{\"1127\":1}}],[\"负责对象的构造\",{\"1\":{\"1127\":3}}],[\"负责对象构造\",{\"1\":{\"385\":1,\"704\":1,\"1080\":1,\"1087\":1}}],[\"负责内存的释放\",{\"1\":{\"1127\":1}}],[\"负责内存的开辟\",{\"1\":{\"1127\":1}}],[\"负责初始化和清理派生类部分\",{\"1\":{\"667\":1}}],[\"负数快速求机器数的方法\",{\"1\":{\"345\":1}}],[\"已提交\",{\"1\":{\"1658\":1}}],[\"已提交读解决了脏读\",{\"1\":{\"1658\":1}}],[\"已提交读隔离级别采用非锁定读\",{\"1\":{\"1658\":1}}],[\"已提交读隔离级别\",{\"1\":{\"1656\":1}}],[\"已提交读\",{\"1\":{\"1631\":1,\"1665\":1,\"1677\":1}}],[\"已知n个人\",{\"1\":{\"810\":1}}],[\"已经符合了生成快照的条件\",{\"1\":{\"1664\":1}}],[\"已经超过我们设置的long\",{\"1\":{\"1579\":1}}],[\"已经下载的字节\",{\"1\":{\"1249\":1}}],[\"已经没有空间了\",{\"1\":{\"968\":1}}],[\"已经有对象池\",{\"1\":{\"751\":1}}],[\"已经使用c编译方式编译成了可重定向的文件\",{\"0\":{\"568\":1}}],[\"已经开辟好的内存上\",{\"1\":{\"385\":1,\"704\":1,\"1080\":1,\"1087\":1}}],[\"已删除无用图片\",{\"1\":{\"60\":1}}],[\"③resize\",{\"1\":{\"969\":1,\"970\":1}}],[\"③reserve\",{\"1\":{\"965\":1}}],[\"③erase\",{\"1\":{\"969\":1,\"970\":1}}],[\"③insert\",{\"1\":{\"969\":1,\"970\":1}}],[\"③find\",{\"1\":{\"965\":1}}],[\"③delete执行其实有两步\",{\"1\":{\"513\":1,\"708\":1}}],[\"③malloc只负责开辟内存空间\",{\"1\":{\"513\":1,\"708\":1}}],[\"③只需要析构对象\",{\"1\":{\"384\":1}}],[\"③有正有负\",{\"1\":{\"87\":1}}],[\"②pop\",{\"1\":{\"969\":1,\"970\":1}}],[\"②push\",{\"1\":{\"969\":1,\"970\":1}}],[\"②empty\",{\"1\":{\"965\":1,\"969\":1,\"970\":1}}],[\"②erase\",{\"1\":{\"965\":1}}],[\"②iterator\",{\"1\":{\"965\":1}}],[\"②insert\",{\"1\":{\"965\":1}}],[\"②delete\",{\"1\":{\"523\":1}}],[\"②delete释放单个元素内存\",{\"1\":{\"513\":1,\"708\":1}}],[\"②malloc开辟内存返回的都是void\",{\"1\":{\"513\":1,\"708\":1}}],[\"②析构容器有有效的元素\",{\"1\":{\"384\":1}}],[\"②析构时用了delete\",{\"1\":{\"383\":1}}],[\"②全负\",{\"1\":{\"87\":1}}],[\"省略号位于参数名称的右侧\",{\"1\":{\"377\":1}}],[\"省略了内存映射文件\",{\"1\":{\"283\":1}}],[\"被修改的数据页的状态会被标记为\",{\"1\":{\"1762\":1}}],[\"被称为逻辑日志\",{\"1\":{\"1758\":1}}],[\"被称为物理日志\",{\"1\":{\"1758\":1}}],[\"被称为函数参数包\",{\"1\":{\"377\":1}}],[\"被阻塞的同时也无法释放行锁2\",{\"1\":{\"1707\":1}}],[\"被阻塞的同时也无法释放行锁1\",{\"1\":{\"1707\":1}}],[\"被驱动表的执行计划这里会显示驱动表的关联字段\",{\"1\":{\"1618\":1}}],[\"被依赖\",{\"1\":{\"1415\":1}}],[\"被虚继承的类就称为虚基类\",{\"1\":{\"932\":1}}],[\"被虚继承的类\",{\"1\":{\"931\":1}}],[\"被截取后的部分\",{\"1\":{\"787\":1}}],[\"被const修饰不可以修改\",{\"1\":{\"621\":1}}],[\"被const修饰类类型\",{\"1\":{\"392\":1}}],[\"被extern\",{\"1\":{\"577\":1}}],[\"被调函数左括号\",{\"1\":{\"500\":1}}],[\"被禁止\",{\"1\":{\"485\":1}}],[\"被类\",{\"1\":{\"435\":1,\"439\":1}}],[\"被所有该类的对象共享\",{\"1\":{\"435\":1}}],[\"被创建的\",{\"1\":{\"435\":1}}],[\"被该类的\",{\"1\":{\"433\":1}}],[\"被删除了\",{\"1\":{\"267\":1}}],[\"针对数据量巨大的单张表\",{\"1\":{\"1890\":1}}],[\"针对数据的增删改查\",{\"1\":{\"1489\":1}}],[\"针对性优化的时候\",{\"1\":{\"1744\":1}}],[\"针对当前读的语句会对索引加记录锁+间隙锁\",{\"1\":{\"1721\":1}}],[\"针对当前读\",{\"1\":{\"1717\":1}}],[\"针对快照读\",{\"1\":{\"1717\":1}}],[\"针对表的所有记录\",{\"1\":{\"1681\":1}}],[\"针对一个具体情况\",{\"1\":{\"1190\":1}}],[\"针对函数\",{\"1\":{\"1188\":1}}],[\"针对于int类型\",{\"1\":{\"713\":1}}],[\"针对内置类型\",{\"0\":{\"524\":1}}],[\"针对上述定义\",{\"1\":{\"455\":1}}],[\"针对某些类型\",{\"1\":{\"367\":1}}],[\"针对compare函数模板\",{\"1\":{\"366\":1,\"368\":1}}],[\"偏移\",{\"1\":{\"555\":1}}],[\"偏特化\",{\"0\":{\"369\":1},\"1\":{\"367\":1}}],[\"偏特化与全特化\",{\"0\":{\"367\":1}}],[\"偏好设置\",{\"1\":{\"62\":1,\"63\":1}}],[\"优秀的json开源库json\",{\"1\":{\"1896\":1}}],[\"优化器\",{\"1\":{\"1881\":2}}],[\"优化思路二\",{\"1\":{\"1740\":1}}],[\"优化思路一\",{\"1\":{\"1740\":1}}],[\"优化分页查询\",{\"0\":{\"1740\":1}}],[\"优化or\",{\"0\":{\"1739\":1}}],[\"优化order\",{\"0\":{\"1736\":1}}],[\"优化2\",{\"1\":{\"1738\":1}}],[\"优化1\",{\"1\":{\"1738\":1}}],[\"优化子查询\",{\"0\":{\"1738\":1}}],[\"优化后\",{\"1\":{\"1735\":1}}],[\"优化后的方案为\",{\"1\":{\"1733\":1}}],[\"优化insert\",{\"0\":{\"1732\":1}}],[\"优化成union后的两个select应该是都可以使用索引的\",{\"1\":{\"1594\":1}}],[\"优化成了range范围搜索\",{\"1\":{\"1592\":1}}],[\"优化的\",{\"1\":{\"1539\":1}}],[\"优化\",{\"0\":{\"1871\":1},\"1\":{\"1525\":1}}],[\"优化代码\",{\"1\":{\"1327\":1}}],[\"优化选项\",{\"1\":{\"398\":1}}],[\"优先记录redo\",{\"1\":{\"1758\":1}}],[\"优先按的方式接收\",{\"1\":{\"1116\":1}}],[\"优先按方式接收\",{\"1\":{\"1067\":1}}],[\"优先级越高\",{\"1\":{\"1025\":1}}],[\"优先级队列底层默认把数据组成一个大根堆结构\",{\"1\":{\"994\":1}}],[\"优先级队列为什么底层依赖vector\",{\"0\":{\"994\":1}}],[\"优先级队列中元素个数\",{\"1\":{\"992\":1}}],[\"优先级队列\",{\"0\":{\"984\":1,\"988\":1,\"992\":1,\"1183\":1},\"1\":{\"784\":1,\"992\":2,\"1171\":1,\"1183\":1}}],[\"优先使用vector\",{\"1\":{\"974\":1}}],[\"优先使用list\",{\"1\":{\"974\":1}}],[\"优先使用特例化\",{\"1\":{\"366\":1}}],[\"优先队列\",{\"0\":{\"784\":1},\"2\":{\"786\":1}}],[\"优先找的是派生类自己作用域的成员\",{\"1\":{\"695\":1}}],[\"优先调用普通函数\",{\"1\":{\"366\":1}}],[\"优点是并发效率非常高\",{\"1\":{\"1712\":1}}],[\"优点\",{\"1\":{\"100\":1,\"202\":1,\"815\":1,\"844\":1,\"866\":1,\"867\":1,\"1232\":1}}],[\"于\",{\"1\":{\"1686\":1}}],[\"于是出现错误了\",{\"1\":{\"1830\":1}}],[\"于是我们看到了3309端口\",{\"1\":{\"1806\":1}}],[\"于是我们有两种方式优化group\",{\"1\":{\"1737\":1}}],[\"于是我们可以做出如下修改让代码按照期望运行\",{\"1\":{\"528\":1}}],[\"于是innodb存储引擎自动给整张表加上了ix锁\",{\"1\":{\"1673\":1}}],[\"于是再次select的时候新commit的数据也会出现在新生成的快照中\",{\"1\":{\"1659\":1}}],[\"于是茶杯购买失败\",{\"1\":{\"1639\":1}}],[\"于是想了一个办法\",{\"1\":{\"811\":1}}],[\"于是到了c++中就有了new\",{\"1\":{\"509\":1}}],[\"于是决定关闭gpu\",{\"1\":{\"63\":1}}],[\"于函数模板执行\",{\"1\":{\"366\":1}}],[\"普通数据反序列化\",{\"0\":{\"1907\":1}}],[\"普通数据序列化\",{\"0\":{\"1902\":1}}],[\"普通\",{\"1\":{\"1717\":1}}],[\"普通索引\",{\"1\":{\"1610\":1,\"1614\":2}}],[\"普通查询\",{\"0\":{\"1494\":1}}],[\"普通正向迭代器的使用\",{\"1\":{\"1011\":1}}],[\"普通的正向迭代器iterator\",{\"1\":{\"1011\":1}}],[\"普通的成员方法特点\",{\"1\":{\"439\":1}}],[\"普通类定义指针\",{\"1\":{\"901\":1}}],[\"普通懒汉式单例\",{\"0\":{\"846\":1}}],[\"普通变量\",{\"1\":{\"435\":1}}],[\"普通指针指向整型成员变量\",{\"1\":{\"411\":1,\"412\":1}}],[\"普通成员方法要求传入的是t\",{\"1\":{\"441\":1}}],[\"普通成员方法\",{\"1\":{\"410\":1,\"413\":1}}],[\"普通成员变量\",{\"0\":{\"410\":1},\"1\":{\"410\":2,\"413\":1}}],[\"普通构造函数\",{\"1\":{\"405\":1}}],[\"普通函数调用需要标准开销\",{\"1\":{\"502\":1}}],[\"普通函数会有参数入栈出栈的开销\",{\"1\":{\"500\":1}}],[\"普通函数\",{\"1\":{\"366\":1,\"876\":1}}],[\"普通函数间的关系\",{\"0\":{\"366\":1}}],[\"普通文件\",{\"1\":{\"17\":1}}],[\"靠\",{\"1\":{\"364\":1}}],[\"属于正确读取的范围\",{\"1\":{\"1658\":1}}],[\"属于一种典型的压缩方法\",{\"1\":{\"1261\":1}}],[\"属于动态绑定\",{\"1\":{\"921\":1}}],[\"属于创建型设计模式\",{\"1\":{\"860\":1}}],[\"属于解释型语言\",{\"1\":{\"359\":1}}],[\"属性名\",{\"1\":{\"1614\":1}}],[\"属性不依赖于其它非主属性\",{\"1\":{\"1462\":1}}],[\"属性\",{\"1\":{\"293\":1,\"446\":1,\"449\":1}}],[\"模上桶的个数\",{\"1\":{\"1603\":1}}],[\"模糊搜索\",{\"0\":{\"1591\":1}}],[\"模拟买票的线程函数\",{\"1\":{\"1209\":3,\"1210\":1}}],[\"模式\",{\"1\":{\"871\":2}}],[\"模式打开文件时\",{\"1\":{\"17\":1}}],[\"模块b实现文件\",{\"1\":{\"578\":1}}],[\"模块a头文件\",{\"1\":{\"578\":1}}],[\"模板偏特化\",{\"1\":{\"389\":1}}],[\"模板是有类型的\",{\"1\":{\"388\":1}}],[\"模板参数包\",{\"0\":{\"376\":1},\"1\":{\"376\":1}}],[\"模板参数列表\",{\"1\":{\"362\":2}}],[\"模板函数就可以知道参数类型了\",{\"1\":{\"378\":1}}],[\"模板函数\",{\"0\":{\"365\":1}}],[\"模板代码调用之前\",{\"1\":{\"363\":1}}],[\"模板代码====\",{\"1\":{\"363\":1}}],[\"模板实现原理\",{\"1\":{\"362\":1}}],[\"模板实践\",{\"2\":{\"357\":1}}],[\"模板的一个新特性\",{\"1\":{\"1194\":1}}],[\"模板的实参推演\",{\"0\":{\"1189\":1}}],[\"模板的实例化发生在编译阶段\",{\"0\":{\"885\":1},\"1\":{\"883\":1}}],[\"模板的部分特例化\",{\"0\":{\"1188\":1}}],[\"模板的部分偏特化\",{\"1\":{\"1158\":2}}],[\"模板的完全特化\",{\"0\":{\"1187\":1}}],[\"模板的完全特例化和非完全特例化\",{\"0\":{\"1186\":1}}],[\"模板的嵌套\",{\"0\":{\"389\":1}}],[\"模板的特化\",{\"0\":{\"367\":1}}],[\"模板的类型\",{\"0\":{\"361\":1}}],[\"模板的定义\",{\"0\":{\"360\":1}}],[\"模板\",{\"0\":{\"885\":1,\"1926\":1},\"1\":{\"359\":1,\"564\":1,\"585\":1,\"883\":1},\"2\":{\"374\":1,\"380\":1,\"391\":1}}],[\"起来干活了\",{\"1\":{\"1229\":1}}],[\"起死回生\",{\"1\":{\"597\":1}}],[\"起始数组位置\",{\"1\":{\"355\":1,\"385\":1,\"704\":1}}],[\"起码深度几十层我想是没问题的\",{\"1\":{\"240\":1}}],[\"析构2次\",{\"1\":{\"1114\":1}}],[\"析构顺序\",{\"1\":{\"1114\":1}}],[\"析构顺序与其相反\",{\"1\":{\"688\":1}}],[\"析构函数中有释放锁的操作unlock\",{\"1\":{\"1226\":1,\"1227\":1}}],[\"析构函数解锁\",{\"1\":{\"1096\":1}}],[\"析构函数也应被定义为虚析构函数\",{\"1\":{\"946\":1}}],[\"析构函数的调用顺序为\",{\"1\":{\"891\":1}}],[\"析构函数的特点\",{\"0\":{\"425\":1}}],[\"析构函数执行后记得要把指针变量指向nullptr\",{\"1\":{\"735\":1}}],[\"析构函数同样不能继承\",{\"1\":{\"675\":1}}],[\"析构函数来初始化\",{\"1\":{\"519\":1}}],[\"析构函数在哪些时候会被调用呢\",{\"0\":{\"427\":1}}],[\"析构函数在对象撤销时自动调用\",{\"1\":{\"425\":1}}],[\"析构函数除了在对象被销毁时自动调用外\",{\"1\":{\"426\":1}}],[\"析构函数会被自动调用\",{\"1\":{\"425\":1}}],[\"析构函数只能有\",{\"1\":{\"425\":1}}],[\"析构函数没有返回类型\",{\"1\":{\"425\":1}}],[\"析构函数要简单的多\",{\"1\":{\"424\":1}}],[\"析构函数\",{\"0\":{\"424\":1},\"1\":{\"405\":1,\"406\":1,\"424\":1,\"468\":1,\"469\":1,\"516\":2,\"685\":1,\"848\":1,\"850\":1,\"851\":1,\"1114\":1}}],[\"析构\",{\"1\":{\"355\":1,\"385\":1,\"704\":1,\"1056\":4,\"1057\":4}}],[\"节省磁盘io\",{\"1\":{\"1758\":1}}],[\"节省资源\",{\"1\":{\"837\":2}}],[\"节省空间\",{\"1\":{\"354\":1}}],[\"节点内存不连续\",{\"1\":{\"815\":2}}],[\"节点\",{\"1\":{\"802\":1}}],[\"节点的前一个节点\",{\"1\":{\"802\":1}}],[\"节头部表\",{\"1\":{\"251\":1}}],[\"十分简洁清晰\",{\"1\":{\"1900\":1}}],[\"十六进制或十进制整数\",{\"1\":{\"1347\":1}}],[\"十六进制\",{\"1\":{\"1299\":1}}],[\"十六进制字面值\",{\"1\":{\"349\":1}}],[\"十进制字面值\",{\"1\":{\"349\":1}}],[\"乘法\",{\"1\":{\"344\":1}}],[\"均改为\",{\"1\":{\"340\":1}}],[\"原理和用法\",{\"1\":{\"1878\":1}}],[\"原理利用栈上的对象出作用域会自动析构这么一个特点\",{\"1\":{\"1041\":1}}],[\"原始的user表如下\",{\"1\":{\"1682\":1}}],[\"原子性是通过\",{\"1\":{\"1645\":1}}],[\"原子性\",{\"1\":{\"1644\":1,\"1757\":1}}],[\"原子类型\",{\"1\":{\"1202\":1,\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1}}],[\"原则\",{\"0\":{\"1354\":1}}],[\"原来\",{\"1\":{\"1682\":1}}],[\"原来备用内存有剩余\",{\"1\":{\"1102\":1}}],[\"原来基类的数据放到最后\",{\"1\":{\"937\":1}}],[\"原来最上面应该为ma与mb\",{\"1\":{\"937\":1}}],[\"原来的方法\",{\"1\":{\"831\":1}}],[\"原来容器底层的内存上所保存的迭代器\",{\"1\":{\"741\":1}}],[\"原链表结点给新链表后记得断开与原链表的结点的连接\",{\"1\":{\"795\":1}}],[\"原因\",{\"1\":{\"639\":1,\"1209\":1}}],[\"原因有这么几点\",{\"1\":{\"553\":1}}],[\"原因在于小表是整表扫描获取id后存入到临时表\",{\"1\":{\"1539\":1}}],[\"原因在于\",{\"1\":{\"553\":1}}],[\"原因就是\",{\"1\":{\"340\":1}}],[\"原样替换\",{\"1\":{\"359\":1}}],[\"原地算法\",{\"1\":{\"67\":1}}],[\"浮点型数据是按照指数形式存储的\",{\"1\":{\"339\":1}}],[\"浮点数等\",{\"1\":{\"1347\":1}}],[\"浮点数的精度丢失问题\",{\"0\":{\"340\":1}}],[\"浮点数的存储方式\",{\"0\":{\"339\":1}}],[\"浮点数字面值表示方法\",{\"0\":{\"338\":1}}],[\"浮点数\",{\"0\":{\"337\":1},\"1\":{\"1347\":1}}],[\"小表是整表查询\",{\"1\":{\"1744\":1}}],[\"小表是整表扫描\",{\"1\":{\"1590\":1}}],[\"小表的每一个uid在大表中就是走索引\",{\"1\":{\"1590\":1}}],[\"小表的每一个uid在大表中搜索都是整表搜索\",{\"1\":{\"1590\":1}}],[\"小表永远是整表扫描\",{\"1\":{\"1537\":1}}],[\"小张\",{\"1\":{\"1384\":2}}],[\"小李\",{\"1\":{\"1384\":1}}],[\"小\",{\"1\":{\"1331\":1}}],[\"小猪\",{\"1\":{\"886\":1}}],[\"小狗\",{\"1\":{\"886\":1}}],[\"小猫\",{\"1\":{\"886\":1}}],[\"小结\",{\"0\":{\"651\":1,\"940\":1,\"1604\":1,\"1694\":1},\"1\":{\"1699\":1}}],[\"小结operator\",{\"1\":{\"519\":1}}],[\"小数形式\",{\"1\":{\"338\":1}}],[\"小于128则通过内存池管理\",{\"1\":{\"1096\":1}}],[\"小于128k的内存分配\",{\"0\":{\"283\":1}}],[\"小于x\",{\"1\":{\"795\":2}}],[\"小于基准的放左边\",{\"1\":{\"220\":1}}],[\"溢出\",{\"0\":{\"332\":1}}],[\"见名知意\",{\"1\":{\"316\":1}}],[\"区间\",{\"1\":{\"1471\":1}}],[\"区等不可再分割\",{\"1\":{\"1460\":1}}],[\"区别函数类型和函数指针类型\",{\"0\":{\"1162\":1}}],[\"区别\",{\"1\":{\"973\":1,\"974\":1}}],[\"区别分析\",{\"0\":{\"525\":1}}],[\"区别是类型可被参数化\",{\"1\":{\"362\":1}}],[\"区分了输入一半补全和全输入光标后插入\",{\"1\":{\"1135\":1}}],[\"区分作⽤\",{\"1\":{\"489\":1}}],[\"区分大小写\",{\"1\":{\"316\":1}}],[\"区域的意思\",{\"1\":{\"267\":1}}],[\"包括所有特殊的行为\",{\"1\":{\"1896\":1}}],[\"包括一对一\",{\"1\":{\"1451\":1}}],[\"包括\",{\"1\":{\"1335\":1,\"1767\":1}}],[\"包括虚函数\",{\"1\":{\"927\":1}}],[\"包括拷贝构造\",{\"1\":{\"685\":1}}],[\"包括函数返回的局部变量的引用以及const对象\",{\"1\":{\"621\":1}}],[\"包括立即数\",{\"1\":{\"621\":1}}],[\"包括变量的值\",{\"1\":{\"1338\":1}}],[\"包括变量\",{\"1\":{\"621\":1}}],[\"包括front也一样\",{\"1\":{\"406\":1}}],[\"包装\",{\"1\":{\"578\":1}}],[\"包含的sql越多\",{\"1\":{\"1724\":1}}],[\"包含的头文件\",{\"1\":{\"999\":1,\"1000\":1}}],[\"包含union的结果集\",{\"1\":{\"1618\":1}}],[\"包含不适合在其它列中显示但十分重要的额外信息\",{\"1\":{\"1521\":1}}],[\"包含一组数字\",{\"1\":{\"1521\":1}}],[\"包含了\",{\"1\":{\"1871\":1}}],[\"包含了很多原子类型\",{\"1\":{\"1233\":2}}],[\"包含了c++库中的所有的泛型算法\",{\"1\":{\"1146\":1}}],[\"包含c++库中的所有的函数对象\",{\"1\":{\"1146\":1}}],[\"包含纯c的头文件而没有显式使用\",{\"1\":{\"578\":1}}],[\"包含头文件和库\",{\"0\":{\"1328\":1}}],[\"包含头文件的顺序可能会影响程序的行为\",{\"1\":{\"593\":1}}],[\"包含头文件\",{\"0\":{\"1209\":1},\"1\":{\"536\":1}}],[\"包含\",{\"1\":{\"312\":1,\"1042\":1,\"1249\":1}}],[\"包起来\",{\"0\":{\"273\":1,\"274\":1}}],[\"预定义变量\",{\"1\":{\"1356\":1}}],[\"预处理\",{\"0\":{\"1330\":1}}],[\"预处理c和c++源文件并将预处理的输出写到文件\",{\"1\":{\"311\":1}}],[\"预判错误\",{\"0\":{\"597\":1}}],[\"预编译指令\",{\"0\":{\"311\":1}}],[\"英特尔的机器指令\",{\"1\":{\"310\":1}}],[\"英文字母个数为\",{\"1\":{\"11\":1}}],[\"寻找catch异常处理的代码是怎样的一个过程呢\",{\"1\":{\"603\":1}}],[\"寻找处理代码的过程\",{\"0\":{\"603\":1}}],[\"寻找用于新数组的值\",{\"1\":{\"77\":1}}],[\"寻址能力\",{\"1\":{\"308\":1}}],[\"容灾\",{\"1\":{\"1780\":1}}],[\"容易造成信息泄露\",{\"1\":{\"1511\":1}}],[\"容易造成混淆\",{\"1\":{\"591\":1}}],[\"容易\",{\"1\":{\"1331\":1}}],[\"容易出现二义性\",{\"1\":{\"593\":1}}],[\"容易引起混淆\",{\"1\":{\"522\":1}}],[\"容易产生误区\",{\"0\":{\"308\":1}}],[\"容器反序列化\",{\"0\":{\"1909\":1}}],[\"容器序列化\",{\"0\":{\"1905\":1},\"1\":{\"1905\":1}}],[\"容器之间可以相互转换\",{\"1\":{\"1896\":1}}],[\"容器一样\",{\"1\":{\"1896\":1}}],[\"容器\",{\"0\":{\"1197\":1},\"1\":{\"1194\":1}}],[\"容器类型\",{\"1\":{\"1183\":1}}],[\"容器类名\",{\"1\":{\"698\":4}}],[\"容器空间适配器\",{\"1\":{\"1127\":1}}],[\"容器空间适配器allocator简单实现\",{\"0\":{\"381\":1}}],[\"容器的默认空间配置器是\",{\"1\":{\"1079\":1}}],[\"容器的空间配置器\",{\"1\":{\"385\":1,\"704\":1,\"1080\":1,\"1087\":1}}],[\"容器的空间配置器allocator\",{\"1\":{\"385\":1}}],[\"容器适配器\",{\"0\":{\"988\":1,\"989\":1}}],[\"容器使用场景\",{\"1\":{\"971\":1}}],[\"容器里面元素个数依旧是0\",{\"1\":{\"966\":1}}],[\"容器中不能使用auto\",{\"0\":{\"1045\":1}}],[\"容器中对象的构造析构\",{\"1\":{\"964\":1}}],[\"容器中还有一个end\",{\"1\":{\"698\":1}}],[\"容器迭代器失效增加代码\",{\"1\":{\"747\":2}}],[\"容器底层没有开辟空间\",{\"1\":{\"973\":1,\"974\":1}}],[\"容器底层元素真真正正从一个元素跑到下一个元素\",{\"1\":{\"698\":1}}],[\"容器底层内存开辟\",{\"1\":{\"385\":1}}],[\"容器有一个begin\",{\"1\":{\"698\":1}}],[\"容器为什么需要空间配置器\",{\"0\":{\"382\":1}}],[\"容量\",{\"1\":{\"101\":1}}],[\"呢\",{\"1\":{\"307\":1,\"1239\":1}}],[\"及其他脚本语言中没有指针\",{\"1\":{\"304\":1}}],[\"另外\",{\"1\":{\"304\":1,\"591\":1,\"876\":1}}],[\"另一部分由bin\",{\"1\":{\"1775\":1}}],[\"另一部分作为备用\",{\"1\":{\"1105\":1}}],[\"另一种是alloc\",{\"1\":{\"1079\":1}}],[\"另一种写法\",{\"1\":{\"178\":1}}],[\"另一个就是在内存上b树的搜索是log2n\",{\"1\":{\"1623\":1}}],[\"另一个就是需要你查出目标值的区间起始下标\",{\"1\":{\"95\":1}}],[\"另一个是自己有虚函数创建的\",{\"1\":{\"938\":1}}],[\"另一个存放大的\",{\"1\":{\"795\":1}}],[\"另一个缺点就是\",{\"1\":{\"628\":1}}],[\"另一个json文件也在\",{\"1\":{\"62\":1}}],[\"迫不及待地开始用它完全重写了现在大名鼎鼎的\",{\"1\":{\"301\":1}}],[\"里面有一些方法\",{\"1\":{\"1207\":1}}],[\"里面有一个成员函数sum\",{\"1\":{\"1189\":1}}],[\"里面\",{\"1\":{\"998\":1,\"1002\":1}}],[\"里面并没有那么多元素\",{\"1\":{\"715\":1}}],[\"里面的字符构成\",{\"1\":{\"174\":1}}],[\"里奇\",{\"1\":{\"301\":1}}],[\"丹尼斯\",{\"1\":{\"301\":1}}],[\"他同时发起两个事务\",{\"1\":{\"1639\":1}}],[\"他\",{\"1\":{\"876\":1}}],[\"他们是static\",{\"1\":{\"628\":1}}],[\"他们只负责分配空间\",{\"1\":{\"519\":1}}],[\"他们之间唯一的区别\",{\"1\":{\"450\":1}}],[\"他们可以分别用三个不同的关键字进行修饰\",{\"1\":{\"449\":1}}],[\"他们的初始化与普通数据成员有所不同\",{\"1\":{\"431\":1}}],[\"他们分别是常量成员\",{\"1\":{\"431\":1}}],[\"他就把对象的地址当作实参传给这些函数了\",{\"1\":{\"392\":1}}],[\"他取了\",{\"1\":{\"301\":1}}],[\"他的主要工作是改造\",{\"1\":{\"301\":1}}],[\"他随着栈的变化而变化\",{\"1\":{\"233\":1}}],[\"设计合理的索引并\",{\"1\":{\"1724\":1}}],[\"设计模式\",{\"0\":{\"1932\":1},\"1\":{\"871\":1},\"2\":{\"828\":1,\"834\":1,\"859\":1,\"870\":1,\"873\":1}}],[\"设计链表\",{\"0\":{\"790\":1},\"1\":{\"790\":1}}],[\"设计出很简单且很接近硬件的\",{\"1\":{\"301\":1}}],[\"设置方法为set成员变量名\",{\"1\":{\"1914\":1}}],[\"设置方式\",{\"1\":{\"62\":1}}],[\"设置成分离线程\",{\"1\":{\"1849\":1,\"1859\":1}}],[\"设置成静态ip有利于xshell外部连接\",{\"1\":{\"1277\":1}}],[\"设置条件变量\",{\"1\":{\"1848\":1,\"1859\":1,\"1875\":1}}],[\"设置超时时间\",{\"1\":{\"1754\":1}}],[\"设置自动提交\",{\"1\":{\"1708\":1}}],[\"设置事务为手动提交\",{\"1\":{\"1687\":1}}],[\"设置事务的隔离级别select\",{\"1\":{\"1640\":1}}],[\"设置可重复读隔离级\",{\"1\":{\"1663\":1}}],[\"设置可执行文件的最终存储路径\",{\"1\":{\"1316\":1}}],[\"设置一个名字为point1的保存点\",{\"1\":{\"1640\":1}}],[\"设置合理的\",{\"0\":{\"1578\":1},\"1\":{\"1573\":1}}],[\"设置好后开启业务\",{\"1\":{\"1573\":1}}],[\"设置默认值\",{\"1\":{\"1434\":1}}],[\"设置默认编辑器\",{\"1\":{\"1016\":1}}],[\"设置外键的表\",{\"1\":{\"1415\":1}}],[\"设置mysql的自动补全功能\",{\"0\":{\"1410\":1}}],[\"设置密码长度为4\",{\"1\":{\"1407\":1}}],[\"设置断点\",{\"1\":{\"1340\":1}}],[\"设置断点或让程序运行到你想要查看汇编代码的位置\",{\"1\":{\"261\":1}}],[\"设置程序运行时的参数\",{\"1\":{\"1340\":1}}],[\"设置命令行参数\",{\"0\":{\"1339\":1}}],[\"设置编译选项\",{\"1\":{\"1317\":1}}],[\"设置编译类型\",{\"1\":{\"1310\":2}}],[\"设置回调函数\",{\"1\":{\"1102\":1}}],[\"设置同时存入文件和屏幕显示\",{\"1\":{\"1032\":1}}],[\"设置日志风格\",{\"1\":{\"1026\":1}}],[\"设置日志输出风格\",{\"1\":{\"1021\":1,\"1026\":1}}],[\"设置纯虚函数的意义\",{\"1\":{\"898\":1}}],[\"设置标记\",{\"1\":{\"59\":1}}],[\"设置代码块的边框\",{\"1\":{\"49\":1}}],[\"设置代码块边框样式\",{\"1\":{\"49\":1}}],[\"设置代码快边框的样式\",{\"0\":{\"49\":1}}],[\"设置写作时间\",{\"1\":{\"45\":1}}],[\"设置注释与反注释的快捷键\",{\"0\":{\"42\":1}}],[\"设置\",{\"1\":{\"33\":1,\"1310\":2}}],[\"设置输入法兼容旧版本\",{\"0\":{\"33\":1}}],[\"游行\",{\"1\":{\"301\":1}}],[\"游标\",{\"1\":{\"286\":1}}],[\"星际旅行\",{\"1\":{\"301\":2}}],[\"年龄\",{\"1\":{\"1461\":2,\"1462\":1}}],[\"年月日时分秒毫秒\",{\"1\":{\"1021\":1}}],[\"年初\",{\"1\":{\"301\":1}}],[\"年\",{\"1\":{\"301\":3,\"1537\":1}}],[\"年从这个项目中退出的\",{\"1\":{\"301\":1}}],[\"年前后这个项目进度缓慢\",{\"1\":{\"301\":1}}],[\"合理使用索引\",{\"1\":{\"1744\":1}}],[\"合法\",{\"1\":{\"455\":2}}],[\"合作开发\",{\"1\":{\"301\":1}}],[\"合作的计划\",{\"1\":{\"301\":1}}],[\"合并\",{\"0\":{\"780\":1,\"1514\":1},\"1\":{\"780\":1,\"783\":1,\"784\":1}}],[\"合并的复杂度为o\",{\"1\":{\"202\":1}}],[\"合并两个有序链表\",{\"0\":{\"762\":1},\"1\":{\"202\":2,\"762\":1}}],[\"麻省理工学院\",{\"1\":{\"301\":1}}],[\"贝尔实验室退出了研究\",{\"1\":{\"301\":1}}],[\"贝尔实验室\",{\"1\":{\"301\":1}}],[\"连接数\",{\"1\":{\"1890\":1}}],[\"连接数据库\",{\"0\":{\"1374\":1}}],[\"连接数据库使用的头文件和库文件\",{\"0\":{\"1372\":1}}],[\"连接器\",{\"1\":{\"1881\":1}}],[\"连接的生产和连接的消费采用生产者\",{\"1\":{\"1866\":1}}],[\"连接的数据库名称\",{\"1\":{\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"连接失败\",{\"1\":{\"1856\":1,\"1878\":1}}],[\"连接connection错误\",{\"1\":{\"1828\":1}}],[\"连接用户目录下的mycat和我们解压路径下的mycat\",{\"1\":{\"1800\":1}}],[\"连接超时时间等\",{\"1\":{\"1865\":1}}],[\"连接超时时间\",{\"1\":{\"1754\":1,\"1865\":1}}],[\"连接池单例模式实践\",{\"0\":{\"1878\":1}}],[\"连接池只需要一个实例\",{\"1\":{\"1866\":1}}],[\"连接池主要包含了以下功能点\",{\"1\":{\"1866\":1}}],[\"连接池中的连接数量已经到达maxsize了\",{\"1\":{\"1865\":1}}],[\"连接池里面的连接数量会动态增加\",{\"1\":{\"1865\":1}}],[\"连接池一般包含了数据库连接所用的ip地址\",{\"1\":{\"1865\":1}}],[\"连接池功能点介绍\",{\"0\":{\"1865\":1}}],[\"连接池代码实现\",{\"1\":{\"1866\":1}}],[\"连接池代码\",{\"0\":{\"1843\":1}}],[\"连接池压力测试\",{\"0\":{\"1842\":1}}],[\"连接池获取连接的超时时间单位是毫秒\",{\"1\":{\"1844\":1,\"1878\":1}}],[\"连接池获取连接的超时时间\",{\"1\":{\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"连接池最大空闲时间默认单位是秒\",{\"1\":{\"1844\":1,\"1878\":1}}],[\"连接池最大空闲时间\",{\"1\":{\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"连接池的实现\",{\"0\":{\"1849\":1}}],[\"连接池的头文件\",{\"0\":{\"1848\":1}}],[\"连接池的最大连接量\",{\"1\":{\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"连接池的初始连接量\",{\"1\":{\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"连接池\",{\"0\":{\"1957\":1},\"1\":{\"1743\":1}}],[\"连接语句中会先以数据量区分大表和小表\",{\"1\":{\"1537\":1}}],[\"连接查询效率越低\",{\"1\":{\"1535\":1}}],[\"连接查询相比单表查询减少了tcp三次握手和四次挥手\",{\"1\":{\"1535\":1}}],[\"连接查询\",{\"0\":{\"1499\":1,\"1534\":1}}],[\"连接mysql失败\",{\"1\":{\"1383\":1}}],[\"连接mysql成功\",{\"1\":{\"1383\":1,\"1384\":1,\"1385\":1}}],[\"连接到mysql\",{\"1\":{\"1383\":1,\"1384\":1,\"1385\":1}}],[\"连接测试程序\",{\"0\":{\"1383\":1}}],[\"连接就已经被切断\",{\"1\":{\"1252\":1}}],[\"连接一台电脑\",{\"1\":{\"301\":1}}],[\"连一个size内存块也分配不出来\",{\"1\":{\"1102\":1}}],[\"连续子数组\",{\"1\":{\"73\":1}}],[\"台终端\",{\"1\":{\"301\":1}}],[\"后跟一个冒号\",{\"1\":{\"1899\":1}}],[\"后跟语句块\",{\"1\":{\"599\":1}}],[\"后台的i\",{\"1\":{\"1762\":1}}],[\"后台下载\",{\"0\":{\"1253\":1}}],[\"后才启动的事务生成的\",{\"1\":{\"1656\":1}}],[\"后续的查询语句利用这个\",{\"1\":{\"1656\":1}}],[\"后边的n就是执行计划中的id\",{\"1\":{\"1618\":1}}],[\"后一次查询与前一次查询的数据量不同\",{\"1\":{\"1635\":1}}],[\"后一个标签\",{\"1\":{\"1137\":1}}],[\"后一半\",{\"1\":{\"792\":1}}],[\"后来我懂了\",{\"1\":{\"1102\":1}}],[\"后来经过简化\",{\"1\":{\"300\":1}}],[\"后置++效率低\",{\"1\":{\"699\":1}}],[\"后面的sql万一执行失败就无法正常rollback\",{\"1\":{\"1640\":1}}],[\"后面的语句\",{\"1\":{\"599\":1}}],[\"后面跟六个空格\",{\"1\":{\"1426\":1}}],[\"后面进行编程时候需要使用\",{\"1\":{\"1399\":1}}],[\"后面会涉及\",{\"1\":{\"563\":1}}],[\"后面简写为string\",{\"1\":{\"536\":1}}],[\"后面每次调试程序都会自动弹出\",{\"1\":{\"306\":1}}],[\"后即初始化\",{\"1\":{\"509\":1}}],[\"后⼀个为顶层\",{\"1\":{\"489\":1}}],[\"后构造的先析构\",{\"1\":{\"428\":1}}],[\"后\",{\"1\":{\"340\":1,\"577\":1}}],[\"后缀为\",{\"1\":{\"44\":1}}],[\"填写libmysql\",{\"1\":{\"1855\":2}}],[\"填写mysql\",{\"1\":{\"1855\":1}}],[\"填充物理页内容\",{\"1\":{\"290\":1}}],[\"填入对应assets文件路径\",{\"1\":{\"60\":1}}],[\"发布\",{\"1\":{\"871\":1}}],[\"发现mytest同步过来了\",{\"1\":{\"1785\":1}}],[\"发现已经不是5个人了\",{\"1\":{\"1639\":1}}],[\"发现有5个\",{\"1\":{\"1639\":1}}],[\"发现变成了50\",{\"1\":{\"1639\":1}}],[\"发现为100\",{\"1\":{\"1639\":1}}],[\"发现只有50\",{\"1\":{\"1639\":1}}],[\"发现查询到前一次不存在的记录\",{\"1\":{\"1639\":1}}],[\"发现前后两次读的数据不一样\",{\"1\":{\"1639\":1}}],[\"发现还是默认的10s\",{\"1\":{\"1578\":1}}],[\"发现这条语句涉及到了外排序\",{\"1\":{\"1525\":1}}],[\"发现满了\",{\"1\":{\"968\":1}}],[\"发现\",{\"1\":{\"630\":1}}],[\"发现typora特别卡顿\",{\"1\":{\"63\":1}}],[\"发生锁冲突的概率小\",{\"1\":{\"1724\":1}}],[\"发生锁冲突的概率最低\",{\"1\":{\"1713\":1}}],[\"发生锁冲突的概率高\",{\"1\":{\"1713\":1}}],[\"发生阻塞\",{\"1\":{\"1708\":1}}],[\"发生了死锁问题\",{\"1\":{\"1707\":1}}],[\"发生了脏读\",{\"1\":{\"1639\":1}}],[\"发生了不可重复读\",{\"1\":{\"1634\":1,\"1659\":1}}],[\"发生竞态条件的代码段\",{\"1\":{\"1217\":1}}],[\"发生动态绑定\",{\"1\":{\"948\":1}}],[\"发生编译错误\",{\"1\":{\"652\":1}}],[\"发生异常的位置\",{\"0\":{\"600\":1,\"601\":1}}],[\"发生异常时必须将异常明确地抛出\",{\"1\":{\"599\":1}}],[\"发生时机在编译阶段\",{\"1\":{\"497\":1}}],[\"发生缺页中断后\",{\"0\":{\"290\":1}}],[\"缺省的拷贝构造函数已经可以满足需求了\",{\"1\":{\"396\":1}}],[\"缺省的拷贝构造函数\",{\"0\":{\"396\":1},\"1\":{\"397\":1}}],[\"缺页中断\",{\"0\":{\"288\":1}}],[\"缺点\",{\"1\":{\"100\":1,\"815\":1,\"844\":1,\"862\":1,\"864\":1,\"866\":1,\"867\":1,\"1146\":1,\"1609\":1}}],[\"向服务器请求开启一个事务\",{\"1\":{\"1681\":1}}],[\"向工程添加多个指定头文件的搜索路径\",{\"1\":{\"1314\":1}}],[\"向os申请\",{\"1\":{\"1102\":1}}],[\"向os申请内存失败\",{\"1\":{\"1102\":1}}],[\"向os申请失败则\",{\"1\":{\"1102\":1}}],[\"向os申请成功\",{\"1\":{\"1102\":1}}],[\"向os申请的所有内存大小\",{\"1\":{\"1082\":1}}],[\"向下强转\",{\"0\":{\"921\":1}}],[\"向上转型\",{\"1\":{\"678\":1}}],[\"向量容器\",{\"1\":{\"355\":1,\"385\":1,\"704\":1,\"1087\":1}}],[\"向操作系统申请新的内存块\",{\"1\":{\"286\":1}}],[\"向右逼近右边界\",{\"1\":{\"97\":1}}],[\"标志位\",{\"1\":{\"1374\":1}}],[\"标志着该块是否可用\",{\"1\":{\"286\":1}}],[\"标签\",{\"0\":{\"1137\":1}}],[\"标识备用内存池的范围\",{\"1\":{\"1102\":2}}],[\"标识符\",{\"0\":{\"316\":1}}],[\"标准库\",{\"0\":{\"1934\":1}}],[\"标准编写\",{\"1\":{\"1896\":1}}],[\"标准命名空间中的实体一般都是小写\",{\"1\":{\"594\":1}}],[\"标准命名空间可以进行扩展\",{\"1\":{\"594\":1}}],[\"标准输入\",{\"1\":{\"476\":1}}],[\"标准输出\",{\"1\":{\"476\":1}}],[\"标准除了文件操作之外\",{\"1\":{\"303\":1}}],[\"标准\",{\"1\":{\"303\":1}}],[\"标题名称\",{\"1\":{\"56\":1}}],[\"标题\",{\"0\":{\"51\":1}}],[\"贴上malloc\",{\"1\":{\"285\":1}}],[\"怎么保证数据库的负载足够\",{\"1\":{\"1885\":1}}],[\"怎么创建启动一个线程\",{\"0\":{\"1204\":1}}],[\"怎么办\",{\"1\":{\"1148\":1,\"1161\":1,\"1180\":1,\"1209\":1}}],[\"怎么办呢\",{\"1\":{\"277\":1}}],[\"怎么解决弱指针指针不能调用函数的问题\",{\"1\":{\"1057\":1}}],[\"怎么解决\",{\"0\":{\"1368\":1},\"1\":{\"1056\":1}}],[\"怎么管理资源的\",{\"1\":{\"1044\":1}}],[\"怎么理解多态\",{\"0\":{\"564\":1}}],[\"怎么知道这个块的地址\",{\"1\":{\"285\":1}}],[\"怎么查询块是否正在被程序使用\",{\"1\":{\"285\":1}}],[\"搞定\",{\"1\":{\"277\":1}}],[\"想要临时跳过某个断点几次时ignore\",{\"1\":{\"1340\":1}}],[\"想在多条语句中应用\",{\"1\":{\"1161\":1}}],[\"想比较小就传入myless\",{\"1\":{\"981\":1}}],[\"想比较大就传入mygreater\",{\"1\":{\"981\":1}}],[\"想跳过剩下的一半的时候\",{\"1\":{\"277\":1}}],[\"想让程序执行的时候从start开始执行而不是main\",{\"1\":{\"244\":1}}],[\"剩余下载时间\",{\"1\":{\"1249\":1}}],[\"剩余内存连接到\",{\"1\":{\"1102\":1}}],[\"剩余的字节\",{\"1\":{\"1622\":1}}],[\"剩余的字节数还能分配出\",{\"1\":{\"1102\":1}}],[\"剩余的备用内存连一个\",{\"1\":{\"1102\":1}}],[\"剩余的备用内存就会根据自身的大小被挂在\",{\"1\":{\"1102\":1}}],[\"剩余的数据\",{\"1\":{\"202\":1}}],[\"剩下的不执行了\",{\"1\":{\"277\":1}}],[\"剩下的不执行\",{\"0\":{\"277\":1}}],[\"宏定义发生的时机是在预处理阶段\",{\"1\":{\"497\":1}}],[\"宏定义没有类型检查\",{\"1\":{\"503\":1}}],[\"宏定义没有类型\",{\"1\":{\"481\":1}}],[\"宏定义是在展开\",{\"1\":{\"481\":1}}],[\"宏定义一般大写\",{\"1\":{\"323\":1}}],[\"宏定义\",{\"1\":{\"311\":1}}],[\"宏\",{\"0\":{\"272\":1}}],[\"放的mycat的日志文件\",{\"1\":{\"1800\":1}}],[\"放的mycat的配置文件\",{\"1\":{\"1800\":1}}],[\"放的是可执行文件\",{\"1\":{\"1800\":1}}],[\"放弃当前线程这一轮的时间片\",{\"1\":{\"1207\":1}}],[\"放在dn1和dn2上\",{\"1\":{\"1891\":1}}],[\"放在一台机器上\",{\"1\":{\"1891\":1}}],[\"放在工程目录下\",{\"1\":{\"1855\":1}}],[\"放在email字段之后\",{\"1\":{\"1552\":1}}],[\"放在和int\",{\"1\":{\"536\":1}}],[\"放在头文件中既能够确保调用函数是定义是相同的\",{\"1\":{\"504\":1}}],[\"放在函数声明前面不起任何作用\",{\"1\":{\"504\":1}}],[\"放在文件最上端\",{\"1\":{\"293\":1}}],[\"放在花括号里\",{\"1\":{\"273\":1}}],[\"放在数据段\",{\"1\":{\"267\":1}}],[\"放入eax寄存器\",{\"1\":{\"954\":1}}],[\"放入cpu的pc寄存器\",{\"1\":{\"234\":1}}],[\"放入寄存器\",{\"1\":{\"234\":1}}],[\"全表扫描数据文件\",{\"1\":{\"1618\":1}}],[\"全文索引\",{\"1\":{\"1610\":1}}],[\"全外连接查询\",{\"1\":{\"1500\":1}}],[\"全词匹配\",{\"1\":{\"1141\":1}}],[\"全都是进行指针指向的改变\",{\"1\":{\"1121\":1}}],[\"全局的一把互斥锁\",{\"1\":{\"1209\":1}}],[\"全局搜索字段\",{\"0\":{\"1141\":1}}],[\"全局查找文件\",{\"0\":{\"1136\":1}}],[\"全局函数\",{\"1\":{\"722\":2}}],[\"全局number\",{\"1\":{\"592\":1,\"594\":1}}],[\"全局静态存储区\",{\"1\":{\"574\":1}}],[\"全局变量的名字是\",{\"1\":{\"1776\":1}}],[\"全局变量\",{\"1\":{\"574\":1,\"616\":1}}],[\"全局变量都是数据\",{\"1\":{\"267\":1}}],[\"全特化\",{\"0\":{\"368\":1},\"1\":{\"367\":1}}],[\"全部由java实现的\",{\"1\":{\"1864\":1}}],[\"全部的readhost和stand\",{\"1\":{\"1803\":1}}],[\"全部会初始化为0\",{\"1\":{\"1082\":1}}],[\"全部进行检查\",{\"1\":{\"747\":1}}],[\"全部特化出来就是全特化\",{\"1\":{\"367\":1}}],[\"全部展开\",{\"1\":{\"54\":1,\"59\":1}}],[\"全部展开按钮\",{\"1\":{\"54\":1,\"59\":1}}],[\"全部收缩\",{\"1\":{\"54\":1,\"59\":1}}],[\"全部收缩按钮\",{\"1\":{\"54\":1,\"59\":1}}],[\"约束\",{\"1\":{\"1552\":4}}],[\"约束条件\",{\"0\":{\"1431\":1},\"1\":{\"1610\":1}}],[\"约瑟夫环c++\",{\"1\":{\"811\":1}}],[\"约瑟夫环\",{\"1\":{\"811\":1}}],[\"约瑟夫环是一个数学的应用问题\",{\"1\":{\"810\":1}}],[\"约瑟夫环问题\",{\"0\":{\"809\":1}}],[\"约800多m\",{\"1\":{\"267\":1}}],[\"约16m\",{\"1\":{\"267\":1}}],[\"看到了mycat发送的查询user表的sql\",{\"1\":{\"1812\":1}}],[\"看到这张表已经有别的事务获取了ix锁了\",{\"1\":{\"1673\":1}}],[\"看到希望用一个函数类型实例化function\",{\"1\":{\"1164\":1}}],[\"看似解决了幻读\",{\"1\":{\"1665\":1}}],[\"看一下执行时间是否超时\",{\"1\":{\"1551\":1}}],[\"看一下是否需要修改属性\",{\"1\":{\"101\":1}}],[\"看是无类型还是其他类型\",{\"1\":{\"1173\":1}}],[\"看起来是一个链表\",{\"1\":{\"1681\":1}}],[\"看起来哈希表比b+树好\",{\"0\":{\"1602\":1}}],[\"看起来它们好像一模一样\",{\"1\":{\"979\":1}}],[\"看起来和普通函数很相似\",{\"1\":{\"362\":1}}],[\"看上面抽象工厂的uml类设计图\",{\"1\":{\"867\":1}}],[\"看它指向哪个对象\",{\"1\":{\"631\":1}}],[\"看成const\",{\"1\":{\"625\":1}}],[\"看不懂\",{\"1\":{\"572\":1}}],[\"看不见\",{\"1\":{\"267\":2}}],[\"看作动态数组\",{\"1\":{\"353\":1}}],[\"看完上面的思路\",{\"1\":{\"285\":1}}],[\"看得见\",{\"1\":{\"267\":1}}],[\"划分后是什么样的\",{\"1\":{\"267\":1}}],[\"程序存在竞态条件\",{\"1\":{\"1208\":1}}],[\"程序启动的跟踪打印的命令\",{\"1\":{\"1202\":1}}],[\"程序崩溃\",{\"1\":{\"908\":1}}],[\"程序执行成功\",{\"1\":{\"742\":1,\"743\":1}}],[\"程序出错\",{\"1\":{\"667\":1}}],[\"程序非正常退出\",{\"1\":{\"603\":1}}],[\"程序的可读性差\",{\"1\":{\"617\":1}}],[\"程序的执行流也不会再回退到异常点\",{\"1\":{\"599\":1}}],[\"程序的错误大致可以分为三种\",{\"1\":{\"597\":1}}],[\"程序的调试能力\",{\"1\":{\"305\":1}}],[\"程序设计风格的一个基本原则\",{\"1\":{\"504\":1}}],[\"程序中使用了访问mysql的有关函数接口\",{\"1\":{\"1372\":1}}],[\"程序中使用了这些接口\",{\"1\":{\"303\":1}}],[\"程序中使用指针\",{\"1\":{\"617\":1}}],[\"程序中无法预期的异常时非常有用\",{\"1\":{\"604\":1}}],[\"程序中采用如下形式声明指向对象的指针\",{\"1\":{\"455\":1}}],[\"程序生成过程\",{\"0\":{\"310\":1}}],[\"程序调试方法\",{\"1\":{\"306\":1}}],[\"程序会转到terminate的标准库函数\",{\"1\":{\"603\":1}}],[\"程序会继续执行\",{\"1\":{\"599\":1}}],[\"程序会执行到最后\",{\"1\":{\"306\":1}}],[\"程序会向下执行一步\",{\"1\":{\"306\":1}}],[\"程序员只能确保在本行代码有效的\",{\"1\":{\"621\":1}}],[\"程序员可以根据错误信息来进一步处理\",{\"1\":{\"597\":1}}],[\"程序员最不需要担心的就是这种错误\",{\"1\":{\"597\":1}}],[\"程序员根据需要指定一些有名字的空间域\",{\"1\":{\"583\":1}}],[\"程序员需要考虑字符数组大小的开辟\",{\"1\":{\"535\":1}}],[\"程序员自己管理内存\",{\"1\":{\"267\":1}}],[\"程序员的自我修养\",{\"1\":{\"264\":1}}],[\"程序结束\",{\"1\":{\"238\":1}}],[\"页面异常=\",{\"1\":{\"263\":1}}],[\"页面配置\",{\"0\":{\"16\":1,\"185\":1,\"208\":1,\"223\":1,\"1232\":1,\"1236\":1},\"1\":{\"45\":2},\"2\":{\"10\":1,\"13\":1,\"19\":1,\"24\":1,\"123\":1,\"187\":1,\"210\":1,\"226\":1,\"387\":1,\"903\":1,\"1005\":1,\"1157\":1,\"1301\":1}}],[\"告诉编译器\",{\"1\":{\"577\":1}}],[\"告诉系统加载文件中\",{\"1\":{\"263\":1}}],[\"告诉程序入口地址在哪里\",{\"1\":{\"263\":1}}],[\"告知系统\",{\"1\":{\"262\":1}}],[\"目的就是把tmp对象带出来\",{\"1\":{\"1115\":1}}],[\"目的是禁止外部拷贝和赋值\",{\"1\":{\"841\":1}}],[\"目的是禁止外部构造和析构\",{\"1\":{\"841\":1}}],[\"目的\",{\"1\":{\"831\":1,\"1608\":1}}],[\"目标文件的文件名部分\",{\"1\":{\"1356\":1}}],[\"目标文件的目录名部分\",{\"1\":{\"1356\":1}}],[\"目标文件\",{\"1\":{\"1353\":1,\"1356\":1}}],[\"目标文件链接在一起\",{\"1\":{\"255\":1}}],[\"目标二进制可执行文件的存放位置\",{\"1\":{\"1316\":1}}],[\"目标\",{\"1\":{\"792\":1,\"1360\":1}}],[\"目标变量名\",{\"1\":{\"612\":1}}],[\"目录中的\",{\"1\":{\"1315\":2}}],[\"目录里的文件\",{\"1\":{\"1315\":1}}],[\"目录里各编写一个\",{\"0\":{\"1315\":1}}],[\"目录下运行\",{\"0\":{\"1319\":1},\"1\":{\"1319\":1}}],[\"目录下输入cmake\",{\"1\":{\"1318\":1}}],[\"目录下的\",{\"1\":{\"1318\":1}}],[\"目录下得到\",{\"1\":{\"1317\":1}}],[\"目录下\",{\"1\":{\"1308\":1,\"1316\":7,\"1317\":1,\"1319\":1,\"1399\":1}}],[\"目录树\",{\"0\":{\"1138\":1}}],[\"目录\",{\"0\":{\"51\":1},\"1\":{\"1318\":1,\"1319\":1}}],[\"目录文件\",{\"1\":{\"17\":1}}],[\"意思是从192\",{\"1\":{\"1821\":1}}],[\"意思是不能创建堆对象\",{\"1\":{\"717\":1}}],[\"意向锁是表级锁\",{\"1\":{\"1673\":1}}],[\"意向锁存在的意义是为了更高效的获取表锁\",{\"1\":{\"1673\":1}}],[\"意向锁之间都兼容\",{\"1\":{\"1673\":1}}],[\"意向锁的作用\",{\"1\":{\"1673\":1}}],[\"意向共享锁和意向排他锁\",{\"0\":{\"1673\":1}}],[\"意向共享锁\",{\"1\":{\"1668\":1,\"1673\":2}}],[\"意向排他锁\",{\"0\":{\"1668\":1},\"1\":{\"1668\":1,\"1673\":2}}],[\"意味着使用mysql默认端口\",{\"1\":{\"1374\":1}}],[\"意味着你可以抛出任何异常\",{\"1\":{\"608\":1}}],[\"意味着将所有的\",{\"1\":{\"255\":1}}],[\"意义\",{\"1\":{\"362\":1}}],[\"意为可移植操作系统接口\",{\"1\":{\"16\":1}}],[\"参数为\",{\"1\":{\"1774\":1}}],[\"参数介绍\",{\"1\":{\"1374\":1}}],[\"参数值是\",{\"1\":{\"1312\":1}}],[\"参数相同\",{\"1\":{\"1237\":2}}],[\"参数具体是什么\",{\"1\":{\"1155\":1}}],[\"参数占位符placeholders\",{\"1\":{\"1155\":1}}],[\"参数占位符\",{\"0\":{\"1155\":1},\"1\":{\"1155\":1}}],[\"参数\",{\"1\":{\"1076\":1,\"1154\":1,\"1299\":1,\"1376\":1}}],[\"参数压栈在编译时期确定好的\",{\"1\":{\"906\":2}}],[\"参数包\",{\"1\":{\"898\":1}}],[\"参数接受的都是容器的迭代器\",{\"1\":{\"704\":1}}],[\"参数不匹配\",{\"1\":{\"695\":1}}],[\"参数不同\",{\"1\":{\"359\":1}}],[\"参数表\",{\"1\":{\"666\":1,\"912\":2}}],[\"参数传递的方式除了上面的指针传递和引用传递两种外\",{\"1\":{\"615\":1}}],[\"参数的类型不同\",{\"1\":{\"560\":1,\"563\":1}}],[\"参数的构造函数\",{\"1\":{\"405\":1}}],[\"参数中的\",{\"0\":{\"400\":1}}],[\"参数类型不对\",{\"1\":{\"695\":1}}],[\"参数类型\",{\"1\":{\"378\":1}}],[\"参数个数\",{\"1\":{\"378\":1}}],[\"参数列表都相同\",{\"1\":{\"915\":1}}],[\"参数列表和返回值与基类虚函数相同\",{\"1\":{\"693\":1}}],[\"参数列表不同\",{\"1\":{\"562\":1,\"692\":1}}],[\"参数列表类型组成的\",{\"1\":{\"562\":1}}],[\"参数列表必须不同\",{\"1\":{\"560\":1,\"563\":1}}],[\"参数列表\",{\"1\":{\"362\":1,\"440\":1,\"449\":1,\"463\":1,\"1248\":1}}],[\"参数用于指定链接后生成的可执行文件的入口点\",{\"1\":{\"255\":1}}],[\"参数由右向左压入堆栈\",{\"0\":{\"237\":1}}],[\"手动提交事务\",{\"0\":{\"1731\":1}}],[\"手动释放\",{\"1\":{\"1040\":1}}],[\"手动链接\",{\"1\":{\"255\":1}}],[\"手机\",{\"1\":{\"0\":1}}],[\"报错表示slow\",{\"1\":{\"1577\":1}}],[\"报错\",{\"0\":{\"1293\":1},\"1\":{\"255\":4,\"522\":1,\"523\":1,\"695\":1}}],[\"段表\",{\"1\":{\"251\":1}}],[\"都记录在binlog中\",{\"1\":{\"1772\":1}}],[\"都写入磁盘上才表示redo\",{\"1\":{\"1759\":1}}],[\"都有共享锁和排他锁的区分\",{\"1\":{\"1702\":1}}],[\"都有可能cpu的时间片到了\",{\"1\":{\"1208\":1}}],[\"都需要跑到叶子节点\",{\"1\":{\"1626\":1}}],[\"都需要通过new\",{\"1\":{\"861\":1}}],[\"都清空了\",{\"1\":{\"1480\":1}}],[\"都指向第二个块\",{\"1\":{\"1099\":1}}],[\"都支持正向迭代器与反向迭代器\",{\"1\":{\"1011\":1}}],[\"都可以执行纯虚函数的动作\",{\"1\":{\"898\":1}}],[\"都可以调用\",{\"1\":{\"886\":1}}],[\"都可以被\",{\"1\":{\"600\":1}}],[\"都依赖一个对象\",{\"1\":{\"871\":1}}],[\"都不能访问基类的私有成员\",{\"1\":{\"658\":1}}],[\"都不用写了\",{\"1\":{\"576\":1}}],[\"都允许相同实参个数的调用\",{\"1\":{\"641\":1}}],[\"都必须要给其传递两个参数\",{\"1\":{\"637\":1}}],[\"都说引用不会占据存储空间\",{\"1\":{\"614\":1}}],[\"都没有被执行\",{\"1\":{\"601\":1}}],[\"都直接加上\",{\"1\":{\"589\":1}}],[\"都直接替换\",{\"1\":{\"484\":1}}],[\"都能够在c文件中使用该函数\",{\"1\":{\"570\":1}}],[\"都通过allocator空间适配器来实现\",{\"1\":{\"385\":1}}],[\"都会被隐藏\",{\"1\":{\"695\":1}}],[\"都会被转化为this\",{\"1\":{\"392\":1}}],[\"都会被调用\",{\"1\":{\"273\":1}}],[\"都会执行\",{\"1\":{\"273\":1}}],[\"都要找到该符号定义的地方\",{\"1\":{\"255\":1}}],[\"都要找到其定义的地方\",{\"1\":{\"245\":1}}],[\"都是网络连接\",{\"1\":{\"1865\":1}}],[\"都是成功的把操作写到磁盘上的redo\",{\"1\":{\"1761\":1}}],[\"都是查询快照上的数据\",{\"1\":{\"1658\":1}}],[\"都是常量级的时间\",{\"1\":{\"1617\":1}}],[\"都是会让线程来cpu执行的时候把它们共享的变量在线程的栈上拷贝一份\",{\"1\":{\"1233\":1}}],[\"都是由条件变量控制的\",{\"1\":{\"1221\":1}}],[\"都是由科学家将其变化为加法\",{\"1\":{\"344\":1}}],[\"都是4字节\",{\"1\":{\"1194\":1}}],[\"都是给出一部分进行使用\",{\"1\":{\"1105\":1}}],[\"都是给字节数\",{\"1\":{\"708\":1}}],[\"都是在全局变量中存储\",{\"1\":{\"1574\":1}}],[\"都是在构造函数中国自动执行mutex的lock\",{\"1\":{\"1228\":1}}],[\"都是在\",{\"1\":{\"1102\":1}}],[\"都是malloc\",{\"1\":{\"1079\":1}}],[\"都是只在本文件内有效\",{\"1\":{\"591\":1}}],[\"都是正常完美的编译运行\",{\"1\":{\"528\":1}}],[\"都是用来申请堆空间的\",{\"1\":{\"515\":1}}],[\"都是用来申请堆空间的2\",{\"1\":{\"513\":1}}],[\"都是底层const\",{\"1\":{\"489\":2}}],[\"都是\",{\"1\":{\"449\":1,\"1656\":1}}],[\"都是利用二分查找的方法在一个排好序的数组中进行查找的\",{\"1\":{\"163\":1}}],[\"都是和\",{\"1\":{\"135\":1}}],[\"⭐符号重定位\",{\"1\":{\"245\":1}}],[\"⭐对符号进行解析完成后\",{\"1\":{\"245\":1}}],[\"⭐对符号进行解析\",{\"1\":{\"245\":1}}],[\"⭐此后\",{\"1\":{\"245\":1}}],[\"⭐在编译过程中\",{\"1\":{\"245\":1}}],[\"源码中希望你用一个函数类型来实例化function模板\",{\"1\":{\"1161\":1}}],[\"源码中用\",{\"1\":{\"1102\":1}}],[\"源码如下\",{\"1\":{\"1127\":1}}],[\"源码阅读的方法\",{\"1\":{\"1105\":1}}],[\"源码加进来后记得同步一下\",{\"0\":{\"35\":1}}],[\"源文件\",{\"1\":{\"848\":1,\"850\":1,\"851\":1}}],[\"源文件经过预编译\",{\"1\":{\"245\":1}}],[\"源对象与拷贝对象互相独立\",{\"1\":{\"397\":1}}],[\"源代码编译\",{\"1\":{\"302\":1}}],[\"汇编选项\",{\"1\":{\"1356\":1}}],[\"汇编程序\",{\"1\":{\"1356\":1}}],[\"汇编和链接\",{\"0\":{\"1330\":1}}],[\"汇编\",{\"0\":{\"638\":1}}],[\"汇编指令可以看到\",{\"1\":{\"500\":1}}],[\"汇编器把汇编代码转成可重定向的文件时不仅生成了符号表\",{\"1\":{\"251\":1}}],[\"汇编就是把汇编代码转成特定平台的二进制码\",{\"1\":{\"244\":1}}],[\"汇编阶段有两种架构的汇编代码x86和at\",{\"1\":{\"244\":1}}],[\"转为右值就可以进行拷贝构造了\",{\"1\":{\"1047\":1}}],[\"转到\",{\"1\":{\"771\":2}}],[\"转换成10进制\",{\"1\":{\"1299\":2}}],[\"转换类型成功\",{\"1\":{\"631\":2}}],[\"转换到继承类指针\",{\"1\":{\"631\":1}}],[\"转换操作符\",{\"1\":{\"530\":2}}],[\"转换为多种不同的类型\",{\"1\":{\"630\":1}}],[\"转换为相同类型的时候\",{\"1\":{\"630\":1}}],[\"转换为类\",{\"1\":{\"530\":1}}],[\"转换为任意指针类型\",{\"1\":{\"530\":1}}],[\"转换为att格式的汇编\",{\"1\":{\"244\":1}}],[\"转换为intel格式的汇编\",{\"1\":{\"244\":1,\"261\":1}}],[\"转变为查找在区域内是否存在一个值属于\",{\"1\":{\"162\":1}}],[\"等语句\",{\"1\":{\"1717\":1}}],[\"等问题\",{\"1\":{\"1712\":1}}],[\"等值搜索\",{\"1\":{\"1563\":1}}],[\"等值查询\",{\"0\":{\"1498\":1},\"1\":{\"1686\":1}}],[\"等值于上面的查询\",{\"1\":{\"1494\":1}}],[\"等一会\",{\"1\":{\"1296\":1}}],[\"等待sql线程逐条执行\",{\"1\":{\"1783\":1}}],[\"等待线程的数量\",{\"1\":{\"1569\":1}}],[\"等待线程t1执行完才会往下走\",{\"1\":{\"1050\":1}}],[\"等待足够的时间以确保远程tcp接收到连接中断请求的确认\",{\"1\":{\"1240\":1}}],[\"等待原来的发向远程tcp的连接中断请求的确认\",{\"1\":{\"1240\":1}}],[\"等待远程tcp对连接中断的确认\",{\"1\":{\"1240\":1}}],[\"等待远程tcp连接中断请求\",{\"1\":{\"1240\":1}}],[\"等待从本地用户发来的连接中断请求\",{\"1\":{\"1240\":1}}],[\"等待cpu的下一次调度\",{\"1\":{\"1233\":1}}],[\"等待下一次cpu的调度\",{\"1\":{\"1233\":1}}],[\"等待下一次调度\",{\"1\":{\"1233\":2}}],[\"等待下一轮我们再轮到这个线程执行\",{\"1\":{\"1208\":1}}],[\"等待子线程结束\",{\"1\":{\"1207\":1}}],[\"等待t线程结束\",{\"1\":{\"1206\":1}}],[\"等待用户传递\",{\"1\":{\"1155\":1}}],[\"等于说又做一次\",{\"1\":{\"1120\":1}}],[\"等于链表的长度\",{\"1\":{\"790\":1}}],[\"等号右边的操作数为const\",{\"1\":{\"736\":1}}],[\"等号赋值的四步走\",{\"1\":{\"735\":1}}],[\"等号左边const修饰\",{\"1\":{\"492\":1}}],[\"等价于\",{\"1\":{\"1362\":1}}],[\"等价于50\",{\"1\":{\"1114\":1}}],[\"等价于int\",{\"1\":{\"625\":1}}],[\"等价于const\",{\"1\":{\"625\":1}}],[\"等价于str1\",{\"1\":{\"535\":1}}],[\"等机器上运行\",{\"1\":{\"302\":1}}],[\"等到进程\",{\"1\":{\"283\":1}}],[\"等\",{\"1\":{\"244\":1,\"425\":1,\"1317\":1,\"1548\":2}}],[\"等等\",{\"1\":{\"50\":1,\"306\":1,\"1745\":1}}],[\"假如现在有人把库删除了\",{\"1\":{\"1774\":1}}],[\"假如\",{\"1\":{\"1686\":1}}],[\"假如这张表有1000万个数据\",{\"1\":{\"1672\":1}}],[\"假如name是有索引的\",{\"1\":{\"1569\":1}}],[\"假如我们有vga接口的电脑\",{\"1\":{\"832\":1}}],[\"假如我一个大工程\",{\"1\":{\"576\":1}}],[\"假如对象占据的存储空间比较大\",{\"1\":{\"615\":1}}],[\"假如你在其他文件要使用改变量i\",{\"1\":{\"576\":1}}],[\"假如有const\",{\"1\":{\"490\":1}}],[\"假如有个函数start\",{\"1\":{\"244\":1}}],[\"假设我们现在的工程会生成\",{\"1\":{\"1318\":1}}],[\"假设我们向内存池申请16字节的时候\",{\"1\":{\"1102\":1}}],[\"假设我们的调用代码是这样的\",{\"1\":{\"528\":1}}],[\"假设它合法\",{\"1\":{\"747\":1}}],[\"假设它的地址是0x100\",{\"1\":{\"715\":1}}],[\"假设ma为类a的属性\",{\"1\":{\"688\":1}}],[\"假设a中有ma变量\",{\"1\":{\"688\":1}}],[\"假设没有else分支\",{\"1\":{\"273\":1}}],[\"假设你需要定义这样一个宏\",{\"1\":{\"273\":1}}],[\"假设下一行指令的地址位0x08124458\",{\"1\":{\"238\":1}}],[\"假设所有操作都是有效的\",{\"1\":{\"182\":1}}],[\"局部静态特性的方式实现单实例\",{\"1\":{\"850\":1}}],[\"局部静态变量体积太大\",{\"1\":{\"240\":1}}],[\"局部变量\",{\"1\":{\"535\":1,\"618\":1,\"1099\":1}}],[\"局部变量等信息就压一次栈\",{\"1\":{\"240\":1}}],[\"出错后可以查看错误日志\",{\"1\":{\"1833\":1}}],[\"出错时返回为null\",{\"1\":{\"1373\":1}}],[\"出了函数作用域\",{\"1\":{\"1221\":1}}],[\"出了语句就不能使用了\",{\"1\":{\"1154\":1}}],[\"出了语句就要析构\",{\"1\":{\"1115\":1}}],[\"出了语句\",{\"1\":{\"1113\":2}}],[\"出作用域就自动析构\",{\"1\":{\"1210\":1}}],[\"出作用域自动解锁\",{\"1\":{\"1096\":1}}],[\"出\",{\"1\":{\"1115\":1}}],[\"出语句调用~test\",{\"1\":{\"1114\":2}}],[\"出语句调用\",{\"1\":{\"1114\":1}}],[\"出语句后\",{\"1\":{\"1111\":1,\"1112\":3,\"1113\":2}}],[\"出main函数作用域\",{\"1\":{\"1056\":1}}],[\"出优先级队列\",{\"1\":{\"992\":1}}],[\"出队\",{\"1\":{\"991\":1}}],[\"出队操作\",{\"1\":{\"406\":1}}],[\"出现错误后还可以查看错误日志中提示的ip是否和自己允许slave登录的ip一致\",{\"1\":{\"1828\":1}}],[\"出现e\",{\"0\":{\"1296\":1}}],[\"出现这种问题时\",{\"1\":{\"653\":1}}],[\"出现栈内存溢出的常见原因有2个\",{\"1\":{\"240\":1}}],[\"出栈\",{\"1\":{\"233\":1,\"990\":1}}],[\"使权限生效\",{\"1\":{\"1821\":1}}],[\"使其与master的数据同步\",{\"1\":{\"1784\":1}}],[\"使其变为一元函数对象\",{\"1\":{\"1146\":1}}],[\"使加锁更准确\",{\"1\":{\"1724\":1}}],[\"使当前线程进入等待状态\",{\"1\":{\"1227\":1}}],[\"使⽤命名的强制类型转换函数const\",{\"1\":{\"489\":1}}],[\"使得普通用户也可以操作\",{\"1\":{\"1836\":1}}],[\"使得上层应用访问数据库的压力能够减到最小\",{\"1\":{\"1745\":1}}],[\"使得并发执行的各个事务之间不能互相影响\",{\"1\":{\"1644\":1}}],[\"使得不需要对字符串判空操作\",{\"1\":{\"1120\":1}}],[\"使得不管是在c还是c++文件中定义该函数\",{\"1\":{\"570\":1}}],[\"使得代码模块化\",{\"1\":{\"882\":1}}],[\"使得\",{\"1\":{\"867\":1}}],[\"使得每个对象占用内存较小\",{\"1\":{\"826\":1}}],[\"使得所有\",{\"1\":{\"795\":1}}],[\"使得可用名称变得模糊\",{\"1\":{\"593\":1}}],[\"使得holdsanint被放大到足够又可以存放一个int\",{\"1\":{\"470\":1}}],[\"使得程序知道退出sum后运行哪一条指令\",{\"1\":{\"238\":1}}],[\"使用反斜杆\",{\"1\":{\"1898\":1}}],[\"使用起来非常方便\",{\"1\":{\"1896\":1}}],[\"使用起来有诸多不便\",{\"1\":{\"535\":1}}],[\"使用主库\",{\"1\":{\"1885\":1}}],[\"使用多个从库副本\",{\"1\":{\"1885\":1}}],[\"使用技巧\",{\"1\":{\"1878\":1}}],[\"使用了线程间的同步通信机制条件变量和互斥锁\",{\"1\":{\"1866\":1}}],[\"使用线程互斥锁保证队列的线程安全\",{\"1\":{\"1866\":1}}],[\"使用完成后\",{\"1\":{\"1865\":1}}],[\"使用连接池耗时\",{\"1\":{\"1851\":1}}],[\"使用连接池的测试\",{\"1\":{\"1851\":1}}],[\"使用master创建的账户读取binlog同步数据\",{\"0\":{\"1825\":1}}],[\"使用mycat给user表插入两条数据\",{\"1\":{\"1892\":1}}],[\"使用mycat\",{\"1\":{\"1808\":1,\"1809\":1}}],[\"使用memcpy函数补上更简单吗\",{\"0\":{\"401\":1}}],[\"使用该方式排序\",{\"1\":{\"1736\":1}}],[\"使用未提交读的事务隔离机制\",{\"1\":{\"1712\":1}}],[\"使用第一个列之外的列作为等值查找会出现\",{\"1\":{\"1618\":1}}],[\"使用唯一索引或者主键\",{\"1\":{\"1618\":1}}],[\"使用索引会读取索引文件\",{\"1\":{\"1617\":1}}],[\"使用索引也会涉及磁盘io的\",{\"1\":{\"1609\":1}}],[\"使用protobuf前需要先进行安装\",{\"1\":{\"1914\":1}}],[\"使用primary\",{\"1\":{\"1610\":1}}],[\"使用patsubst函数来实现模式文本替换\",{\"1\":{\"1361\":1}}],[\"使用pair接收\",{\"1\":{\"178\":1}}],[\"使用不当\",{\"1\":{\"1609\":1}}],[\"使用哪个索引\",{\"0\":{\"1589\":1}}],[\"使用哈希索引o\",{\"1\":{\"1569\":1}}],[\"使用联合主键\",{\"1\":{\"1537\":1}}],[\"使用远程登录的配置修改\",{\"0\":{\"1408\":1}}],[\"使用wildcard函数可以使用通配符\",{\"1\":{\"1361\":1}}],[\"使用wget用户名和密码认证的ftp下载\",{\"1\":{\"1254\":1}}],[\"使用wget匿名ftp下载\",{\"1\":{\"1254\":1}}],[\"使用wget\",{\"0\":{\"1254\":1,\"1256\":1},\"1\":{\"1252\":1}}],[\"使用bash的规则来应用通配符\",{\"0\":{\"1359\":1}}],[\"使用变量\",{\"1\":{\"1356\":1}}],[\"使用链接器选项\",{\"1\":{\"1335\":1}}],[\"使用静态库和动态库\",{\"0\":{\"1331\":1}}],[\"使用简单方便\",{\"1\":{\"1303\":1}}],[\"使用add\",{\"1\":{\"1316\":1}}],[\"使用amix\",{\"0\":{\"1288\":1}}],[\"使用auto定义变量时必须对其进行初始化\",{\"1\":{\"700\":1}}],[\"使用subst函数来实现文本替换\",{\"1\":{\"1361\":1}}],[\"使用sudo命令需要输入用户口令\",{\"1\":{\"1280\":1}}],[\"使用set命令去新建变量来存放需要的源文件\",{\"1\":{\"1312\":1}}],[\"使用strace\",{\"1\":{\"1217\":1}}],[\"使用string\",{\"1\":{\"405\":1}}],[\"使用stl库中提供的泛型算法需要引入\",{\"1\":{\"1007\":1}}],[\"使用断点续传要求服务器支持断点续传\",{\"1\":{\"1252\":1}}],[\"使用最多的\",{\"1\":{\"1238\":1}}],[\"使用lock\",{\"1\":{\"1219\":1}}],[\"使用queue的push和pop操作时\",{\"1\":{\"1219\":1}}],[\"使用绑定器\",{\"1\":{\"1148\":1}}],[\"使用fulltext参数可以设置全文索引\",{\"1\":{\"1610\":1}}],[\"使用function函数对象类型\",{\"1\":{\"1168\":1}}],[\"使用function接收bind\",{\"1\":{\"1151\":1}}],[\"使用find\",{\"1\":{\"1148\":1}}],[\"使用free释放内存\",{\"1\":{\"1080\":1}}],[\"使用过程中\",{\"0\":{\"1109\":1}}],[\"使用一级空间配置器\",{\"1\":{\"1096\":1}}],[\"使用一些简单的继承\",{\"1\":{\"881\":1}}],[\"使用强智能指针\",{\"1\":{\"1056\":1}}],[\"使用的错误日志名为\",{\"1\":{\"1770\":1}}],[\"使用的磁盘i\",{\"1\":{\"1627\":1}}],[\"使用的时候简单配置调用api接口即可实现高可用的搜索\",{\"1\":{\"1610\":1}}],[\"使用的比较少\",{\"1\":{\"1604\":1}}],[\"使用的就是模板部分偏特化\",{\"1\":{\"1190\":1}}],[\"使用的也比较少\",{\"1\":{\"1046\":1}}],[\"使用的都是基类的指针或者引用\",{\"1\":{\"830\":1}}],[\"使用容器难免会涉及到容器的拷贝\",{\"1\":{\"1045\":1}}],[\"使用时\",{\"1\":{\"1041\":1}}],[\"使用vs2010打开msvc10\",{\"1\":{\"1029\":1}}],[\"使用下标计算其结点\",{\"1\":{\"994\":1}}],[\"使用change\",{\"1\":{\"1833\":1}}],[\"使用c\",{\"0\":{\"1399\":1}}],[\"使用cas保证上面++\",{\"1\":{\"1232\":1}}],[\"使用c++11提供的mutex\",{\"1\":{\"1217\":1}}],[\"使用c++中函数对象解决\",{\"0\":{\"982\":1}}],[\"使用c++的标准异常类实例\",{\"0\":{\"605\":1}}],[\"使用c的函数指针解决\",{\"1\":{\"981\":1}}],[\"使用c语言中函数指针解决\",{\"0\":{\"981\":1}}],[\"使用实例\",{\"0\":{\"983\":1}}],[\"使用实例与vector类似\",{\"1\":{\"969\":1,\"970\":1}}],[\"使用实体\",{\"1\":{\"536\":1}}],[\"使用初始的内存效率太低\",{\"1\":{\"966\":1}}],[\"使用前需要包含\",{\"1\":{\"965\":1,\"969\":1,\"970\":1}}],[\"使用方式\",{\"1\":{\"965\":1,\"969\":1,\"970\":1,\"1035\":1}}],[\"使用方法\",{\"0\":{\"5\":1,\"1307\":1,\"1352\":1}}],[\"使用命令\",{\"1\":{\"936\":1}}],[\"使用引用访问虚函数\",{\"1\":{\"922\":1}}],[\"使用单例设计模式的过程中\",{\"1\":{\"853\":1}}],[\"使用互斥锁保证线程安全\",{\"1\":{\"847\":1}}],[\"使用虚拟头节点可以避免复杂的分类讨论\",{\"1\":{\"802\":1}}],[\"使用函数指针接收\",{\"1\":{\"1158\":1}}],[\"使用函数对象来定义这个比较函数原型\",{\"1\":{\"784\":1}}],[\"使用函数可以确保统一的行为\",{\"1\":{\"500\":1}}],[\"使用重载函数操作符的类对象\",{\"1\":{\"784\":1}}],[\"使用小根堆\",{\"1\":{\"784\":1}}],[\"使用队列的push和pop入队和出队操作模拟一个简单对象池的实现的例子\",{\"0\":{\"751\":1}}],[\"使用erase未对源代码进行更新\",{\"1\":{\"747\":1}}],[\"使用erase并对迭代器更新\",{\"1\":{\"747\":1}}],[\"使用insert未对迭代器更新\",{\"1\":{\"747\":1}}],[\"使用insert并对迭代器更新\",{\"1\":{\"747\":1}}],[\"使用右值引用能够很好的解决这个问题\",{\"1\":{\"620\":1}}],[\"使用常引用来引用常量数字10\",{\"1\":{\"620\":1}}],[\"使用指针访问虚函数时\",{\"1\":{\"920\":1}}],[\"使用指针访问非虚函数时\",{\"1\":{\"920\":1}}],[\"使用指针作为函数的形参虽然达到的效果和使用引用一样\",{\"1\":{\"615\":1}}],[\"使用指南\",{\"1\":{\"45\":2},\"2\":{\"9\":1,\"10\":1,\"12\":1,\"13\":1,\"18\":1,\"19\":1,\"23\":1,\"24\":1,\"122\":1,\"123\":1,\"186\":1,\"187\":1,\"209\":1,\"210\":1,\"225\":1,\"226\":1,\"386\":1,\"387\":1,\"719\":1,\"902\":1,\"903\":1,\"1005\":1,\"1156\":1,\"1157\":1,\"1241\":1,\"1300\":1,\"1301\":1}}],[\"使用关键字\",{\"1\":{\"607\":2}}],[\"使用unique修饰的字段\",{\"1\":{\"1610\":1}}],[\"使用unordered\",{\"1\":{\"170\":1}}],[\"使用using编译指令\",{\"1\":{\"588\":1}}],[\"使用glob\",{\"1\":{\"1312\":1}}],[\"使用glob自动查找当前目录下指定扩展名的文件\",{\"1\":{\"1312\":1}}],[\"使用g++链接\",{\"1\":{\"568\":1}}],[\"使用goto总是一种简单的方法\",{\"1\":{\"277\":1}}],[\"使用0来做为空指针会比使用null来做空指针会让你更加警觉\",{\"1\":{\"528\":1}}],[\"使用new表达式为对象数组分配动态空间时\",{\"1\":{\"459\":1}}],[\"使用与函数模板也差不多\",{\"1\":{\"388\":1}}],[\"使用十分不合理\",{\"1\":{\"382\":1}}],[\"使用浮点数直接使用\",{\"1\":{\"337\":1}}],[\"使用汇编写出了\",{\"1\":{\"301\":1}}],[\"使用栈实现队列的下列操作\",{\"1\":{\"182\":1}}],[\"使用数组来做哈希表了\",{\"1\":{\"170\":1}}],[\"使用双指针前要先排序\",{\"1\":{\"133\":1}}],[\"使用条件\",{\"0\":{\"91\":1}}],[\"使用锚点\",{\"1\":{\"59\":1}}],[\"使用tcp加密的ssl通信协议\",{\"1\":{\"1881\":1}}],[\"使用threadlocal可以为每个线程维护一个私有的本地变量\",{\"1\":{\"840\":1}}],[\"使用typora记录笔记的时候虽然支持页间跳转\",{\"1\":{\"56\":1}}],[\"使用text\",{\"1\":{\"50\":1}}],[\"使用\",{\"0\":{\"28\":1,\"274\":1,\"275\":1,\"852\":1,\"1209\":1,\"1249\":1,\"1250\":1,\"1251\":1,\"1252\":1,\"1253\":1},\"1\":{\"56\":1,\"67\":1,\"261\":2,\"957\":1,\"1333\":1,\"1335\":2,\"1338\":1,\"1341\":1,\"1357\":2,\"1470\":1,\"1896\":2}}],[\"使用rb\",{\"1\":{\"17\":1}}],[\"接收master的binary\",{\"1\":{\"1784\":1}}],[\"接收大类型的所有细分类型\",{\"1\":{\"1190\":1}}],[\"接收返回值是对象的函数调用\",{\"1\":{\"1067\":1}}],[\"接收的是容器的迭代器\",{\"1\":{\"1007\":1}}],[\"接收调用该方法的对象的地址\",{\"1\":{\"392\":2}}],[\"接口不太好\",{\"1\":{\"886\":1}}],[\"接口与实现进行解耦\",{\"1\":{\"826\":1}}],[\"接口原型\",{\"1\":{\"518\":1}}],[\"接回到原来的链表中\",{\"1\":{\"802\":1}}],[\"接到结果链表上\",{\"1\":{\"784\":1}}],[\"接着输入如下命令\",{\"1\":{\"1407\":1}}],[\"接着使用这个文件和参数\",{\"1\":{\"1250\":1}}],[\"接着调用函数完毕\",{\"1\":{\"238\":1}}],[\"接着是函数的右括号\",{\"1\":{\"238\":1}}],[\"接着运行return\",{\"1\":{\"238\":1}}],[\"接下来是int\",{\"1\":{\"236\":1}}],[\"第四范式\",{\"0\":{\"1464\":1}}],[\"第三范式\",{\"0\":{\"1462\":1}}],[\"第三个是\",{\"1\":{\"1318\":1}}],[\"第三个虚函数的地址\",{\"1\":{\"894\":1}}],[\"第三个观察者实例\",{\"1\":{\"871\":1}}],[\"第三步\",{\"1\":{\"238\":1}}],[\"第\",{\"1\":{\"599\":1,\"782\":1,\"802\":5,\"1315\":2}}],[\"第2\",{\"1\":{\"264\":1}}],[\"第七章\",{\"1\":{\"264\":1}}],[\"第二次速度快是因为有数据缓存和索引缓冲\",{\"1\":{\"1617\":1}}],[\"第二范式\",{\"0\":{\"1461\":1}}],[\"第二维都是独立开辟的空间\",{\"1\":{\"972\":1}}],[\"第二维为动态开辟的que\",{\"1\":{\"968\":1}}],[\"第二行为向下的偏移量\",{\"1\":{\"937\":1}}],[\"第二行为虚基类指针到虚基类数据的偏移量\",{\"1\":{\"937\":1}}],[\"第二行为离的偏移量\",{\"1\":{\"933\":1}}],[\"第二圈时如果相遇则p1==p2\",{\"1\":{\"771\":1}}],[\"第二个参数减1\",{\"1\":{\"1878\":2}}],[\"第二个参数是字符串\",{\"1\":{\"1318\":1}}],[\"第二个以后的表的select\",{\"1\":{\"1618\":1}}],[\"第二个虚函数的地址\",{\"1\":{\"894\":1}}],[\"第二个观察者实例\",{\"1\":{\"871\":1}}],[\"第二个\",{\"1\":{\"599\":1,\"1591\":1}}],[\"第二种方式就是直接使用作用域限定符\",{\"1\":{\"589\":1}}],[\"第二种情况比较常见\",{\"1\":{\"240\":1}}],[\"第二步\",{\"1\":{\"238\":1}}],[\"第二步进入函数调用\",{\"1\":{\"238\":1}}],[\"第一范式\",{\"0\":{\"1460\":1}}],[\"第一句cout\",{\"1\":{\"1045\":1}}],[\"第一行为向上偏移量\",{\"1\":{\"933\":1}}],[\"第一次运行到它才初始化的\",{\"1\":{\"1114\":1}}],[\"第一次向os申请的话\",{\"1\":{\"1102\":1}}],[\"第一次插入从0变更为1\",{\"1\":{\"966\":1}}],[\"第一次调用erase后\",{\"1\":{\"742\":1}}],[\"第一次析构将堆内存释放\",{\"1\":{\"397\":1}}],[\"第一步符号解析完成后\",{\"1\":{\"255\":1}}],[\"第一种情况不太常见\",{\"1\":{\"240\":1}}],[\"第一个挂掉切换到还在的第二个\",{\"1\":{\"1803\":1}}],[\"第一个zhang\",{\"1\":{\"1591\":1}}],[\"第一个依赖文件\",{\"1\":{\"1356\":1}}],[\"第一个虚函数的地址\",{\"1\":{\"894\":1}}],[\"第一个观察者实例\",{\"1\":{\"871\":1}}],[\"第一个数据结点\",{\"1\":{\"791\":1}}],[\"第一个数据成员放在offset\",{\"1\":{\"555\":1}}],[\"第一个字符必须为字母或下划线\",{\"1\":{\"316\":1}}],[\"第一个\",{\"1\":{\"135\":1,\"599\":1}}],[\"第一级标题做题目\",{\"1\":{\"51\":1}}],[\"控制最大连接量\",{\"1\":{\"1881\":1}}],[\"控制构建类型\",{\"0\":{\"1320\":1}}],[\"控制选项\",{\"0\":{\"1318\":1}}],[\"控制锁的构造和析构\",{\"1\":{\"1210\":1}}],[\"控制流返回到调用者的函数\",{\"1\":{\"235\":1}}],[\"控制就\",{\"1\":{\"22\":1}}],[\"此步需要输入数据的root密码\",{\"1\":{\"1397\":1}}],[\"此项专门用于解压zip格式文档的工具\",{\"1\":{\"1262\":1}}],[\"此参数的效果和指定\",{\"1\":{\"1237\":2}}],[\"此函数可能用于释放某些可以释放的资源\",{\"1\":{\"1102\":1}}],[\"此后\",{\"1\":{\"1056\":1}}],[\"此后局部变量和临时存储都可以通过基准指针ebp加偏移量找到了\",{\"1\":{\"235\":1}}],[\"此处从connection队列获取空闲连接\",{\"1\":{\"1866\":1}}],[\"此处把bind返回的绑定器binder就复用起来了\",{\"1\":{\"1155\":1}}],[\"此处是隐藏\",{\"1\":{\"890\":1}}],[\"此处的c\",{\"1\":{\"890\":1}}],[\"此处就是二义性\",{\"1\":{\"890\":1}}],[\"此处会进行复制操作\",{\"1\":{\"616\":1}}],[\"此处模板参数列表不能为空\",{\"1\":{\"362\":1}}],[\"此变量\",{\"1\":{\"574\":1}}],[\"此成员函数地址即已确定\",{\"1\":{\"392\":1}}],[\"此选项取消编译\",{\"1\":{\"311\":1}}],[\"此外还需要在rule\",{\"1\":{\"1891\":1}}],[\"此外一旦哈希表扩容\",{\"1\":{\"1604\":1}}],[\"此外b+树索引是把磁盘上的存储的索引文件加载到内存上构建的数据结构\",{\"1\":{\"1601\":1}}],[\"此外\",{\"1\":{\"285\":1,\"1338\":1,\"1896\":1}}],[\"此时slave是没法单独使用的\",{\"1\":{\"1803\":1}}],[\"此时slave的mytest也不存在了\",{\"1\":{\"1785\":1}}],[\"此时虽然数据还在buffer\",{\"1\":{\"1762\":1}}],[\"此时一旦发生异常\",{\"1\":{\"1758\":1}}],[\"此时若发生异常\",{\"1\":{\"1757\":1}}],[\"此时mycat会自动切到另一套环境\",{\"1\":{\"1791\":1}}],[\"此时mysql下次再恢复的时候就没有必要考虑这个事务的完整性\",{\"1\":{\"1759\":1}}],[\"此时mysql需要排序前2000010\",{\"1\":{\"1740\":1}}],[\"此时mb还没有值\",{\"1\":{\"422\":1}}],[\"此时会根据新的请求数量去创建更多的连接给应用去使用\",{\"1\":{\"1865\":1}}],[\"此时会放弃使用索引\",{\"1\":{\"1713\":1}}],[\"此时会进入else\",{\"1\":{\"1102\":1}}],[\"此时所有的事务都阻塞住了\",{\"1\":{\"1707\":1}}],[\"此时由于insert需要加排它锁\",{\"1\":{\"1701\":1}}],[\"此时数据涉及到修改了\",{\"1\":{\"1681\":1}}],[\"此时不如直接加表锁\",{\"1\":{\"1670\":1}}],[\"此时事务\",{\"1\":{\"1719\":1}}],[\"此时事务2只能等待\",{\"1\":{\"1673\":1}}],[\"此时事务2\",{\"1\":{\"1665\":1,\"1692\":1}}],[\"此时事务a执行异常\",{\"1\":{\"1639\":1}}],[\"此时事务b再去查询\",{\"1\":{\"1639\":1}}],[\"此时事务b再次去读该数据\",{\"1\":{\"1639\":1}}],[\"此时如果事务a\",{\"1\":{\"1639\":1}}],[\"此时在进行内连接b就变成了小表\",{\"1\":{\"1540\":1}}],[\"此时可以使用make命令的\",{\"1\":{\"1363\":1}}],[\"此时生产者线程拿到互斥锁\",{\"1\":{\"1221\":1}}],[\"此时ticketcount还未变为0\",{\"1\":{\"1209\":1}}],[\"此时线程1进入临界区执行卖票\",{\"1\":{\"1209\":1}}],[\"此时的实例化compare代码就不行了\",{\"1\":{\"1186\":1}}],[\"此时p指向的是一个已经析构的临时对象\",{\"1\":{\"1113\":1}}],[\"此时也需要在\",{\"1\":{\"1102\":1}}],[\"此时需要动态创建连接\",{\"1\":{\"1866\":1}}],[\"此时需要扩容第一维了\",{\"1\":{\"968\":1}}],[\"此时需要重新显式定义拷贝构造函数\",{\"1\":{\"397\":1}}],[\"此时对于析构函数的调用就是\",{\"1\":{\"948\":1}}],[\"此时派生类对象就会产生自己本身的虚函数指针\",{\"1\":{\"940\":1}}],[\"此时派生类对象不会产生虚函数指针\",{\"1\":{\"940\":1}}],[\"此时编译器采用的是\",{\"1\":{\"923\":1}}],[\"此时再增加新的派生类型\",{\"1\":{\"886\":1}}],[\"此时发生动态绑定\",{\"1\":{\"886\":1}}],[\"此时创建宝马对象时\",{\"1\":{\"867\":1}}],[\"此时电脑上的视频可以直接投到投影仪上\",{\"1\":{\"832\":1}}],[\"此时迭代器失效\",{\"1\":{\"747\":1}}],[\"此时都自动调用了基类缺省的无参构造函数\",{\"1\":{\"669\":1}}],[\"此时就需要用索引来加速sql查询\",{\"1\":{\"1609\":1}}],[\"此时就需要断点续传\",{\"1\":{\"1252\":1}}],[\"此时就需要我们的容器的迭代器了\",{\"1\":{\"698\":1}}],[\"此时就需要我们的容器空间配置器了\",{\"1\":{\"384\":1}}],[\"此时就需要我们的dynamic\",{\"1\":{\"631\":1}}],[\"此时就会与预期的构造不一致\",{\"1\":{\"434\":1}}],[\"此时\",{\"1\":{\"426\":1,\"490\":1,\"688\":1,\"949\":2,\"985\":1,\"1708\":1}}],[\"此时什么都没有做\",{\"1\":{\"382\":1}}],[\"此时我们有两种解决方案\",{\"1\":{\"293\":1}}],[\"此时元素下标代表元素\",{\"1\":{\"214\":1}}],[\"此时记录的是出现的次数\",{\"1\":{\"214\":1}}],[\"此时只有⼀个元素\",{\"1\":{\"202\":1}}],[\"此时队列是否为满\",{\"1\":{\"185\":2}}],[\"此时队列是否为空\",{\"1\":{\"185\":2}}],[\"压力测试是设计优化类项目所必须的\",{\"1\":{\"1850\":1}}],[\"压力测试\",{\"0\":{\"1850\":1}}],[\"压测执行各种业务\",{\"0\":{\"1579\":1},\"1\":{\"1573\":1}}],[\"压测后打开慢查询日志\",{\"1\":{\"1573\":1}}],[\"压缩成\",{\"1\":{\"1261\":1}}],[\"压缩或解压缩的文件名\",{\"1\":{\"1261\":1}}],[\"压缩后不能追加\",{\"1\":{\"1260\":1}}],[\"压栈\",{\"1\":{\"234\":1,\"1063\":1}}],[\"压入sum函数的栈\",{\"1\":{\"234\":1}}],[\"回滚过程也会出现异常\",{\"1\":{\"1761\":1}}],[\"回滚的时候发现是null\",{\"1\":{\"1682\":1}}],[\"回滚指针\",{\"1\":{\"1681\":1}}],[\"回滚一个事务到初始的位置\",{\"1\":{\"1640\":1}}],[\"回滚日志\",{\"1\":{\"1032\":1,\"1645\":1,\"1677\":1,\"1679\":1}}],[\"回表的过程\",{\"0\":{\"1565\":1}}],[\"回表\",{\"1\":{\"1564\":1}}],[\"回表会降低查询效率\",{\"1\":{\"1511\":1}}],[\"回收这个连接的资源\",{\"1\":{\"1881\":1}}],[\"回收权限revoke\",{\"0\":{\"1486\":1}}],[\"回收资源\",{\"1\":{\"1031\":3}}],[\"回收时\",{\"1\":{\"512\":1}}],[\"回文链表\",{\"0\":{\"754\":1},\"1\":{\"754\":1}}],[\"回到队前面\",{\"1\":{\"406\":1}}],[\"回到主函数\",{\"1\":{\"238\":1}}],[\"回到main函数\",{\"1\":{\"234\":1}}],[\"回退栈帧\",{\"1\":{\"238\":1}}],[\"回答两点\",{\"0\":{\"6\":1}}],[\"查show\",{\"1\":{\"1507\":1,\"1552\":1}}],[\"查select\",{\"0\":{\"1493\":1}}],[\"查询缓存\",{\"1\":{\"1881\":1}}],[\"查询缓存适用于更新不频繁的表\",{\"1\":{\"1749\":1}}],[\"查询失败\",{\"1\":{\"1847\":1,\"1856\":1}}],[\"查询操作select\",{\"1\":{\"1846\":1,\"1856\":1}}],[\"查询user表\",{\"1\":{\"1812\":1}}],[\"查询日志记录了client发送的所有sql语句\",{\"1\":{\"1771\":1}}],[\"查询日志\",{\"0\":{\"1771\":1},\"1\":{\"1767\":1}}],[\"查询频繁的表\",{\"1\":{\"1749\":1}}],[\"查询排序的代价非常大\",{\"1\":{\"1740\":1}}],[\"查询时不要显示加锁\",{\"1\":{\"1724\":1}}],[\"查询时不需要回表查询\",{\"1\":{\"1618\":1}}],[\"查询一下表数据\",{\"1\":{\"1708\":1}}],[\"查询事务的隔离级别\",{\"1\":{\"1640\":1}}],[\"查询速度会变慢\",{\"1\":{\"1609\":1}}],[\"查询所有没有考试的同学信息\",{\"1\":{\"1544\":1}}],[\"查询的就慢\",{\"1\":{\"1627\":1}}],[\"查询的就快\",{\"1\":{\"1627\":1}}],[\"查询的表行占表的百分比\",{\"1\":{\"1521\":1}}],[\"查询的程序\",{\"0\":{\"1385\":1}}],[\"查询类型\",{\"1\":{\"1521\":1}}],[\"查询数据库\",{\"1\":{\"1506\":1}}],[\"查询权限\",{\"1\":{\"1485\":1,\"1486\":1}}],[\"查询到了已经commit的数据\",{\"1\":{\"1634\":1}}],[\"查询到就会截至查询并返回\",{\"1\":{\"1522\":1}}],[\"查询到\",{\"1\":{\"1385\":1}}],[\"查询书籍\",{\"1\":{\"1168\":2}}],[\"查询成功\",{\"1\":{\"1001\":1}}],[\"查询o\",{\"1\":{\"974\":1}}],[\"查询\",{\"0\":{\"1514\":1},\"1\":{\"965\":1,\"969\":1,\"970\":1,\"1000\":1}}],[\"查看防火墙状态\",{\"1\":{\"1818\":1}}],[\"查看我们多主多从中备用系统的general\",{\"1\":{\"1814\":1}}],[\"查看查询日志general\",{\"1\":{\"1810\":1}}],[\"查看数据库\",{\"1\":{\"1809\":1}}],[\"查看数据源show\",{\"1\":{\"1808\":1}}],[\"查看逻辑节点和真实库的映射关系show\",{\"1\":{\"1808\":1}}],[\"查看逻辑库\",{\"1\":{\"1808\":1}}],[\"查看端口\",{\"1\":{\"1804\":1}}],[\"查看配置文件mycat\",{\"1\":{\"1804\":1}}],[\"查看jdk版本\",{\"0\":{\"1798\":1}}],[\"查看主从复制状态\",{\"0\":{\"1797\":1},\"1\":{\"1797\":1}}],[\"查看slave当前环境下的工作线程\",{\"1\":{\"1786\":1}}],[\"查看slave\",{\"1\":{\"1785\":1}}],[\"查看sum\",{\"0\":{\"250\":1}}],[\"查看一下当前的库\",{\"1\":{\"1774\":1}}],[\"查看一个库的创建信息\",{\"1\":{\"1507\":1}}],[\"查看的二进制日志文件路径\",{\"1\":{\"1773\":1}}],[\"查看状态\",{\"1\":{\"1768\":1}}],[\"查看变量\",{\"1\":{\"1768\":1}}],[\"查看日志相关变量\",{\"0\":{\"1768\":1}}],[\"查看事务执行\",{\"1\":{\"1719\":1,\"1720\":1}}],[\"查看隔离级别\",{\"0\":{\"1632\":1},\"1\":{\"1699\":1}}],[\"查看默认的索引名\",{\"1\":{\"1614\":1}}],[\"查看索引类型\",{\"0\":{\"1599\":1}}],[\"查看另一个session\",{\"1\":{\"1578\":1}}],[\"查看慢查询日志\",{\"0\":{\"1580\":1},\"1\":{\"1573\":1}}],[\"查看支持的存储引擎\",{\"1\":{\"1555\":1}}],[\"查看建表sql\",{\"1\":{\"1551\":1}}],[\"查看表字段信息\",{\"1\":{\"1552\":1}}],[\"查看表的创建信息\",{\"1\":{\"1552\":1}}],[\"查看表结构\",{\"1\":{\"1551\":1}}],[\"查看表\",{\"1\":{\"1551\":1}}],[\"查看是否产生中间表\",{\"1\":{\"1544\":1}}],[\"查看两个表内连接后两个表的所有信息\",{\"1\":{\"1540\":1}}],[\"查看执行计划\",{\"0\":{\"1520\":1}}],[\"查看哪个年龄段有分布\",{\"1\":{\"1512\":1}}],[\"查看该库层面下的所有表\",{\"1\":{\"1507\":1}}],[\"查看整个库下所有的数据库\",{\"1\":{\"1507\":1}}],[\"查看用户信息\",{\"1\":{\"1447\":1}}],[\"查看系统日志\",{\"1\":{\"1411\":1}}],[\"查看mycat\",{\"1\":{\"1805\":1,\"1806\":1}}],[\"查看mysql状态\",{\"1\":{\"1820\":1}}],[\"查看mysql的端口号\",{\"1\":{\"1616\":1}}],[\"查看mysql的状态\",{\"1\":{\"1409\":1}}],[\"查看mysql存储的文件\",{\"0\":{\"1556\":1}}],[\"查看mysql自己的日志\",{\"1\":{\"1411\":1}}],[\"查看mysql端口号\",{\"1\":{\"1409\":1}}],[\"查看master\",{\"1\":{\"1818\":1}}],[\"查看master当前环境下的工作线程\",{\"0\":{\"1786\":1}}],[\"查看main\",{\"0\":{\"249\":1}}],[\"查看记录行的列数\",{\"0\":{\"1380\":1}}],[\"查看定义了哪些伪目标\",{\"1\":{\"1355\":1}}],[\"查看从当前程序计数器\",{\"1\":{\"1348\":1}}],[\"查看从地址0x12345678开始的字符串\",{\"1\":{\"1348\":1}}],[\"查看从地址0x12345678开始的指令\",{\"1\":{\"1348\":1}}],[\"查看从地址0x12345678开始的4个字节\",{\"1\":{\"1348\":1}}],[\"查看当前binlog文件以及位置\",{\"1\":{\"1832\":1}}],[\"查看当前二进制日志的名字\",{\"1\":{\"1822\":1}}],[\"查看当前开放的端口列表\",{\"1\":{\"1818\":1}}],[\"查看当前的binlog\",{\"1\":{\"1772\":1}}],[\"查看当前库下的表\",{\"1\":{\"1552\":1}}],[\"查看当前数据库支持的存储引擎\",{\"0\":{\"1651\":1}}],[\"查看当前数据库\",{\"1\":{\"1508\":1}}],[\"查看当前有没有安装mysql\",{\"0\":{\"1389\":1}}],[\"查看当前所有断点的信息\",{\"1\":{\"1340\":1}}],[\"查看当前所有监听端口\",{\"1\":{\"1238\":1}}],[\"查看当前调用栈的信息\",{\"1\":{\"1340\":1}}],[\"查看设置好的运行参数\",{\"1\":{\"1340\":1}}],[\"查看堆栈\",{\"1\":{\"1338\":1}}],[\"查看版本\",{\"1\":{\"1305\":2}}],[\"查看硬链接数\",{\"1\":{\"1271\":1}}],[\"查看本机所有的网络\",{\"1\":{\"1238\":1}}],[\"查看本机路由表\",{\"1\":{\"1238\":1}}],[\"查看所有3306端口使用情况\",{\"1\":{\"1238\":1}}],[\"查看所有80端口使用情况\",{\"1\":{\"1238\":1}}],[\"查看所有书籍信息\",{\"1\":{\"1168\":2}}],[\"查看某个服务监听端口\",{\"1\":{\"1238\":1}}],[\"查看如果当前进程还有未运行完成的子线程\",{\"1\":{\"1207\":2}}],[\"查看类的成员方法到底是什么\",{\"1\":{\"1158\":1}}],[\"查看\",{\"1\":{\"1105\":1}}],[\"查看队顶元素\",{\"1\":{\"992\":1}}],[\"查看队头元素\",{\"1\":{\"991\":1}}],[\"查看栈顶元素\",{\"1\":{\"990\":1}}],[\"查看内存分布\",{\"0\":{\"958\":1}}],[\"查看方法\",{\"0\":{\"936\":1}}],[\"查看文件信息\",{\"1\":{\"572\":1}}],[\"查看文件头\",{\"1\":{\"251\":1}}],[\"查看二进制文件\",{\"0\":{\"572\":1}}],[\"查看缺页中断的次数\",{\"0\":{\"289\":1},\"1\":{\"289\":1}}],[\"查看可执行程序的program\",{\"0\":{\"262\":1}}],[\"查看可执行文件\",{\"0\":{\"257\":1}}],[\"查看有哪些段以及各个段的信息\",{\"1\":{\"252\":1}}],[\"查看符号表信息\",{\"1\":{\"252\":1}}],[\"查看符号表\",{\"0\":{\"248\":1}}],[\"查看反汇编\",{\"1\":{\"234\":1}}],[\"查找有角色的所有的用户信息\",{\"1\":{\"1738\":1}}],[\"查找效率低\",{\"1\":{\"1622\":1}}],[\"查找较多time\",{\"1\":{\"1238\":1}}],[\"查找请求数前20个ip\",{\"1\":{\"1238\":1}}],[\"查找成功\",{\"1\":{\"1007\":1}}],[\"查找链表中倒数第n个结点\",{\"0\":{\"806\":1}}],[\"查找环的入口地址\",{\"0\":{\"768\":1},\"1\":{\"768\":1}}],[\"查找子串\",{\"1\":{\"535\":1,\"536\":1}}],[\"查找不到\",{\"1\":{\"535\":2}}],[\"查找\",{\"1\":{\"290\":1,\"1000\":1}}],[\"查找该元素存放的位置\",{\"1\":{\"213\":1}}],[\"查找最大和次大的元素\",{\"0\":{\"118\":1}}],[\"查找出现次数超过一半的元素\",{\"0\":{\"113\":1}}],[\"查找两个有序数组的公共部分\",{\"0\":{\"110\":1},\"1\":{\"110\":1}}],[\"查找三个数组的公共元素\",{\"0\":{\"107\":1}}],[\"查找n个数组的公共元素\",{\"0\":{\"104\":1}}],[\"查找元素的位置\",{\"1\":{\"101\":1}}],[\"查找target\",{\"1\":{\"84\":1,\"142\":1}}],[\"查找定位及reference等功能\",{\"0\":{\"41\":1}}],[\"调整后chunk块的大小\",{\"1\":{\"1076\":1}}],[\"调整前chunk块的大小\",{\"1\":{\"1076\":1}}],[\"调整使用>\",{\"1\":{\"121\":1}}],[\"调⽤⽗类\",{\"1\":{\"695\":1}}],[\"调⽤⼦类\",{\"1\":{\"695\":1}}],[\"调⽤到基类被覆盖的虚函数\",{\"1\":{\"695\":1}}],[\"调⽤到基类被覆盖\",{\"1\":{\"695\":1}}],[\"调⽤a中fun函数\",{\"1\":{\"695\":3}}],[\"调⽤的是b中的fun函数\",{\"1\":{\"695\":2}}],[\"调⽤⽅法根据决定\",{\"1\":{\"694\":1}}],[\"调用serializetostring方法\",{\"1\":{\"1915\":1}}],[\"调用add\",{\"1\":{\"1914\":1}}],[\"调用a=malloc\",{\"1\":{\"283\":1}}],[\"调用存储引擎提供的相应api接口进行数据的读写\",{\"1\":{\"1881\":1}}],[\"调用connection的析构函数\",{\"1\":{\"1849\":1,\"1859\":1,\"1872\":1}}],[\"调用c=malloc\",{\"1\":{\"284\":1}}],[\"调用~connection\",{\"1\":{\"1849\":1,\"1859\":1}}],[\"调用了\",{\"1\":{\"1164\":1}}],[\"调用的时候就要传递参数了\",{\"1\":{\"1155\":1}}],[\"调用的时候\",{\"1\":{\"1155\":1}}],[\"调用的是派生类从基类继承来的方法\",{\"1\":{\"953\":1}}],[\"调用的是基类的拷贝构造和拷贝赋值\",{\"1\":{\"662\":1}}],[\"调用右值引用的拷贝构造\",{\"1\":{\"1124\":1}}],[\"调用构造\",{\"1\":{\"1124\":1}}],[\"调用构造函数\",{\"1\":{\"1110\":1,\"1111\":1}}],[\"调用左值引用的拷贝构造\",{\"1\":{\"1124\":1}}],[\"调用左值引用的拷贝\",{\"1\":{\"1124\":1}}],[\"调用左边对象的=重载\",{\"1\":{\"1115\":1}}],[\"调用test\",{\"1\":{\"1115\":2}}],[\"调用带整型参数的构造函数\",{\"1\":{\"1115\":2}}],[\"调用\",{\"1\":{\"1102\":1,\"1115\":1,\"1523\":1}}],[\"调用此函数\",{\"1\":{\"1102\":1}}],[\"调用find\",{\"1\":{\"999\":1}}],[\"调用ecx\",{\"1\":{\"954\":1}}],[\"调用析构时去base中找base\",{\"1\":{\"948\":1}}],[\"调用析构函数\",{\"1\":{\"427\":1,\"854\":2,\"856\":1,\"857\":1}}],[\"调用虚函数\",{\"1\":{\"927\":1}}],[\"调用哪个类的函数取决于定义对象名的类型\",{\"1\":{\"923\":1}}],[\"调用方函数站点地址放入当前函数栈底\",{\"1\":{\"908\":1}}],[\"调用时出错\",{\"1\":{\"908\":1}}],[\"调用一个函数时要先压参数\",{\"1\":{\"906\":1}}],[\"调用同名覆盖方法\",{\"1\":{\"883\":1}}],[\"调用基类的构造函数完成基类成员的初始化\",{\"1\":{\"674\":1}}],[\"调用效率问题\",{\"0\":{\"638\":1}}],[\"调用p指向对象的析构函数\",{\"1\":{\"711\":1}}],[\"调用p\",{\"1\":{\"631\":1}}],[\"调用operator\",{\"1\":{\"519\":1}}],[\"调用delete\",{\"1\":{\"517\":1}}],[\"调用函数时\",{\"1\":{\"637\":1}}],[\"调用函数都要做很多工作\",{\"1\":{\"500\":1}}],[\"调用函数比求解等价表达式要得多\",{\"1\":{\"500\":1}}],[\"调用非const版本的成员函数\",{\"1\":{\"440\":1}}],[\"调用赋值重载函数\",{\"1\":{\"405\":1,\"1111\":1}}],[\"调用拷贝构造函数\",{\"1\":{\"405\":1,\"1110\":2,\"1111\":2}}],[\"调用默认的构造\",{\"1\":{\"405\":1}}],[\"调用堆栈\",{\"1\":{\"306\":3}}],[\"调试方法\",{\"0\":{\"306\":1}}],[\"调试\",{\"1\":{\"234\":1}}],[\"变的更小了\",{\"1\":{\"340\":1}}],[\"变量内容会随着规则自动变化\",{\"1\":{\"1356\":1}}],[\"变量的当前值\",{\"1\":{\"1342\":1}}],[\"变量名实质就是一段连续内存空间的别名\",{\"1\":{\"612\":1}}],[\"变量名\",{\"0\":{\"1356\":1},\"1\":{\"435\":1,\"1356\":3}}],[\"变量命名\",{\"0\":{\"316\":1}}],[\"变量\",{\"0\":{\"315\":1},\"1\":{\"315\":1,\"585\":1,\"1102\":1,\"1356\":1}}],[\"变成2个字节\",{\"1\":{\"308\":1}}],[\"变成sum函数的栈顶\",{\"1\":{\"234\":1}}],[\"变为12个字节\",{\"1\":{\"937\":1}}],[\"变为\",{\"1\":{\"300\":1}}],[\"变形的goto\",{\"1\":{\"277\":1}}],[\"变化的过程最终会⾛到⼀个圈⾥⾯\",{\"1\":{\"147\":1}}],[\"🍔\",{\"1\":{\"1335\":2}}],[\"🍔🍔🍔\",{\"1\":{\"492\":1}}],[\"🍊声名\",{\"1\":{\"267\":1}}],[\"🍗🍗🍗pb依然是base类型的指针\",{\"1\":{\"954\":1}}],[\"🍗🍗🍗\",{\"0\":{\"491\":1,\"625\":1}}],[\"🍗🍗🍗示例\",{\"0\":{\"234\":1}}],[\"🍗\",{\"1\":{\"240\":1}}],[\"🍖堆排序\",{\"0\":{\"194\":1}}],[\"堆\",{\"0\":{\"1919\":1}}],[\"堆顶元素最大\",{\"1\":{\"984\":1}}],[\"堆内存是我们用户手动开辟\",{\"1\":{\"1040\":1}}],[\"堆内存\",{\"1\":{\"675\":1}}],[\"堆对象数组\",{\"1\":{\"459\":1}}],[\"堆对象\",{\"0\":{\"459\":1}}],[\"堆上new出来的派生类对象\",{\"0\":{\"948\":1}}],[\"堆上开辟常量\",{\"1\":{\"511\":1}}],[\"堆上\",{\"1\":{\"412\":1,\"414\":1}}],[\"堆和栈中间\",{\"1\":{\"281\":1}}],[\"堆区\",{\"1\":{\"267\":1}}],[\"堆栈\",{\"2\":{\"242\":1}}],[\"堆栈是一种具有一定规则的\",{\"1\":{\"232\":1}}],[\"堆地址是从低地址向高地址扩充\",{\"1\":{\"232\":1}}],[\"堆排序算法对这些元素的处理方法不止一种\",{\"1\":{\"196\":1}}],[\"堆排序的时间复杂度\",{\"1\":{\"195\":1}}],[\"堆排序对n个数进行heapify\",{\"1\":{\"195\":1}}],[\"堆排序\",{\"1\":{\"194\":1}}],[\"换成自己想设计的密码\",{\"1\":{\"1407\":1}}],[\"换源\",{\"0\":{\"1284\":1}}],[\"换一个支持hdmi接口的电脑\",{\"1\":{\"832\":1}}],[\"换句话说\",{\"1\":{\"228\":1,\"490\":1,\"599\":1}}],[\"换行符都是\",{\"1\":{\"17\":1}}],[\"语义清晰\",{\"1\":{\"802\":1}}],[\"语义以及标准库中的函数原型和功能\",{\"1\":{\"16\":1}}],[\"语句以\",{\"1\":{\"1772\":1}}],[\"语句和\",{\"1\":{\"1772\":1}}],[\"语句的时候\",{\"1\":{\"1717\":1}}],[\"语句级或事务级\",{\"1\":{\"1656\":1}}],[\"语句\",{\"1\":{\"1548\":3,\"1656\":1,\"1717\":1,\"1772\":1}}],[\"语句结束\",{\"1\":{\"1110\":1,\"1111\":1}}],[\"语句时\",{\"1\":{\"949\":1,\"1718\":1}}],[\"语句成功地处理了错误\",{\"1\":{\"599\":1}}],[\"语句就不会再被执行\",{\"1\":{\"599\":1}}],[\"语句块没有检测到异常\",{\"1\":{\"599\":1}}],[\"语句块有没有异常\",{\"1\":{\"599\":1}}],[\"语句区分开\",{\"1\":{\"463\":1}}],[\"语言中\",{\"0\":{\"494\":1},\"1\":{\"494\":1}}],[\"语言编译器和库\",{\"1\":{\"302\":1}}],[\"语言程序则可以使用在任意架构的处理器上\",{\"1\":{\"302\":1}}],[\"语言为基础\",{\"1\":{\"301\":1}}],[\"语言的\",{\"1\":{\"304\":1}}],[\"语言的主体完成\",{\"1\":{\"301\":1}}],[\"语言的编译器是用\",{\"1\":{\"300\":1}}],[\"语言的基础之上发展而来的\",{\"1\":{\"300\":1}}],[\"语言是在\",{\"1\":{\"300\":1}}],[\"语言\",{\"1\":{\"300\":4,\"301\":5}}],[\"语法上\",{\"1\":{\"901\":1}}],[\"语法错误是最容易发现\",{\"1\":{\"597\":1}}],[\"语法错误在编译和链接阶段就能发现\",{\"1\":{\"597\":1}}],[\"语法规则\",{\"1\":{\"362\":1}}],[\"语法\",{\"0\":{\"933\":1},\"1\":{\"227\":1,\"616\":1,\"1361\":1}}],[\"栈中元素个数\",{\"1\":{\"990\":1}}],[\"栈的top将容器底层的back代理了\",{\"1\":{\"989\":1}}],[\"栈的容量\",{\"1\":{\"224\":1}}],[\"栈\",{\"0\":{\"988\":1,\"990\":1,\"1923\":1}}],[\"栈是被限制的线性表\",{\"1\":{\"614\":1}}],[\"栈帧的开辟和回退过程\",{\"1\":{\"502\":1}}],[\"栈对象的创建需要哪些条件\",{\"1\":{\"717\":1}}],[\"栈对象\",{\"1\":{\"433\":1}}],[\"栈结构\",{\"1\":{\"428\":1}}],[\"栈上可以正常创建对象\",{\"1\":{\"717\":1}}],[\"栈上\",{\"1\":{\"411\":1,\"414\":1}}],[\"栈溢出\",{\"0\":{\"240\":1}}],[\"栈顶出栈\",{\"1\":{\"238\":1}}],[\"栈顶寄存器数值不断变小\",{\"1\":{\"233\":1}}],[\"栈减少4byte\",{\"1\":{\"233\":1}}],[\"栈扩大4byte\",{\"1\":{\"233\":1}}],[\"栈空间大小\",{\"0\":{\"239\":1}}],[\"栈空间是从高地址向低地址扩充\",{\"1\":{\"232\":1}}],[\"栈空间\",{\"0\":{\"232\":1},\"1\":{\"535\":1}}],[\"栈满了\",{\"1\":{\"224\":1}}],[\"递归结束的条件\",{\"1\":{\"220\":1}}],[\"递归\",{\"1\":{\"220\":1}}],[\"递减计数\",{\"1\":{\"214\":1}}],[\"依赖关系\",{\"1\":{\"1896\":1}}],[\"依赖undo\",{\"1\":{\"1680\":1}}],[\"依赖文件\",{\"1\":{\"1353\":1}}],[\"依然阻塞住了\",{\"1\":{\"1701\":1}}],[\"依然会发生锁冲突\",{\"1\":{\"1700\":1,\"1713\":1}}],[\"依然会受到umask的影响\",{\"1\":{\"1299\":1}}],[\"依然无法插入\",{\"1\":{\"1693\":1}}],[\"依然不能成功\",{\"1\":{\"1689\":1}}],[\"依然找不到空闲的内存块\",{\"1\":{\"1102\":1}}],[\"依然根据\",{\"1\":{\"136\":1}}],[\"依此规律重复下去\",{\"1\":{\"810\":1}}],[\"依次安装\",{\"1\":{\"1397\":1}}],[\"依次安排内存\",{\"1\":{\"552\":1}}],[\"依次执行下面的步骤\",{\"1\":{\"1015\":1}}],[\"依次释放内存\",{\"1\":{\"519\":1}}],[\"依次调用pa指向对象数组中每个对象的析构函数\",{\"1\":{\"519\":1}}],[\"依次选择\",{\"1\":{\"293\":1}}],[\"依次选择前n\",{\"1\":{\"217\":1}}],[\"特性用锁+mvcc\",{\"1\":{\"1677\":1}}],[\"特例化的语法\",{\"1\":{\"1188\":1}}],[\"特殊情况\",{\"1\":{\"1209\":2}}],[\"特殊的成员函数\",{\"0\":{\"438\":1}}],[\"特殊数据成员的初始化\",{\"0\":{\"431\":1}}],[\"特别体现在函数参数传递等场合中\",{\"1\":{\"922\":1}}],[\"特别是在一些复杂的场景或者涉及到c++和c混合编程的时候\",{\"1\":{\"578\":1}}],[\"特别是对于头文件与\",{\"1\":{\"435\":1}}],[\"特别注意索引调整\",{\"1\":{\"214\":1}}],[\"特点\",{\"0\":{\"354\":1,\"915\":1},\"1\":{\"100\":1,\"500\":1,\"815\":1,\"816\":1,\"818\":1,\"820\":1,\"823\":1,\"1007\":1,\"1267\":1,\"1331\":1}}],[\"反序列化后数据\",{\"1\":{\"1915\":2}}],[\"反序列化数据\",{\"1\":{\"1915\":1}}],[\"反序列化输出结果如下\",{\"1\":{\"1907\":1}}],[\"反序列化\",{\"1\":{\"1907\":1}}],[\"反应的索引类型不准\",{\"0\":{\"1600\":1}}],[\"反之\",{\"1\":{\"1267\":1}}],[\"反转它们之间的链表还需要遍历一次\",{\"1\":{\"802\":1}}],[\"反转后的链表\",{\"1\":{\"801\":1}}],[\"反转后半部分链表\",{\"1\":{\"756\":2}}],[\"反转后半部链表\",{\"0\":{\"756\":1}}],[\"反转链表的子区间\",{\"1\":{\"802\":1}}],[\"反转链表\",{\"0\":{\"777\":1,\"801\":1,\"803\":1},\"1\":{\"756\":1,\"777\":1,\"801\":1}}],[\"反转字符串\",{\"0\":{\"67\":1},\"1\":{\"67\":1}}],[\"反向迭代器的使用\",{\"1\":{\"1011\":1}}],[\"反向迭代器reverse\",{\"1\":{\"1011\":1}}],[\"反向迭代器\",{\"1\":{\"698\":1}}],[\"反向遍历输入数组\",{\"1\":{\"214\":1}}],[\"反汇编\",{\"1\":{\"234\":2,\"260\":1},\"2\":{\"230\":1}}],[\"反汇编二进制文件中的机器指令\",{\"1\":{\"227\":1}}],[\"反汇编小结\",{\"0\":{\"227\":1}}],[\"累积计数\",{\"1\":{\"214\":1}}],[\"累计和就是该元素要存放的位置\",{\"1\":{\"213\":1}}],[\"避免回表\",{\"1\":{\"1588\":1}}],[\"避免每次调用\",{\"1\":{\"848\":1}}],[\"避免了多个对象引起的复杂操作\",{\"1\":{\"837\":1}}],[\"避免了名字空间的污染\",{\"1\":{\"560\":1}}],[\"避免使用\",{\"1\":{\"756\":1}}],[\"避免野指针的出现\",{\"1\":{\"735\":1}}],[\"避免程序崩溃\",{\"1\":{\"599\":1}}],[\"避免除以\",{\"1\":{\"470\":1}}],[\"避免由宏引起的警告\",{\"1\":{\"276\":1}}],[\"避免不必要的操作\",{\"1\":{\"214\":1}}],[\"避免重复的第三个元素\",{\"1\":{\"133\":1}}],[\"避免重复的第二个元素\",{\"1\":{\"133\":1}}],[\"避免重复的第一个元素\",{\"1\":{\"133\":1,\"137\":1}}],[\"类内有申请的\",{\"0\":{\"949\":1}}],[\"类内部\",{\"1\":{\"912\":1}}],[\"类b继承了基类的ma\",{\"1\":{\"937\":1}}],[\"类之外\",{\"1\":{\"912\":1}}],[\"类图\",{\"0\":{\"866\":1}}],[\"类中包含纯虚函数\",{\"1\":{\"900\":1}}],[\"类中有一个获取实例的静态方法\",{\"1\":{\"841\":1}}],[\"类中的\",{\"1\":{\"695\":1}}],[\"类类型下将其混用\",{\"0\":{\"714\":1}}],[\"类类型的转化包括两种\",{\"1\":{\"608\":1}}],[\"类和类的关系\",{\"1\":{\"682\":1}}],[\"类和对象\",{\"0\":{\"444\":1,\"1927\":1},\"1\":{\"496\":1,\"673\":1},\"2\":{\"394\":1,\"403\":1,\"408\":1,\"417\":1,\"430\":1,\"437\":1,\"443\":1,\"452\":1,\"461\":1,\"472\":1,\"726\":1}}],[\"类appender是由category来加载的\",{\"1\":{\"1019\":1}}],[\"类a被虚继承了\",{\"1\":{\"937\":1}}],[\"类a\",{\"1\":{\"653\":1}}],[\"类比switch\",{\"1\":{\"599\":1}}],[\"类比合并2个链表\",{\"1\":{\"202\":1}}],[\"类用于字符串的处理\",{\"1\":{\"536\":1}}],[\"类对象也可以声明为const对象\",{\"1\":{\"454\":1}}],[\"类对象成员需要显示进行初始化\",{\"1\":{\"434\":1}}],[\"类对象成员\",{\"0\":{\"434\":1},\"1\":{\"434\":1}}],[\"类对象成员和静态成员\",{\"1\":{\"431\":1}}],[\"类就是数据类型\",{\"1\":{\"449\":1}}],[\"类的名字\",{\"1\":{\"958\":1}}],[\"类的前向声明\",{\"1\":{\"826\":1}}],[\"类的一个成员函数\",{\"1\":{\"597\":1}}],[\"类的定义分为两个部分\",{\"1\":{\"449\":1}}],[\"类的成员方法一经\",{\"1\":{\"392\":1}}],[\"类是对摩托车\",{\"1\":{\"449\":1}}],[\"类是对现实世界中相似事物的抽象\",{\"1\":{\"449\":1}}],[\"类\",{\"1\":{\"446\":1,\"447\":1,\"585\":1,\"882\":1,\"905\":1}}],[\"类名称的方式进行了\",{\"1\":{\"863\":1}}],[\"类名称的方式来生成对象\",{\"1\":{\"861\":1}}],[\"类名\",{\"1\":{\"395\":3,\"435\":2,\"449\":2,\"455\":1,\"457\":1,\"463\":1,\"721\":2,\"898\":1,\"912\":2}}],[\"类可以实例无数的对象\",{\"1\":{\"392\":1}}],[\"类模板时\",{\"1\":{\"1190\":1}}],[\"类模板在类外面定义成员函数时候需要注意\",{\"1\":{\"388\":1}}],[\"类模板的实例化就是\",{\"1\":{\"388\":1}}],[\"类模板\",{\"1\":{\"388\":2,\"883\":1},\"2\":{\"1192\":1}}],[\"类模板与模板类\",{\"0\":{\"388\":1}}],[\"类型总是占用\",{\"1\":{\"1424\":1}}],[\"类型提供的部分特例化\",{\"1\":{\"1188\":1}}],[\"类型提供的完全特例化版本\",{\"1\":{\"1188\":1}}],[\"类型完全是已知的\",{\"1\":{\"1186\":1}}],[\"类型转换\",{\"0\":{\"1593\":1}}],[\"类型转换函数\",{\"1\":{\"678\":1}}],[\"类型转换有c风格的\",{\"1\":{\"628\":1}}],[\"类型之间的转换\",{\"1\":{\"632\":1}}],[\"类型保持一致才可以进行合理的类型转换\",{\"1\":{\"630\":1}}],[\"类型对函数名字进行改编\",{\"1\":{\"571\":1,\"572\":1}}],[\"类型和安全检查不同\",{\"1\":{\"481\":1}}],[\"类型和地址等基本信息\",{\"1\":{\"248\":1}}],[\"类型参数t与非类型参数ksize\",{\"1\":{\"388\":1}}],[\"类型参数\",{\"1\":{\"371\":1,\"1194\":1,\"1197\":1}}],[\"类型的\",{\"1\":{\"1719\":1}}],[\"类型的意向锁\",{\"1\":{\"1719\":1}}],[\"类型的异常\",{\"1\":{\"601\":1}}],[\"类型的实例并初始化为一个匿名对象\",{\"1\":{\"530\":1}}],[\"类型的指针隐式转换成其他指针类型\",{\"1\":{\"527\":1}}],[\"类型的数据\",{\"1\":{\"490\":1}}],[\"类型的特例化版本\",{\"1\":{\"366\":1,\"368\":1}}],[\"类型的机器码\",{\"1\":{\"310\":1}}],[\"类型\",{\"1\":{\"340\":1,\"435\":2,\"440\":1,\"492\":1,\"612\":2,\"614\":1,\"616\":1,\"624\":1,\"692\":1,\"1475\":1,\"1552\":3,\"1849\":1,\"1859\":1,\"1875\":1}}],[\"类型配置到c++文件类型里\",{\"0\":{\"36\":1}}],[\"类似linux下的命令行一样\",{\"1\":{\"1410\":1}}],[\"类似windows的快捷方式\",{\"1\":{\"1268\":1}}],[\"类似scoped\",{\"1\":{\"1210\":1}}],[\"类似与c++\",{\"1\":{\"1080\":1}}],[\"类似于c++的namespace\",{\"1\":{\"1915\":1}}],[\"类似于c风格的强制类型转换\",{\"1\":{\"632\":1}}],[\"类似于我们c++中的map容器\",{\"1\":{\"1900\":1}}],[\"类似于线性表和栈的关系\",{\"1\":{\"614\":1}}],[\"类似\",{\"1\":{\"228\":1,\"777\":1}}],[\"再通过mycat插入id=3和id=4的数据\",{\"1\":{\"1892\":1}}],[\"再通过读写分离来提升数据库的负载能力\",{\"1\":{\"1779\":1}}],[\"再考虑水平拆分\",{\"1\":{\"1886\":1}}],[\"再也不被时间束缚\",{\"1\":{\"1869\":1}}],[\"再查看一下表和数据\",{\"1\":{\"1774\":1}}],[\"再把被修改数据的状态置为commit才算是实现了事务commit成功\",{\"1\":{\"1762\":1}}],[\"再把结果返回给用户\",{\"1\":{\"1745\":1}}],[\"再把两个⼤⼩为2的合并成4的\",{\"1\":{\"202\":1}}],[\"再把两个数组⼤⼩为1的合并成⼀个⼤⼩为2的\",{\"1\":{\"202\":1}}],[\"再根据行指针回表读取记录\",{\"1\":{\"1736\":1}}],[\"再到主键索引树上找相应的记录\",{\"1\":{\"1701\":1}}],[\"再到备用内存给用户分配size字节的时候\",{\"1\":{\"1102\":1}}],[\"再一次证明了innodb的行锁是加在索引项上的\",{\"1\":{\"1700\":1}}],[\"再获取id=8的共享锁和排它锁\",{\"1\":{\"1699\":1}}],[\"再举一个例子理解\",{\"1\":{\"1664\":1}}],[\"再继续切换\",{\"1\":{\"1556\":1}}],[\"再写where过滤条件\",{\"1\":{\"1537\":1}}],[\"再按照笛卡尔乘积方式处理\",{\"0\":{\"1499\":1}}],[\"再用\",{\"1\":{\"1360\":1}}],[\"再由mycat登录mysql\",{\"1\":{\"1802\":1}}],[\"再由\",{\"1\":{\"1315\":1}}],[\"再直接点击vscode里cmake的按钮即可将生成的所有中间文件都放入一个build目录中\",{\"1\":{\"1309\":1}}],[\"再处理muduocode里的子cmakelist\",{\"1\":{\"1309\":1}}],[\"再测试\",{\"1\":{\"1305\":1}}],[\"再遇到非数字或字符串结束时\",{\"1\":{\"1299\":1}}],[\"再使用ifconﬁg来检查是否设置成功\",{\"1\":{\"1278\":1,\"1279\":1}}],[\"再使⼦序列段间有序\",{\"1\":{\"202\":1}}],[\"再收到和发送一个连接请求后等待对方对连接请求的确认\",{\"1\":{\"1240\":1}}],[\"再发送连接请求后等待匹配的连接请求\",{\"1\":{\"1240\":1}}],[\"再谈mtx和lock\",{\"0\":{\"1224\":1}}],[\"再关注侧枝\",{\"1\":{\"1105\":1}}],[\"再次归还到连接池当中来维护\",{\"1\":{\"1865\":1}}],[\"再次查看binlog\",{\"1\":{\"1773\":1}}],[\"再次查看mysql的剩余依赖项\",{\"1\":{\"1405\":1}}],[\"再次select的时候新commit的数据也会出现在新生成的快照中\",{\"1\":{\"1660\":1}}],[\"再次执行\",{\"1\":{\"1296\":1}}],[\"再次分配出去\",{\"1\":{\"1105\":1}}],[\"再次分配的时候\",{\"1\":{\"1105\":1}}],[\"再次尝试一下正常向os申请空间\",{\"1\":{\"1102\":1}}],[\"再进入调用函数\",{\"1\":{\"1063\":1}}],[\"再析构pa\",{\"1\":{\"1056\":1}}],[\"再想继续添加元素deque就需要扩容\",{\"1\":{\"968\":1}}],[\"再添加20个元素的时候\",{\"1\":{\"966\":1}}],[\"再变为2\",{\"1\":{\"966\":1}}],[\"再在组内查询\",{\"1\":{\"1497\":1}}],[\"再在最上面添加一个vbptr\",{\"1\":{\"937\":1}}],[\"再在函数体中执行赋值操作\",{\"1\":{\"422\":1}}],[\"再走\",{\"1\":{\"802\":1}}],[\"再对其进行++运算符重载函数调用就崩溃了\",{\"1\":{\"742\":1}}],[\"再对数组类型正常使用\",{\"1\":{\"714\":1}}],[\"再对test\",{\"1\":{\"568\":1}}],[\"再调用基类的析构函数将基类部分析构\",{\"1\":{\"948\":1}}],[\"再调用派生类的构造函数\",{\"1\":{\"908\":1}}],[\"再调用派生类中\",{\"1\":{\"675\":1}}],[\"再调用clear会将虚函数的值清为0\",{\"1\":{\"908\":1}}],[\"再调用普通基类的析构函数\",{\"1\":{\"891\":1}}],[\"再调用operator\",{\"1\":{\"711\":1}}],[\"再\",{\"1\":{\"516\":2}}],[\"再释放\",{\"1\":{\"513\":1,\"708\":1}}],[\"再来看另一种情况\",{\"1\":{\"470\":1}}],[\"再将数据反序列化出来解析使用\",{\"1\":{\"1896\":1}}],[\"再将\",{\"1\":{\"1043\":1}}],[\"再将esp赋给ebp\",{\"1\":{\"908\":1}}],[\"再将整个数组内存释放\",{\"1\":{\"383\":1}}],[\"再将a的值压入堆栈\",{\"1\":{\"237\":1}}],[\"再从项目配置的头文件引用目录查找头文件\",{\"1\":{\"312\":1}}],[\"再执行如下命令重启mysql\",{\"1\":{\"1408\":1}}],[\"再执行运算符重载函数调用就崩溃了\",{\"1\":{\"743\":1}}],[\"再执行基类的析构函数\",{\"1\":{\"675\":1}}],[\"再执行派生类构造函数中初始化表达式的其他内容和构造函数体\",{\"1\":{\"651\":1}}],[\"再执行\",{\"1\":{\"277\":1}}],[\"再执行这个宏的话\",{\"1\":{\"273\":1}}],[\"再看一下\",{\"0\":{\"259\":1}}],[\"再出栈\",{\"1\":{\"234\":1}}],[\"再搜索name\",{\"1\":{\"59\":1}}],[\"之所以写成成员函数而不是全局函数\",{\"1\":{\"1848\":1,\"1859\":1,\"1875\":1}}],[\"之所以引入线程池\",{\"1\":{\"1753\":1}}],[\"之创建age键索引\",{\"1\":{\"1566\":1}}],[\"之前怎么和mysql通信\",{\"1\":{\"1791\":1}}],[\"之前\",{\"1\":{\"1736\":1}}],[\"之前的null\",{\"1\":{\"1194\":1}}],[\"之前申请的备用内存\",{\"1\":{\"1102\":1}}],[\"之前已经介绍了const在函数中的应用\",{\"1\":{\"440\":1}}],[\"之前冠以波浪号\",{\"1\":{\"425\":1}}],[\"之前会进行下述操作\",{\"1\":{\"235\":1}}],[\"之后不会再次展开\",{\"1\":{\"1357\":1}}],[\"之后还原esp的值\",{\"1\":{\"235\":1}}],[\"之后ebp的值会保持固定\",{\"1\":{\"235\":1}}],[\"之后会根据情况看是否保存某些特定的寄存器\",{\"1\":{\"235\":1}}],[\"之后让esp等于ebp\",{\"1\":{\"235\":1}}],[\"之后\",{\"1\":{\"202\":1,\"1378\":1}}],[\"之后在把这两个数组合并成⼀个有序的数组\",{\"1\":{\"202\":1}}],[\"之间误用\",{\"0\":{\"523\":1}}],[\"之间并不是这种简单的类型兼容关系\",{\"1\":{\"490\":1}}],[\"之间\",{\"1\":{\"147\":1,\"1656\":1}}],[\"希望在编译代码时\",{\"1\":{\"1318\":1}}],[\"希望使用它的本身的右值语义\",{\"1\":{\"1127\":1}}],[\"希望能对医学方向的同学和生物方面研究的同学提供些许帮助\",{\"1\":{\"3\":1}}],[\"希尔排序是插入排序\",{\"1\":{\"199\":1}}],[\"希尔排序\",{\"0\":{\"199\":1}}],[\"故我们在master上为slave创建账户的时候\",{\"1\":{\"1821\":1}}],[\"故long\",{\"1\":{\"1578\":1}}],[\"故可调用拷贝构造\",{\"1\":{\"1047\":1}}],[\"故在c++中推荐使用引用而非指针作为函数的参数\",{\"1\":{\"615\":1}}],[\"故在函数声明处加extern\",{\"1\":{\"568\":1}}],[\"故使用\",{\"1\":{\"470\":1}}],[\"故是不稳定的\",{\"1\":{\"196\":1}}],[\"故while\",{\"1\":{\"78\":1}}],[\"建库建表\",{\"1\":{\"1836\":1}}],[\"建表\",{\"1\":{\"1774\":1}}],[\"建立连接\",{\"1\":{\"1847\":1,\"1856\":1}}],[\"建立索引\",{\"0\":{\"1720\":1}}],[\"建立库文件和libmylib\",{\"1\":{\"1332\":1}}],[\"建立软链接\",{\"1\":{\"1305\":1}}],[\"建立映射关系\",{\"1\":{\"290\":1}}],[\"建议使用\",{\"1\":{\"1739\":1}}],[\"建议在导入前执行\",{\"1\":{\"1731\":1}}],[\"建议把源码都放在src目录下\",{\"1\":{\"1312\":1}}],[\"建议写在\",{\"1\":{\"802\":1}}],[\"建议放在所有\",{\"1\":{\"593\":1}}],[\"建议用g\",{\"1\":{\"0\":1}}],[\"建堆的时间复杂度为o\",{\"1\":{\"195\":1}}],[\"建堆\",{\"1\":{\"194\":2}}],[\"内连接的时候\",{\"1\":{\"1590\":1}}],[\"内连接之大表和小表\",{\"0\":{\"1590\":1}}],[\"内连接小表全扫描\",{\"1\":{\"1544\":1}}],[\"内连接inner\",{\"1\":{\"1537\":1}}],[\"内连接\",{\"0\":{\"1537\":1},\"1\":{\"1536\":1}}],[\"内置函数\",{\"0\":{\"1361\":1}}],[\"内置类型\",{\"1\":{\"497\":1}}],[\"内容格式显示大致如下\",{\"1\":{\"1776\":1}}],[\"内容如下\",{\"1\":{\"1318\":1}}],[\"内容修改成如下所示\",{\"1\":{\"1314\":1}}],[\"内\",{\"1\":{\"1102\":1,\"1864\":1}}],[\"内部静态变量的懒汉实现\",{\"1\":{\"850\":1}}],[\"内部类加静态数据成员形式\",{\"0\":{\"855\":1}}],[\"内部类\",{\"1\":{\"751\":1}}],[\"内的字符创建一个string对象\",{\"1\":{\"537\":1}}],[\"内联成员函数\",{\"1\":{\"876\":1}}],[\"内联能提高函数的执行效率\",{\"1\":{\"505\":1}}],[\"内联函数在\",{\"1\":{\"876\":1}}],[\"内联函数本就是为了减少函数调用的代价\",{\"1\":{\"876\":1}}],[\"内联函数一般都是一些小函数\",{\"1\":{\"504\":1,\"506\":1}}],[\"内联函数应该在头文件中定义\",{\"1\":{\"504\":1}}],[\"内联函数和带参数的宏定义\",{\"0\":{\"503\":1}}],[\"内联函数并不一定能够内联\",{\"1\":{\"502\":1}}],[\"内联函数如果内联成功\",{\"1\":{\"502\":1}}],[\"内联函数\",{\"1\":{\"501\":1}}],[\"内联函数是c++的增强特性之一\",{\"1\":{\"501\":1}}],[\"内联函数作为编译器优化手段的一种技术\",{\"1\":{\"500\":1}}],[\"内联\",{\"1\":{\"500\":1}}],[\"内核中由于不同架构的限制\",{\"1\":{\"276\":1}}],[\"内核函数运行时所依赖的栈空间\",{\"1\":{\"267\":1}}],[\"内核空间的线程\",{\"1\":{\"267\":1}}],[\"内核空间\",{\"1\":{\"267\":1}}],[\"内核会将此数据段都置0\",{\"1\":{\"267\":1}}],[\"内循环\",{\"1\":{\"217\":1}}],[\"内循环表示每轮循环需要比较的次数\",{\"1\":{\"188\":1}}],[\"内存上搜索25次\",{\"1\":{\"1623\":1}}],[\"内存上\",{\"1\":{\"1623\":1}}],[\"内存页面的整数倍\",{\"1\":{\"1622\":1}}],[\"内存布局等\",{\"1\":{\"1338\":1}}],[\"内存布局中\",{\"1\":{\"889\":1}}],[\"内存池中开辟\",{\"1\":{\"1099\":1}}],[\"内存池allocate分配过程\",{\"0\":{\"1096\":1}}],[\"内存池机制\",{\"1\":{\"1079\":1}}],[\"内存归还dealloacte\",{\"0\":{\"1093\":1}}],[\"内存队列\",{\"0\":{\"1020\":1},\"1\":{\"1019\":1}}],[\"内存不连续\",{\"1\":{\"973\":1}}],[\"内存开辟\",{\"1\":{\"964\":1}}],[\"内存的开辟释放通过空间配置器allocator实现\",{\"1\":{\"964\":1}}],[\"内存的每一个字节都有一个编号\",{\"1\":{\"308\":1}}],[\"内存分布\",{\"0\":{\"935\":1}}],[\"内存分配失败\",{\"1\":{\"597\":1}}],[\"内存分配\",{\"1\":{\"516\":2}}],[\"内存中开始部分\",{\"1\":{\"915\":1}}],[\"内存占用量大\",{\"1\":{\"815\":1}}],[\"内存占用较高\",{\"1\":{\"63\":1}}],[\"内存利用率高\",{\"1\":{\"815\":1}}],[\"内存是按page页面操作的\",{\"1\":{\"1623\":1}}],[\"内存是28字节\",{\"1\":{\"684\":1}}],[\"内存是连续的\",{\"1\":{\"100\":1,\"973\":2,\"974\":1}}],[\"内存泄漏\",{\"1\":{\"616\":1,\"1122\":1},\"2\":{\"1037\":1}}],[\"内存管理内置类型\",{\"1\":{\"524\":1}}],[\"内存管理接口\",{\"1\":{\"518\":1}}],[\"内存越界\",{\"0\":{\"531\":1},\"1\":{\"515\":1,\"531\":1}}],[\"内存溢出\",{\"0\":{\"531\":1},\"1\":{\"515\":1,\"531\":1}}],[\"内存对齐的三大规则\",{\"0\":{\"554\":1}}],[\"内存对齐\",{\"0\":{\"551\":1},\"1\":{\"439\":1},\"2\":{\"559\":1}}],[\"内存释放\",{\"1\":{\"385\":1,\"516\":2,\"964\":1}}],[\"内存大小\",{\"1\":{\"317\":1,\"326\":1}}],[\"内存地址只是一个编号\",{\"0\":{\"308\":1},\"1\":{\"308\":1}}],[\"内存地址及内存空间\",{\"0\":{\"307\":1}}],[\"内存\",{\"1\":{\"306\":1}}],[\"内存窗口对于后面我们调试程序及理解程序执行原理都至关重要\",{\"1\":{\"306\":1}}],[\"内存窗口\",{\"1\":{\"306\":1}}],[\"内存变化\",{\"1\":{\"305\":1}}],[\"内存控制块数据结构\",{\"1\":{\"286\":1}}],[\"内存空间如图4\",{\"1\":{\"284\":1}}],[\"内存空间如图2\",{\"1\":{\"283\":1}}],[\"内存空间的初始布局如图1所示\",{\"1\":{\"283\":1}}],[\"内存空间有没有区域划分\",{\"1\":{\"267\":1}}],[\"⽐较是相邻的两个元素⽐较\",{\"1\":{\"188\":1}}],[\"冒泡排序\",{\"0\":{\"188\":1}}],[\"队\",{\"0\":{\"1921\":1}}],[\"队头的连接没有超过\",{\"1\":{\"1849\":1,\"1859\":1}}],[\"队头出\",{\"1\":{\"968\":1}}],[\"队头不指向具体元素\",{\"1\":{\"751\":1}}],[\"队头元素\",{\"1\":{\"185\":1}}],[\"队尾出\",{\"1\":{\"968\":1}}],[\"队尾赋值\",{\"1\":{\"406\":1}}],[\"队尾入\",{\"1\":{\"406\":1}}],[\"队尾元素\",{\"1\":{\"185\":1}}],[\"队列中空闲连接时间超过maxidletime的就要被释放掉\",{\"1\":{\"1866\":1}}],[\"队列中元素个数\",{\"1\":{\"991\":1}}],[\"队列不为空\",{\"1\":{\"1849\":1,\"1859\":1,\"1875\":1}}],[\"队列的元素抽象\",{\"1\":{\"751\":1}}],[\"队列扩容的总大小\",{\"1\":{\"406\":1}}],[\"队列\",{\"0\":{\"988\":1,\"991\":1},\"2\":{\"184\":1}}],[\"队列为空\",{\"1\":{\"182\":1}}],[\"~logger\",{\"1\":{\"1032\":4}}],[\"~linkedlist\",{\"1\":{\"817\":2}}],[\"~line\",{\"1\":{\"434\":2,\"826\":2}}],[\"~vipvideositeproxy\",{\"1\":{\"830\":1}}],[\"~vector\",{\"1\":{\"355\":1,\"385\":1,\"704\":1,\"1127\":2}}],[\"~freevideositeproxy\",{\"1\":{\"830\":1}}],[\"~connection\",{\"1\":{\"1846\":1,\"1847\":1,\"1856\":2}}],[\"~connectionpool\",{\"1\":{\"1839\":2,\"1848\":1,\"1849\":1,\"1859\":1,\"1875\":2,\"1878\":3}}],[\"~computer\",{\"1\":{\"426\":3,\"439\":1}}],[\"~cmystring\",{\"1\":{\"1120\":6,\"1121\":4,\"1123\":2,\"1124\":4}}],[\"~csmartptr\",{\"1\":{\"1041\":2,\"1055\":1}}],[\"~circlelist\",{\"1\":{\"819\":1}}],[\"~c\",{\"1\":{\"688\":4}}],[\"~b\",{\"1\":{\"688\":4,\"1056\":4,\"1057\":4}}],[\"~base发现它为虚函数\",{\"1\":{\"948\":1}}],[\"~base\",{\"1\":{\"662\":4,\"667\":2,\"894\":2,\"948\":4,\"949\":2}}],[\"~doublelink\",{\"1\":{\"821\":1}}],[\"~derive\",{\"1\":{\"667\":4,\"948\":5}}],[\"~derived\",{\"1\":{\"662\":4,\"894\":2,\"949\":2}}],[\"~d\",{\"1\":{\"649\":2,\"650\":2,\"688\":4}}],[\"~myexception\",{\"1\":{\"606\":1}}],[\"~autoreleas\",{\"1\":{\"855\":1}}],[\"~autorelease\",{\"1\":{\"854\":2,\"855\":1}}],[\"~a\",{\"1\":{\"688\":4,\"1056\":4,\"1057\":4}}],[\"~aa\",{\"1\":{\"518\":2,\"521\":2}}],[\"~arrary\",{\"1\":{\"101\":1}}],[\"~point\",{\"1\":{\"426\":1,\"433\":3,\"434\":2,\"459\":2}}],[\"~single\",{\"1\":{\"850\":2}}],[\"~singleton\",{\"1\":{\"849\":1,\"851\":2,\"852\":1,\"854\":2,\"855\":2,\"856\":2,\"857\":2}}],[\"~singleinstance\",{\"1\":{\"848\":2}}],[\"~string\",{\"1\":{\"405\":1,\"548\":2,\"699\":1,\"735\":2,\"736\":1}}],[\"~stack\",{\"1\":{\"388\":2}}],[\"~seqstack\",{\"1\":{\"224\":1}}],[\"~threadpool\",{\"1\":{\"1151\":1}}],[\"~t\",{\"1\":{\"385\":1,\"516\":1,\"704\":1,\"1080\":1,\"1087\":1}}],[\"~test\",{\"1\":{\"382\":2,\"385\":2,\"517\":2,\"714\":2,\"1110\":2,\"1114\":6,\"1115\":2}}],[\"~\",{\"0\":{\"1135\":1},\"1\":{\"239\":2,\"812\":1,\"1015\":2,\"1090\":5,\"1096\":1,\"1132\":2,\"1133\":1,\"1271\":3,\"1282\":1,\"1287\":2,\"1290\":2,\"1291\":1,\"1305\":1,\"1774\":2,\"1775\":1,\"1836\":7,\"1878\":1}}],[\"~queue\",{\"1\":{\"185\":2,\"406\":1,\"751\":1}}],[\"说得直接一点\",{\"1\":{\"599\":1}}],[\"说明是间隙锁\",{\"1\":{\"1719\":1}}],[\"说明是记录锁\",{\"1\":{\"1719\":1}}],[\"说明是\",{\"1\":{\"1719\":1}}],[\"说明事务保证能够再次读取相同的数据而不会失败\",{\"1\":{\"1631\":1}}],[\"说明读取未提交的数据是不允许的\",{\"1\":{\"1631\":1}}],[\"说明在提交前事务a可以看到事务b的变化\",{\"1\":{\"1631\":1}}],[\"说明当前智能指针是最后使用这个资源的智能指针\",{\"1\":{\"1054\":1}}],[\"说明含有环\",{\"1\":{\"765\":1,\"768\":1}}],[\"说明链表中含有环\",{\"1\":{\"765\":1}}],[\"说明链表中没有环\",{\"1\":{\"765\":1}}],[\"说明变量的性质\",{\"1\":{\"574\":1}}],[\"说明str3的内容是不可以被修改的\",{\"1\":{\"535\":1}}],[\"说明系统没有可用内存\",{\"1\":{\"286\":1}}],[\"说明\",{\"1\":{\"182\":1,\"1356\":1}}],[\"说到去重\",{\"1\":{\"135\":1}}],[\"能直接在二级索引树上取的就直接取\",{\"1\":{\"1588\":1}}],[\"能唯一标识一条记录\",{\"1\":{\"1432\":1}}],[\"能运用在int类型上\",{\"1\":{\"1186\":1}}],[\"能复原val原本类型\",{\"1\":{\"1127\":1}}],[\"能保证资源的绝对释放\",{\"1\":{\"1060\":1}}],[\"能保证参数传递中不产生副本\",{\"1\":{\"617\":1}}],[\"能不能在堆上定义智能指针\",{\"1\":{\"1041\":1}}],[\"能不能由\",{\"1\":{\"174\":1}}],[\"能混用吗\",{\"0\":{\"517\":1}}],[\"能作用于const对象的成员函数除了和\",{\"1\":{\"454\":1}}],[\"能够减少\",{\"1\":{\"1736\":1}}],[\"能够和整数进行区别\",{\"1\":{\"1194\":1}}],[\"能够实现内存的自动释放\",{\"1\":{\"1041\":1}}],[\"能够从虚函数表中取出来派生类重写的show\",{\"1\":{\"908\":1}}],[\"能够把vga信号转成hdmi信号\",{\"1\":{\"832\":1}}],[\"能够混用\",{\"1\":{\"713\":1}}],[\"能够表示的有效数字为\",{\"1\":{\"340\":1}}],[\"能够识别的微指令\",{\"1\":{\"310\":1}}],[\"能看见\",{\"1\":{\"267\":1}}],[\"能找到p\",{\"1\":{\"178\":1}}],[\"记得加上括号\",{\"1\":{\"1470\":1}}],[\"记得重置p\",{\"1\":{\"819\":1}}],[\"记得这里有`\",{\"1\":{\"784\":1}}],[\"记得让p1往前走一位\",{\"1\":{\"762\":1}}],[\"记得修改属性\",{\"1\":{\"101\":1}}],[\"记录时间\",{\"1\":{\"1859\":1}}],[\"记录进入空闲状态后的起始存活时间\",{\"1\":{\"1846\":1,\"1859\":1}}],[\"记录连接所创建的connection连接的总数量\",{\"1\":{\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1}}],[\"记录运行过程中遇到的错误\",{\"1\":{\"1800\":1}}],[\"记录启动过程中遇到的错误\",{\"1\":{\"1800\":1}}],[\"记录了mycat启动过程中的错误\",{\"1\":{\"1805\":1,\"1806\":1}}],[\"记录了所有的\",{\"1\":{\"1772\":1}}],[\"记录了用户从中获取的哪一个元素的迭代器\",{\"1\":{\"747\":1}}],[\"记录数据库的详细内容\",{\"1\":{\"1772\":1}}],[\"记录mysql\",{\"1\":{\"1767\":1}}],[\"记录mysqld服务运行过程中出现的等\",{\"1\":{\"1767\":1}}],[\"记录\",{\"1\":{\"1740\":1}}],[\"记录本身\",{\"1\":{\"1686\":1}}],[\"记录锁+间隙锁\",{\"1\":{\"1717\":1}}],[\"记录锁+间隙锁可以防止删除操作而导致的幻读吗\",{\"0\":{\"1716\":1}}],[\"记录锁\",{\"1\":{\"1686\":1}}],[\"记录事务\",{\"1\":{\"1679\":1}}],[\"记录命令\",{\"1\":{\"1475\":1}}],[\"记录或元组\",{\"1\":{\"1451\":1}}],[\"记录当前的ip地址\",{\"1\":{\"1279\":1}}],[\"记录所有申请的堆空间大小\",{\"1\":{\"1102\":1}}],[\"记录内存块的分配状态\",{\"1\":{\"1082\":1}}],[\"记录完成后需要程序员自己从队列中取出每条日志\",{\"1\":{\"1020\":1}}],[\"记录反转后链表的头结点\",{\"1\":{\"777\":1}}],[\"记录在iterator\",{\"1\":{\"747\":1}}],[\"记录一下常用的反汇编指令方便查看\",{\"1\":{\"227\":1}}],[\"记录元素出现的次数\",{\"1\":{\"178\":1}}],[\"正在访问哪个表\",{\"1\":{\"1521\":1}}],[\"正在用\",{\"1\":{\"48\":1}}],[\"正确的删除方法\",{\"1\":{\"1272\":1}}],[\"正确\",{\"1\":{\"1251\":1}}],[\"正确写法\",{\"1\":{\"432\":1}}],[\"正常向os申请空间失败\",{\"1\":{\"1102\":1}}],[\"正常的\",{\"1\":{\"1102\":1}}],[\"正常析构\",{\"1\":{\"715\":1}}],[\"正常情况下\",{\"1\":{\"715\":1}}],[\"正向迭代器\",{\"1\":{\"698\":1}}],[\"正负数中长的数字\",{\"1\":{\"191\":1}}],[\"正好是\",{\"1\":{\"177\":1}}],[\"赎金信\",{\"0\":{\"174\":1},\"1\":{\"174\":1}}],[\"唯一标识\",{\"1\":{\"1610\":1}}],[\"唯一索引中\",{\"1\":{\"1618\":1}}],[\"唯一索引\",{\"1\":{\"1434\":1,\"1610\":1}}],[\"唯一键约束\",{\"0\":{\"1434\":1}}],[\"唯一单实例对象指针\",{\"1\":{\"848\":1,\"851\":1}}],[\"唯一一点区别在于\",{\"1\":{\"651\":1}}],[\"唯一影响的是所能表示的个数\",{\"1\":{\"308\":1}}],[\"唯一\",{\"1\":{\"169\":1}}],[\"提交一个事务\",{\"1\":{\"1640\":1}}],[\"提取结果\",{\"0\":{\"1377\":1}}],[\"提取子串\",{\"0\":{\"542\":1}}],[\"提前开辟pool\",{\"1\":{\"751\":1}}],[\"提高mysql数据库\",{\"1\":{\"1864\":1}}],[\"提高后台服务性能\",{\"1\":{\"1790\":1}}],[\"提高后端和\",{\"1\":{\"1781\":1}}],[\"提高并发能力\",{\"1\":{\"1724\":1}}],[\"提高查询的效率\",{\"1\":{\"1609\":1}}],[\"提高查询的速度\",{\"1\":{\"1608\":1}}],[\"提高运行效率\",{\"1\":{\"1327\":1}}],[\"提高了我们使用的效率\",{\"1\":{\"963\":1}}],[\"提高程序的可扩展性\",{\"1\":{\"882\":1}}],[\"提高程序的效率和减少不必要的开销\",{\"1\":{\"750\":1}}],[\"提高编译速度\",{\"1\":{\"826\":1}}],[\"提高传递的效率\",{\"1\":{\"617\":1}}],[\"提高代码复用性\",{\"1\":{\"448\":1}}],[\"提倡将其放在一个名称空间中\",{\"1\":{\"593\":1}}],[\"提倡已命名的\",{\"1\":{\"593\":1}}],[\"提供mysql\",{\"1\":{\"1864\":1}}],[\"提供与m1环境完全相同的服务\",{\"1\":{\"1791\":1}}],[\"提供的api\",{\"1\":{\"1790\":1}}],[\"提供的部分特例化\",{\"1\":{\"1188\":1}}],[\"提供一个与派生类\",{\"1\":{\"898\":1}}],[\"提供一个通过网络可以联系到你的方式\",{\"1\":{\"0\":1}}],[\"提供多个产品创建的抽象接口\",{\"1\":{\"867\":1}}],[\"提供了protobuf多种语言的实现\",{\"1\":{\"1913\":1}}],[\"提供了mvcc的非锁定读\",{\"1\":{\"1680\":1}}],[\"提供了输出各种日志级别的方法\",{\"1\":{\"1018\":1}}],[\"提供了一系列标准的异常\",{\"1\":{\"604\":1}}],[\"提供了异常\",{\"1\":{\"597\":1}}],[\"提供const\",{\"1\":{\"366\":1,\"368\":1}}],[\"提示一样\",{\"1\":{\"605\":1}}],[\"提示符下\",{\"1\":{\"261\":1}}],[\"提示\",{\"1\":{\"161\":1}}],[\"利用mutable成员变量名\",{\"1\":{\"1914\":1}}],[\"利用\",{\"0\":{\"1903\":1}}],[\"利用黑匣子\",{\"1\":{\"1338\":1}}],[\"利用的是智能指针的概念\",{\"1\":{\"1226\":1,\"1227\":1}}],[\"利用栈上的对象出作用域自动析构这个特点\",{\"1\":{\"1041\":1}}],[\"利用这一特性\",{\"1\":{\"853\":1}}],[\"利用全局变量得到堆中的第一个内存块的地址\",{\"1\":{\"286\":1}}],[\"利用了pc寄存器\",{\"1\":{\"238\":1}}],[\"利用set容器不能存储重复元素的特点\",{\"1\":{\"154\":1}}],[\"利用不能重复的特点\",{\"0\":{\"154\":1}}],[\"函数结束\",{\"1\":{\"1523\":1}}],[\"函数来检测\",{\"1\":{\"1299\":1}}],[\"函数来初始化函数对象\",{\"1\":{\"784\":1}}],[\"函数字符串转换成十进制\",{\"1\":{\"1299\":1}}],[\"函数声明时参数列表有\",{\"1\":{\"1063\":1}}],[\"函数声明可以有多次\",{\"1\":{\"476\":1}}],[\"函数地址就要记录在虚函数表中\",{\"1\":{\"875\":1}}],[\"函数对象使用在\",{\"1\":{\"1171\":1}}],[\"函数对象的缺点\",{\"1\":{\"1171\":1}}],[\"函数对象的升级版\",{\"1\":{\"1171\":1}}],[\"函数对象的包装\",{\"0\":{\"1166\":1},\"1\":{\"1166\":1}}],[\"函数对象类\",{\"1\":{\"1161\":1}}],[\"函数对象相比于函数指针\",{\"1\":{\"982\":1}}],[\"函数对象与函数指针\",{\"0\":{\"977\":1,\"978\":1}}],[\"函数对象\",{\"1\":{\"784\":1,\"978\":2,\"1007\":1,\"1146\":1,\"1161\":2,\"1180\":1,\"1183\":1,\"1195\":1}}],[\"函数类型在定义的时候\",{\"1\":{\"1188\":1}}],[\"函数类型\",{\"1\":{\"727\":1,\"1162\":1}}],[\"函数原型\",{\"1\":{\"721\":1}}],[\"函数中的形参就会被当成实参变量或对象的一个别名来使用\",{\"1\":{\"615\":1}}],[\"函数检测到下标越界会抛出一个异常\",{\"1\":{\"597\":1}}],[\"函数是在别处定义的\",{\"1\":{\"574\":1}}],[\"函数可以重用\",{\"1\":{\"500\":1}}],[\"函数指针类型\",{\"1\":{\"1162\":1}}],[\"函数指针来初始化函数对象\",{\"1\":{\"784\":1}}],[\"函数指针和结构体来模拟多态性\",{\"0\":{\"494\":1}}],[\"函数指针\",{\"0\":{\"493\":1},\"1\":{\"493\":2,\"497\":1,\"784\":1,\"1102\":1}}],[\"函数定义只能有一次\",{\"1\":{\"476\":1}}],[\"函数参数的类型有多种可能或者不确定\",{\"1\":{\"1158\":1}}],[\"函数参数传递过程中\",{\"1\":{\"1116\":1}}],[\"函数参数长度可变\",{\"1\":{\"1063\":1}}],[\"函数参数中的\",{\"0\":{\"399\":1}}],[\"函数参数包\",{\"0\":{\"377\":1}}],[\"函数体内所有对类数据成员的访问\",{\"1\":{\"392\":1}}],[\"函数体\",{\"1\":{\"362\":1,\"440\":1,\"616\":1,\"666\":1}}],[\"函数名字\",{\"1\":{\"1523\":1}}],[\"函数名字相同\",{\"1\":{\"359\":1}}],[\"函数名相同\",{\"1\":{\"692\":1}}],[\"函数名称必须相同\",{\"1\":{\"560\":1,\"563\":1}}],[\"函数名\",{\"1\":{\"362\":1,\"440\":1,\"616\":1,\"898\":1,\"912\":2,\"915\":1}}],[\"函数模板参数推演ty是左值cmystring\",{\"1\":{\"1127\":1}}],[\"函数模板的参数类型\",{\"0\":{\"371\":1}}],[\"函数模板不能偏特化\",{\"0\":{\"369\":1}}],[\"函数模板必须进行严格的\",{\"1\":{\"368\":1}}],[\"函数模板\",{\"0\":{\"362\":1,\"366\":1},\"1\":{\"883\":1}}],[\"函数模板与类模板\",{\"1\":{\"361\":1}}],[\"函数模板与模板函数\",{\"0\":{\"358\":1}}],[\"函数重载步骤\",{\"1\":{\"571\":1}}],[\"函数重载原理\",{\"1\":{\"571\":1}}],[\"函数重载一定要先处于同一作用域中\",{\"1\":{\"563\":1}}],[\"函数重载需要注意什么\",{\"0\":{\"563\":1}}],[\"函数重载是指在\",{\"1\":{\"560\":1}}],[\"函数重载\",{\"0\":{\"560\":1,\"884\":1},\"1\":{\"359\":1,\"564\":1,\"692\":2}}],[\"函数\",{\"0\":{\"1593\":1},\"1\":{\"310\":1,\"440\":1,\"500\":1,\"585\":1,\"594\":3,\"599\":1,\"695\":2,\"730\":1,\"913\":1,\"1228\":2}}],[\"函数执行结束后将返回满足参数要求的内存块首地址\",{\"1\":{\"286\":1}}],[\"函数运行或产生线程时\",{\"1\":{\"267\":1}}],[\"函数作为程序的入口点\",{\"1\":{\"255\":1}}],[\"函数的使用方法\",{\"1\":{\"1878\":1}}],[\"函数的最大读取大小是其\",{\"1\":{\"1878\":1}}],[\"函数的作用可以这么解释\",{\"1\":{\"1878\":1}}],[\"函数的作用就是用来读取一行数据的\",{\"1\":{\"1878\":2}}],[\"函数的详解\",{\"1\":{\"1878\":1}}],[\"函数的却使用了基类的参数的值\",{\"1\":{\"906\":1}}],[\"函数的异常抛出列表\",{\"1\":{\"608\":1}}],[\"函数的\",{\"1\":{\"560\":1}}],[\"函数的声明\",{\"1\":{\"476\":1,\"563\":1}}],[\"函数的名字与类名相同\",{\"1\":{\"420\":1}}],[\"函数的调用点\",{\"1\":{\"364\":1,\"365\":1,\"368\":1}}],[\"函数的代码并不在\",{\"1\":{\"310\":1}}],[\"函数的时候就可以将该内存块作为可分配块再次进行分配了\",{\"1\":{\"285\":1}}],[\"函数的时间复杂度应是o\",{\"1\":{\"76\":1}}],[\"函数的参数是会入栈\",{\"1\":{\"399\":1}}],[\"函数的参数\",{\"1\":{\"240\":1}}],[\"函数的栈底指针ebp压栈\",{\"1\":{\"238\":1}}],[\"函数调用根目录中的\",{\"1\":{\"1315\":1}}],[\"函数调用的过程\",{\"1\":{\"1063\":1}}],[\"函数调用\",{\"1\":{\"906\":1,\"1115\":1}}],[\"函数调用开销大\",{\"1\":{\"502\":1}}],[\"函数调用参数压栈\",{\"1\":{\"502\":1}}],[\"函数调用参数的压栈顺序\",{\"0\":{\"237\":1}}],[\"函数调用过程中\",{\"0\":{\"1115\":1}}],[\"函数调用过程也被称为函数的开销\",{\"1\":{\"500\":1}}],[\"函数调用过程\",{\"1\":{\"500\":1}}],[\"函数调用完成返回时\",{\"1\":{\"398\":1}}],[\"函数调用层次过深\",{\"1\":{\"240\":1}}],[\"函数调用第一步\",{\"1\":{\"238\":1}}],[\"函数调用指令\",{\"1\":{\"234\":1}}],[\"函数返回对象的时候\",{\"1\":{\"1116\":1}}],[\"函数返回的引用\",{\"1\":{\"621\":1}}],[\"函数返回的值等都是右值\",{\"1\":{\"621\":1}}],[\"函数返回类型是引用的前提\",{\"1\":{\"618\":1}}],[\"函数返回\",{\"1\":{\"152\":1}}],[\"存了关键字和对应的数据地址\",{\"1\":{\"1627\":1}}],[\"存管理\",{\"1\":{\"1079\":1}}],[\"存\",{\"1\":{\"1079\":1}}],[\"存储节点\",{\"1\":{\"1888\":1,\"1891\":1}}],[\"存储mysql连接的队列\",{\"1\":{\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"存储这一块的增删改查的并发的处理能力\",{\"1\":{\"1790\":1}}],[\"存储引擎\",{\"1\":{\"1623\":1,\"1881\":2}}],[\"存储是字符型\",{\"1\":{\"1593\":1}}],[\"存储过程\",{\"0\":{\"1523\":1},\"1\":{\"1437\":1}}],[\"存储函数\",{\"1\":{\"1437\":1}}],[\"存储线程处理函数\",{\"1\":{\"1151\":1}}],[\"存储类型为\",{\"1\":{\"1082\":1}}],[\"存储类型为指针的数组\",{\"1\":{\"493\":1}}],[\"存储的是具体的相应的sql语句\",{\"1\":{\"1758\":1}}],[\"存储的是一些事务id\",{\"1\":{\"1656\":1}}],[\"存储的是数据本身内容\",{\"0\":{\"1624\":1}}],[\"存储的是unordered\",{\"1\":{\"999\":1,\"1000\":1}}],[\"存储的键值对unordered\",{\"1\":{\"1000\":1}}],[\"存储的时候字符串类型\",{\"1\":{\"957\":1}}],[\"存储了下一个节点的地址\",{\"1\":{\"816\":1,\"818\":1}}],[\"存储在vftable中\",{\"1\":{\"875\":1}}],[\"存储在\",{\"1\":{\"392\":1}}],[\"存储另一个文件的路径\",{\"1\":{\"17\":1}}],[\"存放在mysql的配置文件\",{\"1\":{\"1776\":1}}],[\"存放在d盘根目录下\",{\"1\":{\"1026\":2}}],[\"存放在名字空间域中的全局实体只在本空间域内有效\",{\"1\":{\"583\":1}}],[\"存放的是地址\",{\"1\":{\"1681\":1}}],[\"存放的是一个地址\",{\"1\":{\"614\":1}}],[\"存放的rtti指针\",{\"1\":{\"933\":1}}],[\"存放的类型\",{\"0\":{\"585\":1}}],[\"存放的数据类型应该是常量指针类型const\",{\"1\":{\"490\":1}}],[\"存放进程控制块\",{\"1\":{\"267\":1}}],[\"存放初始化为0和未初始化的全局变量\",{\"1\":{\"267\":1}}],[\"存放已经初始化且初始化不为0的全局变量\",{\"1\":{\"267\":1}}],[\"存放指令\",{\"1\":{\"267\":1}}],[\"存放最小的数据\",{\"1\":{\"217\":1}}],[\"存在则删除\",{\"1\":{\"1507\":1}}],[\"存在则创建\",{\"1\":{\"1507\":1}}],[\"存在返回迭代器\",{\"1\":{\"999\":1}}],[\"存在问题\",{\"1\":{\"523\":1}}],[\"存在\",{\"1\":{\"267\":2}}],[\"存在重复元素\",{\"0\":{\"152\":1,\"158\":1,\"161\":1},\"1\":{\"152\":1,\"158\":1,\"161\":1}}],[\"来字符\",{\"1\":{\"1898\":1}}],[\"来查看主从同步的状态\",{\"1\":{\"1830\":1}}],[\"来查看查询缓存的设置\",{\"1\":{\"1750\":1}}],[\"来减少磁盘i\",{\"1\":{\"1748\":1}}],[\"来判定使用哪种排序算法\",{\"1\":{\"1736\":1}}],[\"来判定为什么效率低下\",{\"1\":{\"1573\":1,\"1776\":1}}],[\"来控制并发事务访问同一个记录时的行为就叫\",{\"1\":{\"1656\":1}}],[\"来控制实际对象的访问权限\",{\"1\":{\"830\":2}}],[\"来保证的\",{\"1\":{\"1645\":2}}],[\"来管理\",{\"1\":{\"1622\":1}}],[\"来解析这些内存值\",{\"1\":{\"1347\":1}}],[\"来解决\",{\"1\":{\"147\":1}}],[\"来删除它\",{\"1\":{\"1341\":1}}],[\"来影响库的搜索顺序\",{\"1\":{\"1335\":1}}],[\"来决定是否编译\",{\"1\":{\"1318\":1}}],[\"来生成\",{\"1\":{\"1315\":1}}],[\"来修改\",{\"1\":{\"1310\":1}}],[\"来自动调用互斥锁的lock和unlock方法\",{\"1\":{\"1219\":1}}],[\"来\",{\"1\":{\"1050\":1}}],[\"来看这个例子\",{\"1\":{\"989\":1}}],[\"来创建宝马灯\",{\"1\":{\"867\":1}}],[\"来访问真正委托类对象的freemovie方法\",{\"1\":{\"830\":2}}],[\"来到\",{\"1\":{\"802\":2}}],[\"来实现\",{\"1\":{\"791\":1}}],[\"来维护以及合并的链表\",{\"1\":{\"782\":1}}],[\"来指定函数可能会抛出任何类型的异常\",{\"1\":{\"607\":1}}],[\"来指定函数不会抛出任何异常或只会抛出特定类型的异常\",{\"1\":{\"607\":1}}],[\"来确保正确的链接规范\",{\"1\":{\"578\":2}}],[\"来结尾的字符数组\",{\"1\":{\"535\":1}}],[\"来调用析构\",{\"1\":{\"517\":1}}],[\"来区分空类\",{\"1\":{\"470\":1}}],[\"来标识函数所属的类\",{\"1\":{\"449\":1}}],[\"来标记栈的底部\",{\"1\":{\"233\":1}}],[\"来做同样的事情\",{\"1\":{\"277\":1}}],[\"来定义空宏\",{\"1\":{\"276\":1}}],[\"来定义宏\",{\"0\":{\"275\":1}}],[\"来模拟一个栈\",{\"1\":{\"182\":1}}],[\"来把链表一分为二\",{\"1\":{\"91\":1}}],[\"必然就出错\",{\"1\":{\"517\":1}}],[\"必然会形成⼀个循环\",{\"1\":{\"147\":1}}],[\"必须避免脏读\",{\"1\":{\"1724\":1}}],[\"必须先取得该表的ix锁\",{\"1\":{\"1673\":1}}],[\"必须先取得该表的is锁\",{\"1\":{\"1673\":1}}],[\"必须一一对应\",{\"1\":{\"1475\":1}}],[\"必须\",{\"1\":{\"1315\":1}}],[\"必须依赖一个对象void\",{\"1\":{\"1167\":1}}],[\"必须发生动态绑定\",{\"1\":{\"948\":1}}],[\"必须将一半的人投入海中\",{\"1\":{\"811\":1}}],[\"必须将基类构造函数放在派生类构造函数的\",{\"1\":{\"673\":1}}],[\"必须遵守以下规则\",{\"1\":{\"616\":1}}],[\"必须对引用进行初始化\",{\"1\":{\"612\":1}}],[\"必须要在派生类构造函数的初始化列表中显示调用基类的有参构造函数\",{\"1\":{\"671\":1}}],[\"必须要有内存回收的机制\",{\"1\":{\"618\":1}}],[\"必须要设计出不同名的函数\",{\"1\":{\"560\":1}}],[\"必须要知道所有实现之后才能正常编译\",{\"1\":{\"476\":1}}],[\"必须能够找到\",{\"1\":{\"504\":1}}],[\"必须与函数定义体放在一起才能使函数成为内联\",{\"1\":{\"504\":1}}],[\"必须回收其资源\",{\"1\":{\"426\":1}}],[\"必须在\",{\"1\":{\"1155\":1}}],[\"必须在程序运行时完成选择\",{\"1\":{\"883\":1}}],[\"必须在定义的时候进行初始化\",{\"1\":{\"497\":1}}],[\"必须在类的外部定义和初始化静态数据成员\",{\"1\":{\"435\":1}}],[\"必须在初始化列表中进行\",{\"1\":{\"432\":1}}],[\"必须在初始化列表中进行初始化的情况有哪些\",{\"0\":{\"423\":1},\"1\":{\"673\":2}}],[\"必须在构造函数初始化列表中对其进行初始化\",{\"1\":{\"423\":1}}],[\"必须初始化列表初始化\",{\"1\":{\"423\":1}}],[\"必须唯一\",{\"1\":{\"377\":1}}],[\"必须为它的局部变量分配空间\",{\"1\":{\"235\":1}}],[\"必须得有一级标题才能计数\",{\"1\":{\"51\":1}}],[\"⼀般加override可以确保是重写⽗类的函数\",{\"1\":{\"693\":1}}],[\"⼀个数变化\",{\"1\":{\"147\":1}}],[\"⼀直在\",{\"1\":{\"147\":1,\"149\":1}}],[\"鸽巢原理\",{\"1\":{\"147\":1}}],[\"选定一个库使用\",{\"1\":{\"1507\":1}}],[\"选课关系表为selectcourse\",{\"1\":{\"1461\":1}}],[\"选数据类型两个原则\",{\"0\":{\"1423\":1}}],[\"选取适当的数据类型\",{\"0\":{\"1422\":1}}],[\"选项告诉链接器优先链接静态库\",{\"1\":{\"1335\":1}}],[\"选项来指定库名\",{\"1\":{\"1335\":1}}],[\"选项来添加库文件的搜索路径\",{\"1\":{\"1335\":1}}],[\"选项来分别指示链接器优先链接到静态库或动态库\",{\"1\":{\"1335\":1}}],[\"选项编译的源文件在引用函数头文件时\",{\"1\":{\"1333\":1}}],[\"选项用于进行名称修饰\",{\"1\":{\"516\":1}}],[\"选项\",{\"1\":{\"309\":1,\"1261\":1}}],[\"选择索引\",{\"1\":{\"1881\":1}}],[\"选择合理的事务大小\",{\"1\":{\"1724\":1}}],[\"选择哪种数据结构构建索引\",{\"1\":{\"1602\":1}}],[\"选择数据库\",{\"1\":{\"1506\":1}}],[\"选择ubuntu\",{\"1\":{\"1395\":1}}],[\"选择远程主机配置\",{\"1\":{\"1306\":1}}],[\"选择manual\",{\"1\":{\"1278\":1}}],[\"选择一个合适的静态ip\",{\"1\":{\"1278\":1}}],[\"选择产生不同的对象\",{\"1\":{\"864\":1}}],[\"选择窗口\",{\"1\":{\"306\":1}}],[\"选择排序\",{\"0\":{\"217\":1}}],[\"选择使用\",{\"1\":{\"66\":1}}],[\"选⼀个更⼤的最⼤\",{\"1\":{\"147\":1}}],[\"简化我们对日志的代码设置\",{\"1\":{\"1017\":1}}],[\"简化程序\",{\"1\":{\"359\":1}}],[\"简称mysql协议\",{\"1\":{\"1790\":1}}],[\"简称es\",{\"1\":{\"1610\":1}}],[\"简称\",{\"1\":{\"300\":2,\"526\":1,\"1333\":1}}],[\"简洁和清晰的层次结构使得\",{\"1\":{\"1896\":1}}],[\"简洁\",{\"1\":{\"248\":1}}],[\"简单查询\",{\"1\":{\"1521\":1}}],[\"简单对比下\",{\"1\":{\"998\":1}}],[\"简单使用一下\",{\"1\":{\"990\":1,\"991\":1,\"992\":1}}],[\"简单虚继承内存分布\",{\"0\":{\"937\":1}}],[\"简单来说就是各种锁机制和mvcc多版本并发控制\",{\"1\":{\"1711\":1}}],[\"简单来说\",{\"1\":{\"914\":1}}],[\"简单工厂\",{\"0\":{\"860\":1,\"861\":1,\"868\":1},\"1\":{\"861\":1}}],[\"简单问题不要只回答定义\",{\"1\":{\"502\":1}}],[\"简单版\",{\"0\":{\"355\":1}}],[\"简单\",{\"0\":{\"220\":1}}],[\"简单证明\",{\"1\":{\"147\":1}}],[\"简历\",{\"0\":{\"0\":1}}],[\"▪\",{\"1\":{\"147\":2}}],[\"死锁出现的场景如下\",{\"1\":{\"1707\":1}}],[\"死锁场景以及解决办法\",{\"0\":{\"1707\":1}}],[\"死锁问题一般都是我们自己的应用造成的\",{\"1\":{\"1706\":1}}],[\"死锁\",{\"0\":{\"1705\":1}}],[\"死循环\",{\"1\":{\"1102\":1}}],[\"死的⽅式有两种\",{\"1\":{\"147\":1}}],[\"死死地咬着文本不放\",{\"1\":{\"48\":1}}],[\"题目四\",{\"0\":{\"908\":1}}],[\"题目三\",{\"0\":{\"907\":1}}],[\"题目二\",{\"0\":{\"906\":1}}],[\"题目一\",{\"0\":{\"905\":1}}],[\"题目表述\",{\"1\":{\"762\":1}}],[\"题目描述\",{\"1\":{\"67\":1,\"70\":1,\"73\":1,\"76\":1,\"81\":1,\"84\":1,\"87\":1,\"152\":1,\"754\":1,\"759\":1,\"768\":1,\"771\":1,\"774\":1,\"777\":1,\"780\":1,\"790\":1,\"798\":1}}],[\"题⽬告诉我们\",{\"1\":{\"147\":1}}],[\"分隔\",{\"1\":{\"1899\":2}}],[\"分隔链表\",{\"0\":{\"795\":1},\"1\":{\"795\":1}}],[\"分库伴随着分表\",{\"1\":{\"1888\":1}}],[\"分库分表可以和主从复制同时进行\",{\"1\":{\"1890\":1}}],[\"分库分表和读写分离可以共同进行\",{\"1\":{\"1887\":1}}],[\"分库分表的原则应该是先考虑垂直拆分\",{\"1\":{\"1886\":1}}],[\"分库分表实践\",{\"0\":{\"1884\":1}}],[\"分库分表信息等\",{\"1\":{\"1803\":1}}],[\"分库分表都是需要依赖数据库中间件\",{\"1\":{\"1791\":1}}],[\"分担了原来单机的压力\",{\"1\":{\"1888\":1}}],[\"分散在不同的节点上\",{\"1\":{\"1626\":1}}],[\"分页查询中\",{\"1\":{\"1524\":1}}],[\"分页查询\",{\"0\":{\"1516\":1}}],[\"分组group\",{\"0\":{\"1526\":1}}],[\"分组查询\",{\"0\":{\"1497\":1}}],[\"分组的深度为o\",{\"1\":{\"202\":1}}],[\"分治合并\",{\"0\":{\"783\":1}}],[\"分治思想\",{\"0\":{\"781\":1},\"2\":{\"786\":1}}],[\"分为全局函数友元和成员函数友元\",{\"1\":{\"722\":1}}],[\"分开可以编译\",{\"1\":{\"363\":1}}],[\"分别在\",{\"0\":{\"1315\":1}}],[\"分别为\",{\"1\":{\"538\":1}}],[\"分别是主键索引和\",{\"1\":{\"1720\":1}}],[\"分别是元素类型\",{\"1\":{\"1183\":1}}],[\"分别是语法错误\",{\"1\":{\"597\":1}}],[\"分别是using编译指令\",{\"1\":{\"587\":1}}],[\"分别是\",{\"1\":{\"528\":1,\"657\":1,\"1719\":1}}],[\"分别存放\",{\"1\":{\"339\":1}}],[\"分别由2个系统调用完成\",{\"1\":{\"281\":1}}],[\"分别放形参a\",{\"1\":{\"234\":1}}],[\"分块\",{\"0\":{\"271\":1}}],[\"分配成功之后\",{\"1\":{\"1102\":1}}],[\"分配\",{\"1\":{\"1102\":1}}],[\"分配内存池\",{\"0\":{\"1099\":1}}],[\"分配字节\",{\"1\":{\"751\":1}}],[\"分配一个物理页\",{\"1\":{\"290\":1}}],[\"分配虚拟内存的细节\",{\"0\":{\"285\":1}}],[\"分配物理内存\",{\"1\":{\"263\":1}}],[\"分配空间的\",{\"1\":{\"252\":1}}],[\"分析事务1获取行x锁和事务2获取表s锁\",{\"1\":{\"1673\":1}}],[\"分析下面打印什么\",{\"0\":{\"1124\":1}}],[\"分析这段代码构造函数和析构函数的调用顺序\",{\"0\":{\"1066\":1}}],[\"分析一下2\",{\"1\":{\"908\":1}}],[\"分析一下1\",{\"1\":{\"908\":1}}],[\"分析一下\",{\"1\":{\"905\":1,\"906\":1,\"907\":1}}],[\"分析编译错误\",{\"1\":{\"310\":1}}],[\"分析可执行文件的elf头\",{\"0\":{\"258\":1}}],[\"分析main\",{\"0\":{\"251\":1,\"253\":1}}],[\"分析\",{\"0\":{\"147\":1,\"162\":1,\"715\":1}}],[\"分号后面的是注释\",{\"1\":{\"30\":1}}],[\"次循环把第\",{\"1\":{\"782\":1}}],[\"次之后\",{\"1\":{\"147\":1}}],[\"次\",{\"1\":{\"143\":1,\"802\":1}}],[\"只保留初始的initsize个连接就可以了\",{\"1\":{\"1866\":1}}],[\"只生成一次数据快照\",{\"0\":{\"1664\":1},\"1\":{\"1664\":1}}],[\"只支持表锁\",{\"1\":{\"1706\":1}}],[\"只支持char\",{\"1\":{\"1610\":1}}],[\"只支持vga接口\",{\"1\":{\"832\":1}}],[\"只用cid不会使用到多列索引\",{\"1\":{\"1610\":1}}],[\"只用uid或者uid+cid都可以用到多列索引\",{\"1\":{\"1610\":1}}],[\"只用写一套代码实现逻辑\",{\"1\":{\"363\":1}}],[\"只扫1行\",{\"1\":{\"1521\":1}}],[\"只筛选匹配项\",{\"0\":{\"1501\":1}}],[\"只进行预处理\",{\"1\":{\"1330\":2}}],[\"只给出返回值和参数列表即可\",{\"1\":{\"1162\":1}}],[\"只给数组开辟空间\",{\"1\":{\"1127\":1}}],[\"只给容器底层开辟指定大小空间并不添加新的元素\",{\"1\":{\"965\":1,\"966\":1}}],[\"只管理不大于128字节的小块内存分配\",{\"1\":{\"1079\":1}}],[\"只让一个智能指针管理资源\",{\"1\":{\"1047\":1}}],[\"只剩最后一个结点\",{\"1\":{\"810\":1}}],[\"只删除第一个偶数\",{\"1\":{\"742\":1,\"747\":2}}],[\"只将test\",{\"1\":{\"715\":1}}],[\"只拷贝值\",{\"1\":{\"662\":1}}],[\"只拷贝指针地址的方式\",{\"1\":{\"397\":1}}],[\"只需简单的将函数声明改成\",{\"1\":{\"637\":1}}],[\"只需要保持初始连接量initsize个连接就可以了\",{\"1\":{\"1865\":1}}],[\"只需要检查整表是否被加上ix或is锁即可\",{\"1\":{\"1673\":1}}],[\"只需要包含函数的声明头文件\",{\"1\":{\"1333\":1}}],[\"只需要使用\",{\"1\":{\"1252\":1}}],[\"只需要传入一个实参\",{\"1\":{\"1008\":2}}],[\"只需要传入内存的即可\",{\"1\":{\"708\":1}}],[\"只需要传入内存的起始地址即可\",{\"1\":{\"513\":1}}],[\"只需要在调用时\",{\"1\":{\"652\":1}}],[\"只需要析构\",{\"1\":{\"385\":1}}],[\"只需要安装缺少的库即可\",{\"1\":{\"234\":1}}],[\"只会抛出\",{\"1\":{\"607\":1}}],[\"只会在该文件里起作用\",{\"1\":{\"293\":1}}],[\"只不过\",{\"1\":{\"1781\":1}}],[\"只不过装饰器会对装饰的对象进行功能的扩展\",{\"1\":{\"831\":1}}],[\"只不过逻辑上的用法不同而已\",{\"1\":{\"614\":1}}],[\"只不过使用的异常类\",{\"1\":{\"605\":1}}],[\"只不过是编译器替你完成这种拷贝罢了\",{\"1\":{\"504\":1}}],[\"只写函数声明\",{\"1\":{\"574\":1}}],[\"只在release版本可用\",{\"1\":{\"502\":1}}],[\"只能本地连接\",{\"1\":{\"1799\":1}}],[\"只能串行进行\",{\"1\":{\"1700\":1,\"1713\":1}}],[\"只能部分解决幻读\",{\"0\":{\"1665\":1}}],[\"只能逐一加载每一个磁盘块\",{\"1\":{\"1621\":1}}],[\"只能进行等值查找\",{\"1\":{\"1604\":1}}],[\"只能往上加\",{\"1\":{\"1481\":1}}],[\"只能联想表和列的名字\",{\"1\":{\"1410\":1}}],[\"只能使用在语句中\",{\"1\":{\"1154\":1}}],[\"只能用在简单的加锁解锁的临界区代码中\",{\"1\":{\"1226\":1}}],[\"只能用于二元函数对象\",{\"1\":{\"1146\":1}}],[\"只能用左值引用来引用它\",{\"1\":{\"622\":1}}],[\"只能直接走人\",{\"1\":{\"1054\":1}}],[\"只能读而不能修改\",{\"1\":{\"1011\":1}}],[\"只能读而不能写\",{\"1\":{\"1011\":1}}],[\"只能运行时才能知道\",{\"1\":{\"959\":1}}],[\"只能从头节点开始逐节点遍历\",{\"1\":{\"815\":1}}],[\"只能对已有的c++运算符进行重载\",{\"1\":{\"728\":1}}],[\"只能创建栈对象\",{\"0\":{\"717\":1}}],[\"只能访问基类的部分\",{\"1\":{\"678\":1}}],[\"只能向左匹配参数\",{\"1\":{\"640\":1}}],[\"只能在这些文件的都声明变量\",{\"1\":{\"576\":1}}],[\"只能在类内部访问\",{\"1\":{\"449\":1}}],[\"只能修改数组值\",{\"1\":{\"535\":1}}],[\"只能改变运算对象的底层const\",{\"1\":{\"489\":1}}],[\"只能做加法\",{\"1\":{\"344\":1}}],[\"只隐藏对象的属性和实现细节\",{\"1\":{\"448\":1}}],[\"只读属\",{\"1\":{\"432\":1}}],[\"只读数据段\",{\"1\":{\"267\":1}}],[\"只是表中数据集合不同\",{\"1\":{\"1890\":1}}],[\"只是给id=7\",{\"1\":{\"1701\":1}}],[\"只是显示我们创建索引的时候加的标志\",{\"1\":{\"1600\":1}}],[\"只是这个加锁不在我们的软件层面\",{\"1\":{\"1232\":1}}],[\"只是占位的作用\",{\"1\":{\"1155\":1}}],[\"只是库中的实现\",{\"1\":{\"984\":1}}],[\"只是有的地方时间复杂度不同\",{\"1\":{\"970\":1}}],[\"只是为容器底层开辟空间\",{\"1\":{\"966\":1}}],[\"只是细节有所不同\",{\"1\":{\"560\":1}}],[\"只是要\",{\"1\":{\"388\":1}}],[\"只是比较两个字符串地址谁大谁小\",{\"1\":{\"368\":1}}],[\"只负责对象析构\",{\"1\":{\"385\":1,\"704\":1,\"1080\":1,\"1087\":1}}],[\"只负责内存释放\",{\"1\":{\"385\":1,\"704\":1,\"1080\":1,\"1087\":1}}],[\"只负责内存开辟\",{\"1\":{\"385\":1,\"704\":1,\"1080\":1,\"1087\":1}}],[\"只特殊化几个参数或者一定的参数范围\",{\"1\":{\"367\":1}}],[\"只有调试时才开启\",{\"1\":{\"1767\":1}}],[\"只有ss锁可以共存\",{\"1\":{\"1699\":1}}],[\"只有这些sql都执行成功才算业务成功了\",{\"1\":{\"1650\":1}}],[\"只有让一个用户的余额减少\",{\"1\":{\"1644\":1}}],[\"只有myisam支持\",{\"1\":{\"1610\":1}}],[\"只有执行了\",{\"1\":{\"1378\":1}}],[\"只有当事务中的所有操作都正常执行完了\",{\"1\":{\"1649\":1}}],[\"只有当前线程释放锁了\",{\"1\":{\"1229\":1}}],[\"只有当需要使用该实例时\",{\"1\":{\"843\":1}}],[\"只有从备用内存中分配出来\",{\"1\":{\"1099\":1}}],[\"只有在调试时才开启\",{\"1\":{\"1771\":1}}],[\"只有在执行这个命令后\",{\"1\":{\"1656\":1}}],[\"只有在运行时候才知道寄存器的地址\",{\"1\":{\"954\":1}}],[\"只有在某个函数执行过程中才是固定的\",{\"1\":{\"235\":1}}],[\"只有使用派生类指针此时才可以调用\",{\"1\":{\"907\":1}}],[\"只有使用指针才能到达目的\",{\"1\":{\"615\":1}}],[\"只有protect构造没有public构造的类\",{\"1\":{\"900\":1}}],[\"只有一个线程可以进来\",{\"1\":{\"1217\":1}}],[\"只有一张虚表\",{\"1\":{\"894\":1}}],[\"只有一级指针\",{\"1\":{\"490\":1}}],[\"只有第一个虚函数表中存放的是\",{\"1\":{\"889\":1}}],[\"只有判断指针为空的时候才加锁\",{\"1\":{\"848\":1}}],[\"只有5个\",{\"1\":{\"728\":1}}],[\"只有a类的成员\",{\"1\":{\"653\":1}}],[\"只有将转换后的类型值转换回到其原始类型\",{\"1\":{\"632\":1}}],[\"只有\",{\"1\":{\"597\":1}}],[\"只有type显示定义析构函数时\",{\"1\":{\"520\":1}}],[\"只有q不能被赋值\",{\"1\":{\"490\":1}}],[\"只有正整数和0\",{\"1\":{\"191\":1}}],[\"只要sql线程与i\",{\"1\":{\"1784\":1}}],[\"只要redo\",{\"1\":{\"1763\":1}}],[\"只要下一次mysql服务正常进行\",{\"1\":{\"1757\":1}}],[\"只要事务commit成功\",{\"1\":{\"1757\":1}}],[\"只要我们select的时候\",{\"1\":{\"1658\":1}}],[\"只要我们能确定循环是在\",{\"1\":{\"147\":1}}],[\"只要自己没改\",{\"1\":{\"1635\":1}}],[\"只要能区分开就行\",{\"1\":{\"1614\":1}}],[\"只要是是show\",{\"1\":{\"906\":1}}],[\"只要是标准的栈操作即可\",{\"1\":{\"182\":1}}],[\"只要类中含有一个纯虚函数\",{\"1\":{\"900\":1}}],[\"只要它们的参数列表不同就可以\",{\"1\":{\"560\":1}}],[\"只要那种架构的处理器具有对应\",{\"1\":{\"302\":1}}],[\"只要把\",{\"1\":{\"283\":1}}],[\"只要内核空间是共享的\",{\"1\":{\"267\":1}}],[\"只要前一位没有\",{\"1\":{\"135\":1}}],[\"只对应唯一的答案\",{\"1\":{\"140\":1}}],[\"该项目遵循核心基础设施倡议\",{\"1\":{\"1896\":1}}],[\"该项目是基于c++语言实现的连接池\",{\"1\":{\"1865\":1}}],[\"该线程no\",{\"1\":{\"1871\":1}}],[\"该文件被称作重做日志\",{\"1\":{\"1758\":1}}],[\"该文件包含了系统中所有共享库的列表\",{\"1\":{\"1332\":1}}],[\"该配置项是针对innodb存储引擎起作用的\",{\"1\":{\"1752\":1}}],[\"该方案适用于主键自增且连续的表\",{\"1\":{\"1740\":1}}],[\"该方法\",{\"1\":{\"1377\":1}}],[\"该方法用来初始化一个连接句柄\",{\"1\":{\"1373\":1}}],[\"该方法继承于vga\",{\"1\":{\"832\":1}}],[\"该操作可能会导致大量随机i\",{\"1\":{\"1736\":1}}],[\"该命令会重新生成\",{\"1\":{\"1332\":1}}],[\"该命令表示项目的名称是\",{\"1\":{\"1312\":1}}],[\"该layout定义了这个appender上日志的格式\",{\"1\":{\"1022\":1}}],[\"该日志被写入所有附加到此category的appender\",{\"1\":{\"1022\":1}}],[\"该字符串队列使用了stl中的两个容器\",{\"1\":{\"1020\":1}}],[\"该字符串的目的是提供有关异常的一些文本信息\",{\"1\":{\"605\":1}}],[\"该指针的类型\",{\"1\":{\"953\":1}}],[\"该指针指向进程的堆顶\",{\"1\":{\"286\":1}}],[\"该指针指向进程的堆底\",{\"1\":{\"286\":1}}],[\"该虚函数指针指向了一张虚函数表\",{\"1\":{\"914\":1}}],[\"该类便为抽象类\",{\"1\":{\"900\":1}}],[\"该类中有一个大数组\",{\"1\":{\"240\":1}}],[\"该链表有两个中间结点\",{\"1\":{\"756\":2}}],[\"该运算符可以用来处理无关类型之间的转换\",{\"1\":{\"632\":1}}],[\"该运算符主要用于基类和派生类间的转换\",{\"1\":{\"631\":1}}],[\"该运算符\",{\"1\":{\"630\":1}}],[\"该异常可以通过方法抛出\",{\"1\":{\"604\":1}}],[\"该异常可以通过\",{\"1\":{\"604\":3}}],[\"该异常是所有标准\",{\"1\":{\"604\":1}}],[\"该函数又调用了另外的一个函数\",{\"1\":{\"601\":1}}],[\"该空间中的实体\",{\"1\":{\"591\":1}}],[\"该实体是不可见的\",{\"1\":{\"586\":1}}],[\"该对象包含count个ch字符\",{\"1\":{\"537\":1}}],[\"该语句在头文件中\",{\"1\":{\"504\":2}}],[\"该语句时\",{\"1\":{\"463\":2}}],[\"该成员已经存在\",{\"1\":{\"435\":1}}],[\"该数据成员便具有\",{\"1\":{\"432\":1}}],[\"该数组已按\",{\"1\":{\"140\":1}}],[\"该参数表明要申请多大的内存空间\",{\"1\":{\"286\":1}}],[\"该块的大小\",{\"1\":{\"286\":1}}],[\"该算法是采⽤分治法\",{\"1\":{\"202\":1}}],[\"该两个值的差小于某一阈值\",{\"1\":{\"162\":1}}],[\"该换电脑了\",{\"1\":{\"66\":1}}],[\"跳过该个错误\",{\"1\":{\"1830\":1}}],[\"跳过函数调用\",{\"1\":{\"1340\":1}}],[\"跳过前面的空白字符\",{\"1\":{\"1299\":1}}],[\"跳过重复的第二个元素\",{\"1\":{\"137\":1}}],[\"跳出循环体\",{\"1\":{\"277\":1}}],[\"跳转的按钮\",{\"1\":{\"59\":1}}],[\"跳转高度\",{\"1\":{\"59\":2}}],[\"跳转文档后\",{\"1\":{\"59\":1}}],[\"跳转到修改下划线\",{\"1\":{\"56\":1}}],[\"思考\",{\"1\":{\"717\":1,\"1041\":1}}],[\"思想\",{\"0\":{\"137\":1}}],[\"思路很简单\",{\"1\":{\"285\":1}}],[\"思路\",{\"0\":{\"154\":1},\"1\":{\"81\":1,\"87\":1,\"787\":1}}],[\"了解\",{\"0\":{\"1333\":1,\"1559\":1}}],[\"了解构造和析构的调用\",{\"1\":{\"1109\":1}}],[\"了解后不要纠结这里了\",{\"1\":{\"633\":1}}],[\"了解这个编译过程\",{\"1\":{\"310\":1}}],[\"了\",{\"0\":{\"277\":1},\"1\":{\"136\":1,\"454\":1,\"631\":1,\"695\":1,\"741\":1,\"1046\":1,\"1047\":1,\"1060\":1}}],[\"去处理相应的事件\",{\"1\":{\"871\":1}}],[\"去记录错误\",{\"1\":{\"598\":1}}],[\"去掉extern\",{\"1\":{\"569\":1}}],[\"去从堆里面动态申请出来一段内存给我们用\",{\"1\":{\"509\":1}}],[\"去运行\",{\"1\":{\"310\":1}}],[\"去完成right\",{\"1\":{\"136\":1}}],[\"去重查询\",{\"0\":{\"1495\":1}}],[\"去重成功\",{\"1\":{\"1001\":1}}],[\"去重复逻辑如果放在这里\",{\"1\":{\"136\":1}}],[\"去重\",{\"0\":{\"1512\":1},\"1\":{\"136\":2}}],[\"去重的逻辑多加了\",{\"1\":{\"136\":1}}],[\"去重操作\",{\"1\":{\"135\":1}}],[\"去重逻辑的思考🍔🍔🍔\",{\"0\":{\"134\":1}}],[\"去重版\",{\"1\":{\"110\":1}}],[\"即把表的数据按照某种规则\",{\"1\":{\"1886\":1}}],[\"即根据业务拆分成不同的库\",{\"1\":{\"1886\":1}}],[\"即重新开启主从同步\",{\"1\":{\"1830\":1}}],[\"即在master中创建一个账号\",{\"1\":{\"1821\":1}}],[\"即在构造函数或析构函数内\",{\"1\":{\"925\":1}}],[\"即windows上的mysql\",{\"1\":{\"1814\":1}}],[\"即mycat发送show\",{\"1\":{\"1803\":1}}],[\"即锁的粒度比较小\",{\"1\":{\"1706\":1}}],[\"即快照读\",{\"1\":{\"1677\":1}}],[\"即整表数据\",{\"1\":{\"1656\":1}}],[\"即不允许部分事务完成\",{\"1\":{\"1644\":1}}],[\"即不断向左收缩\",{\"1\":{\"96\":1}}],[\"即索引搜索涉及\",{\"1\":{\"1623\":1}}],[\"即影响所有正在访问当前mysql\",{\"1\":{\"1577\":1}}],[\"即先把表的连接写好\",{\"1\":{\"1537\":1}}],[\"即先使每个⼦序列有序\",{\"1\":{\"202\":1}}],[\"即原子特性\",{\"1\":{\"1460\":1}}],[\"即只有目标文件比依赖旧或者目标文件不存在\",{\"1\":{\"1354\":1}}],[\"即要到达不再路由表里面的网段的包都走0\",{\"1\":{\"1239\":1}}],[\"即硬件上实现的加锁操作\",{\"1\":{\"1232\":1}}],[\"即右值引用\",{\"1\":{\"1127\":1}}],[\"即修改了当前还未分配出去\",{\"1\":{\"1093\":1}}],[\"即将归还\",{\"1\":{\"1093\":1}}],[\"即freelist有16个元素\",{\"1\":{\"1082\":1}}],[\"即c++区别c的在于创建对象需要调用构造函数\",{\"1\":{\"1073\":1}}],[\"即esp指针\",{\"1\":{\"1063\":1}}],[\"即字符串容器std\",{\"1\":{\"1020\":1}}],[\"即数组与链表区别\",{\"1\":{\"974\":1}}],[\"即标准模板库\",{\"1\":{\"963\":1}}],[\"即编译期间指定了函数的调用\",{\"1\":{\"953\":1}}],[\"即编译阶段\",{\"1\":{\"630\":1}}],[\"即我们需要显式调用虚基类的构造函数来完成初始化\",{\"1\":{\"943\":1}}],[\"即我定义一个test\",{\"1\":{\"576\":1}}],[\"即覆盖关系\",{\"1\":{\"915\":1}}],[\"即虚函数会多vfptr指针\",{\"1\":{\"955\":1}}],[\"即虚函数能产生函数地址\",{\"1\":{\"875\":1}}],[\"即虚基类的构造函数只被执行一次\",{\"1\":{\"891\":1}}],[\"即通过代理类\",{\"1\":{\"830\":1}}],[\"即为失效的迭代器\",{\"1\":{\"747\":1}}],[\"即两个迭代器比较之前检查是否失效\",{\"1\":{\"747\":1}}],[\"即操作数\",{\"1\":{\"728\":1}}],[\"即从0x100释放\",{\"1\":{\"715\":1}}],[\"即从最顶上存储对象的数量的内存起始地址开始释放\",{\"1\":{\"517\":1}}],[\"即基类的构造函数均带有参数\",{\"1\":{\"672\":1}}],[\"即用在任意指针\",{\"1\":{\"632\":1}}],[\"即地址\",{\"1\":{\"625\":1}}],[\"即当函数执行完毕时\",{\"1\":{\"616\":1}}],[\"即当前函数没有catch\",{\"1\":{\"608\":1}}],[\"即形参变量只是实参变量的副本而已\",{\"1\":{\"615\":1}}],[\"即本层throw出的异常\",{\"1\":{\"603\":1}}],[\"即便缺少\",{\"1\":{\"578\":1}}],[\"即函数定义写在cpp文件中\",{\"1\":{\"570\":1}}],[\"即函数名\",{\"1\":{\"227\":1}}],[\"即访问数组中不存在的元素\",{\"1\":{\"531\":1}}],[\"即aa\",{\"1\":{\"520\":1}}],[\"即每个源文件里的定义必须是完全相同的\",{\"1\":{\"504\":1}}],[\"即对于这种简短的语句使用函数\",{\"1\":{\"500\":1}}],[\"即第一种\",{\"1\":{\"491\":1}}],[\"即指针的值\",{\"1\":{\"625\":1}}],[\"即指针常量\",{\"1\":{\"392\":1}}],[\"即指向int\",{\"1\":{\"490\":1}}],[\"即p所指向的内容\",{\"1\":{\"490\":1}}],[\"即有如下形式\",{\"1\":{\"449\":1}}],[\"即使没有主从复制\",{\"1\":{\"1781\":1}}],[\"即使没有相应的\",{\"1\":{\"1333\":1}}],[\"即使刷新过程中发生了错误\",{\"1\":{\"1762\":1}}],[\"即使它们还没有被刷新到磁盘上的数据文件中\",{\"1\":{\"1762\":1}}],[\"即使它是只读的或你没有写入权限\",{\"1\":{\"1410\":1}}],[\"即使中途有其他事务插入了一条数据\",{\"1\":{\"1717\":1}}],[\"即使sql中使用了索引\",{\"1\":{\"1713\":1}}],[\"即使数据库因为故障出错\",{\"1\":{\"1644\":1}}],[\"即使其他的事务把这个数据改了\",{\"1\":{\"1631\":1}}],[\"即使有缓存\",{\"1\":{\"1617\":1}}],[\"即使有异常\",{\"1\":{\"599\":1}}],[\"即使delete\",{\"1\":{\"1480\":1}}],[\"即使存在名为clean的文件或目录\",{\"1\":{\"1365\":1}}],[\"即使下载的文件是zip格式\",{\"1\":{\"1251\":1}}],[\"即使是使用\",{\"1\":{\"925\":1}}],[\"即使是void也不能有\",{\"1\":{\"420\":1}}],[\"即使在派生类中省略了virtual关键字\",{\"1\":{\"913\":1}}],[\"即使对象没有使用也会被创建\",{\"1\":{\"844\":1}}],[\"即使用就可以解决该问题\",{\"1\":{\"652\":1}}],[\"即使自定义的实体命名空间中的\",{\"1\":{\"594\":1}}],[\"即使\",{\"1\":{\"490\":1,\"599\":1}}],[\"即使不写\",{\"1\":{\"421\":1}}],[\"即使不加这个去重逻辑\",{\"1\":{\"136\":1}}],[\"即this指针的作用就是区分不同对象的\",{\"1\":{\"392\":1}}],[\"即模板函数\",{\"1\":{\"365\":1}}],[\"即支持\",{\"1\":{\"354\":1}}],[\"即0xcccccccc\",{\"1\":{\"422\":1}}],[\"即0\",{\"1\":{\"338\":1}}],[\"即可把mytest库的user表的数据导出到\",{\"1\":{\"1836\":1}}],[\"即可使用reserve预留空间\",{\"1\":{\"966\":1}}],[\"即可使函数称为内联声明函数\",{\"1\":{\"501\":1}}],[\"即可完成对象的创建操作\",{\"1\":{\"943\":1}}],[\"即可\",{\"1\":{\"337\":1}}],[\"即选有含意的英文单词\",{\"1\":{\"316\":1}}],[\"即如果函数这样写\",{\"1\":{\"240\":1}}],[\"即回到main函数栈底\",{\"1\":{\"234\":1}}],[\"即\",{\"1\":{\"147\":1,\"489\":1,\"625\":1,\"925\":1,\"956\":1,\"1050\":1,\"1424\":1,\"1537\":1,\"1617\":1}}],[\"很显然\",{\"1\":{\"1689\":1}}],[\"很可能引起死锁\",{\"1\":{\"1670\":1}}],[\"很浪费时间\",{\"1\":{\"1233\":1}}],[\"很容易增添球体类的多态性\",{\"1\":{\"882\":1}}],[\"很容易犯错\",{\"1\":{\"615\":1}}],[\"很明显\",{\"1\":{\"864\":1,\"1689\":1}}],[\"很麻烦\",{\"1\":{\"736\":1}}],[\"很多时候\",{\"1\":{\"943\":1}}],[\"很多时候会用到空宏\",{\"1\":{\"276\":1}}],[\"很多同学写本题的时候\",{\"1\":{\"136\":1}}],[\"很不方便\",{\"1\":{\"56\":1}}],[\"那是因为我们在master上配置的是允许从其他地址登录\",{\"1\":{\"1821\":1}}],[\"那上一次commit的数据一定要恢复回来\",{\"1\":{\"1757\":1}}],[\"那现在事务2获取不同行chenwei的记录的排它锁\",{\"1\":{\"1700\":1}}],[\"那只需要就够了\",{\"1\":{\"1694\":1}}],[\"那修改之前的数据怎么办\",{\"1\":{\"1681\":1}}],[\"那我怎么知道这1000万行哪些有行锁哪些没有行锁呢\",{\"1\":{\"1672\":1}}],[\"那我们看一下为什么是部分解决幻读\",{\"1\":{\"1665\":1}}],[\"那我们使用它\",{\"1\":{\"1569\":1}}],[\"那我们出错的可能性就会加大了不少\",{\"1\":{\"528\":1}}],[\"那我们就把\",{\"1\":{\"135\":1}}],[\"那还是获取的表锁\",{\"1\":{\"1669\":1}}],[\"那事务1插入age=20的数据能否成功呢\",{\"1\":{\"1689\":1}}],[\"那事务就没有提交\",{\"1\":{\"1650\":1}}],[\"那事务b读到的数据就不是数据库所存放的数据了\",{\"1\":{\"1639\":1}}],[\"那为什么myisam和innodb存储引擎用的是b+树索引\",{\"0\":{\"1602\":1}}],[\"那为什么需要这样做呢\",{\"1\":{\"943\":1}}],[\"那索引树上的数据就是按照addtime排好序的\",{\"1\":{\"1586\":1}}],[\"那直接写正确的ip即可\",{\"1\":{\"1828\":1}}],[\"那直接抛出异常\",{\"1\":{\"1102\":1}}],[\"那直接从备用内存或者使用malloc申请chunk块\",{\"1\":{\"1096\":1}}],[\"那将备用的内存尽可能多的分割出完整的size内存块\",{\"1\":{\"1102\":1}}],[\"那其实我们可以养成一个好习惯\",{\"1\":{\"795\":1}}],[\"那肯定是\",{\"1\":{\"765\":1}}],[\"那如何指向它的数组名\",{\"1\":{\"698\":1}}],[\"那在很多场合下就可以用引用代替指针\",{\"1\":{\"615\":1}}],[\"那一段连续的内存空间只能取一个别名吗\",{\"1\":{\"612\":1}}],[\"那种无自定义类型析构函数的类对象\",{\"1\":{\"524\":1}}],[\"那就需要加快\",{\"1\":{\"1736\":1}}],[\"那就会出现脏读\",{\"1\":{\"1712\":1}}],[\"那就会够\",{\"1\":{\"528\":1}}],[\"那就得先访问name的二级索引树\",{\"1\":{\"1569\":1}}],[\"那就使得\",{\"1\":{\"1096\":1}}],[\"那就很不划算了\",{\"1\":{\"615\":1}}],[\"那就是静态绑定\",{\"1\":{\"927\":1}}],[\"那就是\",{\"1\":{\"500\":1}}],[\"那就不是去推\",{\"1\":{\"284\":1}}],[\"那q可不可以修改❌\",{\"1\":{\"492\":1}}],[\"那这组数据就pass了\",{\"1\":{\"135\":1}}],[\"那么等待connectiontimeout时间如果还获取不到空闲的连接\",{\"1\":{\"1866\":1}}],[\"那么获取连接失败\",{\"1\":{\"1865\":1,\"1866\":1}}],[\"那么此时应用从连接池获取连接无法成功\",{\"1\":{\"1865\":1}}],[\"那么此时我们可以把表分成n个小表\",{\"1\":{\"1776\":1}}],[\"那么此时我们可以把表分成多个小表等\",{\"1\":{\"1573\":1}}],[\"那么新增加的这些连接资源就要被回收掉\",{\"1\":{\"1865\":1}}],[\"那么我们可以每七天备份一次\",{\"1\":{\"1775\":1}}],[\"那么我们自己实现一下它\",{\"1\":{\"709\":1}}],[\"那么如果您在10秒内无法登录\",{\"1\":{\"1754\":1}}],[\"那么如何处理这种问题呢\",{\"1\":{\"688\":1}}],[\"那么使用第二种优化之后的算法\",{\"1\":{\"1736\":1}}],[\"那么使用函数对象有什么好处呢\",{\"0\":{\"980\":1}}],[\"那么本事务如果再次执行上述语句\",{\"1\":{\"1686\":1}}],[\"那么innodb就自动生成主键列id\",{\"1\":{\"1681\":1}}],[\"那么innodb会根据在二级索引树上的索引值在构建一个哈希索引来加速搜索\",{\"1\":{\"1569\":1}}],[\"那么事务必须要回滚\",{\"1\":{\"1649\":1}}],[\"那么事务就要回退到最初的状态\",{\"1\":{\"1649\":1}}],[\"那么对于innodb来说\",{\"1\":{\"1557\":1}}],[\"那么对于模板来说\",{\"1\":{\"378\":1}}],[\"那么a为小表\",{\"1\":{\"1537\":1}}],[\"那么该如何优化\",{\"1\":{\"1539\":1}}],[\"那么该字段插入\",{\"1\":{\"1477\":1}}],[\"那么该数组就是有序的了\",{\"1\":{\"202\":1}}],[\"那么数据插入\",{\"1\":{\"1459\":1}}],[\"那么char所占的长度依然为10\",{\"1\":{\"1426\":1}}],[\"那么c++11\",{\"1\":{\"620\":1}}],[\"那么表示无穷次重试\",{\"1\":{\"1252\":1}}],[\"那么stl究竟是什么呢\",{\"0\":{\"963\":1}}],[\"那么派生类的这个方法自动处理成虚函数\",{\"1\":{\"915\":1}}],[\"那么它在所有派生类中也保持为虚函数\",{\"1\":{\"913\":1}}],[\"那么它会以什么方式继承呢\",{\"0\":{\"659\":1}}],[\"那么创建一个派生类对象的时候只有该派生类列出的虚基类的构造函数被调用\",{\"1\":{\"891\":1}}],[\"那么用什么类型能将上面的对象都能接受呢\",{\"1\":{\"886\":1}}],[\"那么小米不仅仅生产手机\",{\"1\":{\"866\":1}}],[\"那么是否有一个方法\",{\"1\":{\"853\":1}}],[\"那么开辟对象数组时会多开辟4个字节记录对象的个数\",{\"1\":{\"715\":1}}],[\"那么就不要使用这个ip地址了\",{\"1\":{\"1278\":1}}],[\"那么就不会执行\",{\"1\":{\"599\":1}}],[\"那么就写\",{\"1\":{\"1252\":1}}],[\"那么就出现了问题\",{\"1\":{\"688\":1}}],[\"那么在用一个派生类对象初始化新的派生类对象时\",{\"1\":{\"662\":1}}],[\"那么在执行派生类对象间的复制操作时\",{\"1\":{\"662\":1}}],[\"那么在参数表中其后所有的参数都必须也设置默认值\",{\"1\":{\"640\":1}}],[\"那么在c++中有没有相同的技术或者更好的实现方法呢\",{\"1\":{\"500\":1}}],[\"那么函数定义一定要在函数的调用之前\",{\"1\":{\"639\":1}}],[\"那么函数就不能返回其他的值\",{\"1\":{\"598\":1}}],[\"那么编译器会自动调用基类的无参构造函数来初始化基类部分\",{\"1\":{\"423\":1}}],[\"那么现在\",{\"1\":{\"406\":1}}],[\"那么当发生浅拷贝时\",{\"1\":{\"397\":1}}],[\"那么这些sql就会被记录在慢查询日志当中\",{\"1\":{\"1573\":1,\"1776\":1}}],[\"那么这个插入语句就会被阻塞\",{\"1\":{\"1717\":1}}],[\"那么这个表是怎么变来的呢\",{\"1\":{\"1681\":1}}],[\"那么这个类定义的对象\",{\"1\":{\"915\":1}}],[\"那么这个数就是快乐数\",{\"1\":{\"146\":1}}],[\"那么这次缺页中断就是majflt\",{\"1\":{\"290\":1}}],[\"那么else又没有对应的if了\",{\"1\":{\"274\":1}}],[\"那么实际上写的代码如下\",{\"1\":{\"273\":1}}],[\"那么打印出来可能就是此值\",{\"1\":{\"234\":1}}],[\"那么察看下一个位置的元素\",{\"1\":{\"162\":1}}],[\"那么\",{\"1\":{\"135\":1,\"603\":1,\"915\":1,\"1172\":1,\"1650\":1}}],[\"那么应该这么写\",{\"1\":{\"135\":1}}],[\"那么应该直接跳过去\",{\"1\":{\"135\":1}}],[\"那么无论如何组合都不可能凑成三元组\",{\"1\":{\"133\":1}}],[\"还保留了相应数据类型\",{\"1\":{\"1907\":1}}],[\"还检查了\",{\"1\":{\"1896\":1}}],[\"还没提交事务\",{\"1\":{\"1656\":1}}],[\"还没有准备好\",{\"1\":{\"1233\":1}}],[\"还得看使用索引是否能带来效率的提升\",{\"1\":{\"1594\":1}}],[\"还需要再获取连接\",{\"1\":{\"1866\":1}}],[\"还需要在运行时指定动态库的位置\",{\"1\":{\"1331\":1}}],[\"还需要析构删除的元素\",{\"1\":{\"385\":1,\"704\":1,\"747\":1,\"1087\":1}}],[\"还要配置m2为m1的从\",{\"1\":{\"1808\":1}}],[\"还要存储索引值所在的哪一行的data的数据\",{\"1\":{\"1626\":1}}],[\"还要更新对应的索引信息\",{\"1\":{\"1609\":1}}],[\"还要在cpu和内存中不断来回跑\",{\"1\":{\"1233\":1}}],[\"还要从last方向入队\",{\"1\":{\"968\":1}}],[\"还书\",{\"1\":{\"1168\":2}}],[\"还会添加几个字段\",{\"1\":{\"1681\":1}}],[\"还会添加新的元素\",{\"1\":{\"965\":1,\"966\":1,\"969\":1,\"970\":1}}],[\"还会调用\",{\"1\":{\"1105\":1}}],[\"还生产耳机\",{\"1\":{\"866\":1}}],[\"还生成了各种各样的段\",{\"1\":{\"251\":1}}],[\"还不能算是真正应用了面向对象的设计思想\",{\"1\":{\"881\":1}}],[\"还不用再记忆那么多的类名\",{\"1\":{\"863\":1}}],[\"还不好查找错误的原因\",{\"1\":{\"588\":1}}],[\"还原链表并返回结果\",{\"1\":{\"756\":1}}],[\"还未考虑it\",{\"1\":{\"747\":1}}],[\"还定义了一个头节点\",{\"1\":{\"747\":1}}],[\"还定义了很多系统服务接口\",{\"1\":{\"16\":1}}],[\"还附带了\",{\"1\":{\"684\":1}}],[\"还有这几种情况\",{\"1\":{\"1656\":1}}],[\"还有什么没考虑得到呢\",{\"1\":{\"1566\":1}}],[\"还有udp的外部链接怎么都是\",{\"1\":{\"1239\":1}}],[\"还有自己的mb\",{\"1\":{\"937\":1}}],[\"还有另外一种形式的抽象类\",{\"1\":{\"900\":1}}],[\"还有next指针域指向下一个节点\",{\"1\":{\"820\":1,\"823\":1}}],[\"还有一个mapper指针\",{\"1\":{\"968\":1}}],[\"还有一个next指针域指向下一个节点\",{\"1\":{\"816\":1,\"818\":1}}],[\"还有一个缺点就是函数的返回值只有一个\",{\"1\":{\"598\":1}}],[\"还有值传递\",{\"1\":{\"615\":1}}],[\"还有处理\",{\"1\":{\"353\":1}}],[\"还添加了一种基本类型\",{\"1\":{\"473\":1}}],[\"还换了大括号\",{\"1\":{\"458\":1}}],[\"还可使用new和delete等创建动态对象\",{\"1\":{\"453\":1}}],[\"还可以检查一下master的3306端口是否可以连接\",{\"1\":{\"1828\":1}}],[\"还可以配置白名单黑名单\",{\"1\":{\"1802\":1}}],[\"还可以自定义一个索引名\",{\"1\":{\"1614\":1}}],[\"还可以更改运算结果\",{\"1\":{\"1007\":1}}],[\"还可以解决项目中紧偶合的问题\",{\"1\":{\"882\":1}}],[\"还可以增加一个子类\",{\"1\":{\"831\":1}}],[\"还可以存放以下类型\",{\"1\":{\"585\":1}}],[\"还可以使用迭代器进行遍历访问\",{\"1\":{\"539\":1}}],[\"还可以使用宏定义的方式创建常量\",{\"1\":{\"480\":1}}],[\"还可以进行赋值\",{\"1\":{\"515\":1}}],[\"还可以进行数据的初始化\",{\"1\":{\"513\":1,\"708\":1}}],[\"还可以直接通过类名进行调用\",{\"1\":{\"439\":1}}],[\"还可以\",{\"1\":{\"426\":1}}],[\"还分配的一个相关的用于管理的额外内存\",{\"1\":{\"282\":1,\"285\":1}}],[\"还显示了段的信息\",{\"1\":{\"248\":1}}],[\"还是按照原来的方式转发请求\",{\"1\":{\"1790\":1}}],[\"还是高并发等各个方面都是不能满足实际需求的\",{\"1\":{\"1779\":1}}],[\"还是索引本身创建的有问题\",{\"1\":{\"1776\":1}}],[\"还是了\",{\"1\":{\"1699\":1}}],[\"还是需要设置串行化隔离级别\",{\"1\":{\"1631\":1,\"1677\":1}}],[\"还是磁盘上的地址\",{\"0\":{\"1624\":1}}],[\"还是等值查找\",{\"1\":{\"1622\":1}}],[\"还是说还能影响sql的查询效率呢\",{\"0\":{\"1517\":1}}],[\"还是要采用\",{\"1\":{\"1209\":1}}],[\"还是用malloc\",{\"1\":{\"1082\":1}}],[\"还是友元函数好\",{\"0\":{\"730\":1}}],[\"还是有缺陷不完美\",{\"1\":{\"527\":1}}],[\"还是\",{\"1\":{\"503\":1,\"1127\":1,\"1573\":1}}],[\"还是自定义头文件\",{\"1\":{\"312\":1}}],[\"还是链接错误\",{\"1\":{\"310\":1}}],[\"还是在\",{\"1\":{\"147\":1}}],[\"还是比较它的后一个\",{\"1\":{\"135\":1}}],[\"还是判断\",{\"1\":{\"135\":1}}],[\"与mysql\",{\"1\":{\"1790\":1}}],[\"与此同时\",{\"1\":{\"1707\":1}}],[\"与limit相结合\",{\"0\":{\"1539\":1}}],[\"与左外连接\",{\"1\":{\"1500\":1}}],[\"与数据的实际存储或值域无关\",{\"1\":{\"1424\":1}}],[\"与显示和格式化有关\",{\"1\":{\"1424\":1}}],[\"与正向迭代器打印相反\",{\"1\":{\"1011\":1}}],[\"与vector\",{\"1\":{\"999\":3}}],[\"与deque使用方式一模一样\",{\"1\":{\"970\":1}}],[\"与使用指针访问虚函数类似\",{\"1\":{\"922\":1}}],[\"与基类的虚函数有相同的参数列表和返回类型\",{\"1\":{\"913\":1}}],[\"与所生成的的\",{\"1\":{\"630\":1}}],[\"与string的底层实现有关\",{\"1\":{\"547\":1}}],[\"与字符拼接\",{\"1\":{\"536\":1}}],[\"与call\",{\"1\":{\"953\":1}}],[\"与c字符串拼接\",{\"1\":{\"536\":1}}],[\"与c风格字符串相比\",{\"1\":{\"536\":1}}],[\"与c相比\",{\"1\":{\"450\":1}}],[\"与之前介绍的const放在函数前修饰返回值不同\",{\"1\":{\"440\":1}}],[\"与之相比\",{\"1\":{\"435\":1}}],[\"与之间也是\",{\"1\":{\"366\":1}}],[\"与类同名\",{\"1\":{\"425\":1}}],[\"与是\",{\"1\":{\"366\":1}}],[\"与ebp值\",{\"1\":{\"235\":1}}],[\"与相关联的源代码交替并且以英特尔的框架显示🍗🍗🍗\",{\"1\":{\"234\":1,\"260\":1}}],[\"与nums\",{\"1\":{\"135\":1}}],[\"与\",{\"1\":{\"135\":1,\"340\":1,\"597\":1,\"784\":1}}],[\"其两侧也被加上了间隙锁\",{\"1\":{\"1693\":1}}],[\"其userid\",{\"1\":{\"1686\":1}}],[\"其值能够唯一地标识关系中的每一行数据\",{\"1\":{\"1451\":1}}],[\"其值不能修改\",{\"1\":{\"620\":1}}],[\"其值不能被改变的量称为常量\",{\"1\":{\"323\":1}}],[\"其位置不是固定的\",{\"1\":{\"1333\":1}}],[\"其第一个参数是这个\",{\"1\":{\"1318\":1}}],[\"其内部有一个预先设置好的malloc内存分配失败的回调函数\",{\"1\":{\"1105\":1}}],[\"其创建函数只接收一个参数\",{\"1\":{\"1020\":1}}],[\"其花费的时间比一条普通指令多数千倍\",{\"1\":{\"1020\":1}}],[\"其元素最大\",{\"1\":{\"994\":1}}],[\"其有两个宏\",{\"1\":{\"968\":1}}],[\"其英文全称为standard\",{\"1\":{\"963\":1}}],[\"其基类的布局按照基类被声明时的顺序进行排列\",{\"1\":{\"889\":1}}],[\"其对应接口也要删除\",{\"1\":{\"886\":1}}],[\"其它连接肯定没有\",{\"1\":{\"1849\":1,\"1859\":1}}],[\"其它模式\",{\"1\":{\"1320\":1}}],[\"其它在cv上等待的线程\",{\"1\":{\"1229\":1}}],[\"其它线程得到该通知\",{\"1\":{\"1219\":1}}],[\"其它的虚函数表中存放的并不是真实的\",{\"1\":{\"889\":1}}],[\"其它对象都能够接收到相应的通知\",{\"1\":{\"871\":2}}],[\"其它数据文件等\",{\"1\":{\"283\":1}}],[\"其余的人才能幸免于难\",{\"1\":{\"811\":1}}],[\"其参数至少有一个是类对象\",{\"1\":{\"728\":1}}],[\"其底层为动态开辟的二维数组\",{\"1\":{\"968\":1}}],[\"其底层还是通过进行遍历的\",{\"1\":{\"701\":1}}],[\"其底层放了一组的字符\",{\"1\":{\"698\":1}}],[\"其底层指令也是一模一样的\",{\"1\":{\"619\":1}}],[\"其效果和用指针作为函数参数的效果相当\",{\"1\":{\"615\":1}}],[\"其只是一个变量的别名\",{\"1\":{\"614\":1}}],[\"其语法是\",{\"1\":{\"612\":1}}],[\"其最主要原因是编译器产生代码的规则不同\",{\"1\":{\"562\":1}}],[\"其原型类似于\",{\"1\":{\"560\":1}}],[\"其原型是\",{\"1\":{\"395\":1}}],[\"其为大小的整数倍\",{\"1\":{\"552\":1}}],[\"其示意图如下\",{\"1\":{\"539\":1}}],[\"其并不以空字符\",{\"1\":{\"538\":1}}],[\"其集成的成员操作函数功能强大\",{\"1\":{\"536\":1}}],[\"其定义的是一些对c风格字符串的处理函数\",{\"1\":{\"536\":1}}],[\"其形式如下\",{\"1\":{\"463\":1}}],[\"其机制与使用int等创建普通变量几乎完全一致\",{\"1\":{\"453\":1}}],[\"其访问权限是private\",{\"1\":{\"450\":2}}],[\"其访问权限是public\",{\"1\":{\"450\":2}}],[\"其访问权限是开放给其子类\",{\"1\":{\"449\":1}}],[\"其格式为\",{\"1\":{\"440\":1}}],[\"其具有以下特点\",{\"1\":{\"440\":1}}],[\"其初始化的顺序不是由成员变量在初始化列表中的顺序决定的\",{\"1\":{\"422\":1}}],[\"其模板参数就是模板参数包\",{\"1\":{\"376\":1}}],[\"其他记录丢弃\",{\"1\":{\"1740\":1}}],[\"其他事务在对该表进行增\",{\"1\":{\"1719\":1}}],[\"其他事务update后commit\",{\"1\":{\"1659\":1}}],[\"其他比如涉及\",{\"1\":{\"1581\":1}}],[\"其他操作类型\",{\"1\":{\"1521\":1}}],[\"其他\",{\"0\":{\"1508\":1},\"1\":{\"1544\":1}}],[\"其他系统默认\",{\"1\":{\"1490\":1}}],[\"其他键是可以重复存储的\",{\"1\":{\"1463\":1}}],[\"其他线程不能立马看到isready改成true了\",{\"1\":{\"1233\":1}}],[\"其他线程才能获取互斥锁了\",{\"1\":{\"1229\":1}}],[\"其他分类都是root分类的子分类\",{\"1\":{\"1018\":1}}],[\"其他类列出的将被忽略\",{\"1\":{\"891\":1}}],[\"其他类型依然是泛化版本\",{\"1\":{\"368\":1}}],[\"其他函数无法访问\",{\"1\":{\"850\":1}}],[\"其他的不用关心\",{\"1\":{\"1802\":1}}],[\"其他的\",{\"1\":{\"1437\":1}}],[\"其他的函数\",{\"1\":{\"1105\":1}}],[\"其他的代码也需要\",{\"1\":{\"826\":1}}],[\"其他的一律不能访问\",{\"1\":{\"658\":1}}],[\"其他的都可以访问\",{\"1\":{\"658\":1}}],[\"其他对象\",{\"1\":{\"353\":1}}],[\"其\",{\"1\":{\"283\":1,\"915\":1}}],[\"其中1000是事务1的id\",{\"1\":{\"1665\":1}}],[\"其中所有的信息和第3步记录的内容一致\",{\"1\":{\"1279\":1}}],[\"其中一级空间配置器allocator采用malloc和free来管理内存\",{\"1\":{\"1079\":1}}],[\"其中simpleconfigurator和basicconfigurator\",{\"1\":{\"1026\":1}}],[\"其中std代表的是标准命名空间\",{\"1\":{\"588\":1}}],[\"其中basiclayout\",{\"1\":{\"1021\":1}}],[\"其中baseclass称之为subclass的虚基类\",{\"1\":{\"933\":1}}],[\"其中m\",{\"1\":{\"771\":1}}],[\"其中runtime\",{\"1\":{\"600\":1}}],[\"其中第二行就使用了using编译指令\",{\"1\":{\"588\":1}}],[\"其中public进行修饰的成员表示的是该类可以提供的接口\",{\"1\":{\"449\":1}}],[\"其中任何一个对象的改动都不会对另外一个对象造成影响\",{\"1\":{\"397\":1}}],[\"其中注释表示符号和存放在进程虚拟地址空间的位置\",{\"1\":{\"246\":1}}],[\"其中\",{\"1\":{\"143\":1,\"245\":1,\"283\":1,\"801\":1,\"1374\":1}}],[\"其实图中配置的是多主多从\",{\"1\":{\"1803\":1}}],[\"其实行锁是加在索引树上的\",{\"1\":{\"1700\":1}}],[\"其实只是部分解决\",{\"1\":{\"1665\":1}}],[\"其实就是密码设置简单了\",{\"1\":{\"1407\":1}}],[\"其实就是把需要执行的逻辑提前执行了\",{\"1\":{\"136\":1}}],[\"其实也没有办法再填写了\",{\"1\":{\"1102\":1}}],[\"其实不是\",{\"1\":{\"1041\":1}}],[\"其实不一样\",{\"1\":{\"135\":1}}],[\"其实匿名命名空间和static是同样的道理\",{\"1\":{\"591\":1}}],[\"其实是对c标准库中的<string\",{\"1\":{\"536\":1}}],[\"其实是把它当成一个函数来看待的\",{\"1\":{\"463\":1}}],[\"其实是因为先有高级语言algol\",{\"1\":{\"300\":1}}],[\"其实现如下\",{\"1\":{\"449\":1}}],[\"其实\",{\"1\":{\"344\":1}}],[\"其实主要考虑三个数的去重\",{\"1\":{\"135\":1}}],[\"其作用是将输入的字符串反转过来\",{\"1\":{\"67\":1}}],[\"同步这个主库的任意库里的任意表\",{\"1\":{\"1821\":1}}],[\"同步被写入磁盘\",{\"0\":{\"1760\":1}}],[\"同一个事务无论怎么更改数据\",{\"1\":{\"1681\":1}}],[\"同一份数据会有多个版本\",{\"1\":{\"1677\":1}}],[\"同一目录\",{\"0\":{\"1312\":1}}],[\"同一子网下其他的电脑可以访问虚拟机\",{\"1\":{\"1276\":1}}],[\"同一文件夹下建立软链接\",{\"1\":{\"1271\":1}}],[\"同理\",{\"1\":{\"968\":1}}],[\"同上\",{\"1\":{\"522\":1}}],[\"同第二种情况\",{\"1\":{\"491\":1}}],[\"同样的数据信息\",{\"1\":{\"1901\":1}}],[\"同样的\",{\"1\":{\"1682\":1}}],[\"同样的道理\",{\"1\":{\"518\":1}}],[\"同样地\",{\"1\":{\"463\":1}}],[\"同样可以创建const对象\",{\"1\":{\"453\":1}}],[\"同样酷爱\",{\"1\":{\"301\":1}}],[\"同时也易于机器解析和生成\",{\"1\":{\"1896\":1}}],[\"同时也是实现多版本并发控制\",{\"1\":{\"1679\":1}}],[\"同时存在动态库\",{\"0\":{\"1335\":1}}],[\"同时存在文件和屏幕打印\",{\"1\":{\"1032\":1}}],[\"同时b带两个参数的构造函数也执行了\",{\"1\":{\"943\":1}}],[\"同时为nullptr\",{\"1\":{\"771\":1}}],[\"同时只调用了一次析构函数\",{\"1\":{\"523\":1}}],[\"同时\",{\"1\":{\"235\":1,\"509\":1}}],[\"同时还满足\",{\"1\":{\"132\":1}}],[\"同向双指针法\",{\"0\":{\"77\":1}}],[\"且在区间\",{\"1\":{\"1102\":1}}],[\"且成员离开后从下一个成员开始计数\",{\"1\":{\"812\":1}}],[\"且通过const的使用\",{\"1\":{\"617\":1}}],[\"且只能有一个\",{\"1\":{\"459\":1}}],[\"且其实例只有一个\",{\"1\":{\"435\":1}}],[\"且是函数的最后一个参数\",{\"1\":{\"377\":1}}],[\"且不改变其余元素的顺序而得到\",{\"1\":{\"177\":1}}],[\"且不重复的三元组\",{\"1\":{\"132\":1}}],[\"且\",{\"1\":{\"132\":1,\"158\":1,\"435\":1}}],[\"满足where过滤后a还有5行\",{\"1\":{\"1537\":1}}],[\"满足第一范式才被称为关系型数据库\",{\"1\":{\"1460\":1}}],[\"满足的块将其标志为不可用\",{\"1\":{\"286\":1}}],[\"满足\",{\"1\":{\"132\":1,\"158\":1}}],[\"三张表的联合查询\",{\"1\":{\"1537\":1}}],[\"三\",{\"0\":{\"970\":1,\"991\":1,\"1661\":1,\"1682\":1,\"1691\":1,\"1736\":1,\"1746\":1,\"1770\":1,\"1804\":1,\"1823\":1,\"1887\":1,\"1901\":1,\"1915\":1}}],[\"三元组中出现重复元素的情况直接pass掉了\",{\"1\":{\"135\":1}}],[\"三数之和\",{\"0\":{\"132\":1},\"1\":{\"132\":1}}],[\"三个thread\",{\"1\":{\"1784\":1}}],[\"三个实体的汽车类\",{\"1\":{\"831\":1}}],[\"三个调试窗口\",{\"1\":{\"306\":1}}],[\"三个有序数组的各个元素为\",{\"1\":{\"107\":1}}],[\"三个文件夹\",{\"1\":{\"4\":1}}],[\"结合实践\",{\"1\":{\"1615\":1}}],[\"结合百度脑图\",{\"1\":{\"59\":1}}],[\"结束\",{\"1\":{\"1899\":2}}],[\"结束循环需要加\",{\"1\":{\"1523\":1}}],[\"结束转换\",{\"1\":{\"1299\":1}}],[\"结束后q指向第k个人\",{\"1\":{\"810\":1}}],[\"结束遍历\",{\"1\":{\"286\":1}}],[\"结构化查询语句sql\",{\"0\":{\"1548\":1}}],[\"结构体是不能进行扩展的\",{\"1\":{\"594\":2}}],[\"结构体\",{\"1\":{\"585\":1,\"594\":3}}],[\"结构体作为成员\",{\"0\":{\"557\":1}}],[\"结构\",{\"0\":{\"556\":1},\"1\":{\"555\":1,\"556\":1}}],[\"结尾\",{\"1\":{\"538\":1,\"547\":1}}],[\"结尾的空白符等等\",{\"1\":{\"536\":1}}],[\"结尾空字符的处理\",{\"1\":{\"535\":1}}],[\"结尾自动包含\",{\"1\":{\"535\":1}}],[\"结论二\",{\"1\":{\"940\":1}}],[\"结论一\",{\"1\":{\"940\":1}}],[\"结论\",{\"0\":{\"673\":1},\"1\":{\"530\":1,\"715\":1,\"889\":1,\"891\":1}}],[\"结果解释\",{\"0\":{\"1239\":1}}],[\"结果就不一定是1000了\",{\"1\":{\"1233\":1}}],[\"结果链表中会包含一个环\",{\"1\":{\"795\":1}}],[\"结果\",{\"1\":{\"422\":1,\"1164\":1,\"1165\":1}}],[\"结果为\",{\"1\":{\"146\":1}}],[\"结果集里\",{\"1\":{\"135\":1}}],[\"结果是去重的\",{\"1\":{\"129\":1}}],[\"示例二\",{\"0\":{\"949\":1,\"1114\":1}}],[\"示例一\",{\"0\":{\"948\":1}}],[\"示例\",{\"0\":{\"246\":1,\"421\":1,\"426\":1,\"934\":1,\"1163\":1,\"1173\":1,\"1238\":1,\"1348\":1,\"1364\":1},\"1\":{\"129\":2,\"169\":2,\"177\":1,\"182\":1,\"1334\":1,\"1361\":2,\"1447\":2,\"1462\":1,\"1463\":1,\"1738\":1}}],[\"空闲连接connection全部维护在一个线程安全的connection队列中\",{\"1\":{\"1866\":1}}],[\"空闲连接存活时间\",{\"1\":{\"1754\":1}}],[\"空闲时间\",{\"1\":{\"1859\":1}}],[\"空闲备用空间的首地址\",{\"1\":{\"1102\":1}}],[\"空值查询\",{\"0\":{\"1513\":1}}],[\"空格\",{\"1\":{\"1143\":1}}],[\"空格个数为\",{\"1\":{\"11\":1}}],[\"空格个数\",{\"0\":{\"11\":1}}],[\"空结构体是0\",{\"1\":{\"1071\":1}}],[\"空结构体\",{\"0\":{\"1070\":1}}],[\"空字符\",{\"1\":{\"535\":1}}],[\"空类并不是独立的\",{\"1\":{\"470\":1}}],[\"空类的大小不为0\",{\"0\":{\"470\":1}}],[\"空类\",{\"0\":{\"468\":1}}],[\"空间适配器\",{\"1\":{\"1127\":1}}],[\"空间大小\",{\"1\":{\"355\":1,\"385\":2,\"704\":2}}],[\"空间可自动扩展\",{\"1\":{\"354\":1}}],[\"空间复杂度\",{\"1\":{\"143\":1,\"214\":1,\"771\":1}}],[\"空间复杂度是\",{\"1\":{\"126\":1}}],[\"空间复杂度o\",{\"0\":{\"756\":1},\"1\":{\"125\":1,\"141\":1,\"142\":1,\"755\":1}}],[\"空\",{\"1\":{\"287\":1}}],[\"空宏\",{\"0\":{\"276\":1}}],[\"遍历的节点是非常多的\",{\"1\":{\"1627\":1}}],[\"遍历这2个迭代器之间的元素\",{\"1\":{\"1148\":1}}],[\"遍历各种容器\",{\"1\":{\"1007\":1}}],[\"遍历\",{\"1\":{\"999\":1,\"1099\":1}}],[\"遍历c++风格字符串\",{\"1\":{\"547\":1}}],[\"遍历序列\",{\"1\":{\"213\":1}}],[\"遍历当前元素\",{\"1\":{\"125\":1}}],[\"遍历g\",{\"1\":{\"60\":1}}],[\"整个代码由一个头文件组成\",{\"1\":{\"1896\":1}}],[\"整个事务才会被提交给数据库\",{\"1\":{\"1649\":1}}],[\"整个进程结束\",{\"1\":{\"1206\":1}}],[\"整个for循环做的就是把内存是填写剩下所有\",{\"1\":{\"1099\":1}}],[\"整个程序结束时\",{\"1\":{\"427\":1}}],[\"整型\",{\"0\":{\"329\":1}}],[\"整型常量\",{\"1\":{\"323\":1}}],[\"整数\",{\"1\":{\"124\":1}}],[\"整形数组\",{\"1\":{\"70\":2}}],[\"请选择\",{\"1\":{\"1168\":1}}],[\"请返回游戏结束时最后一位成员的编号\",{\"1\":{\"812\":1}}],[\"请\",{\"1\":{\"132\":1}}],[\"请你反转从位置\",{\"1\":{\"801\":1}}],[\"请你反转链表\",{\"1\":{\"777\":1}}],[\"请你找出并返回链表的中间结点\",{\"1\":{\"798\":1}}],[\"请你找出并返回两个单链表相交的起始节点\",{\"1\":{\"771\":1}}],[\"请你对链表进行分隔\",{\"1\":{\"795\":1}}],[\"请你将所有链表合并到一个升序链表中\",{\"1\":{\"780\":1}}],[\"请你判断该链表是否为回文链表\",{\"1\":{\"754\":1}}],[\"请你在所有可能的子序列中找到最长的和谐子序列的长度\",{\"1\":{\"177\":1}}],[\"请你在该数组中找出\",{\"1\":{\"124\":1}}],[\"请你从数组中找出满足相加之和等于目标数\",{\"1\":{\"140\":1}}],[\"请你设计并实现时间复杂度为\",{\"1\":{\"129\":1}}],[\"请输入md文件路径\",{\"1\":{\"60\":1}}],[\"请输入一行字符\",{\"1\":{\"8\":1,\"11\":1}}],[\"无效的配置项\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":1}}],[\"无\",{\"1\":{\"1318\":1,\"1356\":5}}],[\"无锁队列\",{\"1\":{\"1232\":1}}],[\"无参函数类型\",{\"0\":{\"1164\":1}}],[\"无参构造函数\",{\"1\":{\"468\":1,\"469\":1}}],[\"无论事务是否commit都会记录\",{\"1\":{\"1758\":1}}],[\"无论数据的位置在哪里\",{\"1\":{\"1617\":1}}],[\"无论括号中的数字是多少\",{\"1\":{\"1424\":1}}],[\"无论派生类析构函数声明中是否加virtual关键字\",{\"1\":{\"949\":1}}],[\"无论何时调用func1函数\",{\"1\":{\"637\":1}}],[\"无论是在安全性\",{\"1\":{\"1779\":1}}],[\"无论是在外部还是在派生类中作为其对象成员\",{\"1\":{\"900\":1}}],[\"无论是linux上直接操作还是vscode进行配置\",{\"1\":{\"1309\":1}}],[\"无论是vs还是gcc\",{\"1\":{\"1072\":1}}],[\"无论是c还是c++释放内存后要把指针制空\",{\"1\":{\"510\":1}}],[\"无论是\",{\"1\":{\"503\":1}}],[\"无符号十进制整数\",{\"1\":{\"1347\":1}}],[\"无符号溢出\",{\"0\":{\"334\":1}}],[\"无符号整型\",{\"0\":{\"331\":1}}],[\"无法访问数据库\",{\"1\":{\"1865\":1}}],[\"无法访问物理地址\",{\"1\":{\"304\":1}}],[\"无法直接查看\",{\"1\":{\"1773\":1}}],[\"无法直接相连\",{\"1\":{\"832\":1}}],[\"无法确保事务的持久性\",{\"1\":{\"1758\":1}}],[\"无法成功插入\",{\"1\":{\"1717\":1}}],[\"无法成功获取表s锁\",{\"1\":{\"1673\":1}}],[\"无法解决幻读\",{\"0\":{\"1660\":1}}],[\"无法解决不可重复读\",{\"0\":{\"1659\":1}}],[\"无法读取\",{\"1\":{\"1656\":1}}],[\"无法读取生成快照\",{\"1\":{\"1656\":1}}],[\"无法保证事务的原子特性\",{\"1\":{\"1640\":1}}],[\"无法购买茶杯\",{\"1\":{\"1639\":1}}],[\"无法用到索引\",{\"0\":{\"1593\":1}}],[\"无法一次性弄到内存中怎么办呢\",{\"1\":{\"1525\":1}}],[\"无法做到\",{\"1\":{\"1168\":1}}],[\"无法继续使用\",{\"1\":{\"1155\":1}}],[\"无法正确打印\",{\"1\":{\"1045\":1}}],[\"无法推断出底层的实现\",{\"1\":{\"826\":1}}],[\"无法进行内存随机访问\",{\"1\":{\"815\":1}}],[\"无法去修改数据\",{\"1\":{\"620\":1}}],[\"无法对一个立即数取地址\",{\"1\":{\"620\":1}}],[\"无法分配这么多空间\",{\"1\":{\"605\":1}}],[\"无法被其它文件引用\",{\"1\":{\"591\":1}}],[\"无法满足程序的内存需求\",{\"1\":{\"531\":1}}],[\"无法找到次大值\",{\"1\":{\"118\":1}}],[\"无序关联容器与有序关联容器用法几乎都是一样的\",{\"1\":{\"1002\":1}}],[\"无序关联容器与有序关联容器\",{\"1\":{\"998\":1}}],[\"无序关联容器\",{\"0\":{\"997\":1,\"998\":1},\"1\":{\"998\":1}}],[\"无序修改即可在任何一个平台上运行\",{\"1\":{\"303\":1}}],[\"无序数组\",{\"1\":{\"100\":1}}],[\"无限循环\",{\"1\":{\"146\":1}}],[\"复杂的构建系统\",{\"1\":{\"1896\":1}}],[\"复杂度o\",{\"1\":{\"114\":1,\"115\":1}}],[\"复数类ccomplex\",{\"0\":{\"727\":1}}],[\"复制仅在连续主版本之间支持\",{\"1\":{\"1828\":1}}],[\"复制到\",{\"1\":{\"1828\":1}}],[\"复制多行\",{\"1\":{\"1142\":1}}],[\"复制拷贝构造函数\",{\"1\":{\"537\":1}}],[\"复制\",{\"1\":{\"29\":1}}],[\"你也不会看到前后两次查询的数据的不同\",{\"1\":{\"1631\":1}}],[\"你也可以把上面的工厂方法看作只生产一种产品的抽象工厂\",{\"1\":{\"866\":1}}],[\"你也可以通过指针或者c++的引用来返回另外的值\",{\"1\":{\"598\":1}}],[\"你的密码需要自己设置\",{\"1\":{\"1408\":1}}],[\"你的密码\",{\"1\":{\"1407\":1,\"1408\":1}}],[\"你的命名\",{\"1\":{\"1407\":1}}],[\"你实际上是在告诉\",{\"1\":{\"1334\":1}}],[\"你们赶紧消费吧\",{\"1\":{\"1219\":1}}],[\"你提供一个纯虚函数的实现\",{\"1\":{\"898\":1}}],[\"你应当\",{\"1\":{\"795\":1}}],[\"你通过函数的返回值表示错误代码\",{\"1\":{\"598\":1}}],[\"你会发现\",{\"1\":{\"470\":1}}],[\"你可能需要更新系统的库缓存\",{\"1\":{\"1332\":1}}],[\"你可能需要编辑\",{\"1\":{\"239\":1,\"1332\":1}}],[\"你可能会问\",{\"1\":{\"283\":1}}],[\"你可以直接指定静态库文件的路径\",{\"1\":{\"1335\":1}}],[\"你可以直接指定要链接的库文件的路径\",{\"1\":{\"1335\":1}}],[\"你可以将函数名或地址作为参数传递给\",{\"1\":{\"261\":1}}],[\"你可以使用以下策略\",{\"1\":{\"1335\":1}}],[\"你可以使用以下命令来察看下载进度\",{\"1\":{\"1253\":1}}],[\"你可以使用wget来完成ftp链接的下载\",{\"1\":{\"1254\":1}}],[\"你可以使用\",{\"1\":{\"182\":1,\"261\":2,\"1256\":1,\"1341\":2,\"1410\":1}}],[\"你可以按任意顺序返回答案\",{\"1\":{\"124\":1}}],[\"你可以假设每个输入\",{\"1\":{\"140\":1}}],[\"你可以假设每种输入只会对应一个答案\",{\"1\":{\"124\":1}}],[\"你可以假设数组是非空的\",{\"1\":{\"113\":1}}],[\"你所使用的语言也许不支持栈\",{\"1\":{\"182\":1}}],[\"你所设计的解决方案必须只使用常量级的额外空间\",{\"1\":{\"140\":1}}],[\"你只能使用标准的栈操作\",{\"1\":{\"182\":1}}],[\"你返回所有和为\",{\"1\":{\"132\":1}}],[\"你必须原地修改输入数组\",{\"1\":{\"67\":1}}],[\"|sudo\",{\"1\":{\"1405\":1}}],[\"|sort\",{\"1\":{\"1238\":1}}],[\"|sort|uniq\",{\"1\":{\"1238\":2}}],[\"|head\",{\"1\":{\"1238\":1}}],[\"|awk\",{\"1\":{\"1238\":2}}],[\"|grep\",{\"1\":{\"1238\":2}}],[\"|\",{\"1\":{\"110\":1,\"496\":1,\"678\":1,\"692\":1,\"707\":1,\"750\":1,\"965\":1,\"1015\":1,\"1063\":1,\"1087\":1,\"1121\":1,\"1202\":2,\"1238\":16,\"1284\":3,\"1296\":1,\"1390\":1,\"1398\":1,\"1407\":48,\"1514\":1,\"1610\":1,\"1614\":1,\"1747\":1,\"1773\":1,\"1774\":3,\"1820\":1,\"1828\":1}}],[\"||lielement\",{\"1\":{\"59\":2}}],[\"||topelement\",{\"1\":{\"59\":1}}],[\"||\",{\"1\":{\"8\":1,\"11\":1,\"96\":2,\"97\":1,\"101\":2,\"110\":1,\"142\":2,\"704\":1,\"736\":1,\"747\":1,\"787\":2,\"791\":2,\"792\":1,\"1082\":2}}],[\"两台机器把库平分了\",{\"1\":{\"1888\":1}}],[\"两次同样的select之间有更新操作\",{\"1\":{\"1881\":1}}],[\"两次扫描算法\",{\"1\":{\"1736\":1}}],[\"两次查询数据量不同\",{\"1\":{\"1712\":1}}],[\"两次查询值不同\",{\"1\":{\"1712\":1}}],[\"两次查询的数据量不同\",{\"1\":{\"1694\":1}}],[\"两次查询的数据内容不同\",{\"1\":{\"1694\":1}}],[\"两次查询\",{\"1\":{\"1658\":1}}],[\"两次拷贝全都走移动构造和移动赋值\",{\"1\":{\"1121\":1}}],[\"两张表的连接查询\",{\"1\":{\"1537\":1}}],[\"两两合并\",{\"1\":{\"782\":1}}],[\"两对象间的\",{\"1\":{\"662\":1}}],[\"两者都可以查看当前mysql的状态\",{\"1\":{\"1402\":1}}],[\"两者都可以\",{\"1\":{\"1209\":1}}],[\"两者根本不能\",{\"1\":{\"876\":1}}],[\"两者之间的区别在于创建实例的时间不同\",{\"1\":{\"842\":1}}],[\"两者不匹配\",{\"1\":{\"568\":1}}],[\"两者皆不能进行修改\",{\"1\":{\"488\":1}}],[\"两种定义字符串方式\",{\"1\":{\"535\":1}}],[\"两个数据节点对应两个不同的物理机器\",{\"1\":{\"1888\":2}}],[\"两个数组的交集\",{\"0\":{\"169\":1},\"1\":{\"110\":2,\"169\":1}}],[\"两个逻辑库对应两个不同的数据节点\",{\"1\":{\"1888\":2}}],[\"两个库的数据可能是不一样的\",{\"1\":{\"1785\":1}}],[\"两个log\",{\"1\":{\"1784\":1}}],[\"两个重要的应用场景\",{\"1\":{\"1772\":1}}],[\"两个重要的辅助接口函数\",{\"0\":{\"1090\":1}}],[\"两个事务发生死锁时\",{\"1\":{\"1708\":1}}],[\"两个事务可以同时获取共享锁\",{\"1\":{\"1701\":1}}],[\"两个事务可以获取到不同行的排它锁\",{\"1\":{\"1700\":1}}],[\"两个会话都需要设置成read\",{\"1\":{\"1633\":1}}],[\"两个mysql客户端默认工作在可重复读级别\",{\"1\":{\"1631\":1}}],[\"两个是一对多的关系\",{\"1\":{\"1462\":1}}],[\"两个字节\",{\"1\":{\"1347\":1}}],[\"两个线程共享的队列\",{\"1\":{\"1219\":2}}],[\"两个线程都有可能先运行\",{\"1\":{\"1218\":1}}],[\"两个线程可能减完的值是相同的\",{\"1\":{\"1208\":1}}],[\"两个容器进行元素交换\",{\"1\":{\"965\":1,\"969\":1,\"970\":1}}],[\"两个分区中每个节点的初始相对位置\",{\"1\":{\"795\":1}}],[\"两个指针同时遍历两个链表\",{\"1\":{\"771\":1}}],[\"两个指针移动的总次数最多为\",{\"1\":{\"143\":1}}],[\"两个函数参数不同\",{\"1\":{\"695\":1}}],[\"两个函数参数相同\",{\"1\":{\"695\":1}}],[\"两个函数参数\",{\"1\":{\"695\":2}}],[\"两个c++字符串拼接\",{\"1\":{\"536\":1}}],[\"两个const分开看\",{\"1\":{\"492\":1}}],[\"两个对象不同的指针指向同一个资源\",{\"1\":{\"397\":1}}],[\"两个机器数比较大小\",{\"0\":{\"346\":1}}],[\"两个\",{\"1\":{\"124\":1}}],[\"两数之和\",{\"0\":{\"124\":1,\"140\":1},\"1\":{\"124\":1,\"140\":1}}],[\"两指针相遇\",{\"1\":{\"78\":1}}],[\"成为理想的数据交换语言\",{\"1\":{\"1896\":1}}],[\"成为虚函数的条件\",{\"0\":{\"875\":1}}],[\"成绩\",{\"1\":{\"1461\":2}}],[\"成\",{\"1\":{\"1225\":1}}],[\"成功了\",{\"1\":{\"1701\":1}}],[\"成功之后调用的\",{\"1\":{\"1377\":1}}],[\"成功返回0\",{\"1\":{\"1376\":1}}],[\"成功返回下标\",{\"1\":{\"84\":1}}],[\"成功与第一个参数值相同\",{\"1\":{\"1374\":1}}],[\"成功会显示不是installed\",{\"1\":{\"1287\":1}}],[\"成功从小到大排序\",{\"1\":{\"1007\":1}}],[\"成功调用\",{\"1\":{\"907\":1}}],[\"成20\",{\"1\":{\"484\":1}}],[\"成员方法的调用必须依赖一个对象\",{\"1\":{\"1167\":1}}],[\"成员们按照编号顺序围绕圆桌而坐\",{\"1\":{\"812\":1}}],[\"成员指针访问运算符\",{\"1\":{\"728\":1}}],[\"成员访问运算符\",{\"1\":{\"728\":1}}],[\"成员名字\",{\"1\":{\"684\":1}}],[\"成员名冲突的二义性\",{\"0\":{\"652\":1}}],[\"成员变量名\",{\"1\":{\"1914\":2}}],[\"成员变量\",{\"1\":{\"1212\":1}}],[\"成员变量只有一个裸指针\",{\"1\":{\"1044\":1}}],[\"成员变量引用类型\",{\"1\":{\"423\":1}}],[\"成员变量是一把互斥锁\",{\"1\":{\"1210\":1}}],[\"成员变量是\",{\"1\":{\"423\":1}}],[\"成员函数中访问\",{\"0\":{\"924\":1}}],[\"成员函数名\",{\"1\":{\"449\":1}}],[\"成员函数还可以在类之外实现\",{\"1\":{\"449\":1}}],[\"成员函数也可以定义成静态的\",{\"1\":{\"439\":1}}],[\"成员函数\",{\"1\":{\"438\":1,\"449\":1,\"450\":2,\"722\":2}}],[\"成员函数存在于程序代码区\",{\"1\":{\"433\":1}}],[\"成员函数不占用类的大小\",{\"1\":{\"433\":1}}],[\"成员函数的第一个参数的位置\",{\"1\":{\"392\":1}}],[\"成员函数模板也是可以设置默认值\",{\"1\":{\"372\":1}}],[\"成员函数模板\",{\"0\":{\"372\":1},\"1\":{\"372\":1}}],[\"成员函数执行完操作后\",{\"1\":{\"101\":1}}],[\"$i\",{\"1\":{\"1362\":1}}],[\"$$i\",{\"1\":{\"1362\":1,\"1366\":2}}],[\"$^\",{\"1\":{\"1356\":1,\"1360\":4,\"1366\":2,\"1367\":2}}],[\"$<\",{\"1\":{\"1356\":1,\"1365\":1,\"1367\":1}}],[\"$pc\",{\"1\":{\"1348\":1}}],[\"$pwd\",{\"1\":{\"1271\":2}}],[\"$sudo\",{\"1\":{\"1293\":1,\"1409\":1}}],[\"$cd\",{\"1\":{\"1271\":1}}],[\"$cat\",{\"1\":{\"1271\":2,\"1774\":1}}],[\"$echo\",{\"1\":{\"1271\":2}}],[\"$ll\",{\"1\":{\"1271\":2}}],[\"$ls\",{\"1\":{\"1271\":1}}],[\"$ln\",{\"1\":{\"1271\":4}}],[\"$touch\",{\"1\":{\"1271\":1}}],[\"$7\",{\"1\":{\"1238\":1}}],[\"$4\",{\"1\":{\"1238\":1}}],[\"$3\",{\"1\":{\"1238\":1}}],[\"$2\",{\"1\":{\"1238\":1}}],[\"$1\",{\"1\":{\"1238\":3}}],[\"$5\",{\"1\":{\"1238\":4}}],[\"$objdump\",{\"1\":{\"614\":1,\"621\":1}}],[\"$nm\",{\"1\":{\"572\":1}}],[\"$file\",{\"1\":{\"572\":2}}],[\"$gcc\",{\"1\":{\"572\":1}}],[\"$g++\",{\"1\":{\"234\":1,\"614\":1,\"621\":1,\"1856\":1}}],[\"$ulimit\",{\"1\":{\"239\":2}}],[\"$\",{\"1\":{\"101\":1,\"224\":1,\"253\":2,\"371\":1,\"378\":1,\"422\":1,\"433\":1,\"468\":1,\"605\":1,\"606\":1,\"810\":1,\"817\":1,\"819\":1,\"1015\":5,\"1030\":3,\"1032\":1,\"1035\":2,\"1261\":4,\"1282\":1,\"1296\":4,\"1312\":3,\"1314\":3,\"1315\":3,\"1316\":7,\"1317\":3,\"1318\":1,\"1322\":1,\"1356\":6,\"1357\":4,\"1360\":10,\"1361\":7,\"1362\":1,\"1365\":11,\"1366\":6,\"1367\":15,\"1393\":2,\"1399\":1,\"1402\":2,\"1409\":2,\"1410\":2,\"1523\":2}}],[\"打包库文件\",{\"1\":{\"1356\":1}}],[\"打包成库文件ar\",{\"1\":{\"1331\":1}}],[\"打包成packet\",{\"1\":{\"1260\":1}}],[\"打包成键值对\",{\"1\":{\"1000\":4}}],[\"打包和压缩\",{\"0\":{\"1259\":1}}],[\"打断点\",{\"1\":{\"234\":1,\"306\":1}}],[\"打印变量或表达式的值\",{\"1\":{\"1340\":1}}],[\"打印的层级\",{\"1\":{\"1245\":1}}],[\"打印元素时从最后一个打印到第一个\",{\"1\":{\"1011\":1}}],[\"打印元素时从第一个打到最后一个\",{\"1\":{\"1011\":1}}],[\"打印元素时从\",{\"1\":{\"1011\":2}}],[\"打印数据成员\",{\"1\":{\"894\":2}}],[\"打印实例地址\",{\"1\":{\"848\":1,\"850\":1,\"851\":1}}],[\"打印结果\",{\"1\":{\"688\":1}}],[\"打印一下\",{\"1\":{\"688\":1,\"984\":1}}],[\"打印地址常用printf\",{\"1\":{\"618\":1}}],[\"打印目标文件各个段\",{\"0\":{\"252\":1}}],[\"打印队列头尾\",{\"1\":{\"185\":1}}],[\"打印\",{\"1\":{\"101\":1}}],[\"打开windows从库上的general\",{\"1\":{\"1811\":1}}],[\"打开查询日志general\",{\"0\":{\"1811\":1}}],[\"打开root的远程连接权限\",{\"0\":{\"1799\":1}}],[\"打开自动提交\",{\"1\":{\"1731\":1}}],[\"打开profiling开关\",{\"1\":{\"1582\":1}}],[\"打开慢查询日志开关slow\",{\"0\":{\"1576\":1,\"1577\":1},\"1\":{\"1573\":1}}],[\"打开后找到vmware\",{\"1\":{\"1285\":1}}],[\"打开后能看到两个配置文件\",{\"1\":{\"63\":1}}],[\"打开虚拟机的网络设定\",{\"1\":{\"1278\":1}}],[\"打开命令窗口ping\",{\"1\":{\"1277\":1}}],[\"打开合适的配色文件将里面的内容复制到~\",{\"1\":{\"1143\":1}}],[\"打开全局变量general\",{\"1\":{\"1771\":1}}],[\"打开全局字段搜索面板\",{\"1\":{\"1141\":1}}],[\"打开全局文件搜索面板\",{\"1\":{\"1136\":1}}],[\"打开目录树\",{\"1\":{\"1138\":1}}],[\"打开电脑\",{\"1\":{\"66\":1}}],[\"打开其中一个\",{\"1\":{\"62\":1}}],[\"打开高级设置\",{\"1\":{\"62\":1,\"63\":1}}],[\"打开文件所在位置\",{\"1\":{\"61\":1}}],[\"打开typora的安装目录\",{\"1\":{\"61\":1}}],[\"打开输入法设置\",{\"1\":{\"46\":1}}],[\"打开\",{\"1\":{\"33\":1}}],[\"移除链表元素\",{\"0\":{\"759\":1},\"1\":{\"759\":1}}],[\"移除元素\",{\"0\":{\"76\":1},\"1\":{\"76\":1}}],[\"移植原因\",{\"1\":{\"553\":1}}],[\"移动到linux下并解压\",{\"1\":{\"1305\":1}}],[\"移动语义\",{\"1\":{\"1127\":1}}],[\"移动语义友好\",{\"1\":{\"826\":1}}],[\"移动赋值\",{\"1\":{\"1121\":1}}],[\"移动构造\",{\"1\":{\"1121\":1}}],[\"移动构造和赋值\",{\"1\":{\"1121\":1}}],[\"移动左右指针\",{\"1\":{\"126\":1}}],[\"移动元素\",{\"1\":{\"101\":1}}],[\"尾删\",{\"1\":{\"101\":1,\"355\":1,\"385\":1,\"704\":1,\"747\":1,\"1087\":1}}],[\"尾插\",{\"1\":{\"101\":1,\"355\":1,\"385\":1,\"704\":1,\"1087\":1}}],[\"默认时的长度为从开始位置到尾\",{\"1\":{\"1878\":1}}],[\"默认与vmnet8通信\",{\"1\":{\"1821\":1}}],[\"默认名称是host\",{\"1\":{\"1776\":1}}],[\"默认创建的是b+树\",{\"1\":{\"1600\":1}}],[\"默认在data\",{\"1\":{\"1769\":1}}],[\"默认在\",{\"1\":{\"1574\":1}}],[\"默认安装的事mysql8\",{\"1\":{\"1394\":1}}],[\"默认安装的事mysql5\",{\"1\":{\"1393\":1}}],[\"默认含义\",{\"1\":{\"1356\":1}}],[\"默认是十六进制\",{\"1\":{\"1347\":1}}],[\"默认行为\",{\"1\":{\"1335\":1}}],[\"默认空字符串\",{\"1\":{\"1320\":1}}],[\"默认为\",{\"1\":{\"1310\":1}}],[\"默认为20\",{\"1\":{\"1099\":1}}],[\"默认的库编译方式\",{\"1\":{\"1310\":1}}],[\"默认的下划线样式就好像一条舔狗\",{\"1\":{\"48\":1}}],[\"默认注释了源码镜像以提高\",{\"1\":{\"1284\":1}}],[\"默认小到大排序\",{\"1\":{\"1147\":1,\"1148\":1}}],[\"默认大小写敏感\",{\"1\":{\"1141\":1}}],[\"默认大小为map\",{\"1\":{\"968\":1}}],[\"默认头文件的位置\",{\"1\":{\"1015\":1}}],[\"默认lib库路径是\",{\"1\":{\"1015\":1}}],[\"默认底层从小到大进行输出\",{\"1\":{\"985\":1}}],[\"默认定义的vector底层为0\",{\"1\":{\"966\":3}}],[\"默认使用student的oprator<来进行比较\",{\"1\":{\"784\":1}}],[\"默认只支持从下到上的类型的转换\",{\"1\":{\"678\":1}}],[\"默认继承方式是public共有的\",{\"1\":{\"659\":1}}],[\"默认继承方式是private私有的\",{\"1\":{\"659\":1}}],[\"默认值插入\",{\"1\":{\"1477\":1}}],[\"默认值约束\",{\"0\":{\"1436\":1}}],[\"默认值顺序从右往左赋值\",{\"1\":{\"639\":1}}],[\"默认值只能给一次\",{\"1\":{\"639\":1}}],[\"默认参数要从右往左进行连续的赋初值\",{\"1\":{\"642\":1}}],[\"默认参数可将一系列简单的重载函数合成为一个\",{\"1\":{\"641\":1}}],[\"默认参数与函数重载\",{\"0\":{\"641\":1}}],[\"默认参数应从右至左逐渐定义\",{\"1\":{\"640\":1}}],[\"默认参数的顺序规定\",{\"0\":{\"640\":1}}],[\"默认参数的声明\",{\"0\":{\"639\":1}}],[\"默认参数的目的\",{\"0\":{\"637\":1}}],[\"默认参数\",{\"0\":{\"636\":1},\"1\":{\"606\":1}}],[\"默认构造函数\",{\"1\":{\"537\":1}}],[\"默认\",{\"1\":{\"421\":1,\"1245\":1}}],[\"默认从项目当前目录查找头文件\",{\"1\":{\"312\":1}}],[\"默认情况下\",{\"1\":{\"284\":1,\"1338\":1}}],[\"默认先选择左孩子\",{\"1\":{\"194\":1}}],[\"默认容量大小为10\",{\"1\":{\"101\":1}}],[\"时的相关信息\",{\"1\":{\"1770\":1}}],[\"时的编译选项\",{\"1\":{\"1310\":2}}],[\"时当前数据库中应该给下一个事务的\",{\"1\":{\"1656\":1}}],[\"时间是一样的\",{\"1\":{\"1521\":1}}],[\"时间和日期函数\",{\"0\":{\"1443\":1}}],[\"时间复杂度都是o\",{\"1\":{\"1622\":1}}],[\"时间复杂度需要为o\",{\"1\":{\"993\":1}}],[\"时间复杂度低\",{\"1\":{\"202\":1}}],[\"时间复杂度\",{\"1\":{\"143\":1,\"214\":1,\"771\":1}}],[\"时间复杂度o\",{\"1\":{\"125\":1,\"141\":1,\"142\":1,\"202\":1,\"815\":1,\"965\":5,\"969\":6,\"970\":6}}],[\"时间复杂度是o\",{\"1\":{\"100\":1}}],[\"时得到除以0错误\",{\"1\":{\"470\":1}}],[\"时\",{\"1\":{\"273\":1,\"517\":1,\"604\":1,\"715\":1,\"791\":1,\"908\":1,\"970\":1,\"1050\":1,\"1315\":1,\"1656\":2}}],[\"时不要立即返回\",{\"1\":{\"96\":1}}],[\"随时可以在从库\",{\"1\":{\"1830\":1}}],[\"随便写一段代码有弹出的内容说明装好了\",{\"1\":{\"1287\":1}}],[\"随着服务器流量越来越大\",{\"1\":{\"1885\":1}}],[\"随着服务越来越多的人使用\",{\"1\":{\"1790\":1}}],[\"随着cpu的调度算法执行\",{\"1\":{\"1207\":1}}],[\"随着栈的生产而逐渐变小\",{\"1\":{\"233\":1}}],[\"随机出来的数字\",{\"1\":{\"1147\":1}}],[\"随机访问使用多\",{\"1\":{\"974\":1}}],[\"随机访问为o\",{\"1\":{\"974\":1}}],[\"随机访问\",{\"1\":{\"100\":1,\"354\":1}}],[\"随笔\",{\"0\":{\"31\":1}}],[\"或锁机制来保证的\",{\"1\":{\"1645\":1}}],[\"或q\",{\"1\":{\"1340\":1}}],[\"或l\",{\"1\":{\"1340\":1}}],[\"或p\",{\"1\":{\"1340\":1}}],[\"或pointer\",{\"1\":{\"826\":1}}],[\"或s\",{\"1\":{\"1340\":1}}],[\"或n\",{\"1\":{\"1340\":1}}],[\"或c\",{\"1\":{\"1340\":1}}],[\"或r\",{\"1\":{\"1340\":1}}],[\"或d\",{\"1\":{\"1340\":1}}],[\"或i\",{\"1\":{\"1340\":1}}],[\"或b\",{\"1\":{\"1340\":1}}],[\"或backtrace\",{\"1\":{\"1340\":1}}],[\"或0\",{\"1\":{\"1299\":1}}],[\"或先前的连接中断请求的确认\",{\"1\":{\"1240\":1}}],[\"或类对象的引用\",{\"1\":{\"728\":1}}],[\"或引用\",{\"1\":{\"631\":1,\"632\":1}}],[\"或联合\",{\"0\":{\"556\":1},\"1\":{\"555\":1,\"556\":2}}],[\"或其缩写\",{\"1\":{\"316\":1}}],[\"或16byte\",{\"1\":{\"285\":1}}],[\"或16mb\",{\"1\":{\"239\":1}}],[\"或\",{\"1\":{\"261\":1,\"607\":1,\"876\":1,\"999\":1,\"1310\":1,\"1327\":1,\"1332\":1,\"1347\":1,\"1374\":3}}],[\"或者需要读取的流中已经没有数据了\",{\"1\":{\"1878\":1}}],[\"或者通过配置文件永久修改事务的提交方式\",{\"1\":{\"1652\":1}}],[\"或者前一次查询的一些记录不见了\",{\"1\":{\"1639\":1}}],[\"或者tcmalloc\",{\"1\":{\"1622\":1}}],[\"或者多列主键\",{\"1\":{\"1618\":1}}],[\"或者修改密码设置等级与\",{\"1\":{\"1407\":1}}],[\"或者连接的服务器ip地址\",{\"1\":{\"1374\":1}}],[\"或者对\",{\"1\":{\"1338\":1}}],[\"或者将后缀为\",{\"1\":{\"1261\":2}}],[\"或者中\",{\"1\":{\"1226\":1,\"1228\":1}}],[\"或者其他情况\",{\"1\":{\"1209\":1}}],[\"或者其它的汽车附属产品\",{\"1\":{\"866\":1}}],[\"或者由于中间程序的执行顺序和我们预想的不一样\",{\"1\":{\"1040\":1}}],[\"或者称作\",{\"1\":{\"979\":1}}],[\"或者使用如下命令\",{\"1\":{\"1402\":1}}],[\"或者使用vs先配置项目属性\",{\"1\":{\"936\":1}}],[\"或者使用别人定义好的类创建对象\",{\"1\":{\"453\":1}}],[\"或者说动态多态是怎么表现出来的呢\",{\"0\":{\"916\":1}}],[\"或者说虚函数底层是的怎么实现的呢\",{\"1\":{\"913\":1}}],[\"或者说new和delete\",{\"0\":{\"517\":1}}],[\"或者是ip\",{\"1\":{\"1806\":1}}],[\"或者是索引使用到了\",{\"1\":{\"1573\":1,\"1776\":1}}],[\"或者是\",{\"1\":{\"1521\":1}}],[\"或者是线程1接下来要做某些操作\",{\"1\":{\"1218\":1}}],[\"或者是其他资源\",{\"1\":{\"1060\":1}}],[\"或者是否是同一类型容器的迭代器\",{\"1\":{\"747\":1}}],[\"或者是所调用的函数又调用了另外的一个函数\",{\"1\":{\"600\":1}}],[\"或者在派生类对象间赋值时\",{\"1\":{\"662\":1}}],[\"或者至少告诉用户发生了什么再终止程序\",{\"1\":{\"597\":1}}],[\"或者我们写出正确的调用代码\",{\"1\":{\"528\":1}}],[\"或者干脆不初始化\",{\"1\":{\"455\":1}}],[\"或者服务器出错\",{\"1\":{\"1650\":1}}],[\"或者服务\",{\"1\":{\"449\":1}}],[\"或者执行到下一个断点\",{\"1\":{\"306\":1}}],[\"或者啥也不干\",{\"1\":{\"290\":1}}],[\"或者直接置0\",{\"1\":{\"290\":1}}],[\"或者构成循环\",{\"1\":{\"277\":1}}],[\"或者简写为\",{\"1\":{\"261\":1}}],[\"或者\",{\"1\":{\"182\":2,\"360\":1,\"458\":1,\"1102\":1,\"1142\":1,\"1261\":1,\"1305\":1,\"1332\":1,\"1335\":1,\"1537\":1}}],[\"或者点击工具栏中的\",{\"1\":{\"41\":1}}],[\"或返回left\",{\"1\":{\"97\":1}}],[\"关系\",{\"1\":{\"1451\":1}}],[\"关系模型是一种数据模型\",{\"1\":{\"1451\":1}}],[\"关系型数据库就是二维表\",{\"1\":{\"1519\":1}}],[\"关系型数据库\",{\"1\":{\"1451\":1,\"1452\":1}}],[\"关系型数据库表设计\",{\"0\":{\"1414\":1}}],[\"关联的表\",{\"1\":{\"1415\":1}}],[\"关联容器\",{\"1\":{\"1011\":1}}],[\"关联容器分为\",{\"1\":{\"998\":1}}],[\"关闭防火墙\",{\"1\":{\"1818\":1}}],[\"关闭linux的mysqld服务\",{\"1\":{\"1814\":1}}],[\"关闭自动提交\",{\"1\":{\"1731\":1}}],[\"关闭唯一性校验\",{\"0\":{\"1730\":1},\"1\":{\"1730\":1}}],[\"关闭mysql连接\",{\"1\":{\"1383\":1,\"1384\":1,\"1385\":1}}],[\"关闭连接\",{\"0\":{\"1375\":1}}],[\"关闭网络\",{\"1\":{\"1278\":1,\"1279\":1}}],[\"关闭窗口\",{\"1\":{\"1139\":1}}],[\"关闭目录树\",{\"1\":{\"1138\":1}}],[\"关闭标签\",{\"1\":{\"1137\":1}}],[\"关闭微软输入法的兼容模式\",{\"0\":{\"65\":1}}],[\"关于\",{\"1\":{\"599\":1}}],[\"关注重点🍖🍖🍖\",{\"0\":{\"561\":1}}],[\"关键技术点\",{\"0\":{\"1863\":1}}],[\"关键是找到目标元素\",{\"1\":{\"792\":1}}],[\"关键找到前驱\",{\"1\":{\"792\":1}}],[\"关键\",{\"1\":{\"774\":1}}],[\"关键字和语法\",{\"0\":{\"1194\":1}}],[\"关键字后面的exceptiontype\",{\"1\":{\"599\":1}}],[\"关键字用于\",{\"1\":{\"362\":2}}],[\"关键字\",{\"0\":{\"296\":1,\"573\":1},\"1\":{\"504\":2}}],[\"关键在于找一个基准\",{\"1\":{\"220\":1}}],[\"关键在对于\",{\"1\":{\"96\":1}}],[\"相比\",{\"1\":{\"1737\":1}}],[\"相比构造函数\",{\"1\":{\"424\":1}}],[\"相加\",{\"0\":{\"1497\":1}}],[\"相关\",{\"0\":{\"1137\":1}}],[\"相交链表\",{\"0\":{\"771\":1},\"1\":{\"771\":1}}],[\"相对静止\",{\"1\":{\"765\":1}}],[\"相遇\",{\"1\":{\"765\":1}}],[\"相应的元素指向\",{\"1\":{\"1096\":1}}],[\"相应的元素\",{\"1\":{\"1096\":1}}],[\"相应的指示位置向后移动\",{\"1\":{\"968\":1}}],[\"相应的实体类若删除\",{\"1\":{\"886\":1}}],[\"相应的\",{\"1\":{\"678\":1,\"1407\":1}}],[\"相同\",{\"1\":{\"513\":1}}],[\"相当于是重复了\",{\"1\":{\"1885\":1}}],[\"相当于把\",{\"1\":{\"1836\":1}}],[\"相当于关闭了master\",{\"1\":{\"1814\":1}}],[\"相当于代码和主从环境就是强绑定的\",{\"1\":{\"1790\":1}}],[\"相当于就是主库的所有修改通过主从复制机制体现在从库上\",{\"1\":{\"1780\":1}}],[\"相当于就是转换头\",{\"1\":{\"832\":1}}],[\"相当于进程内的所有线程都阻塞住了\",{\"1\":{\"1707\":1}}],[\"相当于给这条数据加上了共享锁\",{\"1\":{\"1692\":1}}],[\"相当于给当前的数据拍个照片\",{\"1\":{\"1658\":1}}],[\"相当于只依赖联合主键的其中一个字段\",{\"1\":{\"1461\":1}}],[\"相当于debug调试模式\",{\"1\":{\"1320\":1}}],[\"相当于unique\",{\"1\":{\"1219\":1}}],[\"相当于scoped\",{\"1\":{\"1219\":3}}],[\"相当于将左值强制转换成右值引用类型\",{\"1\":{\"1127\":1}}],[\"相当于修改操作\",{\"1\":{\"1000\":1}}],[\"相当于插入\",{\"1\":{\"1000\":1}}],[\"相当于栈将deque代理了一下\",{\"1\":{\"989\":1}}],[\"相当于容器和操纵容器的算法之间的中介\",{\"1\":{\"698\":1}}],[\"相当于下面的操作\",{\"1\":{\"620\":1}}],[\"相当于\",{\"1\":{\"612\":1,\"1849\":1,\"1859\":1,\"1872\":1}}],[\"相当于通过p可以间接修改b的值\",{\"1\":{\"490\":1}}],[\"相当于行为\",{\"1\":{\"449\":1}}],[\"相当于属性\",{\"1\":{\"449\":1}}],[\"相当于试图t\",{\"1\":{\"441\":1}}],[\"相等时让右边界为目标值\",{\"1\":{\"96\":2}}],[\"相向双指针法\",{\"0\":{\"78\":1}}],[\"应尽量约定以相同的访问各表\",{\"1\":{\"1724\":1}}],[\"应尽量以const替换宏定义\",{\"1\":{\"481\":1}}],[\"应对这些表按\",{\"1\":{\"1706\":1}}],[\"应使用\",{\"1\":{\"449\":1}}],[\"应该插入不同主机上的不同物理表\",{\"1\":{\"1892\":1}}],[\"应该写192\",{\"1\":{\"1821\":1}}],[\"应该放在\",{\"1\":{\"1693\":1}}],[\"应该把学院专门设计成一张表\",{\"1\":{\"1462\":1}}],[\"应该优先返回一个\",{\"1\":{\"1116\":1}}],[\"应该及时通知相应的观察者\",{\"1\":{\"871\":1}}],[\"应该区分判断一下\",{\"1\":{\"631\":1}}],[\"应该尽可能地在自然边界上对齐\",{\"1\":{\"553\":1}}],[\"应该是调用的void\",{\"1\":{\"528\":1}}],[\"应该得到的值为\",{\"1\":{\"340\":1}}],[\"应该返回5\",{\"1\":{\"95\":1}}],[\"应该返回1\",{\"1\":{\"95\":1}}],[\"应注意做到\",{\"1\":{\"316\":1}}],[\"应用优化\",{\"0\":{\"1745\":1},\"1\":{\"1743\":1}}],[\"应用\",{\"1\":{\"66\":1}}],[\"比使用xml\",{\"1\":{\"1913\":1}}],[\"比只存放key值的节点要得多\",{\"1\":{\"1626\":1}}],[\"比上图的nonf表中的skill技能这个字段\",{\"1\":{\"1464\":1}}],[\"比直接写makefile简单\",{\"1\":{\"1303\":1}}],[\"比auto\",{\"1\":{\"1046\":1}}],[\"比通过函数指针调用函数\",{\"1\":{\"982\":1}}],[\"比较复杂\",{\"1\":{\"1670\":1}}],[\"比较慢\",{\"1\":{\"1623\":1}}],[\"比较明显\",{\"1\":{\"1537\":1}}],[\"比较运算符\",{\"0\":{\"1471\":1}}],[\"比较性质\",{\"1\":{\"1171\":1}}],[\"比较完成后我们应该将链表恢复原样\",{\"1\":{\"756\":1}}],[\"比较it1与it2\",{\"1\":{\"747\":1}}],[\"比较小的那个进行\",{\"1\":{\"555\":1,\"556\":1}}],[\"比较lhs和rhs是否相同\",{\"1\":{\"535\":1}}],[\"比较两个字符串的时候使用a>b\",{\"1\":{\"368\":1}}],[\"比仅仅使用\",{\"0\":{\"271\":1}}],[\"比\",{\"1\":{\"262\":1}}],[\"比如订单表\",{\"1\":{\"1890\":1}}],[\"比如订单表按年份分成多个小表等\",{\"1\":{\"1776\":1}}],[\"比如text类型字段\",{\"1\":{\"1889\":1}}],[\"比如根据时间拆分\",{\"1\":{\"1886\":1}}],[\"比如2套1主2从\",{\"1\":{\"1803\":1}}],[\"比如通过从而可以进行缓存\",{\"1\":{\"1771\":1}}],[\"比如对一些很小的表\",{\"1\":{\"1713\":1}}],[\"比如对上面的对象数组进行delete\",{\"1\":{\"518\":1}}],[\"比如插入\",{\"1\":{\"1693\":1}}],[\"比如转账业务需要多条sql语句共同完成\",{\"1\":{\"1650\":1}}],[\"比如以name为索引\",{\"1\":{\"1623\":1}}],[\"比如我们给sex建立索引\",{\"1\":{\"1587\":1}}],[\"比如sql执行时间为10s\",{\"1\":{\"1551\":1}}],[\"比如age\",{\"1\":{\"1422\":1}}],[\"比如a派生出b\",{\"1\":{\"943\":1}}],[\"比如0\",{\"1\":{\"1239\":1}}],[\"比如全局搜索文件或字段\",{\"1\":{\"1140\":1}}],[\"比如说\",{\"1\":{\"1060\":1}}],[\"比如说不同厂家的汽车\",{\"1\":{\"866\":1}}],[\"比如在自己类里面设置为虚函数\",{\"1\":{\"876\":1}}],[\"比如在vs2013中\",{\"1\":{\"312\":1}}],[\"比如你可以把一个指向const对象的指针转换成指向非const对象的指针\",{\"1\":{\"628\":1}}],[\"比如下面的程序就会报错\",{\"1\":{\"588\":1}}],[\"比如置为nullptr\",{\"1\":{\"455\":1}}],[\"比如同是\",{\"1\":{\"449\":1}}],[\"比如当给computer类添加一个const的打印函数后\",{\"1\":{\"440\":1}}],[\"比如一个直线类line对象中包含两个point类对象\",{\"1\":{\"434\":1}}],[\"比如进程调度\",{\"1\":{\"303\":1}}],[\"比如怎么查询块的大小\",{\"1\":{\"285\":1}}],[\"比如\",{\"1\":{\"95\":1,\"274\":1,\"463\":2,\"575\":1,\"1603\":2,\"1736\":1,\"1829\":1}}],[\"比对后的结果以照片的形式保存在result文件夹内\",{\"1\":{\"5\":1}}],[\"升级\",{\"1\":{\"1331\":1}}],[\"升级版\",{\"0\":{\"95\":1,\"822\":1}}],[\"升序排序查询\",{\"1\":{\"1496\":1}}],[\"升序\",{\"1\":{\"87\":1,\"762\":1}}],[\"快照内容读取原则\",{\"1\":{\"1656\":1}}],[\"快照中只包含已commit的数据\",{\"1\":{\"1656\":1}}],[\"快照读\",{\"1\":{\"1656\":1,\"1664\":1,\"1679\":1,\"1680\":1}}],[\"快指针走两步\",{\"1\":{\"765\":1,\"768\":1}}],[\"快指针到尾部时停止\",{\"1\":{\"765\":1,\"768\":1}}],[\"快指针\",{\"1\":{\"765\":1}}],[\"快速插入海量数据\",{\"0\":{\"1523\":1}}],[\"快速排序\",{\"0\":{\"220\":1}}],[\"快速定位中间位置\",{\"1\":{\"91\":1}}],[\"快慢指针相遇\",{\"1\":{\"765\":1,\"768\":1}}],[\"快慢指针\",{\"0\":{\"148\":1},\"1\":{\"147\":1,\"756\":1}}],[\"快乐数\",{\"0\":{\"146\":1},\"1\":{\"146\":3}}],[\"快捷增加字体颜色\",{\"1\":{\"29\":2}}],[\"因而也具有更好的可读性和实用性\",{\"1\":{\"615\":1}}],[\"因此也不会使用行锁\",{\"1\":{\"1713\":1}}],[\"因此虽然访问的是innodb引擎下表的不同行\",{\"1\":{\"1713\":1}}],[\"因此做整表遍历和区间查找是非常容易的\",{\"1\":{\"1627\":1}}],[\"因此离根节点进的数据\",{\"1\":{\"1627\":1}}],[\"因此查询会更快一些\",{\"1\":{\"1627\":1}}],[\"因此b+树的每一个非叶子节点存储的关键字是远远多于b\",{\"1\":{\"1627\":1}}],[\"因此b+树理论上来说\",{\"1\":{\"1626\":1}}],[\"因此选b+树来构建索引\",{\"1\":{\"1626\":1}}],[\"因此一个节点\",{\"1\":{\"1626\":1}}],[\"因此一般数据量也不是很大\",{\"1\":{\"1604\":1}}],[\"因此存放的是数据在磁盘上的地址\",{\"1\":{\"1624\":1}}],[\"因此文本的搜索很少在后台数据库上搜索\",{\"1\":{\"1610\":1}}],[\"因此掌握良好的索引创建原则非常重要\",{\"1\":{\"1609\":1}}],[\"因此对索引的使用也会涉及\",{\"1\":{\"1609\":1}}],[\"因此只改变数据类型\",{\"1\":{\"1552\":1}}],[\"因此只有1行\",{\"1\":{\"1521\":1}}],[\"因此该设计不符合第三范式\",{\"1\":{\"1462\":1}}],[\"因此变量的值在赋值后就固定不变\",{\"1\":{\"1357\":1}}],[\"因此需要优化查询\",{\"1\":{\"1551\":1}}],[\"因此需要注意文件的安全性和隐私保护\",{\"1\":{\"1338\":1}}],[\"因此需要显式在line的构造函数初始化列表中初始化\",{\"1\":{\"434\":1}}],[\"因此必须能够处理这种不确定性\",{\"1\":{\"1333\":1}}],[\"因此代码可以被加载器加载到内存的任意位置并正确执行\",{\"1\":{\"1333\":1}}],[\"因此代理类在成员方法中可以控制委托类的成员方法访问权限\",{\"1\":{\"830\":1}}],[\"因此优化一下\",{\"1\":{\"1066\":1}}],[\"因此第一个参数的位置永远是ebp+8\",{\"1\":{\"1063\":1}}],[\"因此底层依赖vector\",{\"1\":{\"994\":1}}],[\"因此sizeof\",{\"1\":{\"955\":1}}],[\"因此data为数据的内容\",{\"1\":{\"1624\":1}}],[\"因此delete调用析构函数先去base中找base\",{\"1\":{\"948\":1}}],[\"因此d内存为20个字节\",{\"1\":{\"688\":1}}],[\"因此向上的偏移量为0\",{\"1\":{\"937\":1}}],[\"因此在b+树上搜索关键字\",{\"1\":{\"1627\":1}}],[\"因此在一个节点内的搜索是二分搜索log2n\",{\"1\":{\"1623\":1}}],[\"因此在调用时\",{\"1\":{\"1155\":1}}],[\"因此在使用上有一定限制\",{\"1\":{\"922\":1}}],[\"因此在预先知道它大小时性能最优\",{\"1\":{\"354\":1}}],[\"因此执行成功\",{\"1\":{\"908\":1}}],[\"因此发生动态绑定时\",{\"1\":{\"905\":1}}],[\"因此我们需要数据序列化将其转为字节流发送到对端主机\",{\"1\":{\"1896\":1}}],[\"因此我们需要绑定器\",{\"1\":{\"1008\":1}}],[\"因此我们应用在对数据库的多个表做更新的时候\",{\"1\":{\"1706\":1}}],[\"因此我们使用装饰器模式\",{\"1\":{\"831\":1}}],[\"因此我们定义指针时\",{\"1\":{\"410\":1}}],[\"因此崩溃\",{\"1\":{\"715\":2}}],[\"因此还要再多开辟一个4字节来存储对象的个数\",{\"1\":{\"715\":1}}],[\"因此a的成员在d实例化的对象的内存中存在两份\",{\"1\":{\"653\":1}}],[\"因此var引用的其实是这个临时变量\",{\"1\":{\"620\":1}}],[\"因此会出现链接错误\",{\"1\":{\"578\":1}}],[\"因此编译器必须提供这么一套称为\",{\"1\":{\"883\":1}}],[\"因此编译器在\",{\"1\":{\"876\":1}}],[\"因此编译器编译函数的过程中\",{\"1\":{\"577\":1}}],[\"因此编写了个小工具解放劳动力\",{\"1\":{\"3\":1}}],[\"因此参数列表不同\",{\"1\":{\"563\":1}}],[\"因此两个函数的参数列表是相同的\",{\"1\":{\"563\":1}}],[\"因此c语言不支持函数重载\",{\"1\":{\"562\":1}}],[\"因此q2不能\",{\"1\":{\"492\":1}}],[\"因此不会出现死锁\",{\"1\":{\"1706\":1}}],[\"因此不会生成\",{\"1\":{\"311\":1}}],[\"因此不能直接返回临时对象\",{\"1\":{\"1122\":1}}],[\"因此不能用作数组下标\",{\"1\":{\"483\":1}}],[\"因此不要使用一个appender加载到多个category中\",{\"1\":{\"1019\":1}}],[\"因此就不再满足我们的需求\",{\"1\":{\"426\":1}}],[\"因此构造了10个对象\",{\"1\":{\"382\":1}}],[\"因此这样的操作基本上是\",{\"1\":{\"354\":1}}],[\"因此实际上未存储的区域是浪费的\",{\"1\":{\"354\":1}}],[\"因此如果vector保存的数据量很大时会很消耗性能\",{\"1\":{\"354\":1}}],[\"因此可能涉及到多表查询\",{\"1\":{\"1535\":1}}],[\"因此可以加作用域进行访问\",{\"1\":{\"695\":1}}],[\"因此可以⽤\",{\"1\":{\"147\":1}}],[\"因此可看做动态数组\",{\"1\":{\"354\":1}}],[\"因此\",{\"1\":{\"147\":2,\"285\":1,\"425\":1,\"459\":1,\"538\":1,\"553\":1,\"577\":1,\"578\":1,\"665\":1,\"675\":1,\"826\":1,\"959\":1,\"981\":1,\"1524\":1,\"1623\":1,\"1626\":1,\"1627\":1,\"1649\":1,\"1719\":1}}],[\"因此算法的总体时间复杂度是\",{\"1\":{\"126\":1}}],[\"因为本身还是c接口\",{\"1\":{\"1849\":1,\"1859\":1,\"1875\":1}}],[\"因为我这里虚拟机用的是nat模式\",{\"1\":{\"1821\":1}}],[\"因为我们将逻辑表student分开映射到两台主机上\",{\"1\":{\"1891\":1}}],[\"因为我们的mysql\",{\"1\":{\"1802\":1}}],[\"因为我们select的时候\",{\"1\":{\"1701\":1}}],[\"因为我们给name加上了索引\",{\"1\":{\"1701\":1}}],[\"因为我们用哈希函数进行了计算\",{\"1\":{\"1603\":1}}],[\"因为我们用的是null空指针啊\",{\"1\":{\"528\":1}}],[\"因为我们调用的标准库函数的代码并不在\",{\"1\":{\"310\":1}}],[\"因为m1和m2之间也是配置成互为主从的\",{\"1\":{\"1791\":1}}],[\"因为myisam数据和索引是单独存放的\",{\"1\":{\"1558\":1}}],[\"因为mysql\",{\"1\":{\"1544\":1,\"1617\":1}}],[\"因为mycount类型就是一个cas原子操作\",{\"1\":{\"1233\":1}}],[\"因为通信都是遵守的是mysql通信协议\",{\"1\":{\"1791\":1}}],[\"因为和环境强相关了\",{\"1\":{\"1790\":1}}],[\"因为和es相比效率太低\",{\"1\":{\"1610\":1}}],[\"因为如果系统崩溃\",{\"1\":{\"1762\":1}}],[\"因为如果不这样做\",{\"1\":{\"943\":1}}],[\"因为状态并不是commit\",{\"1\":{\"1759\":1}}],[\"因为整个事务做的操作可能很多\",{\"1\":{\"1758\":1}}],[\"因为缓存区大了\",{\"1\":{\"1748\":1}}],[\"因为表中有两个索引\",{\"1\":{\"1720\":1}}],[\"因为当执行\",{\"1\":{\"1717\":1}}],[\"因为当用对象调用这些方法的时候\",{\"1\":{\"392\":1}}],[\"因为可重复读隔离级别下\",{\"1\":{\"1717\":1}}],[\"因为可能后期表结构会根据需求调整\",{\"1\":{\"1511\":1}}],[\"因为可能同时遇到更大和更小的数\",{\"1\":{\"214\":1}}],[\"因为不用去找表的某一行的记录进行加锁\",{\"1\":{\"1713\":1}}],[\"因为不知道新版本的库文件是否会产生bug\",{\"1\":{\"1332\":1}}],[\"因为不知道展开几次\",{\"1\":{\"502\":1}}],[\"因为此时已经被事务1的\",{\"1\":{\"1701\":1}}],[\"因为此刻内存上产生了临时变量保存了10\",{\"1\":{\"620\":1}}],[\"因为现在name走的是索引\",{\"1\":{\"1700\":1}}],[\"因为在这种情况下\",{\"1\":{\"1693\":1}}],[\"因为在进行数据拷贝时候\",{\"1\":{\"401\":1}}],[\"因为主键id不能重复\",{\"1\":{\"1692\":1}}],[\"因为主线程join了\",{\"1\":{\"1206\":1}}],[\"因为快照上根本就没有id=24的数据\",{\"1\":{\"1665\":1}}],[\"因为每一个连接都会占用一个socket资源\",{\"1\":{\"1865\":1}}],[\"因为每一次select都会重新产生1次数据快照\",{\"1\":{\"1659\":1}}],[\"因为每循环依次\",{\"1\":{\"1099\":1}}],[\"因为速度快\",{\"1\":{\"1645\":1}}],[\"因为事务要能够允许并发执行\",{\"1\":{\"1711\":1}}],[\"因为事务的并发效率比表锁更高\",{\"1\":{\"1670\":1}}],[\"因为事务\",{\"1\":{\"1663\":1}}],[\"因为事务已经commit\",{\"1\":{\"1639\":1}}],[\"因为事务没有commit\",{\"1\":{\"1639\":1}}],[\"因为b+树是平衡树\",{\"1\":{\"1626\":1}}],[\"因为使用索引的步骤比较繁琐\",{\"1\":{\"1617\":1}}],[\"因为数据要保存一致性\",{\"1\":{\"1885\":1}}],[\"因为数据库不仅仅要更新数据\",{\"1\":{\"1609\":1}}],[\"因为数组都是\",{\"1\":{\"170\":1}}],[\"因为内存搜索\",{\"1\":{\"1601\":1}}],[\"因为搜索引擎是innodb\",{\"1\":{\"1600\":1}}],[\"因为小表永远整表扫描\",{\"1\":{\"1537\":1}}],[\"因为会涉及\",{\"1\":{\"1511\":1}}],[\"因为后面可以会涉及字段的增删\",{\"1\":{\"1475\":1}}],[\"因为其长度固定\",{\"1\":{\"1426\":2}}],[\"因为其被const修饰成常量引用了\",{\"1\":{\"620\":1}}],[\"因为链接器可以使用索引来快速找到库中的特定符号\",{\"1\":{\"1334\":1}}],[\"因为共享库在加载到内存时\",{\"1\":{\"1333\":1}}],[\"因为线程的创建和销毁是很耗费性能的\",{\"1\":{\"1753\":1}}],[\"因为线程就像人一样\",{\"1\":{\"1233\":1}}],[\"因为线程都是并行执行的\",{\"1\":{\"1208\":1}}],[\"因为代码之间可能由于逻辑走掉了\",{\"1\":{\"1225\":1}}],[\"因为代理类和委托类都继承重写了基类的所有方法\",{\"1\":{\"830\":1}}],[\"因为lock\",{\"1\":{\"1219\":1,\"1227\":1}}],[\"因为谁也不知道当时线程执行的先后顺序\",{\"1\":{\"1218\":1}}],[\"因为vector存储的是指针\",{\"1\":{\"1151\":1}}],[\"因为vbptr在该派生类内存起始部分\",{\"1\":{\"937\":1}}],[\"因为要经过磁盘i\",{\"1\":{\"1645\":1}}],[\"因为要用到拷贝构造函数和赋值函数\",{\"1\":{\"1226\":1,\"1228\":1}}],[\"因为要从容器拿1个元素和它指定的元素比较\",{\"1\":{\"1148\":1}}],[\"因为要修改静态链表\",{\"1\":{\"1093\":1}}],[\"因为一次需要从容器中拿2个函数对象出来\",{\"1\":{\"1147\":1}}],[\"因为一旦我们要使用val的右值引用就必须给它\",{\"1\":{\"1127\":1}}],[\"因为一旦有人要创建这些中间类的对象\",{\"1\":{\"943\":1}}],[\"因为对象存放一个动态开辟的char数组\",{\"1\":{\"1120\":1}}],[\"因为a在赋值时b还未定义\",{\"1\":{\"1357\":1}}],[\"因为aux\",{\"1\":{\"1312\":1}}],[\"因为a\",{\"1\":{\"1114\":1}}],[\"因为引用相当于是别名\",{\"1\":{\"1113\":1}}],[\"因为引用的符号都不知道在哪里定义的\",{\"1\":{\"249\":1}}],[\"因为tmp和t2是两个不同函数栈帧上的对象\",{\"1\":{\"1115\":1}}],[\"因为t4原本已存在\",{\"1\":{\"1111\":1}}],[\"因为t3还没有生成\",{\"1\":{\"1110\":1,\"1111\":1}}],[\"因为元素为指针\",{\"1\":{\"1102\":1}}],[\"因为从os申请空间的时候就是按照8的整数申请的\",{\"1\":{\"1102\":1}}],[\"因为容器申请只是申请一个内存块\",{\"1\":{\"1102\":1}}],[\"因为没内存了\",{\"1\":{\"1102\":1}}],[\"因为没有东西因此默认给1字节的内存用于构造对象\",{\"1\":{\"1073\":1}}],[\"因为第一个chunk块要被分配出去了\",{\"1\":{\"1096\":1}}],[\"因为大于128字节的是由malloc分配\",{\"1\":{\"1093\":1}}],[\"因为参数压完后又压入了下一行指令的地址以及调用函数栈底指针\",{\"1\":{\"1063\":1}}],[\"因为参数列表不同\",{\"1\":{\"563\":1}}],[\"因为自己要改变指向了\",{\"1\":{\"1055\":1}}],[\"因为printf导致io中断\",{\"1\":{\"1020\":1}}],[\"因为p是一个指针常量\",{\"1\":{\"625\":1}}],[\"因为为动态绑定最后成功调用派生类的show\",{\"1\":{\"907\":1}}],[\"因为析构函数调用的时候\",{\"1\":{\"877\":1}}],[\"因为构造函数本来是为了初始化对象成员才产生的\",{\"1\":{\"876\":1}}],[\"因为有产品簇\",{\"1\":{\"867\":1}}],[\"因为委托类是包含所有功能的\",{\"1\":{\"830\":1}}],[\"因为头节点有可能发生变化\",{\"1\":{\"802\":1}}],[\"因为删除元素需要知道前一个元素的位置\",{\"1\":{\"774\":1}}],[\"因为基类中没有默认的构造函数\",{\"1\":{\"672\":1}}],[\"因为涉及到参数的入栈出栈\",{\"1\":{\"640\":1}}],[\"因为声明时已经给编译器一个该函数的向导\",{\"1\":{\"639\":1}}],[\"因为它不需要参与查询\",{\"1\":{\"1618\":1}}],[\"因为它可以帮助他们了解程序崩溃时的状态\",{\"1\":{\"1338\":1}}],[\"因为它可以在任意类型之间转换\",{\"1\":{\"628\":1}}],[\"因为它们通常更小\",{\"1\":{\"1335\":1}}],[\"因为它是连续存储\",{\"1\":{\"354\":1}}],[\"因为右值引用会产生一个临时量\",{\"1\":{\"621\":1}}],[\"因为右边界取不到\",{\"1\":{\"94\":1}}],[\"因为立即数并没有在内存中存储\",{\"1\":{\"620\":1}}],[\"因为10无法进行取地址操作\",{\"1\":{\"620\":1}}],[\"因为返回的是引用\",{\"1\":{\"616\":1}}],[\"因为static用在不同的地方\",{\"1\":{\"591\":1}}],[\"因为set比数组占用的空间大\",{\"1\":{\"104\":1,\"107\":1,\"110\":1}}],[\"因为包含了头文件\",{\"1\":{\"576\":1}}],[\"因为函数对象是用类生成的\",{\"1\":{\"982\":1}}],[\"因为函数符号的生成与返回值没有关系\",{\"1\":{\"563\":1}}],[\"因为函数不能这么写\",{\"1\":{\"515\":1}}],[\"因为任何指针变量\",{\"1\":{\"531\":1}}],[\"因为0是空指针\",{\"1\":{\"528\":1}}],[\"因为null不够\",{\"1\":{\"528\":1}}],[\"因为qcun\",{\"1\":{\"492\":1}}],[\"因为q期望的是一个指向const\",{\"1\":{\"490\":1}}],[\"因为解引用会修改const的值\",{\"1\":{\"491\":1}}],[\"因为这块代码无法闭合\",{\"1\":{\"1168\":1}}],[\"因为这样做增加了对数据的保护\",{\"1\":{\"490\":1}}],[\"因为这个是字符串常量\",{\"1\":{\"267\":1}}],[\"因为只有这样同时移动的时候slow才能指向删除节点的上一个节点\",{\"1\":{\"774\":1}}],[\"因为只有这样才能一下定位出数组的中间位置\",{\"1\":{\"91\":1}}],[\"因为只有运行时才知道变量的值是多少\",{\"1\":{\"484\":1}}],[\"因为c\",{\"1\":{\"1063\":1}}],[\"因为c++中函数声明生成符号带参数类型\",{\"1\":{\"568\":1}}],[\"因为c++中不能将void\",{\"1\":{\"527\":1}}],[\"因为c++程序经常要调用c函数\",{\"1\":{\"514\":1}}],[\"因为c++头文件都是用模板写的\",{\"1\":{\"476\":1}}],[\"因为const对象只能被\",{\"1\":{\"454\":1}}],[\"因为const成员的this指针类型为const\",{\"1\":{\"441\":1}}],[\"因为静态数据成员不属于类的任何一个对象\",{\"1\":{\"435\":1}}],[\"因为编译器在自动生成构造函数的过程中会尝试调用基类的构造函数\",{\"1\":{\"423\":1}}],[\"因为是循环队列\",{\"1\":{\"406\":1}}],[\"因为已经满了\",{\"1\":{\"406\":1}}],[\"因为if分支后面有两个语句\",{\"1\":{\"273\":1}}],[\"因为\",{\"1\":{\"240\":1,\"301\":1,\"599\":1,\"876\":1,\"1114\":1,\"1749\":1}}],[\"因为ebp作为一个用于寻址的固定值是有时间周期的\",{\"1\":{\"235\":1}}],[\"因为ebp为32位\",{\"1\":{\"233\":1}}],[\"因为栈向低地址扩充\",{\"1\":{\"233\":1}}],[\"因为缺少源代码信息\",{\"1\":{\"228\":1}}],[\"保持数据一致\",{\"1\":{\"1885\":1}}],[\"保留的类型\",{\"1\":{\"1168\":1}}],[\"保留\",{\"1\":{\"795\":1}}],[\"保护型\",{\"1\":{\"657\":1}}],[\"保护数据成员和成员函数\",{\"1\":{\"449\":1}}],[\"保证数据的完整性\",{\"1\":{\"1758\":1}}],[\"保证数据安全\",{\"1\":{\"1644\":1}}],[\"保证事务出错回滚或者我们手动\",{\"1\":{\"1680\":1}}],[\"保证事务再次读取是依然得到相同的数据\",{\"1\":{\"1677\":1}}],[\"保证事务执行的原子性\",{\"1\":{\"1649\":1}}],[\"保证我们代码的正确性\",{\"1\":{\"1233\":1}}],[\"保证临界区代码段原子操作\",{\"1\":{\"1217\":1}}],[\"保证每个资源变量每时每刻至多被一个线程占用\",{\"1\":{\"840\":1}}],[\"保证一个类只能产生一个实例\",{\"1\":{\"836\":1}}],[\"保证string类中\",{\"1\":{\"736\":1}}],[\"保证string没有空\",{\"1\":{\"736\":1}}],[\"保证了引用传递的安全性\",{\"1\":{\"617\":1}}],[\"保证了若是以c++编译该该代码\",{\"1\":{\"570\":1}}],[\"保证\",{\"1\":{\"485\":1}}],[\"保证相同值的前后顺序\",{\"1\":{\"213\":1}}],[\"保证有序\",{\"1\":{\"87\":1}}],[\"保存的数组是值\",{\"1\":{\"1899\":1}}],[\"保存的对象是一个无序的名称\",{\"1\":{\"1899\":1}}],[\"保存的是专门为分配对应字节的一大块内存空闲位置的起始地址\",{\"1\":{\"1102\":1}}],[\"保存了事务发生之前的\",{\"1\":{\"1679\":1}}],[\"保存所有版本的库文件\",{\"1\":{\"1332\":1}}],[\"保存一份下载链接文件\",{\"1\":{\"1250\":1}}],[\"保存当前还未分配出去\",{\"1\":{\"1093\":1}}],[\"保存当前内存块的内存控制结构\",{\"1\":{\"286\":1}}],[\"保存最小值\",{\"1\":{\"1076\":1}}],[\"保存满足条件的内存块的地址用于函数返回\",{\"1\":{\"286\":1}}],[\"保存并重启typora\",{\"1\":{\"63\":1}}],[\"保存\",{\"1\":{\"62\":2,\"1898\":2}}],[\"保存退出\",{\"1\":{\"61\":1,\"1408\":1}}],[\"①聚合查询2\",{\"1\":{\"1502\":1}}],[\"①聚合查询1\",{\"1\":{\"1502\":1}}],[\"①iterator\",{\"1\":{\"969\":1,\"970\":1}}],[\"①size\",{\"1\":{\"965\":1,\"969\":1,\"970\":1}}],[\"①operator\",{\"1\":{\"965\":1}}],[\"①pop\",{\"1\":{\"965\":1,\"969\":1,\"970\":1}}],[\"①push\",{\"1\":{\"965\":1,\"969\":1,\"970\":1}}],[\"①delete\",{\"1\":{\"523\":1}}],[\"①free不管释放单个元素内存还是数组内存\",{\"1\":{\"513\":1,\"708\":1}}],[\"①malloc按字节开辟内存的\",{\"1\":{\"513\":1,\"708\":1}}],[\"①需要我们把与分开处理了\",{\"1\":{\"384\":1}}],[\"①定义容器对象时\",{\"1\":{\"383\":1}}],[\"①②可合并到③\",{\"1\":{\"87\":1}}],[\"①全正\",{\"1\":{\"87\":1}}],[\"有什么错误\",{\"1\":{\"1830\":1}}],[\"有3种情况\",{\"1\":{\"1791\":1}}],[\"有专门的线程去做把buffer\",{\"1\":{\"1758\":1}}],[\"有两种排序算法\",{\"1\":{\"1736\":1}}],[\"有两个形参变量\",{\"1\":{\"1188\":2}}],[\"有两个load\",{\"1\":{\"262\":1}}],[\"有索引\",{\"0\":{\"1689\":1},\"1\":{\"1702\":1}}],[\"有索引则加载索引\",{\"1\":{\"1623\":1}}],[\"有四个重要的字段\",{\"1\":{\"1656\":1}}],[\"有四个命令\",{\"1\":{\"1407\":1}}],[\"有sql出现错误\",{\"1\":{\"1649\":1}}],[\"有连接查询时\",{\"1\":{\"1618\":1}}],[\"有没有索引没意义\",{\"1\":{\"1537\":1}}],[\"有没有合适的\",{\"1\":{\"1112\":1}}],[\"有没有合适的构造函数\",{\"1\":{\"1112\":1}}],[\"有过滤条件\",{\"1\":{\"1492\":1,\"1494\":1}}],[\"有头文件的情况\",{\"0\":{\"1367\":1}}],[\"有头结点的注意一下\",{\"1\":{\"821\":1}}],[\"有更宽松的尺度\",{\"1\":{\"1333\":1}}],[\"有时候索引占用的空间甚至比数据占用的空间还多\",{\"1\":{\"1609\":1}}],[\"有时候需要实现几个功能类似的函数\",{\"1\":{\"560\":1}}],[\"有时编译程序时想添加一些编译选项\",{\"1\":{\"1317\":1}}],[\"有助于提高\",{\"1\":{\"1232\":1}}],[\"有返回值\",{\"1\":{\"1188\":1}}],[\"有部分特例化\",{\"1\":{\"1186\":1}}],[\"有完全特例化\",{\"1\":{\"1186\":1}}],[\"有参函数类型\",{\"0\":{\"1165\":1}}],[\"有默认值\",{\"1\":{\"1115\":1}}],[\"有\",{\"1\":{\"1112\":1}}],[\"有一个返回值\",{\"1\":{\"1188\":1}}],[\"有一个string形参变量的函数类型\",{\"1\":{\"1154\":1}}],[\"有一个异常处理的过程\",{\"1\":{\"1105\":1}}],[\"有一个疑问\",{\"1\":{\"1102\":1}}],[\"有一个数组其中每一个对象都要进行析构\",{\"1\":{\"715\":1}}],[\"有basiclayout\",{\"1\":{\"1021\":1}}],[\"有bug会到运行时才会发现\",{\"1\":{\"497\":1}}],[\"有bug编译时报错\",{\"1\":{\"481\":1}}],[\"有bug运行时才会报错\",{\"1\":{\"481\":1}}],[\"有点类似于java的单继承结构\",{\"1\":{\"1018\":1}}],[\"有许多重复的元素\",{\"1\":{\"999\":1}}],[\"有序索引顺序扫描直接返回有序数据\",{\"1\":{\"1736\":1}}],[\"有序的容器进行二分查找\",{\"1\":{\"1007\":1}}],[\"有序关联容器包含的头文件\",{\"1\":{\"1002\":1}}],[\"有序关联容器\",{\"0\":{\"997\":1,\"1002\":1},\"1\":{\"1002\":1}}],[\"有序数组\",{\"1\":{\"100\":1}}],[\"有序数组的平方\",{\"0\":{\"87\":1},\"1\":{\"87\":1}}],[\"有序数组nums\",{\"1\":{\"84\":1}}],[\"有virtual\",{\"1\":{\"906\":1}}],[\"有关联关系的系列产品\",{\"1\":{\"867\":1}}],[\"有相关联的产品簇都是在一个工厂完成创建的\",{\"1\":{\"866\":1}}],[\"有相同的数字\",{\"0\":{\"169\":1},\"1\":{\"110\":1,\"169\":1}}],[\"有析构函数\",{\"1\":{\"715\":1}}],[\"有的过程\",{\"1\":{\"1713\":1}}],[\"有的人描述的是\",{\"1\":{\"1464\":1}}],[\"有的人是\",{\"1\":{\"1464\":1}}],[\"有的结构\",{\"1\":{\"1373\":1}}],[\"有的时候用c风格的转换是不合适的\",{\"1\":{\"628\":1}}],[\"有的编译器\",{\"1\":{\"234\":1}}],[\"有名字的\",{\"1\":{\"621\":1}}],[\"有名字的内存空间\",{\"1\":{\"315\":1}}],[\"有名字\",{\"1\":{\"620\":2}}],[\"有内存地址\",{\"1\":{\"620\":2}}],[\"有内存对齐\",{\"1\":{\"433\":1}}],[\"有很多的说法\",{\"1\":{\"614\":1}}],[\"有了\",{\"1\":{\"1836\":1}}],[\"有了对象池后\",{\"1\":{\"751\":1}}],[\"有了第二种用法\",{\"1\":{\"612\":1}}],[\"有了自己定义的类\",{\"1\":{\"453\":1}}],[\"有些也在\",{\"1\":{\"1372\":1}}],[\"有些时候makefile文件的名字不希望以makefile或者makefile来命名\",{\"1\":{\"1363\":1}}],[\"有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求\",{\"1\":{\"1255\":1}}],[\"有些异常是系统自动抛出\",{\"1\":{\"605\":1}}],[\"有些公司不让用goto\",{\"1\":{\"277\":1}}],[\"有可能和前面的快照相同\",{\"1\":{\"1658\":1}}],[\"有可能a原本有20行\",{\"1\":{\"1537\":1}}],[\"有可能没有被释放\",{\"1\":{\"1057\":1}}],[\"有可能提升成功\",{\"1\":{\"1057\":2}}],[\"有可能会与std中的实体冲突\",{\"1\":{\"594\":1}}],[\"有可能还是会造成名字冲突的问题\",{\"1\":{\"588\":1}}],[\"有可能我们自己定义的名字会与c++库中的名字发生冲突\",{\"1\":{\"582\":1}}],[\"有可能在不同的头文件中用了相同的名字来命名所定义的类或函数\",{\"1\":{\"582\":1}}],[\"有好多其他变量呢\",{\"1\":{\"576\":1}}],[\"有几种new的方式\",{\"0\":{\"511\":1}}],[\"有共同点\",{\"1\":{\"449\":1}}],[\"有4种比较特殊的数据成员\",{\"1\":{\"431\":1}}],[\"有严格的类型检查\",{\"1\":{\"359\":1}}],[\"有效\",{\"1\":{\"790\":1}}],[\"有效元素\",{\"1\":{\"355\":1,\"385\":2,\"704\":2}}],[\"有效的字母异位词\",{\"0\":{\"166\":1},\"1\":{\"166\":1}}],[\"有符号溢出\",{\"0\":{\"333\":1}}],[\"有符号整型\",{\"0\":{\"330\":1}}],[\"有同学可能想\",{\"1\":{\"135\":1}}],[\"有小伙伴问我模板格式是什么样的\",{\"1\":{\"6\":1}}],[\"循环开始do\",{\"1\":{\"1523\":1}}],[\"循环条件i<n\",{\"1\":{\"1523\":1}}],[\"循环打印获取的记录\",{\"1\":{\"1385\":1}}],[\"循环\",{\"0\":{\"1362\":1}}],[\"循环链表结束条件\",{\"1\":{\"819\":1}}],[\"循环链表\",{\"2\":{\"814\":1}}],[\"循环里\",{\"1\":{\"802\":1}}],[\"循环队列\",{\"1\":{\"406\":1}}],[\"循环中it\",{\"1\":{\"698\":1}}],[\"循环中\",{\"1\":{\"277\":1}}],[\"循环次数\",{\"1\":{\"81\":1}}],[\"循环不变量\",{\"1\":{\"81\":1}}],[\"前后两次相同的查询语句\",{\"1\":{\"1686\":1}}],[\"前后两次同样的查询\",{\"1\":{\"1635\":1}}],[\"前已经提交的事务生成的\",{\"1\":{\"1656\":1}}],[\"前一个标签\",{\"1\":{\"1137\":1}}],[\"前中后删除元素的时间复杂度\",{\"1\":{\"973\":1}}],[\"前\",{\"1\":{\"792\":1,\"1114\":1}}],[\"前进一步\",{\"1\":{\"765\":1}}],[\"前⼀个const为底层\",{\"1\":{\"489\":1}}],[\"前言\",{\"0\":{\"281\":1,\"299\":1}}],[\"前提条件\",{\"1\":{\"267\":1}}],[\"前提编译时\",{\"1\":{\"234\":1,\"260\":1}}],[\"前面\",{\"1\":{\"1693\":1}}],[\"前面我们建立的软链接\",{\"1\":{\"1306\":1}}],[\"前面是通过lock\",{\"1\":{\"1232\":1}}],[\"前面在进行卖票操作时\",{\"1\":{\"1232\":1}}],[\"前面的智能指针全部被置为nullptr\",{\"1\":{\"1044\":1}}],[\"前面的元素不满足条件\",{\"1\":{\"162\":1}}],[\"前面有元素出队\",{\"1\":{\"406\":1}}],[\"前面符号的指令值都是全0\",{\"1\":{\"255\":1}}],[\"前面都是全0\",{\"1\":{\"255\":1}}],[\"前闭后开\",{\"1\":{\"81\":1}}],[\"前端工具\",{\"1\":{\"0\":1}}],[\"前端框架\",{\"1\":{\"0\":1}}],[\"左开右闭\",{\"1\":{\"1688\":1}}],[\"左边匹配右边\",{\"1\":{\"1544\":1}}],[\"左边的时候\",{\"1\":{\"497\":2}}],[\"左连接表边表全扫描\",{\"1\":{\"1544\":1}}],[\"左连接\",{\"1\":{\"1536\":1}}],[\"左表和右表数据全部都存在\",{\"1\":{\"1500\":1}}],[\"左表匹配右表过滤后的结果若匹配成功\",{\"1\":{\"1500\":1}}],[\"左表\",{\"1\":{\"1500\":9,\"1501\":3}}],[\"左表过滤的结果必须全部存在\",{\"1\":{\"1500\":1}}],[\"左外连接使用的十分多\",{\"1\":{\"1500\":1}}],[\"左外连接查询\",{\"0\":{\"1543\":1},\"1\":{\"1500\":1}}],[\"左孩子为2i+1\",{\"1\":{\"994\":1}}],[\"左值\",{\"1\":{\"620\":2,\"1127\":1}}],[\"左值引用参数的拷贝构造函数和赋值重载函数删除\",{\"1\":{\"1212\":1}}],[\"左值引用\",{\"0\":{\"620\":1},\"1\":{\"1127\":1}}],[\"左右\",{\"1\":{\"1617\":1}}],[\"左右对象共享\",{\"1\":{\"433\":1}}],[\"左右指针\",{\"1\":{\"126\":1}}],[\"左键点击断点就可以取消断点\",{\"1\":{\"306\":1}}],[\"左闭右开\",{\"0\":{\"94\":1},\"1\":{\"97\":1}}],[\"左闭右闭\",{\"0\":{\"93\":1},\"1\":{\"97\":1,\"142\":1}}],[\"左\",{\"1\":{\"81\":1}}],[\"右中括号\",{\"1\":{\"1899\":1}}],[\"右括号\",{\"1\":{\"1899\":1}}],[\"右连接右边表全扫描\",{\"1\":{\"1544\":1}}],[\"右连接\",{\"1\":{\"1536\":1}}],[\"右对应一边不存在则补空\",{\"1\":{\"1500\":1}}],[\"右外连接使用的不是非常多\",{\"1\":{\"1500\":1}}],[\"右外连接查询\",{\"0\":{\"1544\":1},\"1\":{\"1500\":1}}],[\"右表过滤的结果必须全部存在\",{\"1\":{\"1500\":1}}],[\"右表\",{\"1\":{\"1500\":6,\"1501\":2}}],[\"右表匹配左表过滤后的结果若匹配成功\",{\"1\":{\"1500\":1}}],[\"右边都被上了锁\",{\"1\":{\"1689\":1}}],[\"右边的客户端update左侧客户端insert的数据\",{\"1\":{\"1635\":1}}],[\"右边的时候\",{\"1\":{\"497\":1}}],[\"右边匹配左边\",{\"1\":{\"1544\":1}}],[\"右边是得到unique\",{\"1\":{\"1047\":1}}],[\"右孩子为2i+2\",{\"1\":{\"994\":1}}],[\"右孩子存在且比左孩子大\",{\"1\":{\"194\":1}}],[\"右侧事务无法查询到左侧事务insert的数据\",{\"1\":{\"1635\":1}}],[\"右侧的变量类型决定的\",{\"1\":{\"700\":1}}],[\"右侧项目代码\",{\"1\":{\"311\":1}}],[\"右值引用的赋值重载\",{\"1\":{\"1212\":1}}],[\"右值引用的拷贝构造\",{\"1\":{\"1212\":1}}],[\"右值引用的拷贝\",{\"1\":{\"1124\":1}}],[\"右值引用+左值引用=左值引用\",{\"1\":{\"1127\":1}}],[\"右值引用+右值引用=右值引用\",{\"1\":{\"1127\":1}}],[\"右值引用本身是一个左值\",{\"1\":{\"622\":1}}],[\"右值引用只能用来引用右值类型int\",{\"1\":{\"622\":1}}],[\"右值引用只能引用右值\",{\"1\":{\"621\":1}}],[\"右值引用可以修改值\",{\"1\":{\"621\":1}}],[\"右值引用\",{\"0\":{\"621\":1},\"1\":{\"621\":1,\"624\":1,\"1121\":2,\"1194\":2}}],[\"右值\",{\"1\":{\"476\":1,\"1127\":1}}],[\"右\",{\"1\":{\"81\":1}}],[\"右键项目\",{\"1\":{\"1855\":3}}],[\"右键这个图标\",{\"1\":{\"66\":1}}],[\"右键选择打开方式\",{\"1\":{\"61\":1}}],[\"右键图标\",{\"1\":{\"61\":1}}],[\"右键新建文件中没有\",{\"0\":{\"44\":1}}],[\"开放3306端口\",{\"1\":{\"1818\":1}}],[\"开销大\",{\"1\":{\"1713\":1}}],[\"开销小\",{\"1\":{\"1713\":1}}],[\"开头必须用tab键\",{\"1\":{\"1368\":1}}],[\"开启binlog\",{\"1\":{\"1832\":1}}],[\"开启主从复制的权限\",{\"1\":{\"1821\":1}}],[\"开启二进制日志后需要重启mysql服务\",{\"1\":{\"1820\":1}}],[\"开启二进制日志\",{\"0\":{\"1820\":1}}],[\"开启防火墙3306端口\",{\"1\":{\"1818\":1}}],[\"开启查询日志io太多导致mysql效率低\",{\"1\":{\"1771\":1}}],[\"开启查询日志io太多导致mysql效率低下\",{\"1\":{\"1767\":1}}],[\"开启事务\",{\"1\":{\"1708\":1}}],[\"开启一个事务\",{\"1\":{\"1640\":1}}],[\"开启消费者线程\",{\"1\":{\"1219\":2}}],[\"开启生产者线程\",{\"1\":{\"1219\":2}}],[\"开启线程池\",{\"1\":{\"1151\":1}}],[\"开空间出来还是得\",{\"1\":{\"518\":1}}],[\"开发的程序\",{\"1\":{\"302\":1}}],[\"开辟数组时\",{\"1\":{\"512\":1}}],[\"开辟一个数组的空间\",{\"0\":{\"512\":1}}],[\"开辟一个元素的空间\",{\"0\":{\"510\":1}}],[\"开辟失败判断情况与malloc一样\",{\"1\":{\"511\":1}}],[\"开辟1个字节大小的空间\",{\"1\":{\"405\":1}}],[\"开辟了函数的栈帧\",{\"1\":{\"238\":1}}],[\"开辟的栈空间返回给系统\",{\"1\":{\"234\":1}}],[\"开始\",{\"1\":{\"1899\":2}}],[\"开始循环不加分号\",{\"1\":{\"1523\":1}}],[\"开始执行程序\",{\"1\":{\"1340\":1}}],[\"开始的指令\",{\"1\":{\"1348\":1}}],[\"开始的子链表\",{\"1\":{\"787\":1}}],[\"开始的整数数组\",{\"1\":{\"140\":1}}],[\"开始删除jump\",{\"1\":{\"59\":1}}],[\"开\",{\"1\":{\"81\":4,\"1168\":1}}],[\"到这里我们知道\",{\"1\":{\"1818\":1}}],[\"到这里\",{\"1\":{\"1774\":1}}],[\"到这里21字节\",{\"1\":{\"557\":1}}],[\"到磁盘上的redo\",{\"1\":{\"1762\":1}}],[\"到最初的状态\",{\"1\":{\"1649\":1}}],[\"到阻塞状态\",{\"1\":{\"1219\":2,\"1229\":1}}],[\"到备用内存中拿\",{\"1\":{\"1102\":1}}],[\"到位置\",{\"1\":{\"801\":1}}],[\"到using所在的作用域结束\",{\"1\":{\"590\":1}}],[\"到运行时才发现\",{\"1\":{\"359\":1}}],[\"到此已经得到所要的内存块\",{\"1\":{\"286\":1}}],[\"到底从哪里得到了内存空间\",{\"1\":{\"282\":1}}],[\"到\",{\"1\":{\"81\":4,\"741\":2,\"1308\":1,\"1317\":1,\"1318\":2}}],[\"闭原则\",{\"1\":{\"866\":1,\"1168\":1}}],[\"闭\",{\"1\":{\"81\":4}}],[\"行级锁\",{\"0\":{\"1713\":1},\"1\":{\"1713\":1}}],[\"行锁\",{\"1\":{\"1706\":1,\"1719\":2}}],[\"行代码就是被跳过的代码\",{\"1\":{\"599\":1}}],[\"行的\",{\"1\":{\"599\":1}}],[\"行为型模式\",{\"1\":{\"871\":2}}],[\"行为\",{\"1\":{\"446\":1,\"449\":1}}],[\"行\",{\"1\":{\"302\":1}}],[\"行号从\",{\"1\":{\"81\":2}}],[\"行号不变\",{\"1\":{\"81\":2}}],[\"行高\",{\"1\":{\"50\":1}}],[\"位的成员离开圆桌\",{\"1\":{\"812\":1}}],[\"位的符号位\",{\"1\":{\"339\":1}}],[\"位\",{\"1\":{\"340\":1}}],[\"位于辅助索引树中\",{\"1\":{\"1689\":1}}],[\"位于最外层的单位查询的select\",{\"1\":{\"1618\":1}}],[\"位于异常点之后的\",{\"1\":{\"599\":1}}],[\"位于args右边的时候叫做解包\",{\"1\":{\"378\":1}}],[\"位于\",{\"1\":{\"234\":1}}],[\"位置开始\",{\"1\":{\"81\":1}}],[\"位操作判断奇偶性比\",{\"1\":{\"70\":1}}],[\"位操作一定加括号\",{\"1\":{\"70\":1}}],[\"螺旋矩阵ⅱ\",{\"0\":{\"81\":1},\"1\":{\"81\":2}}],[\"则表示机器故障\",{\"1\":{\"1803\":1}}],[\"则表示正常工作\",{\"1\":{\"1803\":1}}],[\"则记录状态为prepare\",{\"1\":{\"1759\":1}}],[\"则db连接将在30分钟内关闭\",{\"1\":{\"1754\":1}}],[\"则dosomething中的第二个语句无论if测试是否通过\",{\"1\":{\"273\":1}}],[\"则可插入\",{\"1\":{\"1689\":1}}],[\"则可称为候选键\",{\"1\":{\"1463\":1}}],[\"则提交这个事务\",{\"1\":{\"1652\":1}}],[\"则显示null\",{\"1\":{\"1543\":1,\"1544\":1}}],[\"则此表不符合bc范式\",{\"1\":{\"1463\":1}}],[\"则设计成一对多的实体关系\",{\"1\":{\"1460\":1,\"1461\":1}}],[\"则进入mysql的安装步骤\",{\"0\":{\"1390\":1}}],[\"则进行动态绑定\",{\"1\":{\"954\":1}}],[\"则进行静态绑定\",{\"1\":{\"954\":1}}],[\"则为0\",{\"1\":{\"1378\":1}}],[\"则应该使用mysql\",{\"1\":{\"1376\":1}}],[\"则替换它们\",{\"1\":{\"1334\":1}}],[\"则替换它\",{\"1\":{\"1334\":2}}],[\"则使用水平拆分\",{\"1\":{\"1886\":1}}],[\"则使用垂直拆分\",{\"1\":{\"1886\":1}}],[\"则使用表锁\",{\"1\":{\"1702\":1}}],[\"则使用行锁\",{\"1\":{\"1702\":1}}],[\"则使用\",{\"1\":{\"1261\":1}}],[\"则抛出异常\",{\"1\":{\"1102\":1}}],[\"则再次尝试正常申请内存\",{\"1\":{\"1102\":1}}],[\"则分配一个大块的空闲内存\",{\"1\":{\"1102\":1}}],[\"则直接malloc\",{\"1\":{\"1105\":1}}],[\"则直接分出去20\",{\"1\":{\"1102\":1}}],[\"则直接返回\",{\"1\":{\"214\":1}}],[\"则ret指向链表的第一个节点\",{\"1\":{\"1096\":1}}],[\"则所有emerg\",{\"1\":{\"1025\":1}}],[\"则严重干扰了线程间的运行方式\",{\"1\":{\"1020\":1}}],[\"则根据派生类前四个字节获取获取虚函数表指针\",{\"1\":{\"959\":1}}],[\"则编译器会调用虚基类的缺省构造函数\",{\"1\":{\"943\":1}}],[\"则最底层的子类要负责完成该虚基类部分成员的构造\",{\"1\":{\"943\":1}}],[\"则创建c对象时\",{\"1\":{\"943\":1}}],[\"则创建派生类的对象时\",{\"1\":{\"669\":1,\"671\":1}}],[\"则删除链表中的第\",{\"1\":{\"790\":1}}],[\"则该vim窗口的文件操作默认为整个工程\",{\"1\":{\"1140\":1}}],[\"则该派生类也会成为抽象类\",{\"1\":{\"900\":1}}],[\"则该节点将附加到链表的末尾\",{\"1\":{\"790\":1}}],[\"则该成员将在构造函数体之前执行默认初始化\",{\"1\":{\"422\":1}}],[\"则p1链长度\",{\"1\":{\"756\":2}}],[\"则从头取出一块对象空间来\",{\"1\":{\"751\":1}}],[\"则不会插入节点\",{\"1\":{\"790\":1}}],[\"则不能用foreach方法遍历\",{\"1\":{\"701\":1}}],[\"则不同\",{\"1\":{\"597\":1}}],[\"则必须在初始化表中完成其初始化\",{\"1\":{\"674\":1}}],[\"则派生类的每一个构造函数必须在其初始化列表中显示的去调用基类的某个带参的构造函数\",{\"1\":{\"672\":1}}],[\"则在临时表\",{\"1\":{\"1736\":1}}],[\"则在执行delete\",{\"1\":{\"949\":1}}],[\"则在头部插入节点\",{\"1\":{\"790\":1}}],[\"则在用已有派生类对象初始化新的派生类对象时\",{\"1\":{\"662\":1}}],[\"则在调用它的函数里找catch\",{\"1\":{\"608\":1}}],[\"则在调用它的层里继续匹配寻找\",{\"1\":{\"603\":1}}],[\"则当创建d的对象d\",{\"1\":{\"652\":1}}],[\"则当对象被销毁时\",{\"1\":{\"426\":1}}],[\"则形参分布中\",{\"1\":{\"640\":1}}],[\"则效率和默认参数是一样的\",{\"1\":{\"638\":1}}],[\"则效率不变\",{\"1\":{\"638\":1}}],[\"则func1函数会按指定的默认值进行工作\",{\"1\":{\"637\":1}}],[\"则内部结构体成员要从成员最大元素大小的整数倍和\",{\"1\":{\"557\":1}}],[\"则下列形式都是合法的\",{\"1\":{\"455\":1}}],[\"则其实现如下\",{\"1\":{\"440\":1}}],[\"则需要写成vmnet8网关ip\",{\"1\":{\"1828\":1}}],[\"则需要考虑关闭自适应哈希索引\",{\"1\":{\"1569\":1}}],[\"则需要像os申请内存\",{\"1\":{\"1082\":1}}],[\"则需要\",{\"1\":{\"421\":1}}],[\"则没有使用索引\",{\"1\":{\"1521\":1}}],[\"则没有\",{\"1\":{\"377\":1}}],[\"则一般通过在makefile文件中使用参数指定引用目录\",{\"1\":{\"312\":1}}],[\"则能用break达到这个目的\",{\"1\":{\"277\":1}}],[\"则符号未定义\",{\"1\":{\"255\":2}}],[\"则会不停的调用回调函数\",{\"1\":{\"1102\":1}}],[\"则会编译错误\",{\"1\":{\"943\":1}}],[\"则会产生页面异常\",{\"1\":{\"263\":1}}],[\"则会造成空间浪费\",{\"1\":{\"212\":1}}],[\"则会在ip层进行分片\",{\"1\":{\"22\":1}}],[\"则会在传输层进行分片\",{\"1\":{\"22\":1}}],[\"则交换\",{\"1\":{\"188\":1}}],[\"则称\",{\"1\":{\"166\":1}}],[\"则返回一个空指针\",{\"1\":{\"1878\":1}}],[\"则返回一个指向新分配的连接句柄的指针\",{\"1\":{\"1373\":1}}],[\"则返回非0值\",{\"1\":{\"1878\":1}}],[\"则返回正常分配\",{\"1\":{\"1102\":1}}],[\"则返回第二个中间结点\",{\"1\":{\"798\":2}}],[\"则返回\",{\"1\":{\"146\":1,\"152\":1,\"768\":1,\"790\":1}}],[\"则\",{\"1\":{\"140\":1,\"670\":1}}],[\"则重新开始\",{\"1\":{\"129\":1}}],[\"则将right位置元素赋给left位置\",{\"1\":{\"78\":1}}],[\"若服务不存在\",{\"1\":{\"1799\":1}}],[\"若异常发生\",{\"1\":{\"1758\":1}}],[\"若sql语句写的不合适\",{\"1\":{\"1744\":1}}],[\"若其他事务已经提交了\",{\"1\":{\"1656\":1}}],[\"若m=500阶的平衡树处理log20000000\",{\"1\":{\"1622\":1}}],[\"若想存储中文使用utf8\",{\"1\":{\"1552\":1}}],[\"若想用指针遍历其底层字符串数组\",{\"1\":{\"698\":1}}],[\"若创建表时字段没有显示的指定默认值时\",{\"1\":{\"1477\":1}}],[\"若没设置回调函数\",{\"1\":{\"1105\":1}}],[\"若没有传入实参\",{\"1\":{\"906\":1}}],[\"若分配不成功则会不停地调用次回调函数释放空间\",{\"1\":{\"1105\":1}}],[\"若分配成功则返回正常分配\",{\"1\":{\"1102\":1}}],[\"若for循环完成\",{\"1\":{\"1102\":1}}],[\"若失败则循环调用回调函数释放资源然后malloc分配\",{\"1\":{\"1102\":1}}],[\"若有设置则调用回调函数释放资源\",{\"1\":{\"1102\":1}}],[\"若有模板特例化\",{\"1\":{\"366\":1}}],[\"若实在太小\",{\"1\":{\"1102\":1}}],[\"若不能正常返回数据\",{\"1\":{\"1803\":1}}],[\"若不能则尝试重启网络\",{\"1\":{\"1279\":1}}],[\"若不够分配20\",{\"1\":{\"1102\":1}}],[\"若不给参数传递实参\",{\"1\":{\"637\":1}}],[\"若二级空间配置器应用管理的剩余内存还够20\",{\"1\":{\"1102\":1}}],[\"若多个线程同时运行\",{\"1\":{\"1020\":1}}],[\"若根节点为i\",{\"1\":{\"994\":1}}],[\"若用vector其底层效率太低\",{\"1\":{\"993\":1}}],[\"若需再次扩容\",{\"1\":{\"968\":1}}],[\"若指针指向的是虚函数\",{\"1\":{\"959\":1}}],[\"若是自动提交方式\",{\"1\":{\"1640\":1}}],[\"若是虚函数\",{\"1\":{\"954\":1}}],[\"若是普通函数\",{\"1\":{\"954\":1}}],[\"若派生类中含\",{\"1\":{\"674\":1}}],[\"若给某一参数设置了默认值\",{\"1\":{\"640\":1}}],[\"若先调用后定义\",{\"1\":{\"639\":1}}],[\"若在派生类中加一个ma\",{\"1\":{\"684\":1}}],[\"若在定义时而不是在声明时置默认值\",{\"1\":{\"639\":1}}],[\"若在本层没找到对应的catch异常处理\",{\"1\":{\"603\":1}}],[\"若传入\",{\"1\":{\"638\":1}}],[\"若两个函数都传入\",{\"1\":{\"638\":1}}],[\"若throw抛出的异常最终没有匹配到catch或则根本就没有catch\",{\"1\":{\"608\":1}}],[\"若混用new\",{\"1\":{\"517\":2}}],[\"若出现多次\",{\"1\":{\"255\":2}}],[\"若一次都无\",{\"1\":{\"255\":2}}],[\"若待排序列的数据较分散\",{\"1\":{\"212\":1}}],[\"若将两个有序表合并成⼀个有序表\",{\"1\":{\"202\":1}}],[\"若\",{\"1\":{\"166\":1,\"1096\":1}}],[\"若存在则至少有一个\",{\"1\":{\"162\":1}}],[\"若为奇数\",{\"1\":{\"81\":1,\"756\":1}}],[\"若left\",{\"1\":{\"78\":1}}],[\"若题目描述\",{\"1\":{\"78\":1}}],[\"遇到io瓶颈\",{\"1\":{\"1886\":1}}],[\"遇到外部排序using\",{\"1\":{\"1566\":1}}],[\"遇到绝对值先化简\",{\"1\":{\"162\":2}}],[\"遇到用于新数组的值\",{\"1\":{\"78\":1}}],[\"遇到val停下\",{\"1\":{\"78\":1}}],[\"直观的语法\",{\"1\":{\"1896\":1}}],[\"直至分配成功\",{\"1\":{\"1102\":1}}],[\"直到执行该命令后什么都没有显示\",{\"1\":{\"1405\":1}}],[\"直到依赖文件是没有子依赖文件\",{\"1\":{\"1353\":1}}],[\"直到返回\",{\"1\":{\"1340\":1}}],[\"直到遇到空字符\",{\"1\":{\"1348\":1}}],[\"直到遇到下一个断点或程序结束\",{\"1\":{\"1340\":1}}],[\"直到遇到断点或程序结束\",{\"1\":{\"1340\":1}}],[\"直到遇上数字或正负符号才开始做转换\",{\"1\":{\"1299\":1}}],[\"直到连接成功\",{\"1\":{\"1252\":1}}],[\"直到圆桌周围的人全部出列\",{\"1\":{\"810\":1}}],[\"直到全部⼩的数组合并起来\",{\"1\":{\"202\":1}}],[\"直到数组的⼤⼩为\",{\"1\":{\"202\":1}}],[\"直到ol次外层\",{\"1\":{\"59\":1}}],[\"直接反序列化取得数据或者直接反序列化出对象\",{\"1\":{\"1906\":1}}],[\"直接序列化一个map容器\",{\"1\":{\"1905\":1}}],[\"直接序列化一个vector容器\",{\"1\":{\"1905\":1}}],[\"直接放在数据节点dn1上\",{\"1\":{\"1891\":1}}],[\"直接用主键对分表的个数取模等\",{\"1\":{\"1886\":1}}],[\"直接关闭防火墙虽然方便\",{\"1\":{\"1818\":1}}],[\"直接变成一个写库\",{\"1\":{\"1791\":1}}],[\"直接操作数据页\",{\"1\":{\"1758\":1}}],[\"直接申请加这张表的锁\",{\"1\":{\"1713\":1}}],[\"直接执行insert的反操作delete就可以了\",{\"1\":{\"1682\":1}}],[\"直接遍历叶子节点的有序链表即可\",{\"1\":{\"1626\":1}}],[\"直接即可\",{\"1\":{\"1626\":1}}],[\"直接通过索引就可以获取查询的数据\",{\"1\":{\"1618\":1}}],[\"直接拿到数据地址的过程\",{\"1\":{\"1569\":1}}],[\"直接修改\",{\"1\":{\"1318\":1}}],[\"直接修改常量值\",{\"1\":{\"485\":1}}],[\"直接写源文件\",{\"1\":{\"1322\":1}}],[\"直接写\",{\"1\":{\"1312\":1}}],[\"直接将其封装成线程安全的queue\",{\"1\":{\"1219\":1}}],[\"直接将资源移动过来\",{\"1\":{\"1127\":1}}],[\"直接构造新对象就可以了\",{\"1\":{\"1110\":1,\"1111\":1}}],[\"直接借一个出去\",{\"1\":{\"1105\":1}}],[\"直接分配\",{\"1\":{\"1102\":1}}],[\"直接返回\",{\"1\":{\"1099\":1}}],[\"直接返回结果就可以了\",{\"1\":{\"133\":1}}],[\"直接调用右值拷贝构造函数\",{\"1\":{\"1123\":2}}],[\"直接调用库函数realloc\",{\"1\":{\"1076\":1}}],[\"直接调用即可\",{\"1\":{\"844\":1}}],[\"直接\",{\"1\":{\"1046\":1}}],[\"直接从连接池中获取一个可用的连接就可以\",{\"1\":{\"1865\":1}}],[\"直接从缓存中取出来就可以了\",{\"1\":{\"1749\":1}}],[\"直接从0x104\",{\"1\":{\"715\":1}}],[\"直接从mid\",{\"1\":{\"93\":1}}],[\"直接从mid+1开始\",{\"1\":{\"93\":1,\"94\":1}}],[\"直接正常顶格写\",{\"1\":{\"584\":1}}],[\"直接包含该头文件即可\",{\"1\":{\"576\":1}}],[\"直接就崩了\",{\"1\":{\"523\":1}}],[\"直接使用mycat\",{\"1\":{\"1800\":1}}],[\"直接使用mysql即可\",{\"0\":{\"1391\":1}}],[\"直接使用\",{\"1\":{\"1306\":1}}],[\"直接使用ip地址\",{\"1\":{\"1237\":1}}],[\"直接使用函数模板\",{\"1\":{\"1148\":1}}],[\"直接使用回调用左值的construct函数\",{\"1\":{\"1127\":1}}],[\"直接使用这种方式\",{\"1\":{\"588\":1}}],[\"直接使用c++兼容c\",{\"0\":{\"569\":1}}],[\"直接使用例子看类模板\",{\"1\":{\"388\":1}}],[\"直接使用类似a\",{\"1\":{\"91\":1}}],[\"直接跳过\",{\"1\":{\"78\":1}}],[\"非锁定读就是读取的时候没有加锁\",{\"1\":{\"1677\":1}}],[\"非锁定读是在快照上的读取\",{\"1\":{\"1658\":1}}],[\"非锁定读\",{\"1\":{\"1656\":1}}],[\"非叶子叶节点只存储key\",{\"1\":{\"1626\":1}}],[\"非聚集索引\",{\"1\":{\"1610\":1}}],[\"非关系型数据库\",{\"1\":{\"1452\":1}}],[\"非空约束\",{\"0\":{\"1435\":1}}],[\"非重要消息\",{\"1\":{\"1318\":1}}],[\"非常重要\",{\"1\":{\"1767\":1}}],[\"非常方便\",{\"1\":{\"1319\":1}}],[\"非常强大\",{\"1\":{\"1194\":1}}],[\"非常好的方法\",{\"1\":{\"1057\":2}}],[\"非函数\",{\"1\":{\"628\":1}}],[\"非临时的就是左值\",{\"1\":{\"621\":1}}],[\"非成员函数\",{\"1\":{\"545\":1,\"876\":1}}],[\"非修改式操作\",{\"1\":{\"535\":1}}],[\"非法访问内存\",{\"1\":{\"523\":1}}],[\"非程序运行阶段\",{\"1\":{\"501\":1}}],[\"非const对象既可以访问非const版本成员函数也可以访问\",{\"1\":{\"440\":1}}],[\"非const左值引用不能绑定到右值\",{\"1\":{\"400\":1}}],[\"非静态的成员函数静态的数据成员和静态的成员函数\",{\"1\":{\"439\":1}}],[\"非静态\",{\"1\":{\"392\":1}}],[\"非类型参数\",{\"1\":{\"371\":1}}],[\"非模板函数\",{\"1\":{\"366\":1}}],[\"非递减顺序排列\",{\"1\":{\"140\":1}}],[\"非递减数组nums\",{\"1\":{\"87\":1}}],[\"非末尾位置增加\",{\"1\":{\"100\":1}}],[\"非val\",{\"1\":{\"78\":2}}],[\"非要用的话\",{\"1\":{\"0\":1}}],[\"由德国大牛\",{\"1\":{\"1896\":1}}],[\"由mycat解析请求\",{\"1\":{\"1791\":1}}],[\"由从库继续对外提供服务\",{\"1\":{\"1780\":1}}],[\"由中间件代理mycat自动把服务的请求映射到从库\",{\"1\":{\"1780\":1}}],[\"由锁+mvcc实现\",{\"1\":{\"1757\":1}}],[\"由undo\",{\"1\":{\"1757\":1}}],[\"由进程列表的命令列中的sleep指示\",{\"1\":{\"1754\":1}}],[\"由innodb存储引擎自动加上表的is或ix锁\",{\"1\":{\"1673\":1}}],[\"由并发控制机制实现\",{\"1\":{\"1644\":1}}],[\"由应用场景需求决定\",{\"1\":{\"1639\":1}}],[\"由上面的三个原因\",{\"1\":{\"1626\":1}}],[\"由上图可知编译过程中\",{\"1\":{\"253\":1}}],[\"由等待状态进入阻塞状态\",{\"1\":{\"1221\":1}}],[\"由三个窗口一起卖票\",{\"1\":{\"1208\":1}}],[\"由空间配置器完成\",{\"1\":{\"1087\":1}}],[\"由全局函数模板construct和destroy完成\",{\"1\":{\"1086\":1}}],[\"由示例可知\",{\"1\":{\"802\":1}}],[\"由示例2可知\",{\"1\":{\"129\":1}}],[\"由系统在调用构造函数时自动完成\",{\"1\":{\"674\":1}}],[\"由此可以看出\",{\"1\":{\"632\":1}}],[\"由函数名\",{\"1\":{\"562\":1}}],[\"由\",{\"1\":{\"459\":1}}],[\"由编译器解释变量类型\",{\"1\":{\"359\":1}}],[\"由字母\",{\"1\":{\"316\":1}}],[\"由高地址向低地址增长\",{\"1\":{\"267\":1}}],[\"由低地址向高地址增长\",{\"1\":{\"267\":1}}],[\"由题意知\",{\"1\":{\"162\":1}}],[\"由于schema\",{\"1\":{\"1892\":1}}],[\"由于str\",{\"1\":{\"597\":1}}],[\"由于master这边收到的就是来自192\",{\"1\":{\"1821\":1}}],[\"由于master挂了\",{\"1\":{\"1814\":1}}],[\"由于mysql\",{\"1\":{\"1802\":1}}],[\"由于mycat是用java写的\",{\"1\":{\"1796\":1}}],[\"由于上线项目sql特别多\",{\"1\":{\"1771\":1}}],[\"由于上线项目的sql太多了\",{\"1\":{\"1767\":1}}],[\"由于上述两种情况只会出现⼀种\",{\"1\":{\"147\":1}}],[\"由于有redo\",{\"1\":{\"1762\":1}}],[\"由于hash索引的生成和维护也是耗费性能的\",{\"1\":{\"1747\":1}}],[\"由于数据库服务器本身的性能局限\",{\"1\":{\"1745\":1}}],[\"由于数据的改变\",{\"1\":{\"1609\":1}}],[\"由于group\",{\"1\":{\"1737\":1}}],[\"由于在间隙锁范围内\",{\"1\":{\"1693\":1}}],[\"由于innodb的行锁实现是针对索引字段添加的锁\",{\"1\":{\"1713\":1}}],[\"由于innodb的数据和索引是存放在一起的\",{\"1\":{\"1681\":1}}],[\"由于id=3的数据已经存在\",{\"1\":{\"1692\":1}}],[\"由于是等值查询\",{\"1\":{\"1692\":1}}],[\"由于新增的数据没有对应的老版本\",{\"1\":{\"1682\":1}}],[\"由于新commit的数据符合生成快照的要求\",{\"1\":{\"1660\":1}}],[\"由于需要加表锁而去挨个遍历数据\",{\"1\":{\"1672\":1}}],[\"由于每个事务可以看见自己修改\",{\"1\":{\"1665\":1}}],[\"由于每一个节点存储的数据量比较大\",{\"1\":{\"1623\":1}}],[\"由于事务1已经commit了\",{\"1\":{\"1664\":1}}],[\"由于事务1并没有commit新的数据\",{\"1\":{\"1658\":1}}],[\"由于用户会写很多数据\",{\"1\":{\"1645\":1}}],[\"由于没有隔离控制\",{\"1\":{\"1639\":1}}],[\"由于设置了已提交读隔离级别\",{\"1\":{\"1634\":1}}],[\"由于磁盘的读取也是按block块操作的\",{\"1\":{\"1623\":1}}],[\"由于password设置的是字符串类型\",{\"1\":{\"1617\":1}}],[\"由于索引也是需要存储成索引文件的\",{\"1\":{\"1609\":1}}],[\"由于我们是直接解压的\",{\"1\":{\"1800\":1}}],[\"由于我们绝大部分的数据都是存放在磁盘的\",{\"1\":{\"1604\":1}}],[\"由于我们知道\",{\"1\":{\"1127\":1}}],[\"由于不同的索引值经过哈希函数计算以及取模后\",{\"1\":{\"1604\":1}}],[\"由于桶内元素也是没有顺序的\",{\"1\":{\"1603\":1}}],[\"由于一张表的一次sql查询只能用一个索引\",{\"1\":{\"1566\":1}}],[\"由于cpu对线程不同的调用顺序\",{\"1\":{\"1217\":1}}],[\"由于c++支持函数重载\",{\"1\":{\"577\":1}}],[\"由于反返回类型只有一个\",{\"1\":{\"1158\":1}}],[\"由于将\",{\"1\":{\"1114\":1}}],[\"由于之前申请的备用内存太小\",{\"1\":{\"1102\":1}}],[\"由于电脑\",{\"1\":{\"832\":1}}],[\"由于电脑只支持vga接口\",{\"1\":{\"832\":1}}],[\"由于派生类对象通过继承而包含了基类数据成员\",{\"1\":{\"665\":1}}],[\"由于函数调用时可不列出已设置默认值的参数\",{\"1\":{\"640\":1}}],[\"由于引用是被限制的指针\",{\"1\":{\"614\":1}}],[\"由于各个头文件是由不同的人设计的\",{\"1\":{\"582\":1}}],[\"由于编译产生符号的规则不同\",{\"1\":{\"562\":1}}],[\"由于\",{\"1\":{\"490\":1,\"591\":1,\"1636\":1,\"1689\":1}}],[\"由于vector内部按顺序表结构设计\",{\"1\":{\"354\":1}}],[\"由于它的特性我们完全可以将vector\",{\"1\":{\"353\":1}}],[\"由于age>20的区间都被事务1加上了间隙锁\",{\"1\":{\"1689\":1}}],[\"由于animal\",{\"1\":{\"886\":1}}],[\"由于a\",{\"1\":{\"238\":1}}],[\"由于两个⼩的数组都是有序的\",{\"1\":{\"202\":1}}],[\"由于存储是离散的\",{\"1\":{\"91\":1}}],[\"由于微软自带的日期格式2024年1月15日与blog匹配的格式不一样需要改成2024\",{\"1\":{\"46\":1}}],[\"由这道题可知erase\",{\"1\":{\"76\":1}}],[\"通俗来讲的话\",{\"1\":{\"1878\":1}}],[\"通俗的说\",{\"1\":{\"583\":1}}],[\"通信的时候\",{\"1\":{\"1821\":1}}],[\"通信就会出现问题\",{\"1\":{\"1790\":1}}],[\"通信就是\",{\"1\":{\"1218\":1}}],[\"通配符在前面\",{\"1\":{\"1591\":1}}],[\"通配符在后面\",{\"1\":{\"1591\":1}}],[\"通配符在最前面不能使用索引查询\",{\"1\":{\"1471\":1}}],[\"通配符\",{\"0\":{\"1360\":1},\"1\":{\"1471\":1}}],[\"通配符和模式匹配\",{\"0\":{\"1358\":1}}],[\"通知消费者线程\",{\"1\":{\"1849\":1,\"1859\":1,\"1875\":1}}],[\"通知消费者消费一个\",{\"1\":{\"1219\":3}}],[\"通知在cv上等待的线程\",{\"1\":{\"1229\":1}}],[\"通知其它线程我消费完了\",{\"1\":{\"1219\":1}}],[\"通知其它所有的线程\",{\"1\":{\"1219\":1}}],[\"通知生产者线程先生产物品\",{\"1\":{\"1219\":1}}],[\"通知唤醒其它所有线程的\",{\"1\":{\"1219\":1}}],[\"通知唤醒另外的一个线程的\",{\"1\":{\"1219\":1}}],[\"通知相应的观察者对象处理事件\",{\"1\":{\"871\":1}}],[\"通常type就是const\",{\"1\":{\"1618\":1}}],[\"通常该方法需要循环调用\",{\"1\":{\"1379\":1}}],[\"通常具有\",{\"1\":{\"1334\":1}}],[\"通常是指对于\",{\"1\":{\"881\":1}}],[\"通常用户在派生类的拷贝构造函数或者派生类的赋值函数中基类的拷贝构造或赋值运算符函数\",{\"1\":{\"662\":1}}],[\"通常\",{\"1\":{\"637\":1}}],[\"通常不需要显式使用\",{\"1\":{\"578\":1}}],[\"通常定义以下函数来求取两个整数的最大值\",{\"1\":{\"500\":1}}],[\"通常体现在追加数据push\",{\"1\":{\"354\":1}}],[\"通过既定的api将sql语句发送给mysql\",{\"1\":{\"1864\":1}}],[\"通过sleep模拟定时效果\",{\"1\":{\"1849\":1,\"1859\":1}}],[\"通过show\",{\"1\":{\"1750\":1,\"1826\":1,\"1828\":1}}],[\"通过mycat查询的时候只需要正常输入就行\",{\"1\":{\"1892\":1}}],[\"通过mysql中间件mycat\",{\"1\":{\"1780\":1}}],[\"通过malloc和free管理内\",{\"1\":{\"1079\":1}}],[\"通过以下命令即可\",{\"1\":{\"1774\":1}}],[\"通过以下命令查看自适应哈希索引搜索的频率低于使用二级索引树搜索的频率\",{\"1\":{\"1747\":1}}],[\"通过管道放到mysql\",{\"1\":{\"1774\":1}}],[\"通过创建覆盖索引能够比较好地提高性能\",{\"1\":{\"1740\":1}}],[\"通过创建合适的\",{\"1\":{\"1736\":1}}],[\"通过比较系统变量\",{\"1\":{\"1736\":1}}],[\"通过zhangsan在辅助索引树上找到它所在行记录的id是1\",{\"1\":{\"1700\":1}}],[\"通过解决\",{\"1\":{\"1694\":1}}],[\"通过设置不同的隔离级别解决\",{\"1\":{\"1639\":1}}],[\"通过求哈希值\",{\"1\":{\"1603\":1}}],[\"通过上述命令检查之后\",{\"1\":{\"1398\":1}}],[\"通过上面两个图\",{\"1\":{\"518\":1}}],[\"通过编译好的版本安装\",{\"1\":{\"1305\":1}}],[\"通过栈上的对象构造和出作用域析构\",{\"1\":{\"1219\":1}}],[\"通过两个例子\",{\"1\":{\"1158\":1}}],[\"通过内存池的实现管理内存\",{\"1\":{\"1081\":1}}],[\"通过自定义内存池实现内\",{\"1\":{\"1079\":1}}],[\"通过ebp的偏移依次获取其他参数\",{\"1\":{\"1063\":1}}],[\"通过对象的资源计数\",{\"1\":{\"1050\":1}}],[\"通过对象名访问虚函数时\",{\"1\":{\"923\":1}}],[\"通过函数对象更改结果\",{\"1\":{\"1007\":1}}],[\"通过函数对象调用\",{\"1\":{\"982\":1}}],[\"通过函数指针间接调用函数\",{\"1\":{\"981\":1}}],[\"通过迭代器iterator来实现的\",{\"1\":{\"965\":1}}],[\"通过迭代器就可以读写它指向的元素\",{\"1\":{\"698\":1}}],[\"通过类base的指针pbase只能调用到base类型的display函数\",{\"1\":{\"913\":1}}],[\"通过类名直接调用\",{\"1\":{\"439\":1}}],[\"通过该指针\",{\"1\":{\"883\":1}}],[\"通过这个id作为主键创建索引树\",{\"1\":{\"1681\":1}}],[\"通过这个\",{\"1\":{\"1656\":1}}],[\"通过这一组数据\",{\"1\":{\"871\":1}}],[\"通过这道题大致了解erase\",{\"1\":{\"76\":1}}],[\"通过传入一个事先设计好的枚举类型\",{\"1\":{\"863\":1}}],[\"通过hdmi接口连接投影仪\",{\"1\":{\"832\":1}}],[\"通过vga接口连接投影仪\",{\"1\":{\"832\":1}}],[\"通过子类实现功能增强的问题\",{\"1\":{\"831\":1}}],[\"通过实现子类的方式\",{\"1\":{\"831\":2}}],[\"通过代理对象的freemovie\",{\"1\":{\"830\":2}}],[\"通过代理类\",{\"1\":{\"830\":1}}],[\"通过\",{\"1\":{\"750\":1,\"1310\":1}}],[\"通过调用基类相应的构造函数\",{\"1\":{\"667\":1}}],[\"通过作用域规则可知其生存期的\",{\"1\":{\"621\":1}}],[\"通过引用变量修改所引用内存的值\",{\"1\":{\"619\":1}}],[\"通过构造函数的隐式类型转化和通过转化操作符的类型转化\",{\"1\":{\"608\":1}}],[\"通过构造函数即可实现\",{\"1\":{\"538\":1}}],[\"通过rhs的前count个字符构造一个string对象\",{\"1\":{\"537\":1}}],[\"通过c风格字符串构造一个string对象\",{\"1\":{\"537\":1}}],[\"通过抛出异常判断内存开辟失败\",{\"1\":{\"511\":1}}],[\"通过p3指针可以修改其所指内容的值\",{\"1\":{\"488\":1}}],[\"通过p1指针无法修改其所指内容的值\",{\"1\":{\"488\":1}}],[\"通过访问限定符体现的出来的\",{\"1\":{\"448\":1}}],[\"通过参数实例化构造出具体的函数或者类\",{\"1\":{\"361\":1}}],[\"通过固定的地址与偏移量来寻找在栈参数与变量\",{\"1\":{\"233\":1}}],[\"通过递归的⽅式将⼤的数组⼀直分割\",{\"1\":{\"202\":1}}],[\"通过返回的地址减去起始地址begin\",{\"1\":{\"163\":4}}],[\"通用性更好一些\",{\"1\":{\"360\":1}}],[\"通用电气\",{\"1\":{\"301\":1}}],[\"通用\",{\"1\":{\"62\":1,\"63\":1}}],[\"更大\",{\"1\":{\"1736\":1}}],[\"更改一下数据\",{\"1\":{\"1773\":1}}],[\"更改事务b查询到的数据\",{\"1\":{\"1639\":1}}],[\"更改桶的数量\",{\"1\":{\"191\":1}}],[\"更详细的时间\",{\"0\":{\"1582\":1}}],[\"更安全\",{\"1\":{\"1219\":1}}],[\"更符合实际的面向对象设计\",{\"1\":{\"866\":1}}],[\"更好理解\",{\"1\":{\"517\":1}}],[\"更直观些\",{\"0\":{\"271\":1}}],[\"更新失败\",{\"1\":{\"1847\":1,\"1856\":1}}],[\"更新操作\",{\"1\":{\"1846\":1,\"1847\":1,\"1856\":2}}],[\"更新的数据\",{\"1\":{\"1665\":1}}],[\"更新的时候\",{\"1\":{\"1459\":1}}],[\"更新和查询数据库记录\",{\"1\":{\"1548\":1}}],[\"更新用户密码\",{\"1\":{\"1447\":1}}],[\"更新依赖源\",{\"1\":{\"1397\":1}}],[\"更新软件列表\",{\"1\":{\"1393\":1}}],[\"更新软件包列表\",{\"1\":{\"1284\":1}}],[\"更新或创建库的索引\",{\"1\":{\"1334\":1}}],[\"更新库缓存\",{\"1\":{\"1332\":1}}],[\"更新库文件的缓存信息\",{\"1\":{\"1030\":1}}],[\"更新版本号\",{\"1\":{\"1332\":1}}],[\"更新空闲内存池的首地址\",{\"1\":{\"1102\":1}}],[\"更新当前增加位置迭代器\",{\"1\":{\"746\":1,\"747\":2}}],[\"更新当前删除位置迭代器\",{\"1\":{\"745\":1}}],[\"更新startx\",{\"1\":{\"81\":1}}],[\"更新最小长度\",{\"1\":{\"73\":1}}],[\"更多应用\",{\"1\":{\"28\":1}}],[\"滑动窗口\",{\"1\":{\"73\":1},\"2\":{\"75\":1,\"165\":1}}],[\"找需要恢复的区间\",{\"1\":{\"1774\":1}}],[\"找查较多的syn连接\",{\"1\":{\"1238\":1}}],[\"找第一个小于70的数字\",{\"1\":{\"1148\":1}}],[\"找第一个小于48的数字\",{\"1\":{\"1008\":2}}],[\"找ma的时候还是在最开始找\",{\"1\":{\"937\":1}}],[\"找不到p1走n+m\",{\"1\":{\"771\":1}}],[\"找不到返回0\",{\"1\":{\"73\":1}}],[\"找中间结点\",{\"1\":{\"756\":1}}],[\"找合适的内存块\",{\"1\":{\"286\":1}}],[\"找一块空闲的虚拟内存\",{\"1\":{\"281\":1}}],[\"找出所有执行耗时的sql语句\",{\"1\":{\"1573\":1}}],[\"找出程序运行的端口\",{\"1\":{\"1238\":1}}],[\"找出满足下述条件的下标对\",{\"1\":{\"161\":1}}],[\"找出数字连续的最长序列\",{\"1\":{\"129\":1}}],[\"找符合条件的左界\",{\"1\":{\"73\":1}}],[\"找到算法mod\",{\"1\":{\"1891\":1}}],[\"找到my\",{\"1\":{\"1824\":1}}],[\"找到对应的主键值\",{\"1\":{\"1701\":1}}],[\"找到对应数据的时间是比较平均的\",{\"1\":{\"1627\":1}}],[\"找到一个平衡点\",{\"1\":{\"1609\":1}}],[\"找到所有满足通配符的文件名\",{\"1\":{\"1361\":1}}],[\"找到cmake\",{\"1\":{\"1306\":1}}],[\"找到安装vmware\",{\"1\":{\"1285\":1}}],[\"找到源码目录中的msvc10目录\",{\"1\":{\"1029\":1}}],[\"找到哪个地址调用哪个函数\",{\"1\":{\"954\":1}}],[\"找到则p1==p2\",{\"1\":{\"771\":1}}],[\"找到前半部分链表的尾节点\",{\"1\":{\"756\":2}}],[\"找到返回该数字的地址\",{\"1\":{\"163\":4}}],[\"找到返回其长度\",{\"1\":{\"73\":1}}],[\"找到答案时\",{\"1\":{\"133\":1}}],[\"找到\",{\"1\":{\"96\":1,\"787\":1,\"802\":1,\"1102\":2}}],[\"找到后直接赋给slow位置即可\",{\"1\":{\"77\":1}}],[\"找到typora\",{\"1\":{\"66\":1}}],[\"找到typora的配置文件\",{\"1\":{\"63\":1}}],[\"找和>=target的长度最小的\",{\"1\":{\"73\":1}}],[\"给对象添加一个属性\",{\"1\":{\"1859\":1}}],[\"给外部提供接口\",{\"1\":{\"1848\":1,\"1859\":1,\"1875\":1}}],[\"给外部提供一个统一的获取汽车剩余路程数的api\",{\"1\":{\"900\":1}}],[\"给mslave用户主从同步的权限\",{\"1\":{\"1821\":1}}],[\"给user表insert一条数据\",{\"1\":{\"1813\":1}}],[\"给出log\",{\"1\":{\"1769\":1}}],[\"给出一个sql\",{\"1\":{\"1531\":1}}],[\"给group\",{\"1\":{\"1737\":1}}],[\"给id=7的数据加上排它锁\",{\"1\":{\"1699\":1}}],[\"给age=21这行数据加上共享锁\",{\"1\":{\"1693\":1}}],[\"给大部分行都加锁\",{\"1\":{\"1670\":1}}],[\"给该字段加了索引并且以该字段作为过滤条件就能用到该索引\",{\"1\":{\"1617\":1}}],[\"给后台服务器增加专门的搜索引擎支持快速高效的搜索\",{\"1\":{\"1610\":1}}],[\"给区分度高的字段加索引\",{\"0\":{\"1587\":1}}],[\"给file1创建软链接\",{\"0\":{\"1271\":1}}],[\"给file1创建硬链接\",{\"0\":{\"1270\":1}}],[\"给指针专用\",{\"1\":{\"1194\":1}}],[\"给指针初始化\",{\"1\":{\"455\":1}}],[\"给t4赋值出语句后\",{\"1\":{\"1111\":1}}],[\"给t4赋值\",{\"1\":{\"1111\":1}}],[\"给typora的代码块设置默认语言\",{\"0\":{\"61\":1}}],[\"给vector容器预留空间\",{\"1\":{\"966\":1}}],[\"给vector容器中所有的奇数前面都添加一个小于1的偶数\",{\"1\":{\"966\":2}}],[\"给vec容器中所有的偶数前面添加一个小于偶数值1的数字\",{\"1\":{\"743\":1,\"746\":1,\"747\":2}}],[\"给vec容器中所有的偶数前面\",{\"0\":{\"743\":1}}],[\"给主题增加观察者对象\",{\"1\":{\"871\":1}}],[\"给共享的资源\",{\"1\":{\"840\":1}}],[\"给每个车增加两个功能\",{\"1\":{\"831\":1}}],[\"给queueitem提供自定义内存管理\",{\"1\":{\"751\":1}}],[\"给string字符串类型提供迭代器iterator的实现\",{\"1\":{\"699\":1}}],[\"给程序一次\",{\"1\":{\"597\":1}}],[\"给所有的派生类保留统一的覆盖\",{\"1\":{\"901\":1}}],[\"给所有的符号分配了虚拟地址\",{\"1\":{\"255\":1}}],[\"给所有容器都可以使用\",{\"1\":{\"704\":1}}],[\"给所有符号分配虚拟地址\",{\"1\":{\"255\":1}}],[\"给esp\",{\"1\":{\"234\":1}}],[\"给你单链表的头指针\",{\"1\":{\"801\":1}}],[\"给你单链表的头结点\",{\"1\":{\"798\":1}}],[\"给你单链表的头节点\",{\"1\":{\"777\":1}}],[\"给你两个单链表的头节点\",{\"1\":{\"771\":1}}],[\"给你两个字符串\",{\"1\":{\"174\":1}}],[\"给你一个链表的头节点\",{\"1\":{\"787\":1,\"795\":1}}],[\"给你一个链表数组\",{\"1\":{\"780\":1}}],[\"给你一个链表\",{\"1\":{\"774\":1}}],[\"给你一个单链表的头节点\",{\"1\":{\"754\":1}}],[\"给你一个下标从\",{\"1\":{\"140\":1}}],[\"给你一个整数数组\",{\"1\":{\"132\":1,\"158\":1,\"161\":1,\"177\":1}}],[\"给定链表头节点head和整数val\",{\"1\":{\"759\":1}}],[\"给定两个数组\",{\"1\":{\"169\":1}}],[\"给定两个字符串\",{\"1\":{\"166\":1}}],[\"给定一个链表的头节点\",{\"1\":{\"768\":1}}],[\"给定一个未排序的整数数组\",{\"1\":{\"129\":1}}],[\"给定一个整数数组\",{\"1\":{\"124\":1,\"152\":1}}],[\"给定一个大小为\",{\"1\":{\"113\":1}}],[\"给定正整数n\",{\"1\":{\"81\":1}}],[\"给定正整数数组nums和正整数target\",{\"1\":{\"73\":1}}],[\"给结果去重\",{\"1\":{\"104\":1,\"107\":1,\"110\":1}}],[\"x=s\",{\"1\":{\"1878\":1}}],[\"xml格式的20分之一\",{\"1\":{\"1913\":1}}],[\"xml的1\",{\"1\":{\"1901\":1}}],[\"xml配置文件中\",{\"1\":{\"1892\":2}}],[\"xml配置以下三点\",{\"1\":{\"1803\":1}}],[\"xmlns\",{\"1\":{\"1888\":1,\"1891\":1}}],[\"xml定义的分表算法\",{\"1\":{\"1886\":1}}],[\"xml中配置以下拆分算法\",{\"1\":{\"1891\":1}}],[\"xml中配置的是多住多从\",{\"1\":{\"1814\":1}}],[\"xml中配置的登录用户名和密码登录\",{\"1\":{\"1808\":1,\"1809\":1}}],[\"xml中读库的端口出错\",{\"1\":{\"1806\":1}}],[\"xml中备份的主库没有结束标签\",{\"1\":{\"1805\":1}}],[\"xml用于配置逻辑库和数据源\",{\"1\":{\"1803\":1}}],[\"xml\",{\"0\":{\"1802\":1,\"1803\":1},\"1\":{\"1804\":1,\"1886\":1,\"1888\":3,\"1891\":3}}],[\"xs都不能共存\",{\"1\":{\"1699\":1}}],[\"xuesheng\",{\"1\":{\"1552\":1}}],[\"xargs\",{\"1\":{\"1405\":1}}],[\"xvf\",{\"1\":{\"1396\":1}}],[\"x命令来查看指定地址的内存值\",{\"1\":{\"1347\":1}}],[\"xia\",{\"1\":{\"1287\":1}}],[\"xiaoming\",{\"1\":{\"1900\":1}}],[\"xiaomi\",{\"1\":{\"439\":1,\"440\":1}}],[\"xr\",{\"1\":{\"1271\":1}}],[\"xftp也行\",{\"1\":{\"1800\":1}}],[\"xfs等\",{\"1\":{\"1267\":1}}],[\"xfvz\",{\"1\":{\"1260\":1}}],[\"xfv\",{\"1\":{\"1260\":1}}],[\"x或\",{\"1\":{\"1237\":1}}],[\"x6\",{\"1\":{\"866\":1,\"867\":1}}],[\"xxx\",{\"1\":{\"936\":1,\"1828\":8,\"1915\":1}}],[\"xx\",{\"1\":{\"557\":1,\"1168\":2,\"1321\":1,\"1699\":1}}],[\"x3\",{\"1\":{\"530\":1}}],[\"x2\",{\"1\":{\"434\":2,\"826\":5}}],[\"x1\",{\"1\":{\"434\":2,\"826\":5,\"862\":1,\"864\":2}}],[\"x86\",{\"1\":{\"234\":2,\"302\":1,\"572\":1,\"1305\":4,\"1395\":1}}],[\"x的前端\",{\"1\":{\"81\":1}}],[\"x\",{\"0\":{\"271\":1,\"1347\":1},\"1\":{\"70\":1,\"148\":3,\"149\":3,\"182\":4,\"239\":1,\"252\":1,\"362\":2,\"371\":2,\"389\":4,\"395\":2,\"463\":2,\"470\":1,\"473\":2,\"485\":1,\"497\":2,\"500\":10,\"501\":3,\"504\":4,\"506\":3,\"571\":10,\"572\":1,\"578\":1,\"594\":3,\"601\":3,\"602\":4,\"615\":3,\"618\":8,\"637\":5,\"641\":5,\"642\":10,\"755\":4,\"756\":4,\"759\":4,\"762\":4,\"768\":2,\"771\":2,\"774\":4,\"782\":4,\"783\":4,\"784\":4,\"787\":4,\"795\":7,\"798\":4,\"802\":4,\"826\":4,\"1082\":1,\"1086\":3,\"1271\":5,\"1347\":2,\"1348\":5,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1697\":1,\"1719\":15,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1}}],[\"把库和表存放在不同的mysql\",{\"1\":{\"1885\":1}}],[\"把libmysql\",{\"1\":{\"1855\":1}}],[\"把left这边的表所有的数据显示出来\",{\"1\":{\"1543\":1}}],[\"把connection直接归还到queue当中\",{\"1\":{\"1849\":1,\"1859\":1,\"1872\":1}}],[\"把const关键\",{\"1\":{\"440\":1}}],[\"把position重新设置一下\",{\"1\":{\"1830\":1}}],[\"把后端所有的细节给客户端隐藏了\",{\"1\":{\"1809\":1}}],[\"把binlog的所有操作在从库上在进行一遍\",{\"1\":{\"1772\":1}}],[\"把结果写回磁盘\",{\"1\":{\"1649\":1}}],[\"把索引从头到尾扫一遍\",{\"1\":{\"1618\":1}}],[\"把每一行记录的name字段作为参数来求一个哈希值\",{\"1\":{\"1603\":1}}],[\"把有序链表整个扫了一遍\",{\"1\":{\"1581\":1}}],[\"把有关联的产品放在一个工厂中\",{\"1\":{\"867\":1}}],[\"把right这边的表所有的数据显示出来\",{\"1\":{\"1544\":1}}],[\"把runinthread这个成员方法充当线程函数\",{\"1\":{\"1151\":1}}],[\"把main\",{\"1\":{\"1360\":1}}],[\"把main函数刚才构建的临时对象析构\",{\"1\":{\"1115\":1}}],[\"把main函数刚才构建的临时对象赋值给t2\",{\"1\":{\"1115\":1}}],[\"把最终输出的\",{\"1\":{\"1316\":1}}],[\"把生成的对象文件放到\",{\"1\":{\"1316\":1}}],[\"把生成的库文件放到\",{\"1\":{\"1316\":1}}],[\"把头文件放到\",{\"1\":{\"1316\":1}}],[\"把源文件放到\",{\"1\":{\"1316\":1}}],[\"把互斥锁mutex释放\",{\"1\":{\"1219\":1}}],[\"把带左值引用参数的拷贝构造函数和赋值重载函数删除了\",{\"1\":{\"1211\":1}}],[\"把子线程设置为分离线程\",{\"1\":{\"1207\":1}}],[\"把子线程设置为分离线程t1\",{\"1\":{\"1207\":1}}],[\"把t线程设置为分离线程\",{\"1\":{\"1206\":1}}],[\"把他们一个大类型的细分类型\",{\"1\":{\"1190\":1}}],[\"把绑定器的类型留下来\",{\"1\":{\"1154\":1}}],[\"把70按顺序插入到vec容器当中\",{\"1\":{\"1148\":1}}],[\"把78出队后\",{\"1\":{\"406\":1}}],[\"把转成的时候\",{\"1\":{\"1112\":1}}],[\"把整型转成test\",{\"1\":{\"1112\":2}}],[\"把其他类型转成类类型的时候\",{\"1\":{\"1112\":1}}],[\"把30强转成test类型int\",{\"1\":{\"1112\":1}}],[\"把资源释放的代码全部放在这个析构函数中执行\",{\"1\":{\"1041\":1}}],[\"把二元函数对象operator\",{\"1\":{\"1008\":1}}],[\"把operator\",{\"1\":{\"1008\":1}}],[\"把所有对象的创建都封装在了一个simplefactory类的createcar函数中\",{\"1\":{\"864\":1}}],[\"把链表节点放入一个最小堆\",{\"1\":{\"784\":1}}],[\"把iterator持有的容器指针置nullptr\",{\"1\":{\"747\":1}}],[\"把int转成enum\",{\"1\":{\"629\":1}}],[\"把我们当前节点的地址到末尾的地址\",{\"1\":{\"747\":1}}],[\"把任何类型的表达式转换成void类型\",{\"1\":{\"629\":1}}],[\"把vec容器中所有偶数全部删除\",{\"1\":{\"966\":3}}],[\"把vec容器中所有的偶数全部删除\",{\"1\":{\"742\":1,\"745\":1,\"747\":2}}],[\"把vec容器中所有的偶数全部\",{\"0\":{\"742\":1}}],[\"把void指针转换成目标类型的指针\",{\"1\":{\"629\":1}}],[\"把val放到i的位置\",{\"1\":{\"121\":1}}],[\"把一个指向基类对象的指针转换成指向一个派生类对象的指针\",{\"1\":{\"628\":1}}],[\"把一些全局实体分别存放到各个命名空间中\",{\"1\":{\"583\":1}}],[\"把它放在项目工程文件所在目录\",{\"1\":{\"312\":1}}],[\"把action1\",{\"0\":{\"273\":1,\"274\":1}}],[\"把\",{\"1\":{\"263\":1,\"385\":2,\"629\":2,\"704\":2,\"1318\":1}}],[\"把栈的值出栈\",{\"1\":{\"234\":1}}],[\"把esp的位置压栈\",{\"1\":{\"234\":1}}],[\"把下一行指令的地址\",{\"1\":{\"234\":1}}],[\"把⻓度为n的输⼊序列分成两个⻓度为n\",{\"1\":{\"202\":1}}],[\"把⼩的元素往前调或者把⼤的元素往后调\",{\"1\":{\"188\":1}}],[\"把去重的逻辑提前了而已\",{\"1\":{\"136\":1}}],[\"把奇数调整到数组的右边\",{\"1\":{\"70\":2}}],[\"把偶数调整到数组的左边\",{\"1\":{\"70\":2}}],[\"把模板文件放到c\",{\"1\":{\"45\":1}}],[\"按网点和日期统计每个网点每天的营业额\",{\"1\":{\"1531\":1}}],[\"按照某种规则\",{\"1\":{\"1890\":1}}],[\"按照主键值升序排列\",{\"1\":{\"1693\":1}}],[\"按照笛卡尔乘积方式处理\",{\"0\":{\"1498\":1}}],[\"按照浮点数的格式显示\",{\"1\":{\"1347\":1}}],[\"按照2倍大小扩容为4\",{\"1\":{\"968\":1}}],[\"按序插入元素65\",{\"0\":{\"1178\":1}}],[\"按引用接收\",{\"1\":{\"1102\":1}}],[\"按位与11111111\",{\"1\":{\"1090\":1}}],[\"按位置删除\",{\"1\":{\"101\":1}}],[\"按位置插\",{\"1\":{\"101\":1}}],[\"按key值删除元素\",{\"1\":{\"999\":1}}],[\"按钮3\",{\"1\":{\"306\":1}}],[\"按钮\",{\"1\":{\"306\":2}}],[\"按从大到小排序\",{\"1\":{\"163\":1}}],[\"按从小到大排序\",{\"1\":{\"163\":1}}],[\"按奇偶排序数组\",{\"0\":{\"70\":1},\"1\":{\"70\":1}}],[\"按ctrl+\",{\"1\":{\"29\":1}}],[\"双字\",{\"1\":{\"1347\":1}}],[\"双向循环链表\",{\"0\":{\"823\":1}}],[\"双向链表\",{\"0\":{\"792\":1,\"820\":1},\"1\":{\"792\":2}}],[\"双const\",{\"1\":{\"497\":1}}],[\"双轮车\",{\"1\":{\"449\":1}}],[\"双端队列两端都可以做为队头与队尾\",{\"1\":{\"968\":1}}],[\"双端队列\",{\"1\":{\"182\":1}}],[\"双指针法\",{\"0\":{\"143\":1}}],[\"双指针同时收缩\",{\"1\":{\"133\":1}}],[\"双指针🍗\",{\"0\":{\"133\":1}}],[\"双指针\",{\"0\":{\"126\":1,\"179\":1},\"1\":{\"76\":2},\"2\":{\"69\":1,\"72\":1,\"75\":1,\"80\":1,\"89\":1,\"112\":1,\"128\":1,\"139\":1,\"145\":1,\"151\":1,\"181\":1,\"758\":1,\"764\":1,\"767\":1,\"770\":1,\"773\":1,\"776\":1,\"786\":1,\"789\":1,\"797\":1,\"800\":1,\"805\":1,\"808\":1}}],[\"双击运行\",{\"1\":{\"44\":1}}],[\"双击ahk脚本运行\",{\"1\":{\"29\":1}}],[\"双击\",{\"1\":{\"28\":1}}],[\"当输入的数据大小超过了第二个参数指定的大小的时候\",{\"1\":{\"1878\":1}}],[\"当mysql的并发请求量过大\",{\"1\":{\"1865\":1}}],[\"当master宕机后\",{\"1\":{\"1803\":1}}],[\"当访问mysql的并发请求多了以后\",{\"1\":{\"1865\":1}}],[\"当访问ma时必须给前面加上对象\",{\"1\":{\"410\":1}}],[\"当这些连接用完再次归还到连接池当中\",{\"1\":{\"1865\":1}}],[\"当这些连接使用完成后\",{\"1\":{\"1865\":1}}],[\"当这个对象出作用域\",{\"1\":{\"1226\":1,\"1227\":1}}],[\"当这个智能指针出作用域\",{\"1\":{\"1054\":1}}],[\"当并发访问mysql\",{\"1\":{\"1865\":1}}],[\"当应用发起mysql访问时\",{\"1\":{\"1865\":1}}],[\"当写库\",{\"1\":{\"1791\":1}}],[\"当a相等时\",{\"1\":{\"1736\":1}}],[\"当age相同时再以name升序\",{\"1\":{\"1525\":1}}],[\"当某个事务修改数据时\",{\"1\":{\"1681\":1}}],[\"当某个事务要获取表的x锁时\",{\"1\":{\"1673\":1}}],[\"当又一次产生数据快照时\",{\"1\":{\"1658\":1}}],[\"当两个或者多个事务并发执行时\",{\"1\":{\"1644\":1}}],[\"当修改数据时\",{\"1\":{\"1644\":1}}],[\"当事务提交时\",{\"1\":{\"1762\":1}}],[\"当事务commit的时候\",{\"1\":{\"1759\":1}}],[\"当事务2再想获取整张表的s锁时\",{\"1\":{\"1673\":1}}],[\"当事务2再次select的时候\",{\"1\":{\"1665\":1}}],[\"当事务2再select\",{\"1\":{\"1664\":1}}],[\"当事务1进行更改的时候\",{\"1\":{\"1658\":1}}],[\"当事务a和事务b并发执行时\",{\"1\":{\"1639\":1}}],[\"当事务a更新后\",{\"1\":{\"1639\":1}}],[\"当事务b查询读取数据后\",{\"1\":{\"1639\":2}}],[\"当表中的数据量到达几十万甚至上百万的时候\",{\"1\":{\"1609\":1}}],[\"当sql执行的时间超过我们设定的时间\",{\"1\":{\"1573\":1,\"1776\":1}}],[\"当单表设计不满足范式设计时需要进行拆分\",{\"1\":{\"1535\":1}}],[\"当到达上限后就会插入失败\",{\"1\":{\"1481\":1}}],[\"当插入数据时\",{\"1\":{\"1477\":1}}],[\"当满足条件时\",{\"1\":{\"1470\":1}}],[\"当只输入make时执行\",{\"1\":{\"1365\":1}}],[\"当新的共享库被安装后\",{\"1\":{\"1332\":1}}],[\"当文件比较多时\",{\"1\":{\"1313\":1}}],[\"当文件特别大或者网络特别慢的时候\",{\"1\":{\"1252\":1}}],[\"当生产者线程函数完之后\",{\"1\":{\"1221\":1}}],[\"当ticketcount\",{\"1\":{\"1209\":1}}],[\"当指定字节数内存分配失败以后\",{\"1\":{\"1105\":1}}],[\"当os开辟内存失败的时候\",{\"1\":{\"1102\":1}}],[\"当前事务没做操作\",{\"1\":{\"1686\":1}}],[\"当前事务再次查询时重新生成的数据快照中的m\",{\"1\":{\"1656\":1}}],[\"当前事务做的修改\",{\"1\":{\"1656\":1}}],[\"当前数据库中\",{\"1\":{\"1656\":2}}],[\"当前读\",{\"1\":{\"1656\":1}}],[\"当前场景中事务b读到了事务a还没有commit的数据50\",{\"1\":{\"1639\":1}}],[\"当前日期\",{\"1\":{\"1443\":1}}],[\"当前时间\",{\"1\":{\"1443\":2}}],[\"当前工程的根目录\",{\"1\":{\"1316\":1}}],[\"当前下载速度\",{\"1\":{\"1249\":1}}],[\"当前线程就会从等待状态\",{\"1\":{\"1219\":1}}],[\"当前线程挂起\",{\"1\":{\"1219\":1}}],[\"当前线程继续往下运行\",{\"1\":{\"1206\":1}}],[\"当前行到48行的内容都删除\",{\"1\":{\"1142\":1}}],[\"当前的数组大小\",{\"1\":{\"1127\":1}}],[\"当前\",{\"1\":{\"1102\":1,\"1310\":1}}],[\"当前函数栈底指针\",{\"1\":{\"233\":1}}],[\"当前函数栈顶指针\",{\"1\":{\"233\":1}}],[\"当内存池最多只能包含1个\",{\"1\":{\"1099\":1}}],[\"当引用计数减1为0的时候\",{\"1\":{\"1054\":1}}],[\"当引用计数减1不为0的时候\",{\"1\":{\"1054\":1}}],[\"当引用作为函数的返回值时\",{\"1\":{\"616\":1}}],[\"当1个智能指针引用这个资源的时候\",{\"1\":{\"1054\":1}}],[\"当category记录一条日志时\",{\"1\":{\"1022\":1}}],[\"当const位于\",{\"1\":{\"497\":3}}],[\"当存储大量数据时\",{\"1\":{\"993\":1}}],[\"当添加元素时候才从\",{\"1\":{\"973\":1,\"974\":1}}],[\"当元素入满时候\",{\"1\":{\"968\":1}}],[\"当类中定义了一个虚函数后\",{\"1\":{\"914\":1}}],[\"当该对象的状态发生改变时\",{\"1\":{\"871\":2}}],[\"当对象被销毁时\",{\"1\":{\"853\":1}}],[\"当需要时\",{\"1\":{\"844\":1}}],[\"当fast为空时\",{\"1\":{\"774\":1,\"806\":1}}],[\"当乘号\",{\"1\":{\"751\":1}}],[\"当我们从网络接收到字符串为json格式时\",{\"1\":{\"1906\":1}}],[\"当我们用范围条件而不是相等条件检索数据\",{\"1\":{\"1686\":1}}],[\"当我们去读数据的时候\",{\"1\":{\"1682\":1}}],[\"当我们希望获取表锁时\",{\"1\":{\"1671\":1}}],[\"当我们默认定义一个vector时候\",{\"1\":{\"973\":1,\"974\":1}}],[\"当我们再继续添加元素时\",{\"1\":{\"968\":1}}],[\"当我们元素的不断增加\",{\"1\":{\"968\":1}}],[\"当我们基类被虚继承后\",{\"1\":{\"937\":1}}],[\"当我们遇到虚继承时候\",{\"1\":{\"937\":1}}],[\"当我们new一个derive对象时\",{\"1\":{\"908\":1}}],[\"当我们把一个函数声明为一个类的友元函数时\",{\"1\":{\"876\":1}}],[\"当我们需要\",{\"1\":{\"750\":1}}],[\"当我们调用vec\",{\"1\":{\"742\":1,\"743\":1}}],[\"当我们执行delete\",{\"1\":{\"715\":1}}],[\"当容器调用\",{\"1\":{\"741\":2}}],[\"当考虑对象成员时\",{\"1\":{\"675\":1}}],[\"当派生类对象被删除时\",{\"1\":{\"675\":1}}],[\"当调用clear\",{\"1\":{\"908\":1}}],[\"当调用次数大的时候开销差别还是很可观\",{\"1\":{\"638\":1}}],[\"当调用函数时\",{\"1\":{\"615\":1,\"640\":1}}],[\"当以引用作为函数的返回值时\",{\"1\":{\"616\":1}}],[\"当发生数学下溢时\",{\"1\":{\"604\":1}}],[\"当发生数学上溢时\",{\"1\":{\"604\":1}}],[\"当尝试存储超出范围的值时\",{\"1\":{\"604\":1}}],[\"当创建了太长的\",{\"1\":{\"604\":1}}],[\"当使用load\",{\"1\":{\"1728\":1}}],[\"当使用了无效的参数时\",{\"1\":{\"604\":1}}],[\"当使用了一个无效的数学域时\",{\"1\":{\"604\":1}}],[\"当使用参数包时\",{\"1\":{\"377\":1}}],[\"当上述的匹配过程中最后都没能匹配到任何catch字句\",{\"1\":{\"603\":1}}],[\"当出现异常时\",{\"0\":{\"597\":1}}],[\"当编译链接时候\",{\"1\":{\"575\":1}}],[\"当函数返回时\",{\"1\":{\"616\":2}}],[\"当函数名字相同的时候\",{\"1\":{\"571\":1}}],[\"当函数的返回值是对象\",{\"1\":{\"398\":1}}],[\"当bar的重载函数在后面加上来了之后\",{\"1\":{\"528\":1}}],[\"当您尝试将int\",{\"1\":{\"490\":1}}],[\"当=作用于对象时\",{\"1\":{\"463\":1}}],[\"当line的构造函数没有在其初始化列表中初始化对象\",{\"1\":{\"434\":1}}],[\"当数据库出现故障导致无法正常使用时\",{\"1\":{\"1770\":1}}],[\"当数据量比较大\",{\"1\":{\"1744\":1}}],[\"当数据量比较大时order\",{\"1\":{\"1525\":1}}],[\"当数据量大时\",{\"1\":{\"1621\":1}}],[\"当数据用完或者出错时\",{\"1\":{\"1379\":1}}],[\"当数据对象改变时\",{\"1\":{\"871\":1}}],[\"当数据成员本身也是自定义类类型对象时\",{\"1\":{\"434\":1}}],[\"当数据成员用const关键字进行修饰以后\",{\"1\":{\"432\":1}}],[\"当数组中有相等元素时\",{\"1\":{\"196\":1}}],[\"当数组中有重复值的时候\",{\"1\":{\"95\":1}}],[\"当用户修改a文件的内容\",{\"1\":{\"1267\":1}}],[\"当用引用作为函数的参数时\",{\"1\":{\"615\":1}}],[\"当用delete删除该对象时\",{\"1\":{\"427\":1}}],[\"当用一个已经存在的对象初始化另一个新对象时\",{\"1\":{\"398\":1}}],[\"当传递临时对象的时候\",{\"1\":{\"400\":1}}],[\"当传递的是\",{\"1\":{\"400\":1}}],[\"当实参和形参都是对象\",{\"1\":{\"398\":1}}],[\"当程序异常终止时\",{\"1\":{\"1338\":1}}],[\"当程序执行时\",{\"1\":{\"435\":1}}],[\"当程序流程第一次到达该对象定义处调用构造函数\",{\"1\":{\"427\":1}}],[\"当程序被编译之后\",{\"1\":{\"392\":1}}],[\"当程序运行时\",{\"1\":{\"267\":1,\"915\":1}}],[\"当分配空间不够时\",{\"1\":{\"354\":1}}],[\"当然也可以指定库指定表\",{\"1\":{\"1821\":1}}],[\"当然也可以通过上面提到的context窗口定位\",{\"1\":{\"41\":1}}],[\"当然是初始化\",{\"1\":{\"1115\":1}}],[\"当然还有c++风格的\",{\"1\":{\"628\":1}}],[\"当然\",{\"1\":{\"598\":1,\"688\":1,\"1166\":1,\"1535\":1}}],[\"当然c++中仍然是可以用这两种方法的\",{\"1\":{\"598\":1}}],[\"当然该错误是人为造成的\",{\"1\":{\"588\":1}}],[\"当然即使是放在头文件中\",{\"1\":{\"504\":1}}],[\"当然内联函数定义也可以放在源文件中\",{\"1\":{\"504\":1}}],[\"当然包括类对象\",{\"1\":{\"470\":1}}],[\"当然可以通过不同的编译器编译后在任何一台平台上运行\",{\"1\":{\"303\":1}}],[\"当时在实验室无聊时\",{\"1\":{\"301\":1}}],[\"当时大型主机至多能提供\",{\"1\":{\"301\":1}}],[\"当一个master挂了\",{\"1\":{\"1803\":1}}],[\"当一个线程在做cpu和内存之间数据的交换\",{\"1\":{\"1232\":1}}],[\"当一个基类中设有虚函数\",{\"1\":{\"913\":1}}],[\"当一个\",{\"1\":{\"290\":1}}],[\"当\",{\"1\":{\"282\":1,\"378\":1,\"1645\":1}}],[\"当你在vim中编辑了一个文件\",{\"1\":{\"1410\":1}}],[\"当你使用\",{\"1\":{\"1334\":1}}],[\"当你执行一段代码到一半\",{\"1\":{\"277\":1}}],[\"当你重新启动终端时\",{\"1\":{\"239\":1}}],[\"当执行dosomething\",{\"1\":{\"273\":1}}],[\"当遍历到\",{\"1\":{\"135\":1}}],[\"当遍历到第一个\",{\"1\":{\"135\":1}}],[\"当算法运行时\",{\"1\":{\"67\":1}}],[\"然而现在我们发现获取age=20的排它锁也获取不到了\",{\"1\":{\"1700\":1}}],[\"然而产生新的数据快照的\",{\"1\":{\"1658\":1}}],[\"然而当备用内存只能分割出一个size内存块时\",{\"1\":{\"1102\":1}}],[\"然而虚函数的目的是为了在完全不了解细节的情况下也能正确处理对象\",{\"1\":{\"876\":1}}],[\"然而后面的这个重载函数或许是我们几个月或者很长一段时间后加上的话\",{\"1\":{\"528\":1}}],[\"然而为了内存对齐\",{\"1\":{\"470\":1}}],[\"然而\",{\"1\":{\"67\":1,\"494\":1,\"578\":1,\"1658\":1}}],[\"然后使用该指针修改成员数据\",{\"1\":{\"1914\":2}}],[\"然后使用explain分析这些耗时的sql语句\",{\"1\":{\"1573\":1}}],[\"然后配置了两个写库\",{\"1\":{\"1888\":1}}],[\"然后start\",{\"1\":{\"1830\":1}}],[\"然后做数据的增删改查\",{\"1\":{\"1830\":1}}],[\"然后从库的sql线程从relay\",{\"1\":{\"1830\":1}}],[\"然后变成写库的从库还要和其他从库之间配置一下主从复制\",{\"1\":{\"1791\":1}}],[\"然后主库会开启dump线程\",{\"1\":{\"1784\":1}}],[\"然后才是写buffer\",{\"1\":{\"1763\":1}}],[\"然后会有一个独立的线程找时机慢慢的将buffer\",{\"1\":{\"1758\":1}}],[\"然后去主键索引树找到相应的记录\",{\"1\":{\"1701\":1}}],[\"然后去大表搜索\",{\"1\":{\"1537\":1}}],[\"然后到主键索引树上\",{\"1\":{\"1700\":1}}],[\"然后整个事务期间都在用这个\",{\"1\":{\"1656\":1}}],[\"然后cache再慢慢往磁盘上写数据\",{\"1\":{\"1645\":1}}],[\"然后ctrl+f全局搜索以下字符串\",{\"1\":{\"61\":1}}],[\"然后操作系统通过磁盘i\",{\"1\":{\"1645\":1}}],[\"然后给另一个人余额加50\",{\"1\":{\"1639\":1}}],[\"然后还进行了取模的操作\",{\"1\":{\"1603\":1}}],[\"然后我们source\",{\"1\":{\"1836\":1}}],[\"然后我们创建的索引就是哈希索引\",{\"1\":{\"1603\":1}}],[\"然后我们通过查看日志\",{\"1\":{\"1573\":1}}],[\"然后取出data即可\",{\"1\":{\"1569\":1}}],[\"然后回表\",{\"1\":{\"1569\":1}}],[\"然后拿着这些uid去exame大表中搜索\",{\"1\":{\"1537\":1}}],[\"然后通过binlog同步到从库\",{\"1\":{\"1781\":1}}],[\"然后通过explain查看执行计划\",{\"1\":{\"1525\":1}}],[\"然后通知一下线程1它做完了\",{\"1\":{\"1218\":1}}],[\"然后复制到shell运行\",{\"1\":{\"1475\":1}}],[\"然后必须要重启mysql\",{\"1\":{\"1410\":1}}],[\"然后设置密码策略为简单\",{\"1\":{\"1407\":1}}],[\"然后递归地找到依赖文件的依赖文件\",{\"1\":{\"1353\":1}}],[\"然后递归调用\",{\"1\":{\"1102\":1}}],[\"然后停下来等待命令\",{\"1\":{\"1340\":1}}],[\"然后输入\",{\"1\":{\"1318\":1}}],[\"然后重新赋予权限\",{\"1\":{\"1828\":1}}],[\"然后重新打开\",{\"1\":{\"1278\":1,\"1279\":1}}],[\"然后重启mysql\",{\"1\":{\"1750\":1}}],[\"然后重复这个过程直到这个数变为\",{\"1\":{\"146\":1}}],[\"然后127\",{\"1\":{\"1239\":1}}],[\"然后线程处于\",{\"1\":{\"1233\":1}}],[\"然后线程1才能做这些操作\",{\"1\":{\"1218\":1}}],[\"然后告诉线程2这部分东西做好了\",{\"1\":{\"1218\":1}}],[\"然后把隔离级别设置成串行化\",{\"1\":{\"1687\":1}}],[\"然后把相同的值写回去了\",{\"1\":{\"1208\":1}}],[\"然后把前一块内存分配出去\",{\"1\":{\"1096\":1}}],[\"然后左边变量的类型也就已知了\",{\"1\":{\"1194\":1}}],[\"然后是返回值\",{\"1\":{\"1173\":1}}],[\"然后return\",{\"1\":{\"1115\":1}}],[\"然后p指向这个临时对象的地址\",{\"1\":{\"1113\":1}}],[\"然后需要重新找os申请新的内存\",{\"1\":{\"1102\":1}}],[\"然后需要在\",{\"1\":{\"1102\":1}}],[\"然后分配空间\",{\"1\":{\"1096\":1}}],[\"然后减1\",{\"1\":{\"1090\":1}}],[\"然后保存退出\",{\"1\":{\"1030\":1,\"1410\":1}}],[\"然后再通过结果返回给服务器应用\",{\"1\":{\"1864\":1}}],[\"然后再检查从库里面的配置信息是否正确\",{\"1\":{\"1828\":1}}],[\"然后再去大表搜索\",{\"1\":{\"1539\":1}}],[\"然后再运行\",{\"1\":{\"1332\":1}}],[\"然后再各处都可以使用\",{\"1\":{\"1168\":1}}],[\"然后再次malloc分配\",{\"1\":{\"1102\":1}}],[\"然后再回到之前的分配流程分配出去\",{\"1\":{\"1102\":1}}],[\"然后再开辟栈空间\",{\"1\":{\"1063\":1}}],[\"然后再执行基类的析构函数\",{\"1\":{\"949\":1}}],[\"然后再给被调函数开辟栈帧\",{\"1\":{\"500\":1}}],[\"然后在xxx\",{\"1\":{\"1915\":1}}],[\"然后在通过dump线程和io线程将这个操作发送到从库的relay\",{\"1\":{\"1830\":1}}],[\"然后在事务提交时\",{\"1\":{\"1762\":1}}],[\"然后在排序区\",{\"1\":{\"1736\":2}}],[\"然后在server层进行过滤返回符合要求的记录\",{\"1\":{\"1618\":1}}],[\"然后在继续查看密码相关信息\",{\"1\":{\"1407\":1}}],[\"然后在mysql命令行输入命令\",{\"1\":{\"1407\":1}}],[\"然后在里面写入符合语法规则的编译命令\",{\"1\":{\"1352\":1}}],[\"然后在b类构造函数初始化列表中调用a类的构造函数\",{\"1\":{\"943\":1}}],[\"然后在进行修改\",{\"1\":{\"52\":1}}],[\"然后生成解决方案\",{\"1\":{\"936\":1}}],[\"然后调用派生类构造\",{\"1\":{\"908\":1}}],[\"然后调用派生类中成员对象的析构函数\",{\"1\":{\"891\":1}}],[\"然后调用对象的构造函数\",{\"1\":{\"710\":1}}],[\"然后返回一个对应的对象\",{\"1\":{\"863\":1}}],[\"然后一起走\",{\"1\":{\"771\":1}}],[\"然后让类d继承自a\",{\"1\":{\"652\":1}}],[\"然后直接引用临时量\",{\"1\":{\"622\":1}}],[\"然后赋值给t4\",{\"1\":{\"1112\":2}}],[\"然后赋值\",{\"1\":{\"614\":1}}],[\"然后处理\",{\"1\":{\"524\":1}}],[\"然后进行存储\",{\"1\":{\"1603\":1}}],[\"然后进行调用拷贝构造函数\",{\"1\":{\"399\":1}}],[\"然后进入mysql数据库\",{\"1\":{\"1408\":1}}],[\"然后进入系统\",{\"1\":{\"1285\":1}}],[\"然后进入被调函数\",{\"1\":{\"500\":1}}],[\"然后执行处理流程crud\",{\"1\":{\"1864\":1}}],[\"然后执行exit命令退出mysql服务\",{\"1\":{\"1408\":1}}],[\"然后执行以下操作\",{\"1\":{\"1030\":1}}],[\"然后执行call指令\",{\"1\":{\"500\":1}}],[\"然后执行程序使其停在断点处\",{\"1\":{\"240\":1}}],[\"然后释放\",{\"1\":{\"384\":1}}],[\"然后用命令重新配置slave\",{\"1\":{\"1829\":1}}],[\"然后用p1拷贝构造p2\",{\"1\":{\"1043\":1}}],[\"然后用\",{\"1\":{\"312\":1}}],[\"然后依次点击监视\",{\"1\":{\"306\":1}}],[\"然后依下边路径找到找到frame\",{\"1\":{\"61\":1}}],[\"然后将这部分数据的状态修改为commit\",{\"1\":{\"1763\":1}}],[\"然后将结果存进指定变量名\",{\"1\":{\"1312\":1}}],[\"然后将指针置空\",{\"1\":{\"759\":1}}],[\"然后将前半部分和后半部分进行比较\",{\"1\":{\"756\":1}}],[\"然后将原来的数据拷贝到新内存块中并将原内存块中的对象销毁\",{\"1\":{\"354\":1}}],[\"然后将\",{\"1\":{\"302\":1,\"1102\":1}}],[\"然后\",{\"1\":{\"261\":1,\"576\":1,\"1239\":1,\"1410\":1,\"1754\":1}}],[\"然后esp从main函数\",{\"1\":{\"234\":1}}],[\"然后对这两个数组分别进⾏排序\",{\"1\":{\"202\":1}}],[\"然后按下快捷键alt+7调出call\",{\"1\":{\"240\":1}}],[\"然后按每个位数分别比较\",{\"1\":{\"191\":1}}],[\"然后按照下图将其后的双引号里面的内容改写\",{\"1\":{\"61\":1}}],[\"然后向左或者向右遍历找到边界\",{\"1\":{\"95\":1}}],[\"然后就可以使用func1\",{\"1\":{\"1164\":1}}],[\"然后就可以使用多态了\",{\"1\":{\"883\":1}}],[\"然后就可以把数组一分为二\",{\"1\":{\"91\":1}}],[\"然后就是source\",{\"1\":{\"41\":1}}],[\"然后找到\",{\"1\":{\"66\":1}}],[\"然后找到并选中上一步解压文件夹里的\",{\"1\":{\"28\":1}}],[\"基于列字段进行\",{\"1\":{\"1889\":1}}],[\"基于c\",{\"1\":{\"1864\":1}}],[\"基于cas的原子整形\",{\"1\":{\"1863\":1}}],[\"基于cas操作的原子类型\",{\"1\":{\"1202\":1}}],[\"基于mysql的主从同步状态决定是否进行切换\",{\"1\":{\"1803\":1}}],[\"基于主从复制的读写分离\",{\"1\":{\"1790\":1}}],[\"基于技术实现\",{\"1\":{\"1781\":1}}],[\"基数为7\",{\"1\":{\"1090\":1}}],[\"基数排序\",{\"0\":{\"191\":1}}],[\"基类向外提供统一的接口\",{\"1\":{\"1881\":1}}],[\"基类被重写的函数的入口地址应该是直接不用了\",{\"1\":{\"958\":1}}],[\"基类a\",{\"1\":{\"939\":1}}],[\"基类变为虚基类\",{\"1\":{\"937\":1}}],[\"基类定义虚函数\",{\"1\":{\"916\":1}}],[\"基类构造首先会将基类的vftable写入vfptr\",{\"1\":{\"908\":1}}],[\"基类构造函数\",{\"1\":{\"666\":1}}],[\"基类中给所有派生类\",{\"1\":{\"883\":1}}],[\"基类配置\",{\"1\":{\"831\":3}}],[\"基类指针调用虚函数\",{\"1\":{\"916\":1}}],[\"基类指针就可以指向派生类对象\",{\"1\":{\"886\":1}}],[\"基类指针指向哪个对象\",{\"1\":{\"1881\":1}}],[\"基类指针指向哪个派生类对象\",{\"1\":{\"883\":1}}],[\"基类指针指向派生类对象\",{\"1\":{\"920\":1}}],[\"基类指针指向派⽣类对象时\",{\"1\":{\"695\":1}}],[\"基类指针指向基类对象\",{\"1\":{\"920\":1}}],[\"基类指针指向不同派生类对象访问不同派生类重写的getmilespergallon\",{\"1\":{\"900\":1}}],[\"基类指针指向了三个不同的对象\",{\"1\":{\"886\":1}}],[\"基类指针\",{\"1\":{\"883\":1}}],[\"基类指针可以直接调用到派⽣类的\",{\"1\":{\"695\":1}}],[\"基类指针可以直接调用到派⽣类的覆盖函数\",{\"1\":{\"695\":1}}],[\"基类是12字节\",{\"1\":{\"684\":1}}],[\"基类\",{\"1\":{\"683\":1,\"684\":1,\"1011\":1}}],[\"基类析构函数会被\",{\"1\":{\"675\":1}}],[\"基类有默认构造函数\",{\"0\":{\"671\":1},\"1\":{\"671\":1}}],[\"基类有一个无参构造函数\",{\"1\":{\"423\":1}}],[\"基类的指针\",{\"0\":{\"948\":1},\"1\":{\"948\":1}}],[\"基类的指针指向派生类对象\",{\"1\":{\"916\":1}}],[\"基类的对象内存如图\",{\"1\":{\"908\":1}}],[\"基类的默认构造函数会自动调用\",{\"1\":{\"671\":1}}],[\"基类的拷贝构造或赋值运算符函数\",{\"1\":{\"662\":2}}],[\"基类的拷贝构造函数和operator=运算符函数不能被派生类继承\",{\"1\":{\"662\":1}}],[\"基类的私有成员只能继承\",{\"1\":{\"658\":1}}],[\"基类n\",{\"1\":{\"646\":1}}],[\"基类1\",{\"1\":{\"646\":1}}],[\"基本上不超过三层\",{\"1\":{\"1623\":1}}],[\"基本上不需要额外辅助的数据结构\",{\"1\":{\"67\":1}}],[\"基本不用\",{\"1\":{\"1507\":1}}],[\"基本数据类型\",{\"0\":{\"1420\":1}}],[\"基本数据类型有常量和变量\",{\"1\":{\"323\":1}}],[\"基本命令\",{\"0\":{\"1340\":1}}],[\"基本编译命令\",{\"0\":{\"1326\":1}}],[\"基本的语法是\",{\"1\":{\"1248\":1}}],[\"基本格式\",{\"0\":{\"584\":1}}],[\"基础必备\",{\"0\":{\"1924\":1},\"1\":{\"1063\":1}}],[\"基础\",{\"0\":{\"1928\":1},\"1\":{\"678\":1,\"692\":1,\"707\":1,\"750\":1,\"1121\":1}}],[\"基础知识\",{\"0\":{\"1039\":1},\"2\":{\"103\":1,\"825\":1}}],[\"基础版\",{\"0\":{\"92\":1,\"821\":1}}],[\"基因序列比对工具\",{\"0\":{\"3\":1}}],[\"的有序集合\",{\"1\":{\"1899\":1}}],[\"的有效内存大小为24\",{\"1\":{\"285\":1}}],[\"的代码\",{\"1\":{\"1896\":1}}],[\"的拆分到扩展表\",{\"1\":{\"1889\":1}}],[\"的访问瓶颈\",{\"1\":{\"1864\":1}}],[\"的下标\",{\"1\":{\"1839\":2,\"1849\":2,\"1875\":2,\"1878\":2}}],[\"的ip地址\",{\"1\":{\"1818\":1}}],[\"的出现\",{\"1\":{\"1736\":1}}],[\"的可重复读隔离级别下\",{\"1\":{\"1721\":1}}],[\"的可执行文件\",{\"1\":{\"1312\":1}}],[\"的右边\",{\"1\":{\"1689\":1}}],[\"的任何记录\",{\"1\":{\"1686\":1}}],[\"的关键技术\",{\"1\":{\"1679\":1}}],[\"的关键字\",{\"1\":{\"1315\":1}}],[\"的变化\",{\"1\":{\"1679\":1}}],[\"的事务\",{\"1\":{\"1656\":1}}],[\"的事务的事务\",{\"1\":{\"1656\":1}}],[\"的一种数据交换的格式\",{\"1\":{\"1913\":1}}],[\"的一致性读取\",{\"1\":{\"1656\":1}}],[\"的一段内存\",{\"1\":{\"509\":1}}],[\"的幻读问题\",{\"1\":{\"1631\":1}}],[\"的时间复杂度就访问到哈希索引name\",{\"1\":{\"1569\":1}}],[\"的时候绑定到变量上面\",{\"1\":{\"618\":1}}],[\"的时候索引无效\",{\"1\":{\"539\":1}}],[\"的时候\",{\"0\":{\"948\":1},\"1\":{\"135\":2,\"400\":1,\"520\":1,\"1664\":1}}],[\"的记录加锁\",{\"1\":{\"1686\":1}}],[\"的记录\",{\"1\":{\"1518\":1,\"1740\":1}}],[\"的字段\",{\"1\":{\"1460\":1}}],[\"的字母异位词\",{\"1\":{\"166\":1}}],[\"的socket处于\",{\"1\":{\"1398\":1}}],[\"的当前值\",{\"1\":{\"1346\":1}}],[\"的静态库\",{\"1\":{\"1334\":1}}],[\"的名字\",{\"1\":{\"1318\":1}}],[\"的option命令\",{\"1\":{\"1318\":1}}],[\"的链接库\",{\"1\":{\"1315\":1}}],[\"的链表节点\",{\"1\":{\"801\":1}}],[\"的源文件编译成一个名称为\",{\"1\":{\"1312\":1}}],[\"的源码后得知\",{\"1\":{\"1043\":1}}],[\"的后面的字符来命令\",{\"1\":{\"1251\":1}}],[\"的思想\",{\"1\":{\"1209\":1}}],[\"的构造\",{\"1\":{\"1115\":1}}],[\"的最佳实践\",{\"1\":{\"1896\":1}}],[\"的最大值\",{\"1\":{\"1656\":1}}],[\"的最小值\",{\"1\":{\"1656\":1}}],[\"的最低版本\",{\"1\":{\"1312\":1}}],[\"的最后的结果是最后一个表达式n的结果\",{\"1\":{\"1114\":1}}],[\"的最高地址指针\",{\"1\":{\"281\":1}}],[\"的对应位置\",{\"1\":{\"1102\":1}}],[\"的8b的内存池申请\",{\"1\":{\"1102\":1}}],[\"的结构\",{\"1\":{\"1082\":1}}],[\"的前4字节内存\",{\"1\":{\"954\":1}}],[\"的析构函数\",{\"1\":{\"891\":1}}],[\"的区域很大\",{\"1\":{\"802\":1}}],[\"的区别在于\",{\"0\":{\"1476\":1}}],[\"的区别\",{\"0\":{\"312\":1,\"1357\":1}}],[\"的节点之前\",{\"1\":{\"795\":1}}],[\"的节点都出现在\",{\"1\":{\"795\":1}}],[\"的节点追加到链表的最后一个元素\",{\"1\":{\"790\":1}}],[\"的节点\",{\"1\":{\"790\":2}}],[\"的所有迭代器全部失效\",{\"1\":{\"741\":2}}],[\"的虚函数\",{\"1\":{\"695\":1}}],[\"的双重拷贝\",{\"1\":{\"653\":1}}],[\"的为引用\",{\"1\":{\"613\":1}}],[\"的异常类型\",{\"1\":{\"600\":1}}],[\"的意思\",{\"1\":{\"599\":1}}],[\"的意思可以看出\",{\"1\":{\"599\":1}}],[\"的机制\",{\"1\":{\"883\":1}}],[\"的机制有关\",{\"1\":{\"523\":1}}],[\"的机会\",{\"1\":{\"597\":1}}],[\"的方式进行编译\",{\"1\":{\"577\":1}}],[\"的方法\",{\"1\":{\"353\":1}}],[\"的理解和用法\",{\"0\":{\"577\":1}}],[\"的函数\",{\"1\":{\"560\":1}}],[\"的整体对齐规则\",{\"0\":{\"556\":1}}],[\"的整数数组\",{\"1\":{\"140\":1}}],[\"的数据成员\",{\"1\":{\"555\":1}}],[\"的数组\",{\"1\":{\"113\":1}}],[\"的读取不是连续的\",{\"1\":{\"553\":1}}],[\"的使用场景2\",{\"0\":{\"576\":1}}],[\"的使用场景1\",{\"0\":{\"575\":1}}],[\"的使用\",{\"0\":{\"1321\":1},\"1\":{\"530\":1}}],[\"的类型\",{\"0\":{\"956\":1}}],[\"的类型转换\",{\"1\":{\"629\":1}}],[\"的类\",{\"1\":{\"530\":1}}],[\"的头文件展开原则\",{\"1\":{\"826\":1}}],[\"的头文件\",{\"1\":{\"515\":1}}],[\"的调用\",{\"1\":{\"500\":1}}],[\"的调用时机\",{\"1\":{\"399\":1}}],[\"的指针的时候\",{\"1\":{\"526\":1}}],[\"的指针\",{\"1\":{\"490\":1}}],[\"的大小表设置不合理\",{\"1\":{\"1744\":1}}],[\"的大小和query语句取出的字段总大小\",{\"1\":{\"1736\":1}}],[\"的大小为0\",{\"1\":{\"470\":1}}],[\"的大致实现\",{\"1\":{\"76\":1}}],[\"的摩托车和自行车\",{\"1\":{\"449\":1}}],[\"的成员函数\",{\"1\":{\"440\":1}}],[\"的模板参数包\",{\"1\":{\"376\":1}}],[\"的参数\",{\"1\":{\"375\":1}}],[\"的正确性\",{\"1\":{\"340\":1}}],[\"的值分别是\",{\"1\":{\"1686\":1}}],[\"的值\",{\"1\":{\"1318\":1}}],[\"的值后程序崩溃\",{\"1\":{\"597\":1}}],[\"的值为\",{\"1\":{\"340\":1}}],[\"的值是\",{\"1\":{\"307\":1}}],[\"的规定\",{\"0\":{\"316\":1}}],[\"的查找范围更广\",{\"1\":{\"312\":1}}],[\"的printf\",{\"1\":{\"310\":1}}],[\"的第二个字母作为这种语言的名字\",{\"1\":{\"301\":1}}],[\"的基础上最终设计出了一种新的语言\",{\"1\":{\"301\":1}}],[\"的跨平台性较差\",{\"1\":{\"301\":1}}],[\"的开发项目\",{\"1\":{\"301\":1}}],[\"的首字母\",{\"1\":{\"301\":1}}],[\"的汇编代码\",{\"0\":{\"259\":1}}],[\"的符号表\",{\"0\":{\"257\":1}}],[\"的ebp存入栈\",{\"1\":{\"235\":1}}],[\"的效果可能与\",{\"1\":{\"228\":1}}],[\"的序列的排序\",{\"1\":{\"212\":1}}],[\"的⼀个⾮常典型的应⽤\",{\"1\":{\"202\":1}}],[\"的升级版\",{\"1\":{\"199\":1}}],[\"的\",{\"0\":{\"1132\":1,\"1290\":1},\"1\":{\"169\":1,\"301\":1,\"302\":1,\"344\":1,\"421\":1,\"530\":1,\"728\":1,\"1656\":1,\"1686\":1,\"1706\":1}}],[\"的形式保存\",{\"1\":{\"1772\":1}}],[\"的形式来调用\",{\"1\":{\"925\":1}}],[\"的形式加载头文件test\",{\"1\":{\"312\":1}}],[\"的形式返回这两个整数的下标\",{\"1\":{\"140\":1}}],[\"的形式给出\",{\"1\":{\"67\":1}}],[\"的两个数\",{\"1\":{\"140\":1}}],[\"的情况会影响形参类型\",{\"1\":{\"563\":1}}],[\"的情况\",{\"1\":{\"136\":1}}],[\"的操作\",{\"1\":{\"136\":1}}],[\"的去重\",{\"1\":{\"136\":1}}],[\"的算法解决此问题\",{\"1\":{\"129\":1}}],[\"的长度\",{\"1\":{\"129\":1,\"597\":1,\"771\":1}}],[\"的比较\",{\"1\":{\"126\":1}}],[\"的那\",{\"1\":{\"124\":1}}],[\"的元素的位置\",{\"1\":{\"162\":1}}],[\"的元素\",{\"1\":{\"113\":1}}],[\"的额外空间解决这一问题\",{\"1\":{\"67\":1}}],[\"的颜色\",{\"1\":{\"50\":1}}],[\"恭喜你\",{\"1\":{\"66\":1}}],[\"大量的在使用protobuf作为数据序列化的方式\",{\"1\":{\"1901\":1}}],[\"大批量插入数据\",{\"0\":{\"1728\":1}}],[\"大部分都是由于我们多个线程在获取多个锁资源的时候\",{\"1\":{\"1706\":1}}],[\"大表相关联的字段没有索引的话\",{\"1\":{\"1590\":1}}],[\"大数据分析列式数据库\",{\"1\":{\"1452\":1}}],[\"大\",{\"1\":{\"1331\":1,\"1686\":1}}],[\"大多数项目为了默认为release模式\",{\"1\":{\"1320\":1}}],[\"大多数情况下都会出现内存溢出的错误\",{\"1\":{\"240\":1}}],[\"大到小排序\",{\"1\":{\"1147\":1,\"1148\":1}}],[\"大根堆为堆顶\",{\"1\":{\"994\":1}}],[\"大根堆\",{\"1\":{\"984\":1}}],[\"大括号\",{\"1\":{\"1898\":1,\"1899\":1}}],[\"大括号内不仅可以存放变量\",{\"1\":{\"585\":1}}],[\"大括号后多了一个分号\",{\"1\":{\"274\":1}}],[\"大致可以看出来new表达式并不直接开辟内存出来\",{\"1\":{\"518\":1}}],[\"大大提高程序的效率\",{\"1\":{\"359\":1}}],[\"大顶堆\",{\"1\":{\"194\":2}}],[\"大于或等于x\",{\"1\":{\"795\":2}}],[\"大于链表长度\",{\"1\":{\"790\":1}}],[\"大于128k的内存分配\",{\"0\":{\"284\":1}}],[\"大于的放右边\",{\"1\":{\"220\":1}}],[\"大于\",{\"1\":{\"113\":1,\"1686\":1}}],[\"大小表\",{\"0\":{\"1540\":1}}],[\"大小的chunk块位于\",{\"1\":{\"1090\":2}}],[\"大小也会变\",{\"1\":{\"955\":1}}],[\"大小1\",{\"1\":{\"330\":1}}],[\"大小\",{\"1\":{\"101\":1,\"238\":1}}],[\"大家知道\",{\"1\":{\"1623\":1}}],[\"大家就自己点击\",{\"1\":{\"66\":1}}],[\"大家第一次可能电脑没有把typora添加进来\",{\"1\":{\"66\":1}}],[\"大纲自动编号\",{\"0\":{\"51\":1}}],[\"管理连接\",{\"1\":{\"1881\":1}}],[\"管理员是\",{\"1\":{\"1374\":1}}],[\"管理空间\",{\"1\":{\"282\":1,\"285\":1}}],[\"管理3d设置\",{\"1\":{\"66\":1}}],[\"管道\",{\"1\":{\"17\":1}}],[\"进一步获取虚函数表中虚函数地址\",{\"1\":{\"959\":1}}],[\"进了一批新的投影仪\",{\"1\":{\"832\":1}}],[\"进而被\",{\"1\":{\"601\":1}}],[\"进阶阅读\",{\"0\":{\"264\":1}}],[\"进程类的数据库\",{\"1\":{\"1452\":1}}],[\"进程就会异常终止\",{\"1\":{\"1207\":2}}],[\"进程退出时调用\",{\"1\":{\"848\":1,\"851\":1}}],[\"进程\",{\"1\":{\"283\":1,\"284\":1}}],[\"进程启动的时候\",{\"1\":{\"283\":1}}],[\"进程分配内存有2种方式\",{\"1\":{\"281\":1}}],[\"进程虚拟地址空间\",{\"0\":{\"267\":1}}],[\"进程的虚拟地址空间\",{\"1\":{\"263\":1}}],[\"进程间通信\",{\"1\":{\"17\":1}}],[\"进行对于的连接回收\",{\"1\":{\"1848\":1,\"1849\":2,\"1859\":3}}],[\"进行配置\",{\"1\":{\"1831\":1}}],[\"进行回滚就很简单了\",{\"1\":{\"1681\":1}}],[\"进行大量无用的磁盘i\",{\"1\":{\"1609\":1}}],[\"进行并发操作\",{\"1\":{\"1569\":1}}],[\"进行分组查询\",{\"1\":{\"1497\":1}}],[\"进行压缩\",{\"1\":{\"1261\":1}}],[\"进行释放的\",{\"1\":{\"1060\":1}}],[\"进行了一些简单的默认配置\",{\"1\":{\"1026\":1}}],[\"进行扩容\",{\"1\":{\"973\":1,\"974\":1}}],[\"进行动态绑定时\",{\"1\":{\"908\":1}}],[\"进行类的封装\",{\"1\":{\"881\":1}}],[\"进行视频播放\",{\"1\":{\"832\":2}}],[\"进行下行转换\",{\"1\":{\"629\":1}}],[\"进行上行转换\",{\"1\":{\"629\":1}}],[\"进行memcpy拷贝没有问题\",{\"1\":{\"401\":1}}],[\"进行实参与形参的结合时\",{\"1\":{\"398\":1}}],[\"进行符号解析\",{\"1\":{\"255\":2}}],[\"进行出栈操作\",{\"0\":{\"235\":1}}],[\"进行比较\",{\"1\":{\"135\":1}}],[\"进行后面的操作\",{\"1\":{\"91\":1}}],[\"进入配置文件修改相应配置\",{\"1\":{\"1408\":1}}],[\"进入函数调用\",{\"1\":{\"1340\":1}}],[\"进入解压完成的文件夹\",{\"1\":{\"1285\":1}}],[\"进入ipv4分页\",{\"1\":{\"1278\":1}}],[\"进入if中\",{\"1\":{\"1102\":1}}],[\"进入的等待状态\",{\"1\":{\"1221\":1}}],[\"进入while循环\",{\"1\":{\"1221\":1}}],[\"进入等待状态\",{\"1\":{\"1219\":1}}],[\"进入else中\",{\"1\":{\"1102\":1}}],[\"进入后\",{\"1\":{\"1063\":1}}],[\"进入sum函数之后\",{\"1\":{\"234\":1}}],[\"进入调用函数\",{\"1\":{\"234\":1}}],[\"进入\",{\"1\":{\"66\":1}}],[\"高可用性\",{\"1\":{\"1779\":1,\"1780\":1}}],[\"高\",{\"1\":{\"1331\":1}}],[\"高阳\",{\"1\":{\"1002\":1}}],[\"高质量程序设计指南\",{\"1\":{\"503\":2,\"505\":1}}],[\"高位在后\",{\"1\":{\"307\":1}}],[\"高地址物理内存\",{\"1\":{\"267\":1}}],[\"高性能\",{\"0\":{\"66\":1},\"1\":{\"66\":1}}],[\"高亮当前选中\",{\"0\":{\"40\":1}}],[\"高亮当前行\",{\"0\":{\"39\":1}}],[\"高亮快捷键修改\",{\"0\":{\"38\":1}}],[\"高亮设置\",{\"0\":{\"37\":1}}],[\"软连接\",{\"1\":{\"1271\":1}}],[\"软件启动的时候比之前慢\",{\"1\":{\"63\":1}}],[\"软链接的删除\",{\"0\":{\"1272\":1}}],[\"软链接\",{\"0\":{\"1266\":1,\"1268\":1},\"1\":{\"17\":1}}],[\"就相应解决\",{\"1\":{\"1830\":1}}],[\"就改成mysqld\",{\"1\":{\"1820\":1}}],[\"就知道是配置的端口错误\",{\"1\":{\"1806\":1}}],[\"就知道是insert增加的数据\",{\"1\":{\"1682\":1}}],[\"就应该判断是网络原因\",{\"1\":{\"1806\":1}}],[\"就开始写redo\",{\"1\":{\"1758\":1}}],[\"就要使用redo\",{\"1\":{\"1757\":1}}],[\"就必须要对上层的应用来进行一些优化\",{\"1\":{\"1745\":1}}],[\"就必然需要调用构造函数\",{\"1\":{\"395\":1}}],[\"就得说到事务的acid特性\",{\"1\":{\"1711\":1}}],[\"就得到可执行文件\",{\"1\":{\"310\":1}}],[\"就算事务1把age=20的数据插入表\",{\"1\":{\"1689\":1}}],[\"就算有其他事务修改了数据并且已经提交了\",{\"1\":{\"1635\":1}}],[\"就能连接上了\",{\"1\":{\"1826\":1}}],[\"就能防止幻读\",{\"1\":{\"1688\":1}}],[\"就能得到结果\",{\"1\":{\"147\":1}}],[\"就回滚1个事务\",{\"1\":{\"1652\":1}}],[\"就发生了幻读\",{\"1\":{\"1635\":1}}],[\"就一定在小的桶里面\",{\"1\":{\"1603\":1}}],[\"就证明mysql已经安装完毕\",{\"0\":{\"1391\":1}}],[\"就\",{\"1\":{\"1186\":1}}],[\"就匹配\",{\"1\":{\"1186\":1}}],[\"就选择对应的\",{\"1\":{\"1186\":1}}],[\"就看这个类类型有没有带int类型参数的构造函数\",{\"1\":{\"1112\":1}}],[\"就malloc申请\",{\"1\":{\"1102\":1}}],[\"就从备用内存中拿\",{\"1\":{\"1102\":1}}],[\"就释放资源\",{\"1\":{\"1055\":1}}],[\"就达到了所谓的智能指针\",{\"1\":{\"1041\":1}}],[\"就称为虚基类\",{\"1\":{\"931\":1}}],[\"就调用哪个存储引擎类的方法\",{\"1\":{\"1881\":1}}],[\"就调用子类的函数\",{\"1\":{\"923\":1}}],[\"就调用基类的函数\",{\"1\":{\"923\":1}}],[\"就调用构造函数创建全局对象\",{\"1\":{\"427\":1}}],[\"就绑定了它\",{\"1\":{\"876\":1}}],[\"就把原链表的节点断开\",{\"1\":{\"795\":1}}],[\"就可以用到索引\",{\"1\":{\"1737\":1}}],[\"就可以对a进行\",{\"1\":{\"1697\":1}}],[\"就可以成功\",{\"1\":{\"1693\":1}}],[\"就可以看见id=24的数据了\",{\"1\":{\"1665\":1}}],[\"就可以通过一次磁盘i\",{\"1\":{\"1623\":1}}],[\"就可以在\",{\"1\":{\"1317\":1,\"1656\":1}}],[\"就可以使用add\",{\"1\":{\"1317\":1}}],[\"就可以显式生成临时对象\",{\"1\":{\"1112\":1}}],[\"就可以很好的解决这个问题了\",{\"1\":{\"981\":1}}],[\"就可以解决该问题\",{\"1\":{\"949\":1}}],[\"就可以解决了\",{\"1\":{\"653\":1}}],[\"就可以每次获得\",{\"1\":{\"784\":1}}],[\"就前进两步\",{\"1\":{\"765\":1}}],[\"就将相应迭代器指向容器的指针置为空\",{\"1\":{\"747\":1}}],[\"就需要设置事务的隔离级别\",{\"1\":{\"1711\":1}}],[\"就需要设置串行化隔离级别\",{\"1\":{\"1635\":1}}],[\"就需要加锁\",{\"1\":{\"1569\":1}}],[\"就需要再开辟一个二维数组\",{\"1\":{\"968\":1}}],[\"就需要使用abstract\",{\"1\":{\"866\":1}}],[\"就需要虚继承来处理了\",{\"1\":{\"688\":1}}],[\"就需要注意以下几种情况\",{\"1\":{\"662\":1}}],[\"就有所不同\",{\"1\":{\"630\":1}}],[\"就不必等待\",{\"1\":{\"1783\":1}}],[\"就不能把整个索引全部加载到内存了\",{\"1\":{\"1621\":1}}],[\"就不会使用索引\",{\"1\":{\"1617\":1}}],[\"就不会再调用基类的\",{\"1\":{\"662\":1}}],[\"就不会再改变其指向\",{\"1\":{\"612\":1}}],[\"就不用加锁\",{\"1\":{\"1569\":1}}],[\"就不用再填写地址域了\",{\"1\":{\"1102\":1}}],[\"就不产生了\",{\"1\":{\"1110\":1,\"1111\":1}}],[\"就不再使用gpu了\",{\"1\":{\"63\":1}}],[\"就如\",{\"1\":{\"605\":1}}],[\"就恢复了正常的执行流\",{\"1\":{\"599\":1}}],[\"就没了函数的调用开销了\",{\"1\":{\"501\":1}}],[\"就像住在同一宿舍里的同学共享一个房间号一样\",{\"1\":{\"435\":1}}],[\"就被创建并初始化的\",{\"1\":{\"435\":1}}],[\"就成为常量成员\",{\"1\":{\"432\":1}}],[\"就会在master上做读和写操作\",{\"1\":{\"1803\":1}}],[\"就会发生幻读\",{\"1\":{\"1686\":1}}],[\"就会产生一个数据快照\",{\"1\":{\"1658\":1}}],[\"就会产生非const左值引用不能绑定到右值的报错\",{\"1\":{\"466\":1}}],[\"就会马上启动事务\",{\"1\":{\"1656\":1}}],[\"就会导致所有的索引值重新计算存储位置\",{\"1\":{\"1604\":1}}],[\"就会导致更多的磁盘i\",{\"1\":{\"1603\":1}}],[\"就会看到超过执行时间的sql\",{\"1\":{\"1573\":1}}],[\"就会进入子目录去找\",{\"1\":{\"1315\":1}}],[\"就会从等待状态\",{\"1\":{\"1219\":1}}],[\"就会调用哪个派生类对象的同名覆盖方法\",{\"1\":{\"883\":1}}],[\"就会把该空间中的所有实体一次性引入到程序之中\",{\"1\":{\"588\":1}}],[\"就会报错\",{\"1\":{\"400\":1}}],[\"就会给所有的符号分配虚拟地址\",{\"1\":{\"245\":1}}],[\"就已经知道参数的个数了\",{\"1\":{\"378\":1}}],[\"就代表负数\",{\"1\":{\"339\":1}}],[\"就代表正数\",{\"1\":{\"339\":1}}],[\"就拿出多少个字节的内存来提供使用\",{\"1\":{\"285\":1}}],[\"就完成虚拟内存分配\",{\"1\":{\"283\":1}}],[\"就是linux上的mysql\",{\"1\":{\"1814\":1}}],[\"就是通过来复制的\",{\"1\":{\"1781\":1}}],[\"就是通过一张虚函数表\",{\"1\":{\"914\":1}}],[\"就是要保证redo\",{\"1\":{\"1763\":1}}],[\"就是redo\",{\"1\":{\"1758\":1}}],[\"就是right还是一个数一个数的减下去的\",{\"1\":{\"136\":1}}],[\"就是行锁\",{\"1\":{\"1686\":1}}],[\"就是并发控制\",{\"1\":{\"1644\":1}}],[\"就是把当前目录下需要的文件搜集到sources变量中\",{\"1\":{\"1312\":1}}],[\"就是192\",{\"1\":{\"1239\":1}}],[\"就是让所有的线程对共享变量不再进行缓存\",{\"1\":{\"1233\":1}}],[\"就是让所有的类对象\",{\"1\":{\"898\":1}}],[\"就是由cas来实现的\",{\"1\":{\"1232\":1}}],[\"就是由private关键字来体现\",{\"1\":{\"449\":1}}],[\"就是函数对象更高级的实现\",{\"1\":{\"1171\":1}}],[\"就是函数指针\",{\"1\":{\"493\":1}}],[\"就是意味着用户调用的时候要传入几个参数\",{\"1\":{\"1155\":1}}],[\"就是多个智能指针多次释放同一个资源\",{\"1\":{\"1054\":1}}],[\"就是从大到小排序\",{\"1\":{\"985\":1}}],[\"就是采用的静态多态\",{\"1\":{\"883\":1}}],[\"就是每一个实例工厂负责生产一个实例产品\",{\"1\":{\"866\":1}}],[\"就是左值\",{\"1\":{\"621\":1}}],[\"就是右值\",{\"1\":{\"621\":1}}],[\"就是明确地告诉程序发生了什么错误\",{\"1\":{\"599\":1}}],[\"就是报告一个运行时错误\",{\"1\":{\"597\":1}}],[\"就是将命名空间的名字符号给去掉\",{\"1\":{\"591\":1}}],[\"就是将给符号分配后的地址写回代码段\",{\"1\":{\"245\":1}}],[\"就是\",{\"1\":{\"489\":2,\"1082\":1}}],[\"就是bool类型\",{\"1\":{\"473\":1}}],[\"就是默认访问权限不同\",{\"1\":{\"450\":1}}],[\"就是靠这个this指针\",{\"1\":{\"392\":1}}],[\"就是类的成员函数也可以设置为模板\",{\"1\":{\"372\":1}}],[\"就是保存其他对象的对象\",{\"1\":{\"353\":1}}],[\"就是我们在项目工程中设置的头文件引用目录\",{\"1\":{\"312\":1}}],[\"就返回当前迭代器\",{\"1\":{\"1148\":1}}],[\"就返回\",{\"1\":{\"146\":1}}],[\"就返回下标\",{\"1\":{\"93\":1,\"94\":1}}],[\"就说明这张表肯定有某些数据被加上了x锁\",{\"1\":{\"1673\":1}}],[\"就说明右半边都没有\",{\"1\":{\"93\":1}}],[\"就说明左半边都没有\",{\"1\":{\"93\":1,\"94\":1}}],[\"就删除这个快捷方式\",{\"1\":{\"27\":1}}],[\"编号为\",{\"1\":{\"812\":1}}],[\"编号为k的人开始报数\",{\"1\":{\"810\":1}}],[\"编译源文件生成目标文件\",{\"1\":{\"1365\":1}}],[\"编译源码获得log4cpp\",{\"1\":{\"1029\":1}}],[\"编译并汇编\",{\"1\":{\"1330\":2}}],[\"编译\",{\"0\":{\"1330\":1}}],[\"编译多个源文件\",{\"0\":{\"1329\":1}}],[\"编译c++程序\",{\"1\":{\"1326\":1}}],[\"编译c程序\",{\"1\":{\"1326\":1}}],[\"编译工具\",{\"0\":{\"1946\":1},\"2\":{\"1324\":1,\"1337\":1,\"1350\":1,\"1370\":1}}],[\"编译选项\",{\"0\":{\"1317\":1},\"1\":{\"1310\":2}}],[\"编译目录\",{\"1\":{\"1310\":1}}],[\"编译之后需要一个对象\",{\"1\":{\"1151\":1}}],[\"编译报错\",{\"1\":{\"1047\":1}}],[\"编译代码时\",{\"1\":{\"1035\":1}}],[\"编译使用log4cpp库的cpp文件时\",{\"1\":{\"1030\":1}}],[\"编译过程知道调用对象的函数operator\",{\"1\":{\"982\":1}}],[\"编译期间将高级源代码编译为汇编码\",{\"1\":{\"953\":1}}],[\"编译防火墙\",{\"1\":{\"826\":1}}],[\"编译提示typeinfo\",{\"1\":{\"614\":2}}],[\"编译执行成功\",{\"1\":{\"570\":1}}],[\"编译得到目标文件并查看目标文件符号表\",{\"1\":{\"568\":1}}],[\"编译时生成与gcc\",{\"1\":{\"1331\":1}}],[\"编译时多态\",{\"1\":{\"883\":1}}],[\"编译时是不会报错的\",{\"1\":{\"608\":1}}],[\"编译时\",{\"1\":{\"564\":1}}],[\"编译时产生不同的符号\",{\"1\":{\"562\":1}}],[\"编译时会直接报错\",{\"1\":{\"312\":1}}],[\"编译语句中添加\",{\"1\":{\"516\":1}}],[\"编译方式不一样\",{\"1\":{\"482\":1}}],[\"编译器的\",{\"1\":{\"1317\":1}}],[\"编译器名称\",{\"1\":{\"1310\":1}}],[\"编译器是从上到下编译的\",{\"1\":{\"1147\":1}}],[\"编译器就看这个类类型\",{\"1\":{\"1112\":2}}],[\"编译器就无法生成默认构造函数\",{\"1\":{\"423\":1}}],[\"编译器报错\",{\"1\":{\"1011\":1}}],[\"编译器仍将其解释为静态联编的\",{\"1\":{\"925\":1}}],[\"编译器根据决定要调用哪个函数\",{\"1\":{\"920\":2}}],[\"编译器需类型产生一个vftable虚函数表\",{\"1\":{\"915\":1}}],[\"编译器可以调用\",{\"1\":{\"907\":1}}],[\"编译器只能看见基类的show\",{\"1\":{\"906\":1}}],[\"编译器只有检查到定义时才知道函数使用了默认值\",{\"1\":{\"639\":1}}],[\"编译器在会将auto为变量实际的类型\",{\"1\":{\"700\":1}}],[\"编译器在调用点内联展开函数的代码时\",{\"1\":{\"504\":1}}],[\"编译器无法判断在调用时是否有参数遗漏\",{\"1\":{\"640\":1}}],[\"编译器无序\",{\"1\":{\"364\":1}}],[\"编译器提供的头文件会这样定义null\",{\"1\":{\"526\":1}}],[\"编译器提供的默认析构函数是没有做回收操作的\",{\"1\":{\"426\":1}}],[\"编译器便无法知道要调用多少次析构函数\",{\"1\":{\"523\":1}}],[\"编译器自行优化\",{\"1\":{\"520\":1}}],[\"编译器自动生成的缺省\",{\"1\":{\"421\":1}}],[\"编译器才会多开4字节来保存对象个数\",{\"1\":{\"520\":1}}],[\"编译器处理方式不同\",{\"1\":{\"481\":1}}],[\"编译器也会自动提供一个\",{\"1\":{\"421\":1}}],[\"编译器将多个模板参数打包成\",{\"1\":{\"376\":1}}],[\"编译器推导\",{\"1\":{\"364\":1}}],[\"编译器会生成lock和unlock\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":2}}],[\"编译器会在该类创建的对象的存储布局的开始位置产生一个虚函数指针\",{\"1\":{\"914\":1}}],[\"编译器会在开头多分配4b空间记录new对象的数量\",{\"1\":{\"517\":1}}],[\"编译器会自行对处理的数据做记录\",{\"1\":{\"524\":1}}],[\"编译器会自动推断大小\",{\"1\":{\"512\":1}}],[\"编译器会自动提供哪些函数\",{\"0\":{\"469\":1}}],[\"编译器会自动提供一个缺省的赋值运算符函数\",{\"1\":{\"463\":1}}],[\"编译器会自动提供一个缺省的拷贝构造函数\",{\"1\":{\"395\":1}}],[\"编译器会为holdsanint额外加上一些字节\",{\"1\":{\"470\":1}}],[\"编译器会添加一个this形参变量\",{\"1\":{\"439\":1}}],[\"编译器会产生编译错误\",{\"1\":{\"423\":1}}],[\"编译器会从原模版实例化出来\",{\"1\":{\"363\":1}}],[\"编译器会直接在<visual\",{\"1\":{\"312\":1}}],[\"编译器直接从系统类库目录里查找头文件\",{\"1\":{\"312\":1}}],[\"编译器角度理解c++代码的编译和链接\",{\"0\":{\"243\":1}}],[\"编译出错\",{\"1\":{\"274\":1,\"907\":1}}],[\"编译失败\",{\"1\":{\"273\":1}}],[\"编译链接\",{\"2\":{\"266\":1}}],[\"编译成共享库\",{\"1\":{\"1333\":1}}],[\"编译成sum\",{\"1\":{\"247\":1}}],[\"编译成main\",{\"1\":{\"247\":1}}],[\"编译阶段编译器先去base作用域看一下base\",{\"1\":{\"954\":1}}],[\"编译阶段编译器只能看见base中的show为public\",{\"1\":{\"907\":1}}],[\"编译阶段\",{\"0\":{\"247\":1}}],[\"编译阶段可以gcc\",{\"1\":{\"244\":1}}],[\"编译和汇编的过程\",{\"1\":{\"245\":1}}],[\"编译完成后会生成相应平台的汇编代码\",{\"1\":{\"244\":1}}],[\"编写的在\",{\"1\":{\"1896\":1}}],[\"编写一个算法来判断一个数\",{\"1\":{\"146\":1}}],[\"编写一个函数来判断\",{\"1\":{\"166\":1}}],[\"编写一个函数\",{\"1\":{\"67\":1}}],[\"编写typora修改颜色的快捷键\",{\"0\":{\"29\":1}}],[\"编辑conf\",{\"1\":{\"63\":1}}],[\"怀疑是导致其卡顿的原因\",{\"1\":{\"63\":1}}],[\"电脑\",{\"1\":{\"832\":2}}],[\"电脑上运行较多应用\",{\"1\":{\"63\":1}}],[\"电子信息\",{\"1\":{\"0\":1}}],[\"中括号\",{\"1\":{\"1898\":1,\"1899\":1}}],[\"中会有如下信息\",{\"1\":{\"1821\":1}}],[\"中继日志通常会位于os缓存中\",{\"1\":{\"1784\":1}}],[\"中继日志充当\",{\"1\":{\"1783\":1}}],[\"中继续搜索\",{\"1\":{\"96\":1}}],[\"中最重要的日志之一\",{\"1\":{\"1770\":1}}],[\"中途执行异常\",{\"1\":{\"1757\":1}}],[\"中配置项的优化\",{\"1\":{\"1746\":1}}],[\"中存储排序结果\",{\"1\":{\"1736\":1}}],[\"中排序后直接输出结果集\",{\"1\":{\"1736\":1}}],[\"中排序\",{\"1\":{\"1736\":1}}],[\"中发生死锁是可能的\",{\"1\":{\"1706\":1}}],[\"中事务\",{\"1\":{\"1656\":1}}],[\"中并不是数据\",{\"1\":{\"1656\":1}}],[\"中间表也不一定都会产生\",{\"1\":{\"1544\":1}}],[\"中间的类b\",{\"1\":{\"653\":1}}],[\"中可以看出\",{\"1\":{\"1463\":1}}],[\"中传入参数\",{\"1\":{\"1155\":1}}],[\"中包含可能会抛出异常的语句\",{\"1\":{\"599\":1}}],[\"中则提示\",{\"1\":{\"570\":1}}],[\"中成员指针类型\",{\"1\":{\"530\":1}}],[\"中这样解释到\",{\"1\":{\"503\":1}}],[\"中有一个逻辑单元叫加法器\",{\"1\":{\"344\":1}}],[\"中文名叫小错误\",{\"1\":{\"289\":1}}],[\"中文名叫大错误\",{\"1\":{\"289\":1}}],[\"中\",{\"1\":{\"263\":1,\"267\":1,\"310\":1,\"501\":1,\"774\":1,\"782\":1,\"943\":1,\"1706\":1}}],[\"中的一个命令\",{\"1\":{\"1341\":1}}],[\"中的设置\",{\"0\":{\"1135\":1}}],[\"中的编号\",{\"1\":{\"1090\":2}}],[\"中的异常声明来匹配throw抛出的异常类型\",{\"1\":{\"608\":1}}],[\"中的语句\",{\"1\":{\"599\":2}}],[\"中的关键字\",{\"1\":{\"599\":1}}],[\"中的空指针常量\",{\"1\":{\"530\":1}}],[\"中的\",{\"1\":{\"503\":2,\"520\":1,\"601\":2,\"1656\":2,\"1719\":1}}],[\"中的内容\",{\"1\":{\"228\":1}}],[\"中的每个字符只能在\",{\"1\":{\"174\":1}}],[\"中使用一次\",{\"1\":{\"174\":1}}],[\"中每个字符出现的次数都相同\",{\"1\":{\"166\":1}}],[\"中进⾏\",{\"1\":{\"147\":2}}],[\"中死循环\",{\"1\":{\"147\":1,\"149\":1}}],[\"中添加\",{\"1\":{\"62\":2}}],[\"中划线\",{\"1\":{\"50\":1}}],[\"从业务上对表拆分\",{\"1\":{\"1888\":1}}],[\"从队列中获取连接\",{\"1\":{\"1849\":1,\"1859\":1,\"1869\":1,\"1872\":1}}],[\"从队列首部移除元素\",{\"1\":{\"182\":1}}],[\"从连接池中获取一个可用的空闲连接\",{\"1\":{\"1848\":1,\"1859\":1,\"1875\":1}}],[\"从第5位开始的长度为3的字符串\",{\"1\":{\"1878\":1}}],[\"从第5位开始到尾的字符串\",{\"1\":{\"1878\":1}}],[\"从第三个参数指定的流中读取最多第二个参数大小的字符到第一个参数指定的容器地址中\",{\"1\":{\"1878\":1}}],[\"从第0位开始idx个字符\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":1}}],[\"从第0位开始找\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":1}}],[\"从第idx位开始找\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":1}}],[\"从第一行命令开始\",{\"1\":{\"1353\":1}}],[\"从第一个人开始依次报数\",{\"1\":{\"811\":1}}],[\"从配置文件中加载配置项\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1}}],[\"从服务器只能提供读取数据\",{\"1\":{\"1790\":1}}],[\"从库可以水平扩展\",{\"1\":{\"1885\":1}}],[\"从库可以通过这个账户和密码\",{\"1\":{\"1821\":1}}],[\"从库要连接主库\",{\"1\":{\"1821\":1}}],[\"从库专门负责相对多的读操作\",{\"1\":{\"1790\":1}}],[\"从库专门有一个\",{\"1\":{\"1783\":1}}],[\"从库还会启一个\",{\"1\":{\"1783\":1}}],[\"从库介绍\",{\"0\":{\"1783\":1}}],[\"从库用来数据的同步和备份\",{\"1\":{\"1780\":1}}],[\"从库读主库的binlog\",{\"1\":{\"1772\":1}}],[\"从mysql\",{\"1\":{\"1774\":1}}],[\"从md文件内容中提取图片名称\",{\"1\":{\"60\":1}}],[\"从名字上就能看到\",{\"1\":{\"1752\":1}}],[\"从当前行的db\",{\"1\":{\"1681\":1}}],[\"从当前位置开始连续执行程序\",{\"1\":{\"1340\":1}}],[\"从用户的角度来看\",{\"1\":{\"1656\":1}}],[\"从树的高度上来说\",{\"1\":{\"1627\":1}}],[\"从磁盘上加载数据到内存的次数太多\",{\"1\":{\"1604\":1}}],[\"从二级索引树上取出主键uid\",{\"1\":{\"1569\":1}}],[\"从根节点开始在b+树上进行二分搜索\",{\"1\":{\"1563\":1}}],[\"从student表中取出所有的a\",{\"1\":{\"1537\":1}}],[\"从结果集中取出一行\",{\"1\":{\"1379\":1}}],[\"从目标文件生成动态文件gcc\",{\"1\":{\"1331\":1}}],[\"从包文件中释放文件\",{\"1\":{\"1260\":1}}],[\"从远程tcp等待连接中断请求\",{\"1\":{\"1240\":1}}],[\"从等待状态\",{\"1\":{\"1229\":1}}],[\"从function的类模板定义处\",{\"1\":{\"1164\":1}}],[\"从上面输出的信息可以看到\",{\"1\":{\"1719\":1}}],[\"从上面可以看到\",{\"1\":{\"1079\":1}}],[\"从上面的例子\",{\"1\":{\"916\":1}}],[\"从上面的uml类图可以看出\",{\"1\":{\"863\":1}}],[\"从右往左压栈\",{\"1\":{\"1063\":1}}],[\"从右向左先压实参\",{\"1\":{\"500\":1}}],[\"从大到小排序\",{\"0\":{\"1177\":1},\"1\":{\"1007\":1}}],[\"从小到大元素有序排列\",{\"1\":{\"1002\":4}}],[\"从首部删除\",{\"1\":{\"969\":1,\"970\":1}}],[\"从首部添加元素\",{\"1\":{\"969\":1,\"970\":1}}],[\"从末尾删除元素\",{\"1\":{\"969\":1,\"970\":1}}],[\"从末尾添加元素\",{\"1\":{\"969\":1,\"970\":1}}],[\"从最新的位置\",{\"1\":{\"1830\":1}}],[\"从最终的打印结果来看\",{\"1\":{\"943\":1}}],[\"从最低位开始排序\",{\"1\":{\"191\":1}}],[\"从其实现来看\",{\"1\":{\"913\":1}}],[\"从虚基类直接或间接派生出来的派生类的构造函数初始化列表均有对该虚基类构造函数的调用\",{\"1\":{\"891\":1}}],[\"从虚拟头节点走\",{\"1\":{\"802\":1}}],[\"从0x104开始开辟内存\",{\"1\":{\"715\":1}}],[\"从这个ip来请求访问这个主库上的任意库\",{\"1\":{\"1821\":1}}],[\"从这个例子可以看出\",{\"1\":{\"605\":1}}],[\"从这一点上看\",{\"1\":{\"698\":1}}],[\"从b继承来了mb与mc\",{\"1\":{\"688\":1}}],[\"从b继承来了ma与mb\",{\"1\":{\"688\":1}}],[\"从connectionpool中可以获取和mysql的连接connection\",{\"1\":{\"1866\":1}}],[\"从c继承来了ma与mc\",{\"1\":{\"688\":1}}],[\"从c++风格字符串转换为c风格字符串\",{\"1\":{\"547\":1}}],[\"从前面的知识\",{\"1\":{\"662\":1}}],[\"从本质上理解\",{\"1\":{\"621\":1}}],[\"从一而终总是指向初始的目标单元\",{\"1\":{\"614\":1}}],[\"从运行结果可以看出\",{\"1\":{\"601\":1}}],[\"从异常点跳转到\",{\"1\":{\"599\":1}}],[\"从\",{\"1\":{\"599\":1,\"802\":1,\"810\":1,\"812\":1,\"1076\":1,\"1828\":1}}],[\"从而针对性优化\",{\"0\":{\"1581\":1},\"1\":{\"1573\":1,\"1767\":1}}],[\"从而更容易地定位问题所在\",{\"1\":{\"1338\":1}}],[\"从而可以保存完整的内存映像\",{\"1\":{\"1338\":1}}],[\"从而节省磁盘空间\",{\"1\":{\"1335\":1}}],[\"从而自动回收单例\",{\"1\":{\"1032\":1}}],[\"从而把后面\",{\"1\":{\"751\":1}}],[\"从而合理的解决命名冲突\",{\"1\":{\"583\":1}}],[\"从而与其他全局实体分隔开\",{\"1\":{\"583\":1}}],[\"从而漏掉了\",{\"1\":{\"136\":1}}],[\"从另一个角度上说\",{\"1\":{\"536\":1}}],[\"从operator\",{\"1\":{\"517\":1}}],[\"从程序设计的观点来说\",{\"1\":{\"449\":1}}],[\"从堆和栈的中间分配一块虚拟内存\",{\"1\":{\"284\":1}}],[\"从操作系统角度来看\",{\"1\":{\"281\":1}}],[\"从查看可执行程序的program\",{\"1\":{\"262\":1}}],[\"从栈顶中移除目标\",{\"1\":{\"232\":1}}],[\"从数组的begin位置到end\",{\"1\":{\"163\":4}}],[\"从指定路径中获取文件名\",{\"1\":{\"60\":1}}],[\"实践中一些接口如果老是报错\",{\"1\":{\"1551\":1}}],[\"实参到形参是一个拷贝构造的过程\",{\"1\":{\"1227\":1}}],[\"实参到形参是一个的过程\",{\"1\":{\"1219\":1}}],[\"实参传递给形参\",{\"1\":{\"1115\":1}}],[\"实体的生命周期一定要大于函数的生命周期\",{\"1\":{\"618\":1}}],[\"实体的可见域是从实体创建到该名称空间结束\",{\"1\":{\"586\":1}}],[\"实体冲突\",{\"1\":{\"594\":1}}],[\"实例5\",{\"1\":{\"966\":1}}],[\"实例4\",{\"1\":{\"966\":1,\"1000\":1,\"1007\":1,\"1011\":1}}],[\"实例3\",{\"1\":{\"966\":1,\"999\":1,\"1000\":1,\"1002\":1,\"1007\":1,\"1011\":1}}],[\"实例2\",{\"0\":{\"985\":1},\"1\":{\"966\":1,\"999\":1,\"1000\":1,\"1002\":1,\"1007\":1,\"1011\":1}}],[\"实例1\",{\"0\":{\"984\":1},\"1\":{\"966\":1,\"999\":1,\"1000\":1,\"1002\":1,\"1007\":1,\"1008\":1,\"1011\":1}}],[\"实例并不存在\",{\"1\":{\"843\":1}}],[\"实例关系和继承关系是对象之间的静态关系\",{\"1\":{\"445\":1}}],[\"实例化对象也可以\",{\"1\":{\"901\":1}}],[\"实例化一个compare<double>\",{\"1\":{\"885\":1}}],[\"实例化一个compare<int>\",{\"1\":{\"885\":1}}],[\"实例化得到对象\",{\"1\":{\"446\":1}}],[\"实例化的函数模板\",{\"1\":{\"365\":1}}],[\"实例化\",{\"0\":{\"364\":1}}],[\"实型常量\",{\"1\":{\"323\":1}}],[\"实际此处使用bytes更常见\",{\"1\":{\"1915\":1}}],[\"实际只是修改buffer\",{\"1\":{\"1758\":1}}],[\"实际使用到的索引\",{\"1\":{\"1521\":1}}],[\"实际项目中可能有些是我们不需要的文件\",{\"1\":{\"1312\":1}}],[\"实际分配的字节数\",{\"1\":{\"1102\":1}}],[\"实际分配内存池\",{\"0\":{\"1102\":1}}],[\"实际中基本不会使用\",{\"1\":{\"1021\":1}}],[\"实际传参\",{\"1\":{\"606\":1}}],[\"实际operator\",{\"1\":{\"519\":1}}],[\"实际做了这样几件事情\",{\"0\":{\"519\":1}}],[\"实际应该这样比较\",{\"1\":{\"368\":1}}],[\"实际的大小\",{\"1\":{\"282\":1,\"285\":1}}],[\"实际上我们刚才的配置文件自动生成了对应的类代码\",{\"1\":{\"1915\":1}}],[\"实际上经过分库分表操作可能分配在不同的机器上\",{\"1\":{\"1802\":1}}],[\"实际上也同样会进行排序操作\",{\"1\":{\"1737\":1}}],[\"实际上也可以用到索引\",{\"1\":{\"1594\":1}}],[\"实际上可以解决部分的幻读问题\",{\"1\":{\"1677\":1}}],[\"实际上可以解决部分\",{\"1\":{\"1631\":1}}],[\"实际上内核的内存管理是按页面\",{\"1\":{\"1622\":1}}],[\"实际上存储的\",{\"1\":{\"1603\":1}}],[\"实际上底层到底是不是哈希索引是不准确的\",{\"1\":{\"1600\":1}}],[\"实际上mysql看到用户只需要1条数据\",{\"1\":{\"1522\":1}}],[\"实际上就是\",{\"1\":{\"1356\":1}}],[\"实际上+\",{\"1\":{\"1099\":1}}],[\"实际上新加子类更容易获得多态功能\",{\"1\":{\"882\":1}}],[\"实际上小米或者华为的工厂里面\",{\"1\":{\"866\":1}}],[\"实际上不需要虚拟头结点即可\",{\"1\":{\"798\":1}}],[\"实际上是unsigned\",{\"1\":{\"535\":1}}],[\"实际上是char\",{\"1\":{\"535\":1}}],[\"实际上是一个链表\",{\"1\":{\"17\":1}}],[\"实际上null在c++中就是0\",{\"1\":{\"528\":1}}],[\"实际上c++的书都会推荐说c++中更习惯使用0来表示空指针而不是null\",{\"1\":{\"527\":1}}],[\"实际上在c语言中\",{\"1\":{\"526\":1}}],[\"实际上没有多级指针\",{\"1\":{\"490\":1}}],[\"实际上\",{\"1\":{\"421\":1,\"440\":1,\"578\":1,\"1592\":1,\"1635\":1,\"1791\":1}}],[\"实际上返回的是第1个大于valuediff\",{\"1\":{\"162\":1}}],[\"实现基于c++代码的数据库连接池模块\",{\"1\":{\"1864\":1}}],[\"实现mysql数据库的操作\",{\"1\":{\"1846\":1,\"1856\":1,\"1859\":1}}],[\"实现读写分离\",{\"1\":{\"1791\":1}}],[\"实现读取md文件内容的逻辑\",{\"1\":{\"60\":1}}],[\"实现备份的同时也实现了数据库性能的优化\",{\"1\":{\"1790\":1}}],[\"实现批量添加源文件\",{\"1\":{\"1312\":1}}],[\"实现接收右值的拷贝构造和拷贝赋值函数\",{\"1\":{\"1121\":1}}],[\"实现内存管理\",{\"1\":{\"1079\":1}}],[\"实现成功\",{\"1\":{\"989\":1}}],[\"实现单例\",{\"0\":{\"852\":1}}],[\"实现中调用hdmi的play\",{\"1\":{\"832\":1}}],[\"实现一个动物类\",{\"0\":{\"886\":1}}],[\"实现一个电脑类\",{\"1\":{\"832\":1}}],[\"实现一个string类\",{\"0\":{\"548\":1}}],[\"实现信息隐藏\",{\"1\":{\"826\":1}}],[\"实现代码\",{\"0\":{\"736\":1}}],[\"实现迭代器iterator\",{\"0\":{\"699\":1}}],[\"实现在\",{\"1\":{\"504\":1}}],[\"实现文件的形式\",{\"1\":{\"435\":1}}],[\"实现循环队列queue\",{\"0\":{\"406\":1}}],[\"实现string类型\",{\"0\":{\"405\":1}}],[\"实现\",{\"0\":{\"286\":1,\"864\":1},\"1\":{\"710\":1,\"711\":1,\"791\":1,\"1677\":1}}],[\"实现的\",{\"1\":{\"914\":1}}],[\"实现的代码\",{\"1\":{\"285\":1}}],[\"实现的大体思路\",{\"1\":{\"285\":1}}],[\"实现流程图如下所示\",{\"1\":{\"285\":1}}],[\"实现删除文件的逻辑\",{\"1\":{\"60\":1}}],[\"实现从md文件内容中提取图片名称的逻辑\",{\"1\":{\"60\":1}}],[\"实现从路径中获取文件名的逻辑\",{\"1\":{\"60\":1}}],[\"实现判断目录是否存在的逻辑\",{\"1\":{\"60\":1}}],[\"实现获取绝对路径的逻辑\",{\"1\":{\"60\":1}}],[\"实现获取父目录的逻辑\",{\"1\":{\"60\":1}}],[\"实现获取目录下所有图片文件的逻辑\",{\"1\":{\"60\":1}}],[\"实现获取目录下所有文件的逻辑\",{\"1\":{\"60\":1}}],[\"笔记文件下所有md文件\",{\"1\":{\"60\":1}}],[\"笔记\",{\"1\":{\"60\":3}}],[\"最先加入队列的元素\",{\"1\":{\"1859\":1}}],[\"最重要的是\",{\"1\":{\"1828\":1}}],[\"最重要的是redo\",{\"1\":{\"1760\":1}}],[\"最常使用\",{\"1\":{\"1803\":1}}],[\"最常用的类型转换符\",{\"1\":{\"629\":1}}],[\"最常用操作\",{\"1\":{\"511\":2}}],[\"最小连接量\",{\"1\":{\"1803\":1}}],[\"最小的事务\",{\"1\":{\"1656\":1}}],[\"最初\",{\"1\":{\"1790\":1}}],[\"最初的时候表是这样的\",{\"1\":{\"1681\":1}}],[\"最初的内存分配\",{\"1\":{\"277\":2}}],[\"最下面\",{\"1\":{\"1754\":1}}],[\"最坏情况\",{\"1\":{\"1622\":1}}],[\"最主要原因在于访问数据库涉及到磁盘io\",{\"1\":{\"1455\":1}}],[\"最少都初始化只有一个\",{\"1\":{\"1120\":1}}],[\"最容易排除的错误\",{\"1\":{\"597\":1}}],[\"最容易定位\",{\"1\":{\"597\":1}}],[\"最好是启用configure\",{\"1\":{\"1312\":1}}],[\"最好使用\",{\"1\":{\"578\":1}}],[\"最好添加\",{\"1\":{\"578\":1}}],[\"最好先备份frame\",{\"1\":{\"61\":1}}],[\"最大空闲时间\",{\"1\":{\"1865\":2}}],[\"最大空闲时间回收连接扫描线程的实现\",{\"0\":{\"1859\":1}}],[\"最大连接量\",{\"1\":{\"1865\":2}}],[\"最大连接量以及最大空闲时间等参数\",{\"1\":{\"1745\":1}}],[\"最大字节数128字节\",{\"1\":{\"1082\":1}}],[\"最大数据成员长度中\",{\"1\":{\"556\":1}}],[\"最大的在后面\",{\"1\":{\"87\":1}}],[\"最多有20个占位参数\",{\"1\":{\"1155\":1}}],[\"最多只保证\",{\"1\":{\"340\":1}}],[\"最多计算到根节点\",{\"1\":{\"121\":1}}],[\"最直白的思考过程\",{\"1\":{\"136\":1}}],[\"最长的和谐子序列是\",{\"1\":{\"177\":1}}],[\"最长和谐子序列\",{\"0\":{\"177\":1},\"1\":{\"177\":1}}],[\"最长数字连续序列是\",{\"1\":{\"129\":1}}],[\"最长连续序列\",{\"0\":{\"129\":1},\"1\":{\"129\":1}}],[\"最右值\",{\"0\":{\"97\":1}}],[\"最左值\",{\"0\":{\"96\":1}}],[\"最终这个表要分在两台机器上\",{\"1\":{\"1891\":1}}],[\"最终版\",{\"0\":{\"1872\":1}}],[\"最终得到的是一个无符号的大整数\",{\"1\":{\"1090\":1}}],[\"最终call\",{\"1\":{\"954\":1}}],[\"最终会调用到derived类的display函数\",{\"1\":{\"913\":1}}],[\"最终能够调用derive的show\",{\"1\":{\"907\":1}}],[\"最终和\",{\"1\":{\"765\":1}}],[\"最终遇到空指针\",{\"1\":{\"765\":1}}],[\"最终导致程序崩溃或系统资源不足\",{\"1\":{\"531\":1}}],[\"最终由编译器决定\",{\"1\":{\"502\":1}}],[\"最终left即为新数组元素个数\",{\"1\":{\"78\":1}}],[\"最终slow即为新数组元素个数\",{\"1\":{\"77\":1}}],[\"最后根据主键关联回原表查询所需要的其他列内容\",{\"1\":{\"1740\":1}}],[\"最后存储的位置非常不确定\",{\"1\":{\"1604\":1}}],[\"最后存储的位置可能会相隔很远\",{\"1\":{\"1603\":1}}],[\"最后是函数代码\",{\"1\":{\"1173\":1}}],[\"最后是d的构造\",{\"1\":{\"688\":1}}],[\"最后对我们常用的容器简单总结下\",{\"1\":{\"1003\":1}}],[\"最后发生内存泄露\",{\"1\":{\"948\":1}}],[\"最后记得释放头结点\",{\"1\":{\"819\":1}}],[\"最后还释放了4个字节的存储对象个数的内存\",{\"1\":{\"715\":1}}],[\"最后将0x100开始的4字节也释放\",{\"1\":{\"715\":1}}],[\"最后将数组与delete进行混用\",{\"1\":{\"714\":1}}],[\"最后将运算结果赋值给temp\",{\"1\":{\"238\":1}}],[\"最后调用虚基类\",{\"1\":{\"891\":1}}],[\"最后调用\",{\"1\":{\"675\":1}}],[\"最后的结果和修改前一样\",{\"1\":{\"605\":1}}],[\"最后的大小为的整数倍\",{\"1\":{\"552\":1}}],[\"最后再组合成一个完整的程序\",{\"1\":{\"582\":1}}],[\"最后释放原来的内存空间\",{\"1\":{\"354\":1}}],[\"最后\",{\"1\":{\"285\":1}}],[\"最后return\",{\"1\":{\"238\":1}}],[\"最后一个\",{\"1\":{\"1099\":1}}],[\"最后一个下标\",{\"1\":{\"1099\":1}}],[\"最后一个结点\",{\"1\":{\"777\":1}}],[\"最后一个父结点的位置为n\",{\"1\":{\"194\":1}}],[\"最后一个元素\",{\"1\":{\"81\":1}}],[\"最后点击右下角\",{\"1\":{\"66\":1}}],[\"最后就是二者的传输方式\",{\"1\":{\"22\":1}}],[\"最外层新建一个\",{\"1\":{\"1316\":1}}],[\"最外层\",{\"1\":{\"59\":1}}],[\"清除残留数据\",{\"1\":{\"1405\":1}}],[\"清除所有生成的目标文件和最终程序\",{\"1\":{\"1355\":1,\"1365\":1}}],[\"清除的按钮\",{\"1\":{\"59\":1}}],[\"清华源\",{\"1\":{\"1284\":1}}],[\"清华大学开源软件镜像站\",{\"1\":{\"1284\":1}}],[\"清理对象\",{\"1\":{\"519\":1}}],[\"清理任务\",{\"1\":{\"425\":1}}],[\"清理未使用的图片\",{\"1\":{\"60\":1}}],[\"清空剪切板\",{\"1\":{\"29\":1}}],[\"先创建xxx\",{\"1\":{\"1915\":1}}],[\"先做数据的增量\",{\"1\":{\"1830\":1}}],[\"先考虑是表多还是数据多\",{\"1\":{\"1886\":1}}],[\"先考虑是否网络互通\",{\"1\":{\"1828\":1}}],[\"先考虑表和表之间用什么字段关联\",{\"1\":{\"1537\":1}}],[\"先把当前访问的数据往redis上缓存一下\",{\"1\":{\"1745\":1}}],[\"先把调用方的栈底地址入栈\",{\"1\":{\"500\":1}}],[\"先在redis上查一下\",{\"1\":{\"1745\":1}}],[\"先设置隔离级别为已提交读并开启事务\",{\"1\":{\"1658\":1}}],[\"先检查where过滤字段是否有索引\",{\"1\":{\"1623\":1,\"1626\":1}}],[\"先检查时候设置用于释放某些可以释放的资源的回调函数\",{\"1\":{\"1102\":1}}],[\"先进行比较\",{\"1\":{\"1617\":1}}],[\"先按age排序\",{\"1\":{\"1566\":1}}],[\"先用命令行执行api调用的sql语句\",{\"1\":{\"1551\":1}}],[\"先执行where过滤\",{\"1\":{\"1540\":1}}],[\"先分组\",{\"1\":{\"1497\":1}}],[\"先分成两个链表\",{\"1\":{\"795\":1}}],[\"先确认目标文件\",{\"1\":{\"1353\":1}}],[\"先确定linux版本号ubuntu\",{\"1\":{\"1284\":1}}],[\"先确定有哪些实体\",{\"1\":{\"446\":1}}],[\"先建立一个名为makefile或者是makefile的文件\",{\"1\":{\"1352\":1}}],[\"先cmake在make\",{\"1\":{\"1308\":1}}],[\"先查看一下\",{\"1\":{\"1296\":1}}],[\"先安装git\",{\"1\":{\"1287\":1}}],[\"先选中多行\",{\"1\":{\"1142\":1}}],[\"先申请大小为原来二倍的空间\",{\"1\":{\"1127\":1}}],[\"先拎清主要逻辑\",{\"1\":{\"1105\":1}}],[\"先定位到\",{\"1\":{\"1096\":1}}],[\"先定义游标\",{\"1\":{\"792\":1}}],[\"先将范围缩小\",{\"0\":{\"1499\":1}}],[\"先将\",{\"1\":{\"1090\":1}}],[\"先将调用函数的栈底指针\",{\"1\":{\"1063\":1}}],[\"先将下一行指令的地址压栈\",{\"1\":{\"1063\":1}}],[\"先将log4cpp\",{\"1\":{\"1015\":1}}],[\"先将b的值压入堆栈\",{\"1\":{\"237\":1}}],[\"先了解一下这个\",{\"1\":{\"908\":1}}],[\"先访问指针指向的对象的前四个字节\",{\"1\":{\"886\":1}}],[\"先看看工厂方法的uml类设计图如下\",{\"1\":{\"866\":1}}],[\"先走k步\",{\"1\":{\"810\":1}}],[\"先走n步\",{\"1\":{\"774\":1,\"806\":1}}],[\"先使用库中的vector来看看什么是失效问题\",{\"1\":{\"742\":1}}],[\"先来看一下对单个元素正常使用\",{\"1\":{\"714\":1}}],[\"先来看看静态成员函数\",{\"1\":{\"438\":1}}],[\"先调用函数进行资源释放\",{\"1\":{\"1102\":1}}],[\"先调用派生类的析构函数\",{\"1\":{\"891\":1}}],[\"先调用operator开辟内存空间\",{\"1\":{\"710\":1}}],[\"先调用析构\",{\"1\":{\"513\":1,\"708\":1}}],[\"先不去考虑越界\",{\"1\":{\"618\":1}}],[\"先回顾一下变量名\",{\"1\":{\"612\":1}}],[\"先知道怎么用\",{\"1\":{\"607\":1}}],[\"先\",{\"1\":{\"516\":2}}],[\"先构造的后析构\",{\"1\":{\"428\":1}}],[\"先找出序列中最大值和最小值\",{\"1\":{\"213\":1}}],[\"先对数组进行排序\",{\"1\":{\"137\":1}}],[\"先对数组排序\",{\"1\":{\"126\":1}}],[\"先搜索标题\",{\"1\":{\"59\":1}}],[\"先备份下面文件\",{\"1\":{\"52\":1}}],[\"j++\",{\"1\":{\"1385\":1}}],[\"jie\",{\"1\":{\"1305\":1}}],[\"jammy\",{\"1\":{\"1284\":8}}],[\"java实现的\",{\"1\":{\"1610\":1}}],[\"java等\",{\"1\":{\"359\":1}}],[\"java\",{\"1\":{\"304\":1,\"1464\":2,\"1798\":1,\"1913\":1}}],[\"java编写的任何代码\",{\"1\":{\"303\":1}}],[\"josephring\",{\"1\":{\"810\":3}}],[\"john\",{\"1\":{\"717\":1,\"718\":1}}],[\"join内连接\",{\"1\":{\"1541\":1}}],[\"join\",{\"1\":{\"60\":1,\"1050\":1,\"1151\":1,\"1206\":2,\"1207\":3,\"1208\":1,\"1219\":4,\"1233\":1,\"1500\":3,\"1501\":1,\"1537\":5,\"1538\":9,\"1539\":1,\"1540\":1,\"1541\":2,\"1543\":1,\"1544\":2,\"1738\":3,\"1851\":4}}],[\"jerry\",{\"1\":{\"494\":1,\"1733\":2,\"1734\":1,\"1735\":2}}],[\"j表示右半边的下标\",{\"1\":{\"202\":1}}],[\"j\",{\"1\":{\"67\":3,\"81\":8,\"132\":4,\"137\":8,\"158\":3,\"161\":4,\"162\":8,\"188\":6,\"191\":8,\"199\":8,\"202\":6,\"205\":7,\"217\":6,\"576\":3,\"755\":4,\"1385\":3}}],[\"jumpto\",{\"1\":{\"59\":2}}],[\"jumptime\",{\"1\":{\"59\":2}}],[\"jump\",{\"1\":{\"59\":4}}],[\"jumpvalue\",{\"1\":{\"59\":4}}],[\"jumpcount++>=count\",{\"1\":{\"59\":1}}],[\"jumpcount=0\",{\"1\":{\"59\":1}}],[\"jumpcount\",{\"1\":{\"59\":2}}],[\"jsmsg\",{\"1\":{\"1908\":3}}],[\"jsbuf\",{\"1\":{\"1907\":5,\"1908\":3,\"1909\":3}}],[\"json进行数据交换许多\",{\"1\":{\"1913\":1}}],[\"json反序列化\",{\"1\":{\"1906\":1}}],[\"json添加数组类型\",{\"0\":{\"1904\":1},\"1\":{\"1904\":1}}],[\"json字符串\",{\"1\":{\"1903\":1,\"1907\":1}}],[\"json数据对象\",{\"1\":{\"1903\":1}}],[\"json普通数据序列化\",{\"1\":{\"1902\":1}}],[\"json序列化\",{\"1\":{\"1901\":1}}],[\"json的两种结构\",{\"0\":{\"1899\":1}}],[\"json语法\",{\"0\":{\"1897\":1,\"1898\":1}}],[\"json简介\",{\"0\":{\"1896\":1}}],[\"json简介及使用\",{\"0\":{\"1895\":1}}],[\"json\",{\"0\":{\"1906\":1},\"1\":{\"63\":1,\"1896\":5,\"1900\":1,\"1901\":4,\"1902\":1,\"1903\":1,\"1904\":1,\"1905\":1,\"1907\":3,\"1908\":3,\"1909\":3}}],[\"js文件\",{\"1\":{\"61\":2}}],[\"js的末尾添加如下代码\",{\"1\":{\"52\":1}}],[\"js\",{\"1\":{\"52\":1,\"59\":1,\"359\":1,\"1900\":2,\"1902\":6,\"1903\":6,\"1904\":7,\"1905\":4,\"1907\":6,\"1908\":5,\"1909\":4}}],[\"个字符\",{\"1\":{\"1878\":1}}],[\"个字节的存储空间\",{\"1\":{\"1424\":1}}],[\"个类别\",{\"1\":{\"1548\":1}}],[\"个参数指定生成库的源文件\",{\"1\":{\"1315\":1}}],[\"个参数指定库的名字\",{\"1\":{\"1315\":1}}],[\"个参数决定是动态还是静态\",{\"1\":{\"1315\":1}}],[\"个性化配置\",{\"0\":{\"1133\":1,\"1291\":1}}],[\"个\",{\"1\":{\"1099\":1,\"1318\":1,\"1719\":1}}],[\"个非教徒在深海上遇险\",{\"1\":{\"811\":1}}],[\"个节点\",{\"1\":{\"790\":1}}],[\"个节点之前添加值为\",{\"1\":{\"790\":1}}],[\"个节点的值\",{\"1\":{\"790\":1}}],[\"个节点中的最小节点\",{\"1\":{\"784\":2}}],[\"个位置\",{\"1\":{\"787\":1}}],[\"个有序链表的逻辑类似合并两个有序链表\",{\"1\":{\"784\":1}}],[\"个链表和res合并\",{\"1\":{\"782\":1}}],[\"个升序链表\",{\"0\":{\"780\":1},\"1\":{\"780\":1,\"783\":1}}],[\"个结点\",{\"0\":{\"774\":1},\"1\":{\"774\":2}}],[\"个数\",{\"1\":{\"571\":1,\"1475\":1}}],[\"个数不同\",{\"1\":{\"560\":1,\"563\":1}}],[\"个数为\",{\"1\":{\"8\":1}}],[\"个月的时间\",{\"1\":{\"301\":1}}],[\"个键盘\",{\"1\":{\"301\":1}}],[\"个人想加个这个功能\",{\"1\":{\"59\":1}}],[\"毕竟这是个伪装成markdown编辑器的浏览器\",{\"1\":{\"56\":1}}],[\"创建初始的数量连接\",{\"1\":{\"1839\":1,\"1849\":1,\"1859\":1,\"1875\":1}}],[\"创建slave账户\",{\"1\":{\"1832\":1}}],[\"创建多个索引\",{\"1\":{\"1614\":1}}],[\"创建索引\",{\"1\":{\"1614\":1}}],[\"创建新表时和已创建的表都可以加索引\",{\"1\":{\"1610\":1}}],[\"创建哈希索引\",{\"0\":{\"1603\":1}}],[\"创建表的时候指定索引字段\",{\"1\":{\"1614\":1}}],[\"创建表\",{\"1\":{\"1551\":1}}],[\"创建数据库\",{\"1\":{\"1485\":1,\"1486\":1,\"1506\":1}}],[\"创建用户指定加密方式\",{\"1\":{\"1447\":1}}],[\"创建用户示例\",{\"1\":{\"1447\":1}}],[\"创建或更新库的目标文件索引\",{\"1\":{\"1334\":1}}],[\"创建一个用于主从库通信用的账号\",{\"0\":{\"1821\":1}}],[\"创建一个表\",{\"1\":{\"1552\":1}}],[\"创建一个数据库\",{\"1\":{\"1507\":1}}],[\"创建一个库\",{\"1\":{\"1334\":1}}],[\"创建一个名为\",{\"1\":{\"530\":1,\"1334\":1}}],[\"创建动态库\",{\"1\":{\"1331\":1}}],[\"创建静态库\",{\"1\":{\"1331\":1}}],[\"创建硬链接\",{\"1\":{\"1271\":1}}],[\"创建了一个线程对象\",{\"1\":{\"1207\":1}}],[\"创建线程池\",{\"1\":{\"1151\":1}}],[\"创建标签\",{\"1\":{\"1137\":1}}],[\"创建派生类对象\",{\"1\":{\"916\":1}}],[\"创建派生类对象时\",{\"1\":{\"665\":1}}],[\"创建汽车关联的产品\",{\"1\":{\"867\":1}}],[\"创建汽车\",{\"1\":{\"867\":1}}],[\"创建循环链表\",{\"1\":{\"810\":1}}],[\"创建链表用虚拟头结点\",{\"1\":{\"795\":1}}],[\"创建出堆对象的同时\",{\"1\":{\"718\":1}}],[\"创建和销毁由编译器幕后控制\",{\"1\":{\"621\":1}}],[\"创建全局变量和全局函数的时候\",{\"1\":{\"590\":1}}],[\"创建两个文件\",{\"1\":{\"575\":1}}],[\"创建对象\",{\"1\":{\"518\":1}}],[\"创建对象数组\",{\"1\":{\"453\":1}}],[\"创建指向对象的指针\",{\"1\":{\"453\":1}}],[\"创建的所有对象所共享\",{\"1\":{\"435\":1,\"439\":1}}],[\"创建超链接\",{\"1\":{\"56\":1}}],[\"创建快捷方式\",{\"1\":{\"27\":1}}],[\"kill\",{\"1\":{\"1296\":1}}],[\"kill掉占用资源的进程\",{\"1\":{\"1296\":1}}],[\"kind\",{\"1\":{\"682\":1}}],[\"khtml\",{\"1\":{\"1255\":1}}],[\"kty>\",{\"1\":{\"985\":2}}],[\"kty\",{\"1\":{\"985\":1}}],[\"k取模链表长度\",{\"1\":{\"787\":1}}],[\"ksize>\",{\"1\":{\"388\":12}}],[\"ksize\",{\"1\":{\"388\":3}}],[\"kmin\",{\"1\":{\"371\":2}}],[\"kernel\",{\"1\":{\"1623\":1}}],[\"ket\",{\"1\":{\"1428\":1}}],[\"ken\",{\"1\":{\"301\":2}}],[\"key修饰的字段会自动创建索引\",{\"1\":{\"1610\":1}}],[\"keys\",{\"1\":{\"1521\":1}}],[\"key另一个表的主键\",{\"1\":{\"1437\":1}}],[\"key不能重复\",{\"1\":{\"1432\":1}}],[\"key\",{\"1\":{\"178\":3,\"220\":4,\"999\":1,\"1000\":3,\"1001\":1,\"1002\":1,\"1428\":1,\"1437\":1,\"1452\":1,\"1521\":2,\"1537\":3,\"1551\":1,\"1552\":1,\"1614\":1,\"1626\":1,\"1681\":1,\"1686\":1,\"1717\":3,\"1719\":13,\"1839\":11,\"1849\":11,\"1875\":11,\"1878\":2,\"1900\":1}}],[\"keybinding\",{\"1\":{\"62\":2}}],[\"kbytes\",{\"1\":{\"239\":6}}],[\"kb\",{\"1\":{\"239\":1}}],[\"k表示结果的下标\",{\"1\":{\"202\":1}}],[\"k\",{\"0\":{\"780\":1},\"1\":{\"56\":1,\"132\":4,\"158\":4,\"202\":5,\"576\":3,\"780\":1,\"783\":1,\"784\":3,\"787\":7,\"810\":2,\"1001\":4}}],[\"添加key\",{\"1\":{\"1904\":1}}],[\"添加数组\",{\"1\":{\"1904\":1}}],[\"添加数据\",{\"1\":{\"1774\":1}}],[\"添加json对象\",{\"1\":{\"1902\":1,\"1904\":1}}],[\"添加配置\",{\"1\":{\"1754\":1}}],[\"添加一个birthdate字段\",{\"1\":{\"1552\":1}}],[\"添加一个新的email字段\",{\"1\":{\"1552\":1}}],[\"添加一个字段到首位置\",{\"1\":{\"1552\":1}}],[\"添加一个字段到任意位置之后\",{\"1\":{\"1552\":1}}],[\"添加一条数据\",{\"1\":{\"1490\":1}}],[\"添加注释comment\",{\"1\":{\"1552\":1}}],[\"添加指定字段数据\",{\"1\":{\"1490\":1}}],[\"添加调试信息\",{\"1\":{\"1327\":1}}],[\"添加编译选项\",{\"0\":{\"1327\":1}}],[\"添加非标准库的搜索路径\",{\"1\":{\"1316\":1}}],[\"添加新文件时会自动更新变量\",{\"1\":{\"1312\":1}}],[\"添加可执行文件作为构建目标\",{\"0\":{\"1311\":1}}],[\"添加相应环境变量即可\",{\"1\":{\"1306\":1}}],[\"添加的函数如下\",{\"1\":{\"1121\":1}}],[\"添加自己新的成员\",{\"1\":{\"684\":1}}],[\"添加\",{\"0\":{\"743\":1,\"1317\":1,\"1318\":1},\"1\":{\"66\":1}}],[\"添加业内返回跳转功能\",{\"1\":{\"59\":1}}],[\"添加iframe成功\",{\"1\":{\"59\":1}}],[\"添加收缩全部按钮\",{\"1\":{\"54\":1,\"59\":1}}],[\"添加收缩文件全部代码块按钮\",{\"0\":{\"54\":1}}],[\"添加代码收缩公共能\",{\"1\":{\"59\":1}}],[\"添加代码收缩功能\",{\"1\":{\"53\":1}}],[\"添加代码块折叠按钮\",{\"0\":{\"52\":1}}],[\"8341\",{\"1\":{\"1820\":1}}],[\"8333\",{\"1\":{\"1820\":1}}],[\"8k\",{\"1\":{\"1622\":1}}],[\"85\",{\"1\":{\"1537\":1}}],[\"85rem\",{\"1\":{\"51\":1}}],[\"8066数据端口\",{\"0\":{\"1809\":1},\"1\":{\"1812\":1,\"1813\":1,\"1814\":1}}],[\"808c1b4abe9b4249acdb95968b5c7109\",{\"1\":{\"1774\":1}}],[\"80表示在所有的可用接口上监听tcp80端口\",{\"1\":{\"1239\":1}}],[\"80|grep\",{\"1\":{\"1238\":1}}],[\"80\",{\"1\":{\"1114\":2,\"1238\":3,\"1537\":1}}],[\"800\",{\"1\":{\"1025\":1}}],[\"8000\",{\"1\":{\"439\":1,\"440\":1}}],[\"8个字节\",{\"1\":{\"934\":1}}],[\"88\",{\"1\":{\"817\":4}}],[\"82\",{\"1\":{\"817\":4}}],[\"876\",{\"0\":{\"798\":1},\"1\":{\"798\":1}}],[\"87c43f84\",{\"1\":{\"597\":1}}],[\"86\",{\"0\":{\"795\":1},\"1\":{\"795\":1}}],[\"8687\",{\"1\":{\"500\":1}}],[\"8>\",{\"1\":{\"388\":1}}],[\"8进制\",{\"0\":{\"349\":1}}],[\"8位阶码\",{\"1\":{\"339\":1}}],[\"8byte\",{\"1\":{\"285\":1}}],[\"89f6ddfd541041c6a8b684c31db1262a\",{\"1\":{\"1681\":1}}],[\"894946\",{\"1\":{\"1415\":2}}],[\"89\",{\"1\":{\"191\":1,\"1537\":1}}],[\"819200\",{\"1\":{\"239\":1}}],[\"8192\",{\"1\":{\"239\":2}}],[\"811\",{\"1\":{\"147\":1}}],[\"810\",{\"1\":{\"147\":2}}],[\"81\",{\"1\":{\"101\":2,\"1617\":1}}],[\"8\",{\"0\":{\"1379\":1},\"1\":{\"60\":1,\"104\":3,\"107\":3,\"110\":2,\"129\":1,\"169\":1,\"234\":1,\"239\":1,\"301\":1,\"378\":3,\"439\":1,\"547\":1,\"553\":1,\"557\":1,\"572\":1,\"638\":1,\"747\":1,\"810\":4,\"953\":1,\"966\":1,\"973\":1,\"974\":1,\"1032\":1,\"1082\":1,\"1090\":7,\"1102\":3,\"1114\":1,\"1115\":1,\"1133\":1,\"1271\":1,\"1291\":1,\"1299\":1,\"1310\":1,\"1312\":3,\"1314\":1,\"1315\":1,\"1316\":1,\"1317\":1,\"1318\":1,\"1407\":1,\"1537\":1,\"1632\":1,\"1719\":2,\"1828\":3}}],[\"8rem\",{\"1\":{\"51\":1}}],[\"否则使用第一种\",{\"1\":{\"1736\":1}}],[\"否则使用sourceinsight会卡死\",{\"0\":{\"33\":1}}],[\"否则事务2再查询age=18就有两条记录了\",{\"1\":{\"1693\":1}}],[\"否则有小数\",{\"1\":{\"1622\":1}}],[\"否则索引用不上\",{\"1\":{\"1610\":1}}],[\"否则我们就关闭它\",{\"1\":{\"1569\":1}}],[\"否则不删除\",{\"1\":{\"1507\":1}}],[\"否则不创建\",{\"1\":{\"1507\":1}}],[\"否则补null\",{\"1\":{\"1500\":2}}],[\"否则查询速度太慢了=>水平或垂直分库分表操作\",{\"1\":{\"1481\":1}}],[\"否则存在外部被修改的风险\",{\"1\":{\"848\":1}}],[\"否则两个两个一起走到链尾p1=nullptr\",{\"1\":{\"771\":1}}],[\"否则各自走到链尾\",{\"1\":{\"771\":1}}],[\"否则出错\",{\"1\":{\"630\":1}}],[\"否则编译时报错\",{\"1\":{\"612\":1}}],[\"否则编译报错\",{\"1\":{\"433\":1}}],[\"否则会导致派生类的析构函数无法调用\",{\"1\":{\"948\":1}}],[\"否则会\",{\"1\":{\"553\":1}}],[\"否则会有的报错\",{\"1\":{\"435\":1}}],[\"否则会有多重定义的报错\",{\"1\":{\"435\":1}}],[\"否则抛出硬件异常\",{\"1\":{\"553\":1}}],[\"否则可能造成内存泄漏\",{\"1\":{\"513\":1,\"515\":1}}],[\"否则容易出错\",{\"1\":{\"500\":1}}],[\"否则就是默认值\",{\"1\":{\"434\":1}}],[\"否则就是minflt\",{\"1\":{\"290\":1}}],[\"否则返回0\",{\"1\":{\"1878\":1}}],[\"否则返回\",{\"1\":{\"174\":1}}],[\"否则\",{\"1\":{\"158\":1,\"161\":1,\"631\":2,\"640\":1,\"754\":1,\"1479\":1}}],[\"否则乱序\",{\"1\":{\"51\":1}}],[\"计时开始\",{\"1\":{\"751\":1}}],[\"计数数组累计求和\",{\"1\":{\"213\":1}}],[\"计数排序只适用于\",{\"1\":{\"212\":1}}],[\"计数排序应用场景\",{\"0\":{\"212\":1}}],[\"计数排序\",{\"0\":{\"211\":1}}],[\"计数是从第二级标题开始的\",{\"1\":{\"51\":1}}],[\"计算器案例\",{\"0\":{\"1181\":1}}],[\"计算链表长度\",{\"1\":{\"787\":1}}],[\"计算两个链表的差\",{\"1\":{\"771\":1}}],[\"计算机所做的减法\",{\"1\":{\"344\":1}}],[\"计算机的\",{\"1\":{\"344\":1}}],[\"计算机网络\",{\"0\":{\"21\":1}}],[\"计算内存块的实际大小\",{\"1\":{\"286\":1}}],[\"计算出计数数组的范围\",{\"1\":{\"213\":1}}],[\"计算中间下标\",{\"1\":{\"93\":1,\"94\":1}}],[\"字段新类型\",{\"1\":{\"1552\":1}}],[\"字段约束\",{\"1\":{\"1552\":2}}],[\"字段类型\",{\"1\":{\"1552\":2}}],[\"字段\",{\"1\":{\"1548\":1}}],[\"字段名称\",{\"1\":{\"1552\":5}}],[\"字段名\",{\"1\":{\"1491\":1,\"1492\":3,\"1494\":1,\"1495\":1,\"1496\":6,\"1497\":2,\"1500\":3,\"1501\":1,\"1531\":1,\"1552\":1}}],[\"字段名3\",{\"1\":{\"1490\":1,\"1494\":1,\"1500\":3,\"1501\":1}}],[\"字段名2\",{\"1\":{\"1490\":1,\"1494\":1,\"1497\":1,\"1500\":9,\"1501\":3}}],[\"字段名1\",{\"1\":{\"1490\":1,\"1494\":1,\"1500\":15,\"1501\":5}}],[\"字段或属性\",{\"1\":{\"1451\":1}}],[\"字\",{\"1\":{\"1347\":2}}],[\"字节\",{\"1\":{\"553\":1,\"1347\":1}}],[\"字放在函数的参数表和函数体之间\",{\"1\":{\"440\":1}}],[\"字面值常量\",{\"1\":{\"323\":1,\"476\":1}}],[\"字面值界定符\",{\"1\":{\"320\":1}}],[\"字符集\",{\"1\":{\"1552\":1}}],[\"字符流或者windows日志\",{\"1\":{\"1022\":1}}],[\"字符控制函数\",{\"1\":{\"535\":1}}],[\"字符检查函数\",{\"1\":{\"535\":1}}],[\"字符型常量在编译时直接编入代码段\",{\"1\":{\"323\":1}}],[\"字符字面值的表示方法\",{\"1\":{\"320\":1}}],[\"字符\",{\"0\":{\"320\":1},\"1\":{\"1347\":1}}],[\"字符串列创建索引时\",{\"1\":{\"1615\":1}}],[\"字符串函数\",{\"0\":{\"1441\":1}}],[\"字符串用单引号\",{\"1\":{\"1428\":1}}],[\"字符串使用单引号\",{\"1\":{\"1425\":1}}],[\"字符串类型\",{\"0\":{\"1425\":1}}],[\"字符串类型底层的成员变量为私有的\",{\"1\":{\"698\":1}}],[\"字符串转8进制长整型数字\",{\"1\":{\"1299\":1}}],[\"字符串转不同进制数学\",{\"0\":{\"1299\":1}}],[\"字符串比较就不行了\",{\"1\":{\"1186\":1}}],[\"字符串比较\",{\"0\":{\"545\":1}}],[\"字符串的长度和容量相关\",{\"0\":{\"540\":1}}],[\"字符串的内容复制或写入既有的c风格字符串或字符数组内\",{\"1\":{\"538\":1}}],[\"字符串的遍历\",{\"1\":{\"536\":1}}],[\"字符串长度\",{\"1\":{\"536\":1}}],[\"字符串拼接\",{\"1\":{\"535\":1,\"536\":1}}],[\"字符串处理在程序中应用广泛\",{\"1\":{\"535\":1}}],[\"字符串替换\",{\"1\":{\"497\":1}}],[\"字符串字面值可以取地址\",{\"1\":{\"476\":1}}],[\"字符串常量\",{\"1\":{\"476\":1}}],[\"字符串常量是存在字符串常量区\",{\"1\":{\"323\":1}}],[\"字符串\",{\"1\":{\"1299\":1,\"1347\":1,\"1356\":1},\"2\":{\"69\":1,\"168\":1}}],[\"字符设备文件\",{\"1\":{\"17\":1}}],[\"字体颜色\",{\"1\":{\"50\":1}}],[\"字体大小\",{\"1\":{\"50\":1}}],[\"常见于order\",{\"1\":{\"1618\":1}}],[\"常见于使用索引列就可以处理不需要读取数据文件的查询\",{\"1\":{\"1618\":1}}],[\"常见于使用<\",{\"1\":{\"1618\":1}}],[\"常见于辅助索引的等值查找\",{\"1\":{\"1618\":1}}],[\"常见的连接池括阿里的druid\",{\"1\":{\"1864\":1}}],[\"常见的数据库有哪些\",{\"0\":{\"1452\":1}}],[\"常见的编译命令\",{\"0\":{\"1325\":1}}],[\"常针对字符串类型的数据的索引优化\",{\"1\":{\"1614\":1}}],[\"常用于数据量较大的字符串类型上\",{\"1\":{\"1610\":1}}],[\"常用于查找攻来源\",{\"1\":{\"1238\":1}}],[\"常用函数\",{\"0\":{\"1440\":1}}],[\"常用参数\",{\"1\":{\"1261\":1}}],[\"常用操作\",{\"0\":{\"1142\":1}}],[\"常用方法\",{\"1\":{\"965\":1,\"969\":1,\"970\":1}}],[\"常用的数据传输序列化格式有xml\",{\"1\":{\"1901\":1}}],[\"常用的语句关键字主要包括\",{\"1\":{\"1548\":2}}],[\"常用的引擎有myisam\",{\"1\":{\"1453\":1}}],[\"常用的格式有\",{\"1\":{\"1347\":1}}],[\"常用的组织结构\",{\"0\":{\"1316\":1}}],[\"常用的使用方法\",{\"0\":{\"1134\":1,\"1292\":1}}],[\"常用的投影接口的类型有\",{\"1\":{\"832\":1}}],[\"常用的库函数如下\",{\"1\":{\"535\":1}}],[\"常用的css文本属性\",{\"1\":{\"50\":1}}],[\"常变量不能当数组下标\",{\"1\":{\"484\":1}}],[\"常变量不能定义数组\",{\"1\":{\"484\":1}}],[\"常考题\",{\"0\":{\"481\":1,\"513\":1}}],[\"常量迭代器不能修改\",{\"1\":{\"1011\":1}}],[\"常量的反向迭代器的使用\",{\"1\":{\"1011\":1}}],[\"常量的反向迭代器const\",{\"1\":{\"1011\":1}}],[\"常量的正向迭代器的使用\",{\"1\":{\"1011\":1}}],[\"常量的正向迭代器const\",{\"1\":{\"1011\":1}}],[\"常量的底层const不能赋值给⾮常量的底层const\",{\"1\":{\"489\":1}}],[\"常量反向迭代器\",{\"1\":{\"698\":1}}],[\"常量正向迭代器\",{\"1\":{\"698\":1}}],[\"常量对象被转换成非常量对象\",{\"1\":{\"630\":1}}],[\"常量引用被转换成非常量引用\",{\"1\":{\"630\":1}}],[\"常量指针被转化成非常量指针\",{\"1\":{\"630\":1}}],[\"常量指针的第二种写法\",{\"1\":{\"488\":1}}],[\"常量指针\",{\"1\":{\"488\":2,\"497\":2}}],[\"常量指针和指针常量\",{\"0\":{\"488\":1}}],[\"常量不能进行赋值\",{\"1\":{\"497\":1}}],[\"常量不能再作为左值\",{\"1\":{\"485\":1}}],[\"常量不能被赋值\",{\"1\":{\"480\":1}}],[\"常量不可改变值\",{\"1\":{\"323\":1}}],[\"常量必须要进行初始化\",{\"1\":{\"480\":1}}],[\"常量数据成员\",{\"0\":{\"432\":1},\"1\":{\"432\":1}}],[\"常量\",{\"0\":{\"323\":1},\"1\":{\"585\":1}}],[\"常量就存放在此\",{\"1\":{\"267\":1}}],[\"常规\",{\"1\":{\"33\":1,\"1855\":2}}],[\"所带来的性能损耗\",{\"1\":{\"1864\":1}}],[\"所设置值的\",{\"1\":{\"1574\":1,\"1776\":1}}],[\"所采用的进制\",{\"1\":{\"1299\":1}}],[\"所\",{\"1\":{\"1050\":1}}],[\"所在服务器上的磁盘空间不足\",{\"1\":{\"1886\":1}}],[\"所在学院\",{\"1\":{\"1462\":1}}],[\"所在的语句\",{\"1\":{\"1110\":1,\"1111\":1}}],[\"所在的位置\",{\"1\":{\"599\":1}}],[\"所在list还有元素\",{\"1\":{\"784\":1}}],[\"所指的对象是常量\",{\"1\":{\"489\":1}}],[\"所谓抛出异常\",{\"1\":{\"597\":1,\"599\":1}}],[\"所谓命名空间就是一个可以由用户自己定义的作用域\",{\"1\":{\"582\":1}}],[\"所谓项目配置的引用目录\",{\"1\":{\"312\":1}}],[\"所谓有始有终\",{\"1\":{\"235\":1}}],[\"所有类都经过严格的单元测试\",{\"1\":{\"1896\":1}}],[\"所有读请求随机分发到writehost对应的readhost上执行\",{\"1\":{\"1803\":1}}],[\"所有读操作随机在readhost和writehost上分发\",{\"1\":{\"1803\":1}}],[\"所有数据的增删改查都是在一台机器上进行\",{\"1\":{\"1790\":1}}],[\"所有权限\",{\"1\":{\"1485\":1,\"1486\":1}}],[\"所有表\",{\"1\":{\"1447\":1}}],[\"所有表示的地址个数是2^32\",{\"1\":{\"308\":1}}],[\"所有表示的地址个数是2^20\",{\"1\":{\"308\":1}}],[\"所有依赖文件\",{\"1\":{\"1356\":1}}],[\"所有的读写操作都会转发给windows上的mysql\",{\"1\":{\"1814\":1}}],[\"所有的select操作都在slave上执行\",{\"1\":{\"1803\":1}}],[\"所有的sql都执行一遍\",{\"1\":{\"1783\":1}}],[\"所有的事务都自动使用排它锁或共享锁\",{\"1\":{\"1701\":1}}],[\"所有的key和data都是存在叶子节点\",{\"1\":{\"1626\":1}}],[\"所有的关系型数据库都支持sql语句\",{\"1\":{\"1548\":1}}],[\"所有的源文件生成一个可执行程序\",{\"1\":{\"1365\":1}}],[\"所有的跳转都是相对跳转\",{\"1\":{\"1333\":1}}],[\"所有的硬链接\",{\"1\":{\"1267\":1}}],[\"所有子线程都进行mycount++\",{\"1\":{\"1233\":1}}],[\"所有子线程都自动结束了\",{\"1\":{\"1206\":1}}],[\"所有线程都在输出\",{\"1\":{\"1208\":1}}],[\"所有形参的类型都取出来\",{\"1\":{\"1189\":1}}],[\"所有容器都可以使用\",{\"1\":{\"1007\":1}}],[\"所有对数据的修改操作都会被记录在redo\",{\"1\":{\"1762\":1}}],[\"所有对象都可以共享这份代码\",{\"1\":{\"876\":1}}],[\"所有对象的创建不再通过new\",{\"1\":{\"863\":1}}],[\"所有对符号的引用\",{\"1\":{\"245\":1,\"255\":1}}],[\"所有从a继承而来的地方都采用虚继承\",{\"1\":{\"688\":1}}],[\"所有代码有冲突\",{\"1\":{\"621\":1}}],[\"所有\",{\"1\":{\"245\":1,\"255\":1}}],[\"所有不需要减一\",{\"1\":{\"94\":1}}],[\"所有颜色表示法\",{\"1\":{\"50\":1}}],[\"所以项目中我们选择常用的json格式来打包传输数据\",{\"1\":{\"1901\":1}}],[\"所以对逻辑表插入的两条数据\",{\"1\":{\"1892\":1}}],[\"所以对于进行管理\",{\"1\":{\"1079\":1}}],[\"所以对于包含产品簇这么一类实体关系的设计\",{\"1\":{\"866\":1}}],[\"所以对于不修改数据成员的情况\",{\"1\":{\"440\":1}}],[\"所以修改数据节点的数量为2\",{\"1\":{\"1891\":1}}],[\"所以库级别的数据库操作还是有io瓶颈\",{\"1\":{\"1890\":1}}],[\"所以更多的读请求不成问题\",{\"1\":{\"1885\":1}}],[\"所以一定要考虑队列的线程安全操作\",{\"1\":{\"1849\":1,\"1859\":1,\"1870\":1,\"1872\":1}}],[\"所以一般项目都会用到连接池\",{\"1\":{\"1476\":1}}],[\"所以一般\",{\"1\":{\"576\":1}}],[\"所以一般的二分查找不能直接应用于链表\",{\"1\":{\"91\":1}}],[\"所以线程处理函数void\",{\"1\":{\"1849\":1,\"1859\":1,\"1875\":1}}],[\"所以创建账户的命令应如下\",{\"1\":{\"1821\":1}}],[\"所以错误日志显示的是192\",{\"1\":{\"1821\":1}}],[\"所以物理机接收到的是192\",{\"1\":{\"1821\":1}}],[\"所以m2可以同步m1的数据\",{\"1\":{\"1791\":1}}],[\"所以把读写分离用代码实现肯定不合适\",{\"1\":{\"1790\":1}}],[\"所以中继日志的开销很小\",{\"1\":{\"1784\":1}}],[\"所以当事务commit后\",{\"1\":{\"1760\":1}}],[\"所以当使用b\",{\"1\":{\"1623\":1}}],[\"所以会分别对这两个索引加锁\",{\"1\":{\"1720\":1}}],[\"所以肯定能成功\",{\"1\":{\"1692\":1}}],[\"所以undo\",{\"1\":{\"1682\":1,\"1761\":1}}],[\"所以该版本的记录对当前事务不可见\",{\"1\":{\"1656\":2}}],[\"所以该版本的记录对当前事务可见\",{\"1\":{\"1656\":2}}],[\"所以该方法的参数也只能支持vga接口的指针\",{\"1\":{\"832\":1}}],[\"所以事务2插入age=22和age=21都失败了\",{\"1\":{\"1689\":1}}],[\"所以事务过程中每次查询的数据都是一样的\",{\"1\":{\"1656\":1}}],[\"所以事务b\",{\"1\":{\"1635\":1}}],[\"所以记住事务的几个基本概念\",{\"1\":{\"1649\":1}}],[\"所以connectionpool以单例模式进行设计\",{\"1\":{\"1866\":1}}],[\"所以commit不会等着这些数据从缓存全部写到磁盘再返回\",{\"1\":{\"1645\":1}}],[\"所以c++写c风格字符串最好写为const\",{\"1\":{\"535\":1}}],[\"所以c++中引入0来表示空指针\",{\"1\":{\"527\":1}}],[\"所以id字段为null\",{\"1\":{\"1618\":1}}],[\"所以无法使用索引\",{\"1\":{\"1593\":1}}],[\"所以用sex过滤出来的数据可能会占到整张表的一大部分\",{\"1\":{\"1587\":1}}],[\"所以进行全表扫描\",{\"1\":{\"1540\":1}}],[\"所以慢\",{\"1\":{\"1525\":1}}],[\"所以满足第四范式的关系图如下\",{\"1\":{\"1464\":1}}],[\"所以主要核心crud由mysql做\",{\"1\":{\"1437\":1}}],[\"所以难免会有多余的空格占位符占据空间\",{\"1\":{\"1426\":1}}],[\"所以操作系统对线程的执行来说\",{\"1\":{\"1233\":1}}],[\"所以多线程程序出问题\",{\"1\":{\"1218\":1}}],[\"所以要进行\",{\"1\":{\"1209\":2}}],[\"所以窗口买票结束\",{\"1\":{\"1208\":1}}],[\"所以最后调用test\",{\"1\":{\"1114\":1}}],[\"所以最终访问到是基类的虚函数\",{\"1\":{\"921\":1}}],[\"所以构造有3种方式\",{\"1\":{\"1114\":1}}],[\"所以不用进行区分\",{\"1\":{\"1791\":1}}],[\"所以不是构造\",{\"1\":{\"1111\":2}}],[\"所以不存在对象的构造\",{\"1\":{\"463\":1}}],[\"所以其生存周期\",{\"1\":{\"1110\":1,\"1111\":1}}],[\"所以遍历用二级指针\",{\"1\":{\"1102\":1}}],[\"所以释放的底层是free\",{\"1\":{\"1093\":1}}],[\"所以为0\",{\"1\":{\"1073\":1}}],[\"所以打印也是base\",{\"1\":{\"953\":1}}],[\"所以类纯虚函数的声明就是在告诉子类的设计者\",{\"1\":{\"898\":1}}],[\"所以普通函数声明为虚函数没有意义\",{\"1\":{\"876\":1}}],[\"所以需要root远程连接的权限打开\",{\"1\":{\"1799\":1}}],[\"所以需要手动释放资源\",{\"1\":{\"1151\":1}}],[\"所以需要添加适配器类\",{\"1\":{\"832\":1}}],[\"所以需要把符号的具体地址写到符号的指令上\",{\"1\":{\"255\":1}}],[\"所以返回值为void\",{\"1\":{\"736\":1}}],[\"所以d在构造时调用b\",{\"1\":{\"688\":1}}],[\"所以只用索引还是不行的\",{\"1\":{\"1886\":1}}],[\"所以只能整张表搜索\",{\"1\":{\"1591\":1}}],[\"所以只在定义时设默认值时\",{\"1\":{\"639\":1}}],[\"所以只要不出现无限制的调用都应该是没有问题的\",{\"1\":{\"240\":1}}],[\"所以引用是占据内存的\",{\"1\":{\"614\":1}}],[\"所以引用符号不能去掉\",{\"1\":{\"399\":1}}],[\"所以看不到它的输出\",{\"1\":{\"599\":1}}],[\"所以即使有错误\",{\"1\":{\"599\":1}}],[\"所以即便是不匹配的使用\",{\"1\":{\"524\":1}}],[\"所以还可以采用第三种使用方式\",{\"1\":{\"589\":1}}],[\"所以都加上\",{\"1\":{\"589\":1}}],[\"所以25\",{\"1\":{\"557\":1}}],[\"所以通常情况下\",{\"1\":{\"526\":1}}],[\"所以它要负责这个资源的释放\",{\"1\":{\"1054\":1}}],[\"所以它也没有动态绑定的必要\",{\"1\":{\"876\":1}}],[\"所以它的实现机制不像前面的new\",{\"1\":{\"524\":1}}],[\"所以它们并不是在创建类对象时被定义的\",{\"1\":{\"435\":1}}],[\"所以程序就挂了\",{\"1\":{\"523\":1}}],[\"所以像new\",{\"1\":{\"520\":1}}],[\"所以系统只能执行默认的操作\",{\"1\":{\"597\":1}}],[\"所以系统并没有重载new或delete表达式\",{\"1\":{\"518\":1}}],[\"所以系统中的驱动都需要用\",{\"1\":{\"304\":1}}],[\"所以说\",{\"1\":{\"504\":1}}],[\"所以说类是对象的封装\",{\"1\":{\"449\":1}}],[\"所以可以用\",{\"1\":{\"1690\":1}}],[\"所以可以插入\",{\"1\":{\"1689\":1}}],[\"所以可以解决脏读\",{\"1\":{\"1662\":1}}],[\"所以可以修改\",{\"1\":{\"1102\":1}}],[\"所以可以添加相关的成员变量用来记录函数对象使用时更多的信息\",{\"1\":{\"982\":1}}],[\"所以可以通过判断有没有生成函数符号\",{\"1\":{\"501\":1}}],[\"所以可以不显式定义\",{\"1\":{\"396\":1}}],[\"所以是\",{\"1\":{\"489\":1}}],[\"所以也是这句创建了pt2对象\",{\"1\":{\"395\":1}}],[\"所以也必须持续到链接阶段\",{\"1\":{\"244\":1}}],[\"所以低位在前\",{\"1\":{\"307\":1}}],[\"所以称之为跨平台语言\",{\"1\":{\"303\":1}}],[\"所以世界上第一个\",{\"1\":{\"300\":1}}],[\"所以就很好了避免幻读问题\",{\"1\":{\"1717\":2}}],[\"所以就称为\",{\"1\":{\"300\":1}}],[\"所以就可以\",{\"1\":{\"170\":1}}],[\"所以很多人都不倡导使用\",{\"1\":{\"277\":1}}],[\"所以入口地址\",{\"1\":{\"251\":1}}],[\"所以必须在链接阶段生效\",{\"1\":{\"244\":1}}],[\"所以在一切会影响select\",{\"1\":{\"1693\":1}}],[\"所以在代码中直接展开\",{\"1\":{\"876\":1}}],[\"所以在\",{\"1\":{\"641\":1}}],[\"所以在合并的时候是很快的\",{\"1\":{\"202\":1}}],[\"所以在哪里减的都是一样的\",{\"1\":{\"136\":1}}],[\"所以这条数据\",{\"1\":{\"1689\":1}}],[\"所以这样的设计不能算完美\",{\"1\":{\"864\":1}}],[\"所以这些语句永远都没有执行的机会了\",{\"1\":{\"599\":1}}],[\"所以这个16位的cpu\",{\"1\":{\"308\":1}}],[\"所以这种去重\",{\"1\":{\"136\":1}}],[\"所以这里是有两个重复的维度\",{\"1\":{\"135\":1}}],[\"所以我们一般都是通过命令mysqldump进行备份\",{\"1\":{\"1836\":1}}],[\"所以我们一般用的是已提交读\",{\"1\":{\"1712\":1}}],[\"所以我们设置为手动提交\",{\"1\":{\"1652\":1}}],[\"所以我们在传参的时候\",{\"1\":{\"1127\":1}}],[\"所以我们通常是将默认值的设置放在声明中而不是定义中\",{\"1\":{\"639\":1}}],[\"所以我们要重写它的拷贝构造函数和赋值函数\",{\"1\":{\"404\":1}}],[\"所以我通过自建立节点的方式来脱离它的控制\",{\"1\":{\"58\":1}}],[\"所以我做了一个点击后就会返回的按钮\",{\"1\":{\"57\":1}}],[\"所以\",{\"1\":{\"56\":1,\"162\":1,\"282\":1,\"285\":1,\"1020\":1,\"1090\":1,\"1102\":1,\"1208\":1,\"1636\":1}}],[\"所以tcp是面向连接的而udp是不需要连接的\",{\"1\":{\"22\":1}}],[\"所以联系方式放到最上边会比较方便\",{\"1\":{\"0\":1}}],[\"所以有这么一段也不错\",{\"1\":{\"0\":1}}],[\"上限数量是maxsize\",{\"1\":{\"1866\":1}}],[\"上限是maxsize个\",{\"1\":{\"1865\":1}}],[\"上图中的binlog\",{\"1\":{\"1781\":1}}],[\"上图中的这个橙色表是最后的成品\",{\"1\":{\"1681\":1}}],[\"上加了\",{\"1\":{\"1719\":1}}],[\"上锁范围\",{\"1\":{\"1688\":1}}],[\"上一个规则的依赖\",{\"1\":{\"1360\":1}}],[\"上一个函数调用之前的esp被保存在固定的ebp中\",{\"1\":{\"235\":1}}],[\"上tree查看文件名\",{\"0\":{\"1244\":1}}],[\"上构建一个临时对象\",{\"1\":{\"1115\":1}}],[\"上调至最邻近的8的倍数\",{\"1\":{\"1090\":2}}],[\"上的\",{\"1\":{\"1041\":1}}],[\"上述代码是无法编译通过的\",{\"1\":{\"620\":1}}],[\"上面两句等同于此句一次性添加数组对象\",{\"1\":{\"1904\":1}}],[\"上面两句话的意思是将ebp推入栈中\",{\"1\":{\"235\":1}}],[\"上面表格所有的锁都是针对整表\",{\"1\":{\"1673\":1}}],[\"上面一样\",{\"1\":{\"1652\":1}}],[\"上面数据段的变量不加volatile出现的问题\",{\"1\":{\"1233\":1}}],[\"上面程序还是有问题的\",{\"1\":{\"1209\":1}}],[\"上面写法灵活性太差\",{\"1\":{\"1183\":1}}],[\"上面是对function作用于全局函数\",{\"1\":{\"1166\":1}}],[\"上面用到了方法std\",{\"1\":{\"1127\":1}}],[\"上面这段代码最终会报错\",{\"1\":{\"1043\":1}}],[\"上面的csmartptr和标准的shared\",{\"1\":{\"1055\":1}}],[\"上面的代码将auto\",{\"1\":{\"1045\":1}}],[\"上面的代码实现的是一个简单的智能指针\",{\"1\":{\"1041\":1}}],[\"上面的代码中\",{\"1\":{\"597\":1}}],[\"上面的整数中\",{\"1\":{\"1001\":1}}],[\"上面的1000个整数中\",{\"1\":{\"1001\":1}}],[\"上面的例子中\",{\"1\":{\"913\":1}}],[\"上面三个函数可以合成下面这一个\",{\"1\":{\"641\":1}}],[\"上inline无效\",{\"1\":{\"502\":1}}],[\"上移到ebp位置\",{\"1\":{\"234\":1}}],[\"上移两个int的位\",{\"1\":{\"234\":1}}],[\"上滤\",{\"0\":{\"121\":1}}],[\"上\",{\"1\":{\"81\":1,\"1524\":1,\"1610\":2,\"1803\":1}}],[\"上万字后打字出现卡顿\",{\"0\":{\"64\":1}}],[\"上划线\",{\"1\":{\"50\":1}}],[\"上三角号代表\",{\"1\":{\"30\":1}}],[\"规定文本中间将显示一条线\",{\"1\":{\"50\":1}}],[\"取出结果集中的一行记录\",{\"0\":{\"1379\":1}}],[\"取反\",{\"1\":{\"1090\":1,\"1470\":1}}],[\"取虚函数地址\",{\"1\":{\"954\":1}}],[\"取用它们重写的bark\",{\"1\":{\"886\":1}}],[\"取\",{\"1\":{\"301\":1}}],[\"取得该块的内存控制块的首地址\",{\"1\":{\"287\":1}}],[\"取得下一个内存块\",{\"1\":{\"286\":1}}],[\"取得当前内存块的内存控制结构\",{\"1\":{\"286\":1}}],[\"取a\",{\"1\":{\"234\":1}}],[\"取消大小限制\",{\"1\":{\"1338\":1}}],[\"取消\",{\"1\":{\"59\":1,\"60\":1}}],[\"取消样式\",{\"1\":{\"29\":1}}],[\"取值越小\",{\"1\":{\"1025\":1}}],[\"取值\",{\"1\":{\"50\":3}}],[\"用protobuf序列化后的大是json的10分之一\",{\"1\":{\"1913\":1}}],[\"用p来接收hashmap的值\",{\"1\":{\"178\":1}}],[\"用id\",{\"1\":{\"1892\":1}}],[\"用lambda表达式定制连接释放的功能\",{\"1\":{\"1866\":1}}],[\"用哪个端口就开放哪个端口\",{\"1\":{\"1818\":1}}],[\"用逗号分隔开即可\",{\"1\":{\"1802\":1}}],[\"用rz命令将mycat包传输到linux\",{\"1\":{\"1800\":1}}],[\"用root连接mysql服务器\",{\"1\":{\"1799\":1}}],[\"用mysql自定义的基于tcp的数据协议\",{\"1\":{\"1790\":1}}],[\"用malloc申请\",{\"1\":{\"1102\":1}}],[\"用更高效的连接\",{\"1\":{\"1738\":1}}],[\"用可重复的age\",{\"0\":{\"1689\":1}}],[\"用索引文的数据构建b+树\",{\"1\":{\"1626\":1}}],[\"用索引文的数据构建b树\",{\"1\":{\"1623\":1}}],[\"用的过程\",{\"1\":{\"1744\":1}}],[\"用的比较少\",{\"1\":{\"1610\":1}}],[\"用的最多就是查询select\",{\"1\":{\"1548\":1}}],[\"用联合索引优化using\",{\"0\":{\"1586\":1}}],[\"用explain分析这些sql的执行计划\",{\"1\":{\"1573\":1,\"1776\":1}}],[\"用explain分析这些耗时的sql语句\",{\"0\":{\"1581\":1},\"1\":{\"1573\":1}}],[\"用这个uid去主键索引树上取得对应的数据\",{\"1\":{\"1569\":1}}],[\"用userid选择出来的数据越多\",{\"1\":{\"1586\":1}}],[\"用use\",{\"1\":{\"1507\":1}}],[\"用完了能否复用被删掉的id\",{\"0\":{\"1481\":1}}],[\"用\",{\"1\":{\"1338\":1,\"1471\":1,\"1744\":1}}],[\"用二进制\",{\"1\":{\"1299\":1}}],[\"用十六进制\",{\"1\":{\"1299\":1}}],[\"用十进制\",{\"1\":{\"1299\":1}}],[\"用tcpdump嗅探80端口的访问看看谁最高\",{\"1\":{\"1238\":1}}],[\"用test来实例化\",{\"1\":{\"382\":1}}],[\"用function类型表示函数对象的类型\",{\"1\":{\"1180\":1}}],[\"用function类型绑定它\",{\"1\":{\"1180\":1}}],[\"用fast扫描原数组\",{\"1\":{\"77\":1}}],[\"用什么类型来表示lambda表达式\",{\"1\":{\"1180\":1}}],[\"用不可重复的\",{\"0\":{\"1688\":1}}],[\"用不到参数直接写void\",{\"1\":{\"1173\":1}}],[\"用不好裸指针也是造成我们内存资源的一种因素\",{\"1\":{\"1040\":1}}],[\"用引用变量引用临时对象是安全的\",{\"1\":{\"1113\":1}}],[\"用引用传递函数的参数\",{\"1\":{\"617\":1}}],[\"用临时对象给已存在对象赋值\",{\"0\":{\"1111\":1}}],[\"用临时对象生成新对象的时候\",{\"1\":{\"1110\":1,\"1111\":1}}],[\"用临时对象生成新对象\",{\"0\":{\"1110\":1}}],[\"用法见下方代码\",{\"1\":{\"1060\":1}}],[\"用智能指针来托管数组的资源\",{\"1\":{\"1060\":1}}],[\"用模板实现的\",{\"1\":{\"1007\":1}}],[\"用模板实现的函数\",{\"0\":{\"365\":1}}],[\"用派生类析构函数将自己部分进行析构\",{\"1\":{\"948\":1}}],[\"用b类构造函数\",{\"1\":{\"943\":1}}],[\"用对象本身调用虚函数\",{\"1\":{\"927\":1}}],[\"用券观看电影\",{\"1\":{\"830\":5}}],[\"用一个变量res\",{\"1\":{\"782\":1}}],[\"用一个指针扫描负数\",{\"1\":{\"87\":1}}],[\"用d调用成员函数print时\",{\"1\":{\"652\":1}}],[\"用指针作为参数\",{\"1\":{\"615\":1}}],[\"用指针定义\",{\"1\":{\"547\":1}}],[\"用数组定义\",{\"1\":{\"547\":1}}],[\"用aa\",{\"1\":{\"518\":1}}],[\"用它们便可实现动态的内存管理\",{\"1\":{\"509\":1}}],[\"用函数指针定义的变量本身就是一个指针\",{\"1\":{\"1188\":1}}],[\"用函数指针保存函数类型\",{\"1\":{\"1158\":1}}],[\"用函数对象类型func1将hello1函数类型保留下来了\",{\"1\":{\"1164\":1}}],[\"用函数内联取代宏\",{\"1\":{\"503\":1}}],[\"用函数体去代替函数的调用\",{\"1\":{\"500\":1}}],[\"用来进行崩溃后的数据恢复\",{\"1\":{\"1758\":1}}],[\"用来描述这个\",{\"1\":{\"1318\":1}}],[\"用来记录bind绑定器绑定的结果\",{\"1\":{\"1154\":1}}],[\"用来捕获并处理\",{\"1\":{\"599\":1}}],[\"用来降低程序的运行时间\",{\"1\":{\"501\":1}}],[\"用来表示true和false\",{\"1\":{\"473\":1}}],[\"用来规定线条如何显示\",{\"1\":{\"50\":1}}],[\"用来规定文本修饰\",{\"1\":{\"50\":1}}],[\"用来规定文本修饰要使用的线条类型\",{\"1\":{\"50\":1}}],[\"用以执行一些\",{\"1\":{\"425\":1}}],[\"用以完成对象及其他操作\",{\"1\":{\"420\":1}}],[\"用带const\",{\"1\":{\"405\":1}}],[\"用了\",{\"1\":{\"301\":1}}],[\"用户获取的连接用shared\",{\"1\":{\"1866\":1}}],[\"用户是否合法\",{\"1\":{\"1864\":1}}],[\"用户是看不到的\",{\"1\":{\"282\":1,\"285\":1}}],[\"用户配置\",{\"1\":{\"1802\":1}}],[\"用户的\",{\"1\":{\"1548\":1}}],[\"用户名和密码以及其它的性能参数\",{\"1\":{\"1865\":1}}],[\"用户名\",{\"1\":{\"1485\":1,\"1486\":1,\"1508\":1,\"1836\":5}}],[\"用户管理与授权\",{\"0\":{\"1447\":1}}],[\"用户表\",{\"1\":{\"1415\":2}}],[\"用户不需要重新链接就能更新库文件\",{\"1\":{\"1332\":1}}],[\"用户自己传入参数\",{\"1\":{\"1155\":1}}],[\"用户设置了回调函数\",{\"1\":{\"1102\":1}}],[\"用户也没有设置任何回调函数\",{\"1\":{\"1102\":1}}],[\"用户\",{\"1\":{\"861\":1}}],[\"用户代码也需要重新编译\",{\"1\":{\"826\":1}}],[\"用户重载的operator=运算符\",{\"1\":{\"685\":1}}],[\"用户重载的operator\",{\"1\":{\"685\":1}}],[\"用户没有必要\",{\"1\":{\"504\":1}}],[\"用户可以阅读函数的声明\",{\"1\":{\"504\":1}}],[\"用户传进来的字符串是空的话\",{\"1\":{\"405\":1}}],[\"用户空间\",{\"1\":{\"282\":1,\"285\":1}}],[\"用到\",{\"0\":{\"276\":1}}],[\"用栈实现队列\",{\"0\":{\"182\":1},\"1\":{\"182\":1}}],[\"用记事本打开\",{\"1\":{\"61\":1}}],[\"用于连接生产线程和连接消费线程的通信\",{\"1\":{\"1848\":1,\"1859\":1,\"1875\":1}}],[\"用于登录主库取数据\",{\"1\":{\"1832\":1}}],[\"用于slave登录master读取binlog\",{\"1\":{\"1821\":1}}],[\"用于配置client登录mycat的账号密码\",{\"1\":{\"1802\":1}}],[\"用于windows和linux传输文件\",{\"1\":{\"1800\":1}}],[\"用于标识当前mysql的身份\",{\"1\":{\"1773\":1}}],[\"用于加速数据的读取和写入\",{\"1\":{\"1762\":1}}],[\"用于记录事务操作的变化\",{\"1\":{\"1758\":1}}],[\"用于记录已经遍历过的元素\",{\"1\":{\"137\":1}}],[\"用于事务的回滚操作\",{\"1\":{\"1679\":1}}],[\"用于实现已提交读和可重复读隔离级别\",{\"1\":{\"1656\":1}}],[\"用于实现的关键字\",{\"1\":{\"504\":1}}],[\"用于控制不同的许可和访问级别的语句\",{\"1\":{\"1548\":1}}],[\"用于添加\",{\"1\":{\"1548\":1}}],[\"用于添加要修改记录的条件\",{\"1\":{\"1479\":1}}],[\"用于唯一标识关系中的每一行数据\",{\"1\":{\"1451\":1}}],[\"用于在每次程序停止时自动显示一个或多个表达式的值\",{\"1\":{\"1341\":1}}],[\"用于在面试的时候联系\",{\"1\":{\"0\":1}}],[\"用于创建\",{\"1\":{\"1334\":1}}],[\"用于gdb等调试器\",{\"1\":{\"1327\":1}}],[\"用于设置编译选项\",{\"1\":{\"1317\":1}}],[\"用于保存函数类型\",{\"1\":{\"1158\":1}}],[\"用于保存字符串\",{\"1\":{\"405\":1}}],[\"用于\",{\"1\":{\"1018\":1,\"1745\":1}}],[\"用于类对象的运算符一般必须重载\",{\"1\":{\"728\":1}}],[\"用于类层次结构中基类和派生类之间指针或引用的转换\",{\"1\":{\"629\":1}}],[\"用于继承结构中\",{\"1\":{\"631\":1}}],[\"用于基本数据类型之间的转换\",{\"1\":{\"629\":1}}],[\"用于将一种基本数据类型转换成另一种基本数据类型\",{\"1\":{\"629\":1}}],[\"用于变量的声明\",{\"1\":{\"574\":1}}],[\"用于模拟\",{\"1\":{\"530\":1}}],[\"用于声明的关键字\",{\"1\":{\"504\":1}}],[\"用于管理所有的内存块\",{\"1\":{\"286\":1}}],[\"用于往堆内插入数据\",{\"1\":{\"121\":1}}],[\"用于存储锚点\",{\"1\":{\"59\":1}}],[\"下使用的\",{\"1\":{\"1896\":1}}],[\"下次服务重启时\",{\"1\":{\"1761\":1}}],[\"下次再申请内存时直接在ptmalloc或者tcmalloc上申请\",{\"1\":{\"1622\":1}}],[\"下读操作\",{\"1\":{\"1679\":1}}],[\"下读取一个索引就需要25次磁盘io\",{\"1\":{\"1622\":1}}],[\"下表bank\",{\"1\":{\"1531\":1}}],[\"下的\",{\"1\":{\"1099\":1}}],[\"下载安装包\",{\"0\":{\"1395\":1}}],[\"下载cmake\",{\"1\":{\"1305\":1}}],[\"下载链接\",{\"1\":{\"1255\":1}}],[\"下载并重命名\",{\"0\":{\"1251\":1}}],[\"下载多个文件\",{\"0\":{\"1250\":1}}],[\"下载完成百分比\",{\"1\":{\"1249\":1}}],[\"下载单个文件\",{\"0\":{\"1249\":1}}],[\"下载log4cpp\",{\"1\":{\"1015\":1}}],[\"下载地址2\",{\"1\":{\"5\":1}}],[\"下载地址1\",{\"1\":{\"5\":1}}],[\"下标\",{\"1\":{\"597\":1}}],[\"下标越界\",{\"1\":{\"597\":2}}],[\"下标访问先判断下标的有效性\",{\"1\":{\"101\":1}}],[\"下标访问\",{\"1\":{\"100\":1}}],[\"下面是对mysql操作的封装\",{\"1\":{\"1856\":1}}],[\"下面是对异常类的说明\",{\"1\":{\"604\":1}}],[\"下面和宏一样就不要加多余的空格了\",{\"1\":{\"1844\":1,\"1878\":1}}],[\"下面连着2个mysql从服务器专门做读操作\",{\"1\":{\"1790\":1}}],[\"下面就是配置文件的格式\",{\"1\":{\"1026\":1}}],[\"下面两段代码是否正确\",{\"0\":{\"908\":1}}],[\"下面这个是对指针类a型提供的部分特例化版本\",{\"1\":{\"1188\":1}}],[\"下面这个是对char\",{\"1\":{\"1188\":1}}],[\"下面这个种行为c++已经不支持了\",{\"1\":{\"633\":1}}],[\"下面这两行相当于头插法\",{\"1\":{\"747\":1}}],[\"下面这些基类的特征是不能从基类继承下来的\",{\"1\":{\"685\":1}}],[\"下面我们来分析一下原因\",{\"1\":{\"597\":1}}],[\"下面我们用一个点point来举例\",{\"1\":{\"421\":1}}],[\"下面引用当前流行的名称空间使用指导原则\",{\"1\":{\"593\":1}}],[\"下面的\",{\"1\":{\"1686\":1}}],[\"下面的方法能够减少tcp\",{\"1\":{\"1476\":1}}],[\"下面的例子会下载一个文件并以名称download\",{\"1\":{\"1251\":1}}],[\"下面的例子演示了\",{\"1\":{\"601\":1}}],[\"下面的这种情况编译正常\",{\"1\":{\"639\":1}}],[\"下面的是函数重载\",{\"1\":{\"563\":1}}],[\"下面的foo函数\",{\"1\":{\"504\":1}}],[\"下面的才是偏特化\",{\"1\":{\"370\":1}}],[\"下面以一台大家\",{\"1\":{\"449\":1}}],[\"下面让我们再来看一个有意思的例子\",{\"1\":{\"439\":1}}],[\"下一次mysql启动后\",{\"1\":{\"1760\":1}}],[\"下一次mysqld再启动时\",{\"1\":{\"1758\":1}}],[\"下一次再查询相同内容的时候\",{\"1\":{\"1749\":1}}],[\"下一次查出的数据量和上一次的数据量不一样\",{\"1\":{\"1689\":1}}],[\"下一步\",{\"1\":{\"235\":1}}],[\"下一个也是\",{\"1\":{\"135\":1}}],[\"下沉\",{\"1\":{\"194\":2}}],[\"下\",{\"1\":{\"81\":1,\"1143\":1,\"1574\":1}}],[\"下划线\",{\"1\":{\"50\":1}}],[\"下划线与文字距离\",{\"1\":{\"48\":1}}],[\"下划线线条粗细\",{\"1\":{\"48\":1}}],[\"对端主机读取字节流上报应用服务\",{\"1\":{\"1896\":1}}],[\"对user表分别读写操作\",{\"1\":{\"1814\":1}}],[\"对数据进行恢复\",{\"1\":{\"1760\":1}}],[\"对返回数据进行排序\",{\"1\":{\"1736\":1}}],[\"对某行记录加锁\",{\"1\":{\"1713\":1}}],[\"对整张表加锁\",{\"1\":{\"1713\":1}}],[\"对事务加x和s锁之间有以下的关系\",{\"1\":{\"1697\":1}}],[\"对每个英文字符占用2个字节\",{\"1\":{\"1426\":1}}],[\"对一个表而言\",{\"1\":{\"1724\":1}}],[\"对一个汉字占用两个字节\",{\"1\":{\"1426\":1}}],[\"对一个类来说\",{\"1\":{\"900\":1}}],[\"对英文字符\",{\"1\":{\"1426\":1}}],[\"对目录做软链接\",{\"1\":{\"1271\":1}}],[\"对内存池中的\",{\"1\":{\"1076\":1}}],[\"对资源进行引用计数的类\",{\"1\":{\"1055\":1}}],[\"对输出日期做定制\",{\"1\":{\"1021\":1}}],[\"对容器的元素进行过滤\",{\"1\":{\"1007\":1}}],[\"对容器的操作\",{\"1\":{\"740\":1}}],[\"对vector容器中元素遍历\",{\"1\":{\"966\":1}}],[\"对虚基类构造函数的调用总是先于普通基类的构造函数\",{\"1\":{\"943\":1}}],[\"对有一组关联关系的产品簇提供产品对象的同一创建\",{\"1\":{\"867\":1}}],[\"对有序数组\",{\"1\":{\"142\":1}}],[\"对插入\",{\"1\":{\"744\":1}}],[\"对运算符的重载处理\",{\"1\":{\"727\":1}}],[\"对\",{\"1\":{\"716\":1}}],[\"对所指的对象进行间接操作\",{\"1\":{\"619\":1}}],[\"对引用的操作就是对目标变量的操作\",{\"1\":{\"617\":1}}],[\"对它所指向的变量\",{\"1\":{\"617\":1}}],[\"对类型的要求比较严格\",{\"1\":{\"608\":1}}],[\"对错误的处理总是围绕着两种方法\",{\"1\":{\"598\":1}}],[\"对命名空间的思考和总结\",{\"0\":{\"593\":1}}],[\"对函数名字做了改编\",{\"1\":{\"571\":1}}],[\"对齐8字节\",{\"1\":{\"1082\":1}}],[\"对齐系数\",{\"1\":{\"557\":1}}],[\"对齐将按照\",{\"1\":{\"556\":1}}],[\"对齐规则是按照成员的\",{\"1\":{\"552\":1}}],[\"对齐规则\",{\"0\":{\"552\":1}}],[\"对字符串中包含的字符进行访问\",{\"1\":{\"539\":1}}],[\"对字符串进行操作的c函数定义在头文件<string\",{\"1\":{\"535\":1}}],[\"对被调函数的栈帧初始化\",{\"1\":{\"500\":1}}],[\"对point\",{\"1\":{\"434\":1}}],[\"对其进行实例化\",{\"1\":{\"382\":1}}],[\"对象拥有小括号重载函数的对象\",{\"1\":{\"1146\":1}}],[\"对象优化\",{\"2\":{\"1118\":1,\"1126\":1,\"1129\":1}}],[\"对象优先按\",{\"1\":{\"1116\":1}}],[\"对象初始化是调用构造函数\",{\"1\":{\"1115\":1}}],[\"对象被后续调用的方法太多\",{\"0\":{\"1115\":1}}],[\"对象作为参数\",{\"1\":{\"1067\":1}}],[\"对象不能析构\",{\"1\":{\"1056\":1}}],[\"对象构造\",{\"1\":{\"964\":1}}],[\"对象构造和析构\",{\"1\":{\"385\":1}}],[\"对象b占8个字节\",{\"1\":{\"934\":1}}],[\"对象类型是子类时\",{\"1\":{\"923\":1}}],[\"对象类型是基类时\",{\"1\":{\"923\":1}}],[\"对象访问\",{\"0\":{\"923\":1}}],[\"对象derived2的地址\",{\"1\":{\"894\":2}}],[\"对象derived的地址\",{\"1\":{\"894\":2}}],[\"对象必须存在\",{\"1\":{\"875\":1}}],[\"对象3应该及时的收到相应的通知\",{\"1\":{\"871\":1}}],[\"对象3\",{\"1\":{\"871\":1}}],[\"对象2\",{\"1\":{\"871\":2}}],[\"对象1\",{\"1\":{\"871\":2}}],[\"对象池\",{\"2\":{\"753\":1}}],[\"对象池大小\",{\"1\":{\"751\":1}}],[\"对象析构\",{\"1\":{\"715\":1,\"964\":1}}],[\"对象在本行创建\",{\"1\":{\"459\":1}}],[\"对象要么没有定义任何形式的构造函数\",{\"1\":{\"459\":1}}],[\"对象个数\",{\"1\":{\"457\":1,\"520\":1}}],[\"对象数组的初始化\",{\"0\":{\"458\":1}}],[\"对象数组的声明\",{\"0\":{\"457\":1}}],[\"对象数组\",{\"0\":{\"456\":1},\"1\":{\"456\":1}}],[\"对象占据一定的内存空间\",{\"1\":{\"455\":1}}],[\"对象的优化\",{\"0\":{\"1940\":1}}],[\"对象的构造顺序标识\",{\"1\":{\"1114\":1}}],[\"对象的地址\",{\"1\":{\"517\":1}}],[\"对象的组织\",{\"0\":{\"453\":1},\"1\":{\"496\":1}}],[\"对象的创建就必须要放在line的构造函数的初始化列表中进行\",{\"1\":{\"434\":1}}],[\"对象的创建\",{\"1\":{\"422\":1}}],[\"对象可以看成某个类的实例\",{\"1\":{\"449\":1}}],[\"对象可按其性质划分为类\",{\"1\":{\"445\":1}}],[\"对象成为类的实例\",{\"1\":{\"445\":1}}],[\"对象是存在的\",{\"1\":{\"877\":1}}],[\"对象是类的实例\",{\"1\":{\"449\":1}}],[\"对象是属性及其操作的封装体\",{\"1\":{\"445\":1}}],[\"对象是在\",{\"1\":{\"435\":1}}],[\"对象变量\",{\"1\":{\"435\":1}}],[\"对象名\",{\"1\":{\"435\":1,\"455\":1}}],[\"对象超出其作用域被销毁时\",{\"1\":{\"425\":1}}],[\"对象使用浅拷贝不一定有错\",{\"1\":{\"397\":1}}],[\"对象\",{\"0\":{\"1109\":1},\"1\":{\"353\":1,\"517\":1,\"1899\":1}}],[\"对堆中的内存块进行遍历\",{\"1\":{\"286\":1}}],[\"对这两个⼦序列分别采⽤归并排序\",{\"1\":{\"202\":1}}],[\"对尾指针\",{\"1\":{\"185\":1}}],[\"对头指针\",{\"1\":{\"185\":2}}],[\"对right\",{\"1\":{\"136\":1}}],[\"对应索引树的节点\",{\"1\":{\"1621\":1}}],[\"对应的虚函数的地址\",{\"1\":{\"889\":1}}],[\"对应的就是\",{\"1\":{\"135\":1}}],[\"对应快捷键ctrl+u\",{\"1\":{\"48\":1}}],[\"对于列表类型\",{\"1\":{\"1914\":1}}],[\"对于普通单个成员变量\",{\"1\":{\"1914\":1}}],[\"对于普通的单继承而言\",{\"1\":{\"894\":1}}],[\"对于底层\",{\"1\":{\"1761\":1}}],[\"对于buffer\",{\"1\":{\"1760\":1}}],[\"对于mysql\",{\"1\":{\"1746\":1}}],[\"对于filesort\",{\"1\":{\"1736\":1}}],[\"对于\",{\"1\":{\"1694\":2}}],[\"对于上面的例子\",{\"1\":{\"1686\":1}}],[\"对于键值在条件范围内但并不存在的记录\",{\"1\":{\"1686\":1}}],[\"对于每个版本的数据\",{\"1\":{\"1681\":1}}],[\"对于每一个字节数的chunk块分配\",{\"1\":{\"1105\":1}}],[\"对于每一个固定的右界\",{\"1\":{\"73\":1}}],[\"对于一个消息类型里成员变量本身又是一个对象\",{\"1\":{\"1914\":1}}],[\"对于一个事务来说\",{\"1\":{\"1635\":1}}],[\"对于一个正整数\",{\"1\":{\"146\":1}}],[\"对于2000000的数据查询时间仍然很长\",{\"1\":{\"1617\":1}}],[\"对于字符串类型来说\",{\"1\":{\"1591\":1}}],[\"对于sql和索引的优化问题\",{\"1\":{\"1572\":1}}],[\"对于innodb来说应该是直接取得数据\",{\"1\":{\"1569\":1}}],[\"对于inner\",{\"1\":{\"1541\":1}}],[\"对于查询不在的情况\",{\"1\":{\"1544\":1}}],[\"对于偏移量我们之前是使用where\",{\"1\":{\"1539\":1}}],[\"对于路径多多使用tab键\",{\"1\":{\"1396\":1}}],[\"对于链接时库搜索\",{\"1\":{\"1335\":1}}],[\"对于运行时动态库搜索\",{\"1\":{\"1335\":1}}],[\"对于下载非常大的文件的时候\",{\"1\":{\"1253\":1}}],[\"对于动态链接的下载通常文件名会不正确\",{\"1\":{\"1251\":1}}],[\"对于软件层面可以说是无锁操作\",{\"1\":{\"1232\":1}}],[\"对于备用内存池划分完chunk块以后\",{\"1\":{\"1105\":1}}],[\"对于自由链表的增删改要加锁\",{\"1\":{\"1096\":1}}],[\"对于c++\",{\"0\":{\"1072\":1}}],[\"对于c语言\",{\"0\":{\"1071\":1}}],[\"对于computer中的两个成员函数\",{\"1\":{\"449\":1}}],[\"对于对象的优化\",{\"0\":{\"1067\":1}}],[\"对于queue来说\",{\"1\":{\"993\":1}}],[\"对于继承链上的中间类\",{\"1\":{\"943\":1}}],[\"对于test\",{\"1\":{\"913\":1}}],[\"对于虚继承的派生类对象的析构\",{\"1\":{\"891\":1}}],[\"对于多线程环境\",{\"1\":{\"856\":1}}],[\"对于整型来说\",{\"1\":{\"713\":1}}],[\"对于那些无初始值的异常类型来说\",{\"1\":{\"605\":1}}],[\"对于using\",{\"1\":{\"593\":1}}],[\"对于初学者来说\",{\"1\":{\"588\":1}}],[\"对于纯c的函数声明\",{\"1\":{\"578\":1}}],[\"对于二进制文件不能用vi看\",{\"1\":{\"572\":1}}],[\"对于程序的可读性有很大的好处\",{\"1\":{\"560\":1}}],[\"对于内联函数\",{\"1\":{\"504\":1,\"506\":1}}],[\"对于编译器来说p存放的就是整型常量的地址const\",{\"1\":{\"492\":1}}],[\"对于指针需要关注两点\",{\"0\":{\"487\":1}}],[\"对于非const对象\",{\"1\":{\"440\":1}}],[\"对于静态成员函数\",{\"1\":{\"439\":1}}],[\"对于用new运算符创建的对象\",{\"1\":{\"427\":1}}],[\"对于关键字static定义的静态局部变量\",{\"1\":{\"427\":1}}],[\"对于局部定义的对象\",{\"1\":{\"427\":1}}],[\"对于全局定义的对象\",{\"1\":{\"427\":1}}],[\"对于类成员函数而言\",{\"1\":{\"392\":1}}],[\"对于早期的编译器可能识别不了typename关键字\",{\"1\":{\"360\":1}}],[\"对于我们后面编写程序遇到编译错误后\",{\"1\":{\"310\":1}}],[\"对于有正有负的情况\",{\"1\":{\"87\":1}}],[\"对c语言的解释和执行方式保持一致\",{\"1\":{\"16\":1}}],[\"自己玩的时候\",{\"1\":{\"1828\":1}}],[\"自己配置的时候不知道为什么\",{\"1\":{\"1826\":1}}],[\"自然就不会使用行锁\",{\"1\":{\"1700\":1}}],[\"自然就出现了幻读\",{\"1\":{\"1660\":1}}],[\"自然无法插入\",{\"1\":{\"1689\":1}}],[\"自然也不能在自己的类内将它声明为虚函数\",{\"1\":{\"876\":1}}],[\"自适应哈希索引\",{\"0\":{\"1747\":1}}],[\"自适应哈希索引默认分配了8个分区\",{\"1\":{\"1569\":1}}],[\"自适应哈希索引是默认开启的\",{\"1\":{\"1569\":1}}],[\"自适应哈希索引作用\",{\"1\":{\"1569\":1}}],[\"自增键约束\",{\"0\":{\"1433\":1}}],[\"自带的预定义变量\",{\"1\":{\"1316\":1,\"1317\":1}}],[\"自由链表大小\",{\"1\":{\"1082\":1}}],[\"自由链表的个数\",{\"1\":{\"1082\":1}}],[\"自定义变量\",{\"1\":{\"1356\":1}}],[\"自定义互斥锁\",{\"1\":{\"1219\":1}}],[\"自定义智能指针的删除器\",{\"1\":{\"1171\":1}}],[\"自定义操作\",{\"1\":{\"1171\":1}}],[\"自定义删除器\",{\"0\":{\"1060\":1}}],[\"自定义vector容器erase方法实现\",{\"1\":{\"747\":1}}],[\"自定义vector容器insert方法实现\",{\"1\":{\"747\":1}}],[\"自定义erase实现\",{\"1\":{\"747\":1}}],[\"自定义insert实现\",{\"1\":{\"747\":1}}],[\"自定义的类类型\",{\"1\":{\"715\":1}}],[\"自定义的实体与命名空间中的实体冲突\",{\"1\":{\"594\":1}}],[\"自定义红色下划线样式\",{\"1\":{\"48\":1}}],[\"自复制\",{\"1\":{\"464\":1,\"548\":1}}],[\"自行车\",{\"1\":{\"449\":1}}],[\"自动切换\",{\"1\":{\"1803\":1}}],[\"自动创建的\",{\"1\":{\"1569\":1}}],[\"自动变量\",{\"1\":{\"1356\":1}}],[\"自动判断\",{\"1\":{\"1299\":1}}],[\"自动状态下ip地址可能会变\",{\"1\":{\"1277\":1}}],[\"自动调用析构函数\",{\"1\":{\"1226\":1,\"1227\":1}}],[\"自动调用全局对象的析构函数\",{\"1\":{\"427\":1}}],[\"自动的加锁解锁\",{\"1\":{\"1202\":1}}],[\"自动识别val是左值还是右值并返回对应类型\",{\"1\":{\"1127\":1}}],[\"自动释放\",{\"1\":{\"1032\":1}}],[\"自动刹车\",{\"1\":{\"831\":1}}],[\"自动推导类型\",{\"1\":{\"699\":1,\"700\":1}}],[\"自动将\",{\"1\":{\"17\":1}}],[\"加好友消息等等\",{\"1\":{\"1896\":1}}],[\"加快crud\",{\"1\":{\"1758\":1}}],[\"加排它锁\",{\"1\":{\"1688\":1}}],[\"加个volatile\",{\"1\":{\"1233\":1}}],[\"加个宏\",{\"1\":{\"1202\":1}}],[\"加1就会进位为8\",{\"1\":{\"1090\":1}}],[\"加菲猫\",{\"1\":{\"905\":1}}],[\"加锁分析\",{\"0\":{\"1718\":1}}],[\"加锁慢\",{\"1\":{\"1713\":1}}],[\"加锁快\",{\"1\":{\"1713\":1}}],[\"加锁期间其它事务\",{\"1\":{\"1697\":1}}],[\"加锁期间但\",{\"1\":{\"1697\":1}}],[\"加锁保证线程安全\",{\"1\":{\"1093\":1}}],[\"加锁\",{\"1\":{\"848\":2,\"1686\":2}}],[\"加锁的懒汉式实现\",{\"1\":{\"848\":1}}],[\"加锁的懒汉式单例\",{\"0\":{\"847\":1}}],[\"加上\",{\"1\":{\"1188\":1}}],[\"加上mutable\",{\"1\":{\"1174\":1}}],[\"加上pop\",{\"1\":{\"747\":1}}],[\"加上extern\",{\"1\":{\"577\":1}}],[\"加了主键就存放再\",{\"1\":{\"1558\":1}}],[\"加了left或right就左连接或右连接\",{\"1\":{\"1543\":1}}],[\"加了\",{\"1\":{\"715\":1}}],[\"加工\",{\"1\":{\"509\":1}}],[\"加20\",{\"1\":{\"340\":1}}],[\"加数相差很大\",{\"1\":{\"340\":1}}],[\"加数\",{\"1\":{\"340\":1}}],[\"加载配置项\",{\"0\":{\"1839\":1}}],[\"加载共享库\",{\"1\":{\"267\":1}}],[\"加载到内存后是如何存放的\",{\"1\":{\"267\":1}}],[\"加载段\",{\"1\":{\"262\":1}}],[\"加\",{\"1\":{\"234\":1,\"260\":1}}],[\"加入队列的连接需要刷新时间\",{\"1\":{\"1859\":1}}],[\"加入了\",{\"1\":{\"301\":2}}],[\"加入\",{\"1\":{\"48\":1,\"49\":1,\"51\":1}}],[\"加号代表\",{\"1\":{\"30\":1}}],[\"多主多从场景\",{\"1\":{\"1791\":1}}],[\"多主多从\",{\"1\":{\"1791\":1}}],[\"多表查询不用in\",{\"1\":{\"1744\":1}}],[\"多表select\",{\"0\":{\"1534\":1}}],[\"多版本并发控制\",{\"1\":{\"1645\":1,\"1656\":1,\"1677\":1}}],[\"多列索引必须使用到第一个列\",{\"1\":{\"1610\":1}}],[\"多列索引\",{\"1\":{\"1610\":1,\"1614\":1}}],[\"多对多的关系\",{\"1\":{\"1465\":1}}],[\"多对多的通信\",{\"1\":{\"22\":1}}],[\"多对多\",{\"0\":{\"1417\":1}}],[\"多线程detach\",{\"1\":{\"1859\":1}}],[\"多线程会进行缓存\",{\"1\":{\"1233\":1}}],[\"多线程操作不安全\",{\"1\":{\"1232\":1}}],[\"多线程的头文件\",{\"1\":{\"1219\":1}}],[\"多线程执行的结果出现不一致的情况\",{\"1\":{\"1217\":1}}],[\"多线程执行的结果不一致的情况\",{\"1\":{\"1208\":1}}],[\"多线程\",{\"2\":{\"1214\":1}}],[\"多线程程序\",{\"1\":{\"1208\":1}}],[\"多线程编程两个问题\",{\"0\":{\"1216\":1}}],[\"多线程编程\",{\"0\":{\"1203\":1}}],[\"多线程对于堆上和数据段上的数据一般都加volatile修饰\",{\"1\":{\"1082\":1}}],[\"多线程访问共享对象的线程安全问题\",{\"0\":{\"1050\":1}}],[\"多线程调试\",{\"0\":{\"1020\":1}}],[\"多了virtual\",{\"1\":{\"955\":1}}],[\"多了一个虚基指针\",{\"1\":{\"940\":1}}],[\"多了一个vbptr指针\",{\"1\":{\"937\":1}}],[\"多存储一个vfptr虚函数指针\",{\"1\":{\"915\":1}}],[\"多种方法\",{\"1\":{\"881\":1}}],[\"多个逻辑库的话\",{\"1\":{\"1802\":1}}],[\"多个事务\",{\"1\":{\"1707\":1}}],[\"多个字段有索引\",{\"0\":{\"1589\":1}}],[\"多个进程访问同一个mysql数据库\",{\"1\":{\"1452\":1}}],[\"多个程序可以共享同一个库文件\",{\"1\":{\"1335\":1}}],[\"多个目录\",{\"0\":{\"1313\":1}}],[\"多个源文件\",{\"0\":{\"1312\":1,\"1313\":1}}],[\"多个函数访问类的私有成员\",{\"1\":{\"723\":1}}],[\"多个文件都要访问test\",{\"1\":{\"576\":1}}],[\"多重映射表\",{\"1\":{\"1000\":1,\"1002\":1}}],[\"多重集合\",{\"1\":{\"999\":1,\"1002\":1}}],[\"多重继承\",{\"1\":{\"688\":1,\"889\":1}}],[\"多重复几遍就好了\",{\"1\":{\"45\":1}}],[\"多基派生的二义性\",{\"0\":{\"890\":1}}],[\"多基派生中\",{\"1\":{\"653\":1}}],[\"多基继承和单基继承的派生类构造函数完成的任务和执行顺序并没有本质不同\",{\"1\":{\"651\":1}}],[\"多基继承\",{\"0\":{\"645\":1}}],[\"多使用printf打印信息\",{\"1\":{\"547\":1}}],[\"多级\",{\"0\":{\"490\":1}}],[\"多态底层是通过来实现的\",{\"1\":{\"883\":1}}],[\"多态的分类\",{\"0\":{\"883\":1}}],[\"多态的定义\",{\"0\":{\"881\":1}}],[\"多态的定义和原理\",{\"0\":{\"880\":1}}],[\"多态性可以简单地概括为\",{\"1\":{\"881\":1}}],[\"多态性是面向对象的精髓\",{\"1\":{\"881\":1}}],[\"多态性是面向对象编程的一个重要特性\",{\"1\":{\"494\":1}}],[\"多态性\",{\"1\":{\"881\":1}}],[\"多态\",{\"0\":{\"1933\":1},\"1\":{\"448\":1},\"2\":{\"879\":1,\"888\":1,\"893\":1,\"896\":1,\"910\":1,\"918\":1,\"929\":1,\"945\":1,\"951\":1,\"961\":1}}],[\"多加了\",{\"1\":{\"136\":1}}],[\"多数元素是指在数组中出现次数\",{\"1\":{\"113\":1}}],[\"一开始就删主库的东西\",{\"1\":{\"1830\":1}}],[\"一开始就指向第二个\",{\"1\":{\"1099\":1}}],[\"一主多从场景\",{\"1\":{\"1791\":1}}],[\"一主多从\",{\"1\":{\"1791\":1}}],[\"一主一从\",{\"1\":{\"1791\":1}}],[\"一部分由数据备份完成\",{\"1\":{\"1775\":1}}],[\"一部分的关系\",{\"1\":{\"682\":1}}],[\"一致性哈希\",{\"1\":{\"1886\":1}}],[\"一致性以及并发的效率\",{\"1\":{\"1712\":1}}],[\"一致性和并发的效率\",{\"1\":{\"1711\":1}}],[\"一致性则是通过持久性+原子性+隔离性来保证\",{\"1\":{\"1645\":1}}],[\"一致性\",{\"1\":{\"1644\":1,\"1757\":1}}],[\"一句sql执行完就自动提交了\",{\"1\":{\"1640\":1}}],[\"一些\",{\"1\":{\"1626\":1}}],[\"一行行的搜索\",{\"1\":{\"1623\":1}}],[\"一张表的一次sql查询只能用一个索引\",{\"1\":{\"1610\":1}}],[\"一张表需要存储的有表结构\",{\"1\":{\"1557\":1}}],[\"一断电或重启mysql服务器就没了\",{\"1\":{\"1601\":1}}],[\"一下就查询到客户的所有信息\",{\"1\":{\"1511\":1}}],[\"一对一\",{\"0\":{\"1415\":1}}],[\"一对多和多对多的关系\",{\"1\":{\"1451\":1}}],[\"一对多\",{\"0\":{\"1416\":1},\"1\":{\"22\":1,\"1465\":1}}],[\"一组可变参数个数\",{\"1\":{\"1158\":1}}],[\"一组数据\",{\"1\":{\"871\":1}}],[\"一级空间配置器的实现\",{\"1\":{\"1080\":1}}],[\"一级空间配置器\",{\"0\":{\"1080\":1}}],[\"一级空间配置器内存管理类\",{\"1\":{\"1079\":1}}],[\"一元函数对象的升级\",{\"1\":{\"1195\":1}}],[\"一元函数对象\",{\"1\":{\"1008\":1,\"1148\":3}}],[\"一定要考虑迭代器失效问题\",{\"1\":{\"965\":1,\"969\":1,\"970\":1}}],[\"一定要看到模板定义的地方\",{\"1\":{\"363\":1}}],[\"一\",{\"0\":{\"964\":1,\"978\":1,\"989\":1,\"998\":1,\"1007\":1,\"1656\":1,\"1669\":1,\"1677\":1,\"1686\":1,\"1712\":1,\"1728\":1,\"1744\":1,\"1758\":1,\"1767\":1,\"1796\":1,\"1818\":1,\"1885\":1,\"1896\":1,\"1913\":1}}],[\"一类产品\",{\"1\":{\"867\":1}}],[\"一次扫描算法\",{\"1\":{\"1736\":1}}],[\"一次磁盘io读取的数据放在一个节点上\",{\"1\":{\"1622\":1}}],[\"一次插入多条\",{\"0\":{\"1476\":1}}],[\"一次提取一行数据q\",{\"1\":{\"1377\":1}}],[\"一次性取出满足条件的所有字段\",{\"1\":{\"1736\":1}}],[\"一次性提取所有数据\",{\"1\":{\"1377\":1}}],[\"一次性将log4cpp中的实体全部引出来\",{\"1\":{\"1031\":1}}],[\"一次从容器中拿出一个元素和70进行比较\",{\"1\":{\"1148\":1}}],[\"一次\",{\"1\":{\"1102\":1}}],[\"一次遍历\",{\"0\":{\"803\":1}}],[\"一次只引出一个实体\",{\"1\":{\"594\":1}}],[\"一圈\",{\"1\":{\"765\":1}}],[\"一种是哈希索引\",{\"1\":{\"1623\":1}}],[\"一种是allocator<\",{\"1\":{\"1079\":1}}],[\"一种的b\",{\"1\":{\"1623\":1}}],[\"一种的关系\",{\"1\":{\"682\":1}}],[\"一种特殊的函数可用\",{\"1\":{\"362\":1}}],[\"一是使用整型的返回值标识错误\",{\"1\":{\"598\":1}}],[\"一样没有影响\",{\"1\":{\"594\":1}}],[\"一台电脑都没有购买\",{\"1\":{\"439\":1}}],[\"一直跟这个事务启动时看到的数据是一致的\",{\"1\":{\"1717\":1}}],[\"一直进行扩容\",{\"1\":{\"966\":1}}],[\"一直到程序结束\",{\"1\":{\"435\":1}}],[\"一直是高级语言中的第一\",{\"1\":{\"304\":1}}],[\"一经初始化\",{\"1\":{\"432\":1}}],[\"一律用\",{\"1\":{\"312\":1}}],[\"一旦这里面相关的代码有变动\",{\"1\":{\"826\":1}}],[\"一旦绑定到某个变量之后\",{\"1\":{\"612\":1}}],[\"一旦有异常抛出就会被后面的\",{\"1\":{\"599\":1}}],[\"一旦你的\",{\"1\":{\"303\":1}}],[\"一旦程序停止在断点或你指定的位置\",{\"1\":{\"261\":1}}],[\"一般是表中的字段较多\",{\"1\":{\"1889\":1}}],[\"一般是针对几百列的这种大表\",{\"1\":{\"1889\":1}}],[\"一般连接池和服务器程序是部署在一台主机上的\",{\"1\":{\"1865\":1}}],[\"一般都是主从配置以后\",{\"1\":{\"1830\":1}}],[\"一般我们不会做这样的操作\",{\"1\":{\"1830\":1}}],[\"一般我们业务上如果要考虑到事务处理\",{\"1\":{\"1640\":1}}],[\"一般mysql\",{\"1\":{\"1799\":1}}],[\"一般要通过数据库集群的主从复制机制来数据\",{\"1\":{\"1779\":1}}],[\"一般分页查询时\",{\"1\":{\"1740\":1}}],[\"一般数据库引擎默认工作在事务的中间两个隔离级别\",{\"1\":{\"1677\":1}}],[\"一般不会用\",{\"1\":{\"1631\":1}}],[\"一般不建议进行扩展\",{\"1\":{\"594\":1}}],[\"一般过滤条件的字段需要加索引\",{\"1\":{\"1586\":1}}],[\"一般满足范式三即可\",{\"1\":{\"1535\":1}}],[\"一般一个表的数据不会超过千万级\",{\"1\":{\"1481\":1}}],[\"一般放到服务层实现\",{\"1\":{\"1415\":1}}],[\"一般给0\",{\"1\":{\"1374\":1}}],[\"一般用的比较少\",{\"1\":{\"1076\":1}}],[\"一般用于\",{\"1\":{\"141\":1}}],[\"一般将\",{\"1\":{\"730\":1}}],[\"一般将单目运算符和复合运算符\",{\"1\":{\"730\":1}}],[\"一般地\",{\"1\":{\"504\":1}}],[\"一般建议先写出const版本的成员函数\",{\"1\":{\"440\":1}}],[\"一般先写const版本的\",{\"1\":{\"440\":1}}],[\"一般来说\",{\"1\":{\"363\":1,\"435\":1,\"454\":1,\"652\":1,\"946\":1,\"1313\":1,\"1652\":1}}],[\"一般为null\",{\"1\":{\"1374\":1}}],[\"一般为\",{\"1\":{\"312\":1}}],[\"一般选第一个元素\",{\"1\":{\"220\":1}}],[\"一个数组以左中括号\",{\"1\":{\"1899\":1}}],[\"一个对象以左括号\",{\"1\":{\"1899\":1}}],[\"一个对象池\",{\"1\":{\"750\":1}}],[\"一个mysql\",{\"1\":{\"1767\":1}}],[\"一个常见又非常头疼的问题就是\",{\"1\":{\"1740\":1}}],[\"一个事务commit成功通常涉及以下几个关键步骤\",{\"1\":{\"1762\":1}}],[\"一个事务对数据对象a加了\",{\"1\":{\"1697\":2}}],[\"一个事务去访问记录的时候\",{\"1\":{\"1656\":1}}],[\"一个事务是由一条或者多条对数据库操作的sql语句所组成的一个不可分割的单元\",{\"1\":{\"1649\":1}}],[\"一个事务的操作导致另一个事务前后\",{\"1\":{\"1639\":1}}],[\"一个事务的操作导致另一个事务\",{\"1\":{\"1639\":1}}],[\"一个节点对应一个磁盘io\",{\"1\":{\"1626\":1}}],[\"一个需要union操作或者含有子查询的select\",{\"1\":{\"1618\":1}}],[\"一个桶里面的节点代表1次磁盘i\",{\"1\":{\"1603\":1}}],[\"一个分区可以包含一个或多个桶\",{\"1\":{\"1569\":1}}],[\"一个课又有多个学生\",{\"1\":{\"1537\":1}}],[\"一个学生有多门课\",{\"1\":{\"1537\":1}}],[\"一个或多个\",{\"1\":{\"1521\":1}}],[\"一个字节\",{\"1\":{\"1347\":1}}],[\"一个命令便将我们项目想编译的可执行文件\",{\"1\":{\"1303\":1}}],[\"一个线程对共享变量的改变马上就可以反映到另外一个线程里面了\",{\"1\":{\"1233\":1}}],[\"一个线程对共享变量的改变\",{\"1\":{\"1233\":1}}],[\"一个进程中\",{\"1\":{\"1233\":1}}],[\"一个是指向修改前的数据的指针\",{\"1\":{\"1681\":1}}],[\"一个是事务id\",{\"1\":{\"1681\":1}}],[\"一个是读取索引文件到内存上构建b树的磁盘io\",{\"1\":{\"1623\":1}}],[\"一个是持有类成员方法\",{\"1\":{\"1158\":1}}],[\"一个是持有普通函数\",{\"1\":{\"1158\":1}}],[\"一个是继承基类的\",{\"1\":{\"938\":1}}],[\"一个appender也可以被多个category加载\",{\"1\":{\"1019\":1}}],[\"一个寄存器\",{\"1\":{\"954\":1}}],[\"一个接口\",{\"1\":{\"881\":1}}],[\"一个类有虚函数\",{\"1\":{\"933\":1}}],[\"一个类里面\",{\"1\":{\"915\":1}}],[\"一个类里面定义了虚函数\",{\"1\":{\"915\":2}}],[\"一个类型定义的\",{\"1\":{\"915\":1}}],[\"一个类的虚函数表就确定了\",{\"1\":{\"915\":1}}],[\"一个类可以包含纯虚函数\",{\"1\":{\"900\":1}}],[\"一个类\",{\"1\":{\"894\":1}}],[\"一个类只有一个实例\",{\"1\":{\"837\":1}}],[\"一个类包含一个空类对象数据成员\",{\"1\":{\"470\":1}}],[\"一个链表存放小\",{\"1\":{\"795\":1}}],[\"一个小于偶数值1的数字\",{\"0\":{\"743\":1}}],[\"一个个写成友元函数麻烦\",{\"1\":{\"723\":1}}],[\"一个右值引用变量本身是一个左值\",{\"1\":{\"621\":1}}],[\"一个经典的例子就是交换两个变量的值\",{\"1\":{\"615\":1}}],[\"一个大型的工程往往是由若干个人独立完成的\",{\"1\":{\"582\":1}}],[\"一个东西有多种多样的形态\",{\"0\":{\"564\":1}}],[\"一个函数名可以有多种用途\",{\"1\":{\"560\":1}}],[\"一个bool类型的数据占据的内存空间大小为1\",{\"1\":{\"473\":1}}],[\"一个空的类\",{\"0\":{\"469\":1}}],[\"一个空的队列不会调用\",{\"1\":{\"182\":1}}],[\"一个已经存在的对象初始化一个新对象\",{\"1\":{\"399\":1}}],[\"一个地址所指大小1个字节\",{\"1\":{\"308\":2}}],[\"一个内存地址所代表的永远是1个字节\",{\"1\":{\"308\":1}}],[\"一个就是很直接让你查找目标值的最左或者最右\",{\"1\":{\"95\":1}}],[\"一个指针始终未更新\",{\"1\":{\"87\":1}}],[\"一个指针扫描正数\",{\"1\":{\"87\":1}}],[\"一个页面可以有多个标签\",{\"1\":{\"45\":1}}],[\"一个页面可以有多个分类\",{\"1\":{\"45\":1}}],[\"一层覆盖\",{\"1\":{\"76\":2}}],[\"一层查找\",{\"1\":{\"76\":2}}],[\"一层for\",{\"1\":{\"73\":1}}],[\"重置智能指针析构\",{\"0\":{\"1870\":1}}],[\"重做日志\",{\"1\":{\"1645\":1,\"1677\":1,\"1679\":1}}],[\"重建软链接即可\",{\"1\":{\"1332\":1}}],[\"重要消息\",{\"1\":{\"1318\":1}}],[\"重启mysql服务\",{\"1\":{\"1824\":1}}],[\"重启mysql\",{\"1\":{\"1820\":1}}],[\"重启防护墙\",{\"1\":{\"1818\":1}}],[\"重启服务生效\",{\"1\":{\"1818\":1}}],[\"重启释放资源\",{\"1\":{\"1296\":1}}],[\"重启系统后设置虚拟机窗口为自动适应\",{\"1\":{\"1285\":1}}],[\"重启typora\",{\"1\":{\"61\":1}}],[\"重复的只出现一次\",{\"1\":{\"1002\":2,\"1495\":1}}],[\"重复使用相同的元素\",{\"1\":{\"140\":1}}],[\"重写函数体\",{\"1\":{\"913\":1}}],[\"重写接口\",{\"1\":{\"831\":2,\"901\":1}}],[\"重写关系中\",{\"1\":{\"694\":1}}],[\"重写要求参数列表和返回值相同\",{\"1\":{\"694\":1}}],[\"重写是⽗类和⼦类之间的垂直关系\",{\"1\":{\"694\":1}}],[\"重写就是重写函数体\",{\"1\":{\"693\":1}}],[\"重写指的是在派⽣类中覆盖基类中的同名函数\",{\"1\":{\"693\":1}}],[\"重写\",{\"0\":{\"691\":1,\"693\":1},\"1\":{\"693\":1,\"916\":1}}],[\"重定义的格式要求\",{\"1\":{\"913\":1}}],[\"重定义\",{\"1\":{\"563\":1}}],[\"重载符号\",{\"1\":{\"1154\":1}}],[\"重载函数的对象即函数对象\",{\"1\":{\"978\":1}}],[\"重载函数通常用来命名一组功能相似的函数\",{\"1\":{\"560\":1}}],[\"重载小于操作符\",{\"1\":{\"784\":1}}],[\"重载new和delete运算符实现一个对象池\",{\"0\":{\"750\":1}}],[\"重载为友元\",{\"1\":{\"730\":1}}],[\"重载为成员函数\",{\"1\":{\"730\":1}}],[\"重载的运算符必须\",{\"1\":{\"728\":1}}],[\"重载不能改变\",{\"1\":{\"728\":1}}],[\"重载不能改变运算符的\",{\"1\":{\"728\":1}}],[\"重载不能改变运算符的别\",{\"1\":{\"728\":1}}],[\"重载运算符运算对象\",{\"1\":{\"728\":1}}],[\"重载针对vector有意义\",{\"1\":{\"704\":1}}],[\"重载根据调⽤来选择函数体\",{\"1\":{\"694\":1}}],[\"重载则要求参数列表不同\",{\"1\":{\"694\":1}}],[\"重载是不同函数之间的⽔平关系\",{\"1\":{\"694\":1}}],[\"重载与重写的区别\",{\"0\":{\"694\":1}}],[\"重载\",{\"0\":{\"691\":1,\"692\":1}}],[\"重载lower\",{\"1\":{\"163\":1}}],[\"重新在mysql\",{\"1\":{\"1826\":1}}],[\"重新产生数据快照\",{\"1\":{\"1658\":1}}],[\"重新生成数据快照m\",{\"1\":{\"1656\":1}}],[\"重新编译\",{\"1\":{\"1355\":1,\"1365\":1}}],[\"重新编译库\",{\"1\":{\"1332\":1}}],[\"重新建立新链接\",{\"1\":{\"1332\":1}}],[\"重新获取时间片\",{\"1\":{\"1233\":1}}],[\"重新获得了一个流畅的typora\",{\"1\":{\"66\":1}}],[\"重新选择\",{\"1\":{\"1168\":1}}],[\"重新再次申请\",{\"1\":{\"1102\":1}}],[\"重新给用户分配\",{\"1\":{\"1102\":1}}],[\"重新执行发生缺页中断的那条指令\",{\"1\":{\"290\":1}}],[\"重点在这里\",{\"1\":{\"1050\":1}}],[\"重点\",{\"0\":{\"244\":1}}],[\"重名为typoranewfile\",{\"1\":{\"44\":1}}],[\"重命名为mytyporahotkeyscript\",{\"1\":{\"29\":1}}],[\"指的就是mvcc提供的快照读\",{\"1\":{\"1677\":1}}],[\"指的就是\",{\"1\":{\"1656\":1}}],[\"指的是当前事件在binlog记录的位置\",{\"1\":{\"1773\":1}}],[\"指的是在创建\",{\"1\":{\"1656\":2}}],[\"指的是创建该\",{\"1\":{\"1656\":1}}],[\"指的是表2特有的数据\",{\"1\":{\"1536\":1}}],[\"指的是表1特有的数据\",{\"1\":{\"1536\":1}}],[\"指的是两个表的交集\",{\"1\":{\"1536\":1}}],[\"指的是内存池每个块的大小\",{\"1\":{\"1096\":1}}],[\"指的是程序试图访问数组的越界元素\",{\"1\":{\"531\":1}}],[\"指的是程序在动态分配内存时\",{\"1\":{\"531\":1}}],[\"指的是const修饰的变量所指向的对象是⼀个常量\",{\"1\":{\"489\":1}}],[\"指的是const修饰的变量本身是⼀个常量\",{\"1\":{\"489\":1}}],[\"指的是\",{\"1\":{\"489\":2}}],[\"指的是磁盘上数据的集合\",{\"1\":{\"16\":1}}],[\"指明可执行文件\",{\"1\":{\"1315\":1}}],[\"指明本项目包含子目录\",{\"1\":{\"1315\":1}}],[\"指明要调用的是某个基类的成员函数即可\",{\"1\":{\"652\":1}}],[\"指导编译器怎么做ccomplex类对象的加法操作\",{\"1\":{\"731\":1}}],[\"指针指向临时对象\",{\"1\":{\"1113\":2}}],[\"指针指向的是虚函数\",{\"1\":{\"921\":1}}],[\"指针指向的内存空间已被释放或不再有效\",{\"1\":{\"531\":1}}],[\"指针指向的变量是什么\",{\"1\":{\"487\":1}}],[\"指针访问\",{\"0\":{\"920\":1}}],[\"指针转换成其他类型的指针\",{\"1\":{\"629\":1}}],[\"指针会将实参地址拷贝给形参\",{\"1\":{\"619\":1}}],[\"指针可以有一级指针\",{\"1\":{\"619\":1}}],[\"指针可以不初始化\",{\"1\":{\"619\":1}}],[\"指针是通过某个指针变量指向一个对象\",{\"1\":{\"619\":1}}],[\"指针与引用的异同点\",{\"1\":{\"618\":1}}],[\"指针后\",{\"1\":{\"617\":1}}],[\"指针和动态分配导致的内存回收问题\",{\"1\":{\"608\":1}}],[\"指针的大小\",{\"1\":{\"547\":1}}],[\"指针\",{\"1\":{\"535\":1,\"795\":2}}],[\"指针定义\",{\"1\":{\"535\":1}}],[\"指针定义时未被初始化\",{\"1\":{\"531\":1}}],[\"指针赋值给int\",{\"1\":{\"526\":1}}],[\"指针数组\",{\"0\":{\"493\":1},\"1\":{\"493\":2,\"497\":1}}],[\"指针函数指针\",{\"1\":{\"1188\":1}}],[\"指针函数\",{\"0\":{\"493\":1},\"1\":{\"493\":2,\"497\":1}}],[\"指针结合\",{\"0\":{\"490\":1}}],[\"指针常量\",{\"1\":{\"488\":2,\"497\":1,\"618\":1}}],[\"指针本身是什么\",{\"1\":{\"487\":1}}],[\"指针中存储的是对象所占内存空间的\",{\"1\":{\"455\":1}}],[\"指针名\",{\"1\":{\"455\":1}}],[\"指示队尾的位置\",{\"1\":{\"406\":1}}],[\"指示队头的位置\",{\"1\":{\"406\":1}}],[\"指数也分正负\",{\"1\":{\"339\":1}}],[\"指数部分采用规范化的指数形式\",{\"1\":{\"339\":1}}],[\"指数形式\",{\"1\":{\"338\":1}}],[\"指令角度堆栈调用过程\",{\"1\":{\"1063\":1}}],[\"指令角度理解堆栈调用过程\",{\"0\":{\"231\":1},\"1\":{\"1063\":1}}],[\"指令生成是在编译阶段生成\",{\"1\":{\"1063\":1}}],[\"指令上是call一个寄存器\",{\"1\":{\"959\":1}}],[\"指令上\",{\"1\":{\"622\":1}}],[\"指令和数据\",{\"1\":{\"267\":1}}],[\"指向一把锁的指针\",{\"1\":{\"1212\":1}}],[\"指向返回值是void\",{\"1\":{\"1162\":1}}],[\"指向空闲小内存池的尾地址\",{\"1\":{\"1102\":1}}],[\"指向空闲内存池的首地址\",{\"1\":{\"1102\":1}}],[\"指向第二个chunk地址\",{\"1\":{\"1102\":1}}],[\"指向第一维的一维数组\",{\"1\":{\"968\":1}}],[\"指向第一个结点\",{\"1\":{\"792\":1}}],[\"指向小内存池的首地址\",{\"1\":{\"1102\":1}}],[\"指向小内存池的起始地址\",{\"1\":{\"1093\":1}}],[\"指向待分配的内存首地址\",{\"1\":{\"1102\":1}}],[\"指向待分配出去的内存块\",{\"1\":{\"1099\":1}}],[\"指向malloc的首地址\",{\"1\":{\"1102\":1}}],[\"指向了第二个\",{\"1\":{\"1099\":1}}],[\"指向分配\",{\"1\":{\"1099\":1}}],[\"指向下一个空闲chunk块的起始地址\",{\"1\":{\"1082\":1}}],[\"指向该资源引用计数的类\",{\"1\":{\"1055\":1}}],[\"指向资源的指针\",{\"1\":{\"1055\":1}}],[\"指向的是派生类对象\",{\"1\":{\"954\":1}}],[\"指向的时候\",{\"1\":{\"948\":1}}],[\"指向虚基类表\",{\"1\":{\"937\":1}}],[\"指向运行时rtti信息与虚函数地址\",{\"1\":{\"933\":1}}],[\"指向vftable\",{\"1\":{\"933\":1}}],[\"指向相应类型的虚函数表vftable\",{\"1\":{\"915\":1}}],[\"指向派生类对象\",{\"1\":{\"883\":1,\"901\":1,\"906\":1}}],[\"指向为委托类的对象\",{\"1\":{\"830\":1}}],[\"指向头结点\",{\"1\":{\"765\":1}}],[\"指向对象池首个元素的指针\",{\"1\":{\"751\":1}}],[\"指向对象的指针\",{\"0\":{\"455\":1}}],[\"指向当前函数第一行指令\",{\"1\":{\"908\":1}}],[\"指向当前对象容器的指针\",{\"1\":{\"747\":1}}],[\"指向当前的内存块\",{\"1\":{\"286\":1}}],[\"指向原对象\",{\"1\":{\"633\":1}}],[\"指向\",{\"0\":{\"948\":1},\"1\":{\"497\":4}}],[\"指向函数的指针\",{\"1\":{\"493\":1}}],[\"指向const\",{\"1\":{\"490\":1}}],[\"指向int指针的指针\",{\"1\":{\"490\":1}}],[\"指向静态成员方法的指针\",{\"0\":{\"415\":1}}],[\"指向成员方法的指针\",{\"1\":{\"414\":1}}],[\"指向普通成员方法的指针\",{\"0\":{\"414\":1}}],[\"指向类型成员的指针\",{\"0\":{\"409\":1}}],[\"指向堆内存的指针\",{\"1\":{\"397\":1,\"464\":1}}],[\"指向数组有效空间最后一个元素的后继\",{\"1\":{\"1127\":1}}],[\"指向数组的首元素的地址\",{\"1\":{\"1127\":1}}],[\"指向数组的指针\",{\"1\":{\"493\":1}}],[\"指向数组空间的后继位置\",{\"1\":{\"355\":1,\"385\":1,\"704\":1}}],[\"指向数据最后一个有效元素的后继\",{\"1\":{\"1127\":1}}],[\"指向数据段的最高地址\",{\"1\":{\"283\":1}}],[\"指向数据域\",{\"1\":{\"224\":1}}],[\"指向最后一个有效元素后继位置\",{\"1\":{\"355\":1,\"385\":1,\"704\":1}}],[\"指向栈顶\",{\"1\":{\"224\":1}}],[\"指定master的ip\",{\"1\":{\"1825\":1}}],[\"指定makefile文件\",{\"0\":{\"1363\":1}}],[\"指定查看某个时间段内的更改\",{\"1\":{\"1773\":1}}],[\"指定查看某个库的更改\",{\"1\":{\"1773\":1}}],[\"指定的目录\",{\"1\":{\"1915\":1}}],[\"指定的目录中写入日志文件\",{\"1\":{\"1770\":1}}],[\"指定的数\",{\"1\":{\"556\":1}}],[\"指定的数值和这个数据成员自身长度中\",{\"1\":{\"555\":1}}],[\"指定加密方式\",{\"1\":{\"1447\":1}}],[\"指定源文件生成一个可执行程序\",{\"0\":{\"1365\":1},\"1\":{\"1365\":1}}],[\"指定如何解析和显示内存内容\",{\"1\":{\"1347\":1}}],[\"指定库文件搜索路径\",{\"1\":{\"1328\":1}}],[\"指定头文件搜索路径\",{\"1\":{\"1328\":1}}],[\"指定搜索的子目录\",{\"1\":{\"1316\":2}}],[\"指定搜索的子目录为要参与构建的项目\",{\"1\":{\"1309\":1}}],[\"指定运行此配置文件所需的\",{\"1\":{\"1312\":1}}],[\"指定项目名称\",{\"1\":{\"1310\":1}}],[\"指定了call\",{\"1\":{\"953\":1}}],[\"指定内存上构造val\",{\"1\":{\"385\":1,\"704\":1,\"1080\":1,\"1087\":1}}],[\"指定输出为\",{\"1\":{\"227\":1}}],[\"指定右键新建的\",{\"1\":{\"44\":1}}],[\"指定\",{\"1\":{\"44\":1}}],[\"并有效地提升网络传输效率\",{\"1\":{\"1896\":1}}],[\"并检测是否可以相互通信\",{\"1\":{\"1818\":1}}],[\"并检查数据完整性\",{\"1\":{\"1548\":1}}],[\"并执行其中的事件更新slave的数据\",{\"1\":{\"1784\":1}}],[\"并写到中继日志relay\",{\"1\":{\"1783\":1}}],[\"并创建表\",{\"1\":{\"1774\":1}}],[\"并默认在参数data\",{\"1\":{\"1770\":1}}],[\"并请求共享或排他锁时\",{\"1\":{\"1686\":1}}],[\"并2个开启事务\",{\"1\":{\"1663\":1}}],[\"并用这个快照来提供一定级别\",{\"1\":{\"1656\":1}}],[\"并发连接数量和超时时间\",{\"0\":{\"1754\":1}}],[\"并发能力更好\",{\"1\":{\"1713\":1}}],[\"并发度高\",{\"1\":{\"1713\":1}}],[\"并发度低\",{\"1\":{\"1713\":1}}],[\"并发的效率就太低了\",{\"1\":{\"1712\":1}}],[\"并发执行为了同时保证数据的安全性\",{\"1\":{\"1711\":1}}],[\"并发执行事务时通常会发生以下问题\",{\"1\":{\"1639\":1}}],[\"并发性越低\",{\"1\":{\"1644\":1,\"1645\":1}}],[\"并设置为主键\",{\"1\":{\"1552\":1}}],[\"并同时将其类型改为smallint\",{\"1\":{\"1552\":1}}],[\"并按照营业额进行倒序排序\",{\"1\":{\"1531\":1}}],[\"并想以超级用户权限保存它时\",{\"1\":{\"1410\":1}}],[\"并把它存放到一个行结构中\",{\"1\":{\"1379\":1}}],[\"并把快捷方式放入\",{\"1\":{\"27\":1}}],[\"并以汇编指令格式显示\",{\"1\":{\"1348\":1}}],[\"并以十六进制显示\",{\"1\":{\"1348\":1}}],[\"并使用\",{\"1\":{\"1335\":1}}],[\"并使用不同的函数实现来实现多态性的效果\",{\"1\":{\"494\":1}}],[\"并让\",{\"1\":{\"1102\":1}}],[\"并挂在\",{\"1\":{\"1099\":1}}],[\"并填写剩下所有\",{\"1\":{\"1099\":1}}],[\"并\",{\"1\":{\"1093\":1}}],[\"并未添加元素\",{\"1\":{\"973\":1,\"974\":1}}],[\"并没有看见查询user表的sql\",{\"1\":{\"1812\":1}}],[\"并没有解决幻读的问题\",{\"1\":{\"1635\":1}}],[\"并没有linux下面的功能强大\",{\"1\":{\"1410\":1}}],[\"并没有为我们容器添加元素\",{\"1\":{\"966\":1}}],[\"并没有直接加载到物理内存\",{\"1\":{\"263\":1}}],[\"并对虚函数进行了重定义\",{\"1\":{\"913\":1}}],[\"并返回\",{\"1\":{\"1102\":1}}],[\"并返回反转后的链表\",{\"1\":{\"777\":1}}],[\"并返回它们的数组下标\",{\"1\":{\"124\":1}}],[\"并将结果返回\",{\"1\":{\"1299\":1}}],[\"并将其复制到桌面\",{\"1\":{\"1285\":1}}],[\"并将实参变量的值拷贝给形参变量\",{\"1\":{\"615\":1}}],[\"并将出栈内容赋值给ebp\",{\"1\":{\"238\":1}}],[\"并交给\",{\"1\":{\"599\":1}}],[\"并初始化\",{\"1\":{\"515\":1}}],[\"并给上元素个数\",{\"1\":{\"513\":1,\"708\":1}}],[\"并在一个或多个派生类中被重新定义的成员函数\",{\"1\":{\"912\":1}}],[\"并在\",{\"1\":{\"484\":1}}],[\"并在map中寻找是否有匹配的key\",{\"1\":{\"125\":1}}],[\"并不去释放connection\",{\"1\":{\"1865\":1}}],[\"并不需要等commit的时候才开始\",{\"1\":{\"1760\":1}}],[\"并不需要我们自己写抛出异常\",{\"1\":{\"605\":1}}],[\"并不能完全解决幻读\",{\"1\":{\"1665\":1}}],[\"并不能为我们减少磁盘i\",{\"1\":{\"1603\":1}}],[\"并不代表事务启动了\",{\"1\":{\"1656\":1}}],[\"并不依赖于主键学号\",{\"1\":{\"1462\":1}}],[\"并不知道是否开辟了5个test对象的数组\",{\"1\":{\"715\":1}}],[\"并不意味着其可见域是全局的\",{\"1\":{\"586\":1}}],[\"并不一定会导致编译错误\",{\"1\":{\"578\":1}}],[\"并不检查索引是否有效\",{\"1\":{\"539\":1}}],[\"并不占据对象的存储空间\",{\"1\":{\"435\":1}}],[\"并不是允许从192\",{\"1\":{\"1821\":1}}],[\"并不是把主库的binlog读过来直接执行\",{\"1\":{\"1783\":1}}],[\"并不是事务commit时才记录\",{\"1\":{\"1758\":1}}],[\"并不是完全解决了\",{\"1\":{\"1717\":1}}],[\"并不是说不加锁\",{\"1\":{\"1232\":1}}],[\"并不是说所有资源的释放都是delete指针\",{\"1\":{\"1060\":1}}],[\"并不是有序的\",{\"1\":{\"1147\":1}}],[\"并不是从内存池分配的内存\",{\"1\":{\"1076\":1}}],[\"并不是这个类的成员函数\",{\"1\":{\"876\":1}}],[\"并不是一个对象对应一个单独的成员函数体\",{\"1\":{\"392\":1}}],[\"并不是申请多少字节\",{\"1\":{\"285\":1}}],[\"并查看每步的汇编代码变化\",{\"1\":{\"261\":1}}],[\"并指定\",{\"1\":{\"255\":1}}],[\"并添加相应的条目\",{\"1\":{\"239\":1}}],[\"并为sum函数开辟栈帧\",{\"1\":{\"234\":1}}],[\"并尝试将代码中的地址转换为符号名\",{\"1\":{\"227\":1}}],[\"并且仅从主低到从高之间支持\",{\"1\":{\"1828\":1}}],[\"并且可以相互通信\",{\"1\":{\"1818\":1}}],[\"并且对数据加锁\",{\"1\":{\"1656\":2}}],[\"并且commit\",{\"1\":{\"1639\":2}}],[\"并且支持范围查找\",{\"1\":{\"1622\":1}}],[\"并且数据存放在索引树上\",{\"1\":{\"1558\":1}}],[\"并且检查要安装的软件名是否正确\",{\"1\":{\"1295\":1}}],[\"并且将ubuntu的网络设置设为自动\",{\"1\":{\"1279\":1}}],[\"并且将p2指针指向p1的内存空间\",{\"1\":{\"1043\":1}}],[\"并且要查看开放这些端口的具体进程和用户\",{\"1\":{\"1236\":1}}],[\"并且释放当前锁\",{\"1\":{\"1219\":1}}],[\"并且\",{\"1\":{\"1219\":1}}],[\"并且拷贝完立马就释放了\",{\"1\":{\"1120\":2}}],[\"并且把第一个\",{\"1\":{\"1099\":1}}],[\"并且能够设置类别优先级\",{\"1\":{\"1018\":1}}],[\"并且统计数字重复的次数\",{\"1\":{\"1001\":1}}],[\"并且该虚函数指针位于派生类对象存储空间的\",{\"1\":{\"940\":1}}],[\"并且指定priority\",{\"1\":{\"784\":1}}],[\"并且返回链表的头结点\",{\"1\":{\"774\":1}}],[\"并且仍然指向原来的对象\",{\"1\":{\"630\":2}}],[\"并且在当前\",{\"1\":{\"599\":1}}],[\"并且在该行程序前加上红色双向箭头快速定位\",{\"1\":{\"41\":1}}],[\"并且不会再执行异常点\",{\"1\":{\"599\":1}}],[\"并且维护成本也大\",{\"1\":{\"576\":1}}],[\"并且他用\",{\"1\":{\"301\":1}}],[\"并且这些内存是可以用的\",{\"1\":{\"285\":1}}],[\"并且计数排序只适用于整型排序\",{\"1\":{\"212\":1}}],[\"并且给定的数组总是存在多数元素\",{\"1\":{\"113\":1}}],[\"并且set把数值映射到key都要做hash计算\",{\"1\":{\"104\":1,\"107\":1,\"110\":1}}],[\"并更新left\",{\"1\":{\"78\":1}}],[\"dn2\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"dn1\",{\"1\":{\"1888\":2,\"1891\":3}}],[\"dndebug\",{\"1\":{\"1321\":1}}],[\"dtd\",{\"1\":{\"1888\":1,\"1891\":1}}],[\"dhcp协议\",{\"1\":{\"1796\":1}}],[\"d508ea09b0b44e77a66982dbe8894d08\",{\"1\":{\"1772\":1}}],[\"d76e9880719c4ff181c3b1841cf71a97\",{\"1\":{\"1771\":1}}],[\"dcl\",{\"1\":{\"1548\":1}}],[\"dcl语句小结\",{\"0\":{\"1484\":1}}],[\"dpkg\",{\"1\":{\"1390\":1,\"1397\":10,\"1405\":5}}],[\"d个属性\",{\"1\":{\"1385\":1}}],[\"d条信息\",{\"1\":{\"1385\":1}}],[\"dml\",{\"1\":{\"1548\":1,\"1772\":1}}],[\"dml数据操作语言\",{\"1\":{\"1489\":1}}],[\"dml语句小结\",{\"0\":{\"1489\":1}}],[\"dmydebug=on\",{\"1\":{\"1318\":1}}],[\"dma\",{\"1\":{\"267\":1}}],[\"drop\",{\"1\":{\"1447\":1,\"1485\":1,\"1486\":1,\"1506\":1,\"1507\":2,\"1548\":1,\"1551\":1,\"1552\":3,\"1614\":1}}],[\"drwxr\",{\"1\":{\"1271\":1}}],[\"drwxrwxr\",{\"1\":{\"1271\":4}}],[\"dracula\",{\"1\":{\"1133\":1,\"1291\":1}}],[\"dv\",{\"1\":{\"1261\":2}}],[\"dst\",{\"1\":{\"1238\":1}}],[\"dso\",{\"1\":{\"572\":1}}],[\"durability\",{\"1\":{\"1644\":1}}],[\"dui\",{\"1\":{\"1142\":1}}],[\"dummyhead2\",{\"1\":{\"795\":5}}],[\"dummyhead1\",{\"1\":{\"795\":5}}],[\"dummyhead\",{\"1\":{\"759\":5,\"762\":5,\"774\":6,\"777\":5,\"782\":5,\"783\":5,\"784\":3,\"791\":8,\"798\":3,\"802\":5}}],[\"dump线程会睡眠并等待binlog产生新的事件\",{\"1\":{\"1784\":1}}],[\"dump线程从master的binlog中读取事件并发送给slave的i\",{\"1\":{\"1784\":1}}],[\"dump\",{\"0\":{\"1903\":1},\"1\":{\"234\":4,\"1784\":1,\"1903\":1,\"1907\":1,\"1908\":1,\"1909\":1}}],[\"df\",{\"1\":{\"891\":2}}],[\"dlink\",{\"1\":{\"821\":12}}],[\"dlinkedlistnode\",{\"1\":{\"792\":20}}],[\"dll动态链接库\",{\"1\":{\"1855\":1}}],[\"dll和log4cpp\",{\"1\":{\"1029\":1}}],[\"dll\",{\"1\":{\"267\":2}}],[\"d各初始化与析构一次\",{\"1\":{\"688\":1}}],[\"d这个派生类中调用了两次a的构造\",{\"1\":{\"688\":1}}],[\"d能看见b\",{\"1\":{\"688\":1}}],[\"d也有自己的属性md\",{\"1\":{\"688\":1}}],[\"d也有a的数据\",{\"1\":{\"688\":1}}],[\"d从b与c多继承而来\",{\"1\":{\"688\":1}}],[\"d有两个基类分别为b和c\",{\"1\":{\"688\":1}}],[\"d是b和c多继承而来\",{\"1\":{\"688\":1}}],[\"d3b2c91361144652ae6c23c89c4b300e\",{\"1\":{\"1774\":1}}],[\"d3f5lxplbmhlaq\",{\"1\":{\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1}}],[\"d3\",{\"1\":{\"662\":12}}],[\"d继承b\",{\"1\":{\"653\":1}}],[\"d实例化对象会调用a的构造函数和析构函数\",{\"1\":{\"653\":2}}],[\"d不能直接调用a的成员\",{\"1\":{\"653\":1}}],[\"d的实例化的对象是无法访问b\",{\"1\":{\"647\":1}}],[\"d2de0f6308ee48d4ad209a141295607b\",{\"1\":{\"1658\":1}}],[\"d2\",{\"1\":{\"631\":2,\"662\":6,\"1183\":2}}],[\"d2f8037978a4\",{\"1\":{\"601\":1}}],[\"d1reportsingleclasslayout\",{\"1\":{\"936\":1,\"958\":1}}],[\"d1\",{\"1\":{\"557\":4,\"631\":2,\"662\":18,\"936\":2,\"1183\":2}}],[\"dynamic会检查p指针是否指向的是一个derive2类型的对象\",{\"1\":{\"631\":2}}],[\"dynamic\",{\"0\":{\"631\":1,\"1016\":1},\"1\":{\"604\":1,\"607\":1,\"628\":1,\"631\":1,\"883\":1}}],[\"dy\",{\"1\":{\"372\":1}}],[\"dx\",{\"1\":{\"372\":2}}],[\"dbdriver=\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"dbtype=\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"dbcp连接池\",{\"1\":{\"1864\":1}}],[\"dbname=chat\",{\"1\":{\"1844\":1}}],[\"dbname\",{\"1\":{\"1839\":4,\"1846\":1,\"1847\":2,\"1848\":1,\"1849\":4,\"1856\":3,\"1859\":3,\"1875\":5,\"1878\":1}}],[\"dbs\",{\"1\":{\"1836\":1}}],[\"db3\",{\"1\":{\"1836\":1}}],[\"db2\",{\"1\":{\"1836\":1}}],[\"db1\",{\"1\":{\"1836\":1}}],[\"db写数据都是先在cache缓存上写的\",{\"1\":{\"1645\":1}}],[\"dbms保证它对数据库中的数据的修改是永久性的\",{\"1\":{\"1644\":1}}],[\"db\",{\"1\":{\"364\":2,\"368\":2,\"371\":2,\"1374\":2,\"1656\":3,\"1681\":6,\"1682\":2}}],[\"days=7\",{\"1\":{\"1769\":1}}],[\"dadd16147c434974bbb33a909a48ecf0\",{\"1\":{\"1664\":1}}],[\"dai\",{\"1\":{\"1296\":2}}],[\"dailyrollingfileappender\",{\"1\":{\"1019\":1}}],[\"da\",{\"1\":{\"364\":2,\"371\":2}}],[\"datahost>\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"datahost=\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"datasource\",{\"1\":{\"1808\":1}}],[\"datasize\",{\"1\":{\"188\":2}}],[\"datanode=\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"datanode\",{\"1\":{\"1803\":1,\"1808\":1}}],[\"data1\",{\"1\":{\"1729\":1}}],[\"data是主键所在行的数据\",{\"1\":{\"1563\":1}}],[\"datad\",{\"1\":{\"939\":1}}],[\"datac\",{\"1\":{\"939\":1}}],[\"database=\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"database=school\",{\"1\":{\"1773\":1}}],[\"databases\",{\"1\":{\"1506\":1,\"1507\":1,\"1836\":3}}],[\"database\",{\"1\":{\"1447\":3,\"1506\":2,\"1507\":5,\"1508\":1,\"1773\":1,\"1808\":1}}],[\"datab\",{\"1\":{\"939\":1}}],[\"dataa\",{\"1\":{\"939\":1}}],[\"data位置分配内存并初始化\",{\"1\":{\"511\":1}}],[\"data段到内存中\",{\"1\":{\"263\":1}}],[\"data段\",{\"1\":{\"255\":2,\"267\":1}}],[\"data<=>\",{\"1\":{\"255\":1}}],[\"data\",{\"0\":{\"1624\":1},\"1\":{\"60\":3,\"101\":18,\"185\":8,\"205\":3,\"239\":1,\"246\":5,\"251\":1,\"255\":1,\"257\":1,\"262\":1,\"263\":1,\"267\":2,\"281\":1,\"388\":8,\"405\":16,\"422\":2,\"446\":1,\"511\":2,\"517\":1,\"538\":1,\"600\":1,\"667\":8,\"688\":25,\"714\":2,\"751\":5,\"810\":5,\"817\":8,\"819\":7,\"821\":7,\"919\":5,\"948\":12,\"953\":5,\"954\":5,\"1082\":1,\"1115\":2,\"1183\":9,\"1443\":1,\"1548\":3,\"1719\":1,\"1720\":1,\"1729\":1,\"1736\":2,\"1774\":2,\"1775\":2}}],[\"datetime\",{\"1\":{\"1773\":2,\"1774\":2}}],[\"datetime=\",{\"1\":{\"1773\":2,\"1774\":2}}],[\"date\",{\"1\":{\"45\":1,\"1443\":2,\"1531\":3,\"1537\":2,\"1552\":1}}],[\"d=10\",{\"1\":{\"267\":1}}],[\"dword\",{\"1\":{\"234\":12,\"236\":5,\"238\":1,\"267\":2,\"638\":3,\"906\":2,\"954\":2}}],[\"d或\",{\"1\":{\"228\":1}}],[\"d8bc6e4874094de4849792b5a05963c0\",{\"1\":{\"81\":1}}],[\"dictionary\",{\"1\":{\"1407\":2}}],[\"distinct\",{\"0\":{\"1512\":1},\"1\":{\"1495\":1,\"1496\":3,\"1512\":1,\"1514\":1,\"1544\":2}}],[\"distutils\",{\"0\":{\"1293\":1},\"1\":{\"1293\":1}}],[\"distrib\",{\"1\":{\"1285\":1}}],[\"distance\",{\"1\":{\"722\":4}}],[\"dispatch\",{\"1\":{\"871\":2}}],[\"disp\",{\"1\":{\"389\":5}}],[\"display\",{\"0\":{\"1341\":1},\"1\":{\"378\":7,\"585\":1,\"589\":3,\"590\":3,\"592\":5,\"594\":2,\"898\":7,\"913\":4,\"1341\":3,\"1342\":1,\"1343\":1,\"1344\":1,\"1345\":1,\"1346\":1}}],[\"disaster\",{\"1\":{\"1102\":1}}],[\"disas\",{\"1\":{\"261\":3}}],[\"disassembly\",{\"1\":{\"234\":1,\"244\":2,\"261\":1}}],[\"disassemble\",{\"1\":{\"228\":1,\"234\":3,\"261\":3}}],[\"disable\",{\"1\":{\"63\":1,\"1818\":1}}],[\"dimensions\",{\"1\":{\"271\":2}}],[\"dir下\",{\"1\":{\"1772\":1,\"1776\":1}}],[\"dir指定的目录下的两个文件\",{\"1\":{\"1758\":1}}],[\"dirty\",{\"1\":{\"1639\":1}}],[\"dir是\",{\"1\":{\"1316\":1}}],[\"directories\",{\"1\":{\"1314\":1,\"1315\":1,\"1316\":2}}],[\"directories指定头文件\",{\"0\":{\"1314\":1}}],[\"directory指定源文件\",{\"0\":{\"1314\":1}}],[\"directory也存在弊端\",{\"1\":{\"1312\":1}}],[\"directory自动会查找指定目录下的所有源文件\",{\"1\":{\"1312\":1}}],[\"directory\",{\"1\":{\"234\":1,\"312\":1,\"1299\":1,\"1312\":2,\"1314\":3,\"1315\":3,\"1316\":3,\"1317\":1}}],[\"directoryexists\",{\"1\":{\"60\":3}}],[\"dir+\",{\"1\":{\"60\":1}}],[\"dirs\",{\"1\":{\"60\":1}}],[\"dir\",{\"1\":{\"60\":5,\"1272\":2,\"1310\":4,\"1312\":4,\"1314\":6,\"1315\":6,\"1316\":11,\"1317\":3,\"1318\":1,\"1769\":1,\"1770\":1,\"1915\":1}}],[\"divide\",{\"1\":{\"202\":1}}],[\"div\",{\"1\":{\"53\":7,\"54\":4,\"59\":11,\"191\":6}}],[\"done\",{\"1\":{\"1207\":1,\"1362\":2,\"1366\":1}}],[\"dologinout\",{\"1\":{\"1168\":2}}],[\"doquerybooks\",{\"1\":{\"1168\":2}}],[\"doback\",{\"1\":{\"1168\":2}}],[\"doborrow\",{\"1\":{\"1168\":2}}],[\"does\",{\"0\":{\"1016\":1,\"1407\":1},\"1\":{\"1407\":1}}],[\"domain\",{\"1\":{\"604\":1}}],[\"dog的vfptr存放cat的vftable地址\",{\"1\":{\"905\":1}}],[\"dogspeak\",{\"1\":{\"494\":2}}],[\"dog\",{\"1\":{\"494\":8,\"886\":11,\"905\":3}}],[\"doublelink\",{\"1\":{\"821\":3}}],[\"double等内置类型同等位置上\",{\"1\":{\"536\":1}}],[\"double的阶码为11位\",{\"1\":{\"339\":1}}],[\"double\",{\"1\":{\"296\":1,\"337\":1,\"340\":1,\"365\":2,\"370\":3,\"371\":1,\"372\":2,\"397\":3,\"426\":4,\"435\":4,\"439\":3,\"464\":3,\"497\":1,\"557\":3,\"563\":7,\"588\":1,\"599\":1,\"601\":4,\"602\":3,\"632\":1,\"692\":2,\"751\":1,\"884\":4,\"898\":17,\"900\":10,\"1423\":1}}],[\"doshowallbooks\",{\"1\":{\"1168\":2}}],[\"dosomething\",{\"1\":{\"273\":2,\"274\":1,\"275\":1,\"276\":1}}],[\"dosinglepicclean\",{\"1\":{\"60\":2}}],[\"do\",{\"0\":{\"270\":1,\"275\":1},\"1\":{\"271\":1,\"275\":1,\"276\":1,\"277\":5,\"296\":1,\"1102\":2,\"1362\":2,\"1366\":1,\"1523\":1},\"2\":{\"279\":1}}],[\"doctype\",{\"1\":{\"1888\":1,\"1891\":1}}],[\"doclean\",{\"1\":{\"60\":3}}],[\"document\",{\"1\":{\"53\":1,\"54\":5,\"59\":20}}],[\"downloads\",{\"1\":{\"1395\":1,\"1799\":1}}],[\"download\",{\"1\":{\"1015\":1,\"1251\":2,\"1305\":1,\"1395\":1}}],[\"down\",{\"1\":{\"29\":2}}],[\"d\",{\"0\":{\"228\":1},\"1\":{\"52\":1,\"227\":2,\"228\":1,\"234\":1,\"239\":1,\"267\":1,\"293\":1,\"323\":2,\"422\":7,\"470\":2,\"483\":3,\"484\":9,\"500\":5,\"535\":1,\"557\":4,\"570\":1,\"575\":1,\"576\":3,\"601\":1,\"602\":1,\"621\":2,\"640\":2,\"647\":2,\"649\":3,\"650\":3,\"652\":7,\"653\":10,\"667\":1,\"669\":1,\"670\":1,\"672\":1,\"688\":10,\"889\":7,\"890\":4,\"891\":14,\"920\":5,\"922\":1,\"923\":2,\"939\":1,\"953\":2,\"954\":2,\"1019\":1,\"1021\":5,\"1026\":4,\"1031\":4,\"1032\":6,\"1238\":1,\"1245\":1,\"1261\":1,\"1347\":1,\"1356\":1,\"1384\":2,\"1408\":1,\"1410\":1,\"1443\":1,\"1555\":1,\"1757\":1,\"1769\":1,\"1820\":2,\"1836\":2,\"1851\":2,\"1856\":1,\"1878\":1}}],[\"deadlock\",{\"1\":{\"1706\":1}}],[\"deallocate\",{\"1\":{\"385\":4,\"704\":4,\"964\":1,\"1076\":1,\"1080\":4,\"1087\":1,\"1093\":2,\"1127\":3}}],[\"deﬁnition\",{\"1\":{\"1548\":1}}],[\"delimiter\",{\"1\":{\"1523\":2}}],[\"delete删除\",{\"0\":{\"1480\":1}}],[\"deleter\",{\"1\":{\"1060\":1}}],[\"delete就得加个中括号\",{\"1\":{\"1060\":1}}],[\"delete调用析构函数的时候\",{\"1\":{\"948\":1}}],[\"deleteinstance\",{\"1\":{\"848\":2,\"851\":2}}],[\"deleteatindex\",{\"1\":{\"790\":1,\"791\":1,\"792\":1}}],[\"delete时先调用析构函数\",{\"1\":{\"715\":1}}],[\"delete释放内存空间\",{\"1\":{\"711\":1}}],[\"delete与free区别\",{\"0\":{\"708\":1}}],[\"delete运算符\",{\"1\":{\"685\":1}}],[\"delete只是malloc和free的一层封装\",{\"1\":{\"519\":1}}],[\"delete表达式\",{\"1\":{\"519\":1}}],[\"delete表达式也不是直接去释放掉内存\",{\"1\":{\"518\":1}}],[\"delete表达式与malloc\",{\"0\":{\"513\":1}}],[\"delete真正的实现其实是依赖下面这几个内存管理接口的\",{\"1\":{\"518\":1}}],[\"delete的实现\",{\"0\":{\"711\":1}}],[\"delete的组合\",{\"0\":{\"522\":1}}],[\"delete的表达式与标准库函数同名了\",{\"1\":{\"518\":1}}],[\"delete的功能完全覆盖了malloc\",{\"0\":{\"514\":1}}],[\"delete是c++中的表达式\",{\"1\":{\"515\":1}}],[\"delete异同点\",{\"1\":{\"515\":1}}],[\"delete关键字\",{\"0\":{\"509\":1},\"1\":{\"707\":1,\"750\":1}}],[\"delete\",{\"0\":{\"518\":2,\"519\":1,\"521\":2,\"523\":2},\"1\":{\"101\":2,\"185\":1,\"224\":2,\"240\":1,\"355\":3,\"385\":3,\"388\":1,\"405\":2,\"406\":5,\"412\":1,\"426\":1,\"459\":3,\"464\":1,\"509\":2,\"510\":1,\"512\":1,\"515\":2,\"516\":2,\"517\":4,\"518\":4,\"519\":5,\"520\":1,\"521\":1,\"522\":2,\"523\":2,\"524\":3,\"548\":2,\"618\":1,\"662\":7,\"699\":2,\"704\":3,\"707\":1,\"709\":3,\"711\":6,\"713\":2,\"714\":5,\"715\":1,\"736\":6,\"747\":1,\"750\":1,\"751\":3,\"759\":2,\"762\":1,\"774\":3,\"782\":1,\"783\":1,\"791\":1,\"792\":1,\"795\":2,\"802\":1,\"810\":2,\"817\":5,\"819\":3,\"821\":2,\"826\":1,\"830\":2,\"848\":1,\"850\":2,\"851\":1,\"854\":4,\"855\":1,\"856\":2,\"857\":2,\"864\":3,\"905\":2,\"906\":1,\"907\":2,\"908\":2,\"948\":3,\"949\":3,\"1032\":2,\"1040\":1,\"1041\":2,\"1050\":1,\"1055\":2,\"1060\":2,\"1114\":2,\"1120\":2,\"1121\":1,\"1122\":1,\"1123\":5,\"1151\":1,\"1340\":2,\"1384\":1,\"1480\":3,\"1485\":1,\"1486\":1,\"1491\":2,\"1548\":1,\"1656\":1,\"1665\":1,\"1688\":1,\"1772\":1,\"1846\":1,\"1847\":1,\"1849\":2,\"1856\":2,\"1859\":1},\"2\":{\"720\":1,\"753\":1}}],[\"desc\",{\"1\":{\"1496\":1,\"1525\":1,\"1531\":1,\"1538\":2,\"1551\":1,\"1552\":1,\"1614\":1}}],[\"dest\",{\"1\":{\"535\":4,\"538\":1}}],[\"destruction\",{\"1\":{\"572\":1}}],[\"destructor\",{\"1\":{\"424\":1}}],[\"destroy\",{\"1\":{\"385\":4,\"704\":4,\"747\":4,\"854\":1,\"856\":2,\"857\":2,\"964\":1,\"1032\":3,\"1080\":2,\"1086\":4,\"1087\":2,\"1127\":4}}],[\"destory\",{\"1\":{\"385\":1,\"704\":1,\"1032\":1}}],[\"destpath\",{\"1\":{\"60\":2}}],[\"devour\",{\"1\":{\"1878\":1}}],[\"dev\",{\"1\":{\"1318\":1,\"1371\":1,\"1397\":2,\"1399\":1}}],[\"demo6\",{\"1\":{\"1318\":1}}],[\"demo5\",{\"1\":{\"1317\":1}}],[\"demo4\",{\"1\":{\"1316\":1}}],[\"demo3\",{\"1\":{\"1314\":1,\"1315\":1}}],[\"demo\",{\"1\":{\"1312\":2,\"1314\":1,\"1315\":3,\"1316\":2,\"1317\":1}}],[\"demo2\",{\"1\":{\"1312\":2}}],[\"demo1\",{\"1\":{\"1312\":3}}],[\"deps\",{\"1\":{\"1367\":2}}],[\"depends\",{\"1\":{\"1312\":1}}],[\"depends选项\",{\"1\":{\"1312\":1}}],[\"depth=1\",{\"1\":{\"1132\":1,\"1290\":1}}],[\"debit\",{\"1\":{\"1428\":1}}],[\"deb\",{\"1\":{\"1284\":8,\"1395\":2,\"1396\":1,\"1397\":10}}],[\"debugger\",{\"1\":{\"1341\":1}}],[\"debug\",{\"1\":{\"1018\":1,\"1020\":1,\"1025\":3,\"1032\":13,\"1310\":3,\"1318\":2,\"1849\":2,\"1875\":2}}],[\"debug定位小技巧\",{\"1\":{\"547\":1}}],[\"debug版本\",{\"1\":{\"502\":1}}],[\"details\",{\"1\":{\"1878\":1}}],[\"detach\",{\"1\":{\"1050\":1,\"1206\":1,\"1207\":2,\"1849\":2,\"1859\":3}}],[\"detach是使主线程不用等待子线程可以继续往下执行\",{\"1\":{\"1050\":1}}],[\"detectcycle\",{\"1\":{\"768\":1}}],[\"derive\",{\"1\":{\"667\":7,\"906\":3,\"907\":7,\"908\":7,\"919\":3,\"920\":4,\"923\":2,\"948\":9,\"953\":5,\"954\":5,\"956\":1}}],[\"derive02func\",{\"1\":{\"631\":2}}],[\"derive实现了一个新功能的api接口函数\",{\"1\":{\"631\":1}}],[\"derive2实现新功能的api接口函数\",{\"1\":{\"631\":1}}],[\"derive2\",{\"1\":{\"631\":5}}],[\"derive1\",{\"1\":{\"631\":4}}],[\"derived2\",{\"1\":{\"678\":2,\"894\":6}}],[\"derived\",{\"1\":{\"422\":5,\"662\":33,\"669\":8,\"670\":2,\"672\":8,\"678\":18,\"889\":7,\"894\":24,\"898\":2,\"900\":11,\"913\":5,\"949\":4}}],[\"declare\",{\"1\":{\"784\":1,\"1523\":1}}],[\"declared\",{\"1\":{\"516\":1}}],[\"decltype\",{\"1\":{\"784\":3}}],[\"decorator\",{\"1\":{\"831\":1}}],[\"decoration是三个属性的缩写\",{\"1\":{\"50\":1}}],[\"decoration属性来定义段落文本的下划线\",{\"1\":{\"50\":1}}],[\"decoration\",{\"1\":{\"48\":3,\"50\":7,\"51\":1}}],[\"decodeuri\",{\"1\":{\"59\":1}}],[\"dennis\",{\"1\":{\"301\":2}}],[\"deque恰好符合条件\",{\"1\":{\"993\":1}}],[\"deque特点\",{\"1\":{\"973\":1}}],[\"deque底层是动态开辟的二维数组空间\",{\"1\":{\"972\":1,\"973\":1}}],[\"deque底层内存是否是连续的\",{\"0\":{\"972\":1}}],[\"deque容器内存的扩容方式\",{\"1\":{\"968\":1}}],[\"deque容器\",{\"0\":{\"967\":1}}],[\"deque\",{\"0\":{\"962\":1,\"971\":1},\"1\":{\"182\":1,\"999\":3}}],[\"de\",{\"1\":{\"60\":1}}],[\"defref\",{\"1\":{\"1055\":1}}],[\"definitions\",{\"1\":{\"1321\":1}}],[\"definition\",{\"1\":{\"755\":1,\"756\":1,\"759\":1,\"762\":1,\"768\":1,\"771\":1,\"774\":1,\"782\":1,\"783\":1,\"784\":1,\"787\":1,\"795\":1,\"798\":1,\"802\":1}}],[\"definition来定位\",{\"1\":{\"41\":1}}],[\"defined\",{\"1\":{\"1082\":3}}],[\"defines\",{\"1\":{\"503\":1}}],[\"define\",{\"1\":{\"163\":1,\"188\":1,\"194\":1,\"199\":1,\"205\":1,\"217\":1,\"220\":1,\"244\":1,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"293\":3,\"311\":1,\"323\":2,\"338\":5,\"439\":1,\"480\":1,\"497\":2,\"500\":2,\"504\":1,\"506\":1,\"526\":3,\"577\":1,\"578\":1,\"817\":1,\"1079\":2,\"1081\":1,\"1194\":1,\"1839\":1,\"1845\":2,\"1846\":1,\"1848\":1,\"1856\":3,\"1859\":2,\"1875\":1,\"1878\":1}}],[\"def\",{\"1\":{\"60\":2}}],[\"defaults\",{\"1\":{\"1773\":1}}],[\"default\",{\"1\":{\"51\":2,\"296\":1,\"864\":1,\"871\":3,\"1076\":1,\"1079\":7,\"1081\":2,\"1082\":7,\"1086\":2,\"1090\":1,\"1096\":1,\"1099\":1,\"1102\":1,\"1168\":1,\"1434\":1,\"1436\":1,\"1437\":1,\"1523\":1,\"1551\":1}}],[\"ddl\",{\"1\":{\"1548\":1,\"1772\":1}}],[\"dd\",{\"1\":{\"46\":1,\"557\":1}}],[\"在公司级别的项目中\",{\"1\":{\"1901\":1}}],[\"在网络中\",{\"1\":{\"1901\":1}}],[\"在网络互通的前提下\",{\"1\":{\"1831\":1}}],[\"在名称\",{\"1\":{\"1898\":1}}],[\"在名称空间外\",{\"1\":{\"586\":1}}],[\"在2台机器上查询然后如何合并这些操作都是由mycat完成的\",{\"1\":{\"1891\":1}}],[\"在2删除的基础上\",{\"1\":{\"966\":1}}],[\"在物理上分开了\",{\"1\":{\"1891\":1}}],[\"在还没读取够第二个参数指定大小的字符前\",{\"1\":{\"1878\":1}}],[\"在高并发的情况下\",{\"1\":{\"1864\":1}}],[\"在vs上使用mysql的头文件和库文件的配置\",{\"0\":{\"1855\":1}}],[\"在vmware菜单栏里点击虚拟机选项\",{\"1\":{\"1285\":1}}],[\"在远程服务器\",{\"1\":{\"1836\":1}}],[\"在windows下的slave服务器中查看general\",{\"1\":{\"1812\":1,\"1813\":1}}],[\"在windows下使用习惯了intel汇编\",{\"1\":{\"234\":1}}],[\"在标签schemas中间\",{\"1\":{\"1802\":1}}],[\"在a上做\",{\"1\":{\"1790\":1}}],[\"在innodb存储引擎中\",{\"1\":{\"1762\":1}}],[\"在it迭代器指向的位置增加一个元素\",{\"1\":{\"965\":1}}],[\"在iterator私有成员下添加一个指向当前对象的指针\",{\"1\":{\"747\":1}}],[\"在磁盘上的redo\",{\"1\":{\"1759\":1}}],[\"在关系图上的操作就是\",{\"1\":{\"1759\":1}}],[\"在关系型数据库中\",{\"1\":{\"1451\":1}}],[\"在异常发生时\",{\"1\":{\"1758\":1}}],[\"在事务执行过程中\",{\"1\":{\"1762\":1}}],[\"在事务的acid特性中\",{\"1\":{\"1757\":1}}],[\"在事务中进行数据插入\",{\"0\":{\"1734\":1}}],[\"在配置文件中添加配置\",{\"1\":{\"1754\":1}}],[\"在配置文件\",{\"1\":{\"1754\":1}}],[\"在缓冲区工作的时间就长了\",{\"1\":{\"1748\":1}}],[\"在索引上完成排序分页操作\",{\"1\":{\"1740\":1}}],[\"在导入结束后执行set\",{\"1\":{\"1730\":1}}],[\"在导入数据前执行\",{\"1\":{\"1730\":1}}],[\"在能正确完成业务的前提下\",{\"1\":{\"1724\":1}}],[\"在串行隔离级别中如果进行等值查询\",{\"1\":{\"1694\":1}}],[\"在之前\",{\"1\":{\"1673\":1}}],[\"在绝大部分情况下都应该使用行锁\",{\"1\":{\"1670\":1}}],[\"在已提交读和可重复读隔离级别下\",{\"1\":{\"1682\":1}}],[\"在已提交读隔离级别依然会发生不可重复读的现象\",{\"1\":{\"1658\":1}}],[\"在已提交读隔离级别\",{\"1\":{\"1658\":1}}],[\"在已提交读隔离级别下\",{\"1\":{\"1656\":1}}],[\"在已经创建的表上添加索引\",{\"1\":{\"1614\":1}}],[\"在有些场景下\",{\"1\":{\"1639\":1}}],[\"在有序链表上进行整表搜索\",{\"1\":{\"1563\":1}}],[\"在有序链表中查找\",{\"1\":{\"1563\":1}}],[\"在有序链表中进行全文搜索\",{\"1\":{\"1563\":1}}],[\"在当前目录下生成相应的\",{\"1\":{\"1915\":1}}],[\"在当前的可重复读隔离级别\",{\"1\":{\"1635\":1}}],[\"在当期遍历前一个位置插入\",{\"1\":{\"746\":1}}],[\"在可重复读隔离级别下\",{\"1\":{\"1656\":1,\"1663\":1}}],[\"在可重复读隔离级别\",{\"1\":{\"1635\":1,\"1664\":1,\"1708\":1}}],[\"在可重复读级别\",{\"1\":{\"1631\":1,\"1677\":1}}],[\"在b+树的叶子节点上存放数据\",{\"1\":{\"1681\":1}}],[\"在b\",{\"1\":{\"1627\":1}}],[\"在union和union\",{\"1\":{\"1618\":1}}],[\"在表的多个字段上创建索引\",{\"1\":{\"1610\":1}}],[\"在内存中划分一块空间用做缓存的地方\",{\"1\":{\"1749\":1}}],[\"在内存上的等值查询\",{\"1\":{\"1603\":1}}],[\"在内部进行插入和删除的操作效率低\",{\"1\":{\"354\":1}}],[\"在桶里面用链表串起来\",{\"1\":{\"1603\":1}}],[\"在二级索引树上用userid过滤出来的数据中\",{\"1\":{\"1586\":1}}],[\"在打开慢查询日志开关的时候\",{\"1\":{\"1577\":1}}],[\"在打开的文件末尾另起一行添加动态库log4cpp的路径\",{\"1\":{\"1030\":1}}],[\"在左表中不存在相应数据\",{\"1\":{\"1544\":1}}],[\"在右表中不存在相应数据\",{\"1\":{\"1543\":1}}],[\"在右边任务栏中找到dvd图标\",{\"1\":{\"1285\":1}}],[\"在一台机器上\",{\"1\":{\"1888\":1}}],[\"在一定程度上防止了幻读\",{\"1\":{\"1635\":1}}],[\"在一个字段上创建索引\",{\"1\":{\"1610\":1}}],[\"在一个数据库中每行的值都不相同\",{\"1\":{\"1463\":1}}],[\"在一些操作公共资源的场景时\",{\"1\":{\"837\":1}}],[\"在一些函数中\",{\"1\":{\"277\":1}}],[\"在子表添加一列关联父表的主键\",{\"1\":{\"1415\":1}}],[\"在里面搜索关键字mysql\",{\"1\":{\"1411\":1}}],[\"在重启mysql时候如果出现打不开\",{\"0\":{\"1411\":1}}],[\"在下面加入一行auto\",{\"1\":{\"1410\":1}}],[\"在下载的过程中会显示进度条\",{\"1\":{\"1249\":1}}],[\"在不使用时\",{\"1\":{\"1375\":1}}],[\"在不同的作用域中可以定义相同名字的变量\",{\"1\":{\"582\":1}}],[\"在赋值时就被展开\",{\"1\":{\"1357\":1}}],[\"在断点处\",{\"1\":{\"1342\":1}}],[\"在断点调试状态下\",{\"1\":{\"306\":1}}],[\"在许多系统中\",{\"1\":{\"1335\":1}}],[\"在某些业务场景下是可以允许的\",{\"1\":{\"1639\":1}}],[\"在某些系统上\",{\"1\":{\"1332\":1}}],[\"在某个工程的根目录下输入打开vim\",{\"1\":{\"1140\":1}}],[\"在运行时根据位置进行加载\",{\"1\":{\"1331\":1}}],[\"在运行期动态分配分配内存\",{\"1\":{\"285\":1}}],[\"在最后添加\",{\"1\":{\"1282\":1}}],[\"在虚拟机中选择nat模式\",{\"1\":{\"1279\":1}}],[\"在虚函数表中\",{\"1\":{\"958\":1}}],[\"在serializable隔离级别下\",{\"1\":{\"1701\":1}}],[\"在shell或者是windows下的命令行里面使用ping命令测试你想要的ip地址\",{\"1\":{\"1278\":1}}],[\"在str中查找首次出现子串substr的位置\",{\"1\":{\"535\":1}}],[\"在str中查找首次出现ch字符的位置\",{\"1\":{\"535\":1}}],[\"在成功解压同时亦会自动移除原始zip文件\",{\"1\":{\"1262\":1}}],[\"在压缩或解压过程中显示解压或压缩的文件\",{\"1\":{\"1261\":1}}],[\"在线帮助\",{\"1\":{\"1237\":1}}],[\"在数据段的变量前面加上\",{\"1\":{\"1233\":1}}],[\"在数据成员完成各自对齐之后\",{\"1\":{\"556\":1}}],[\"在析构函数中自动执行mutex的unlock\",{\"1\":{\"1228\":1}}],[\"在析构函数中负责释放资源\",{\"1\":{\"1041\":1}}],[\"在它的构造函数里面可以主动的获取这把锁lock\",{\"1\":{\"1226\":1,\"1227\":1}}],[\"在等待子线程\",{\"1\":{\"1206\":1}}],[\"在代码上无法区分整数和指针地址\",{\"1\":{\"1194\":1}}],[\"在~\",{\"1\":{\"1143\":1}}],[\"在空间配置器里面增加一个带右值引用的construct的方法\",{\"1\":{\"1127\":1}}],[\"在return\",{\"1\":{\"1115\":1}}],[\"在master中查看show\",{\"1\":{\"1829\":1}}],[\"在main函数的入口和退出\",{\"0\":{\"235\":1}}],[\"在mycat上直接操作userdb这个库即可\",{\"1\":{\"1802\":1}}],[\"在mycat上就是要配置主服务器和从服务器的信息\",{\"1\":{\"1791\":1}}],[\"在mycat上配置读写分离\",{\"1\":{\"1791\":1}}],[\"在mysql终端执行source命令\",{\"1\":{\"1836\":1}}],[\"在mysql上用命令可以查看\",{\"1\":{\"1574\":1,\"1776\":1}}],[\"在mysql5\",{\"1\":{\"1569\":2}}],[\"在mvcc下\",{\"1\":{\"1681\":1}}],[\"在mian\",{\"1\":{\"1114\":1}}],[\"在提升的过程中有可能提升失败\",{\"1\":{\"1057\":1}}],[\"在多线程中\",{\"1\":{\"1057\":1}}],[\"在多个人协同开发时\",{\"1\":{\"577\":1}}],[\"在源码中\",{\"1\":{\"1044\":1}}],[\"在源码目录中有include文件夹\",{\"1\":{\"1029\":1}}],[\"在做拷贝构造函数时\",{\"1\":{\"1043\":1}}],[\"在智能指针的析构函数中保证释放资源\",{\"1\":{\"1041\":1}}],[\"在构造函数中初始化资源地址\",{\"1\":{\"1041\":1}}],[\"在构造函数体内初始化const数据成员是非法的\",{\"1\":{\"432\":1}}],[\"在进程结束的时候执行\",{\"1\":{\"1032\":1}}],[\"在进行函数调用时\",{\"1\":{\"678\":1}}],[\"在进行源程序的阅读中\",{\"1\":{\"41\":1}}],[\"在上面第三范式的nonf表\",{\"1\":{\"1463\":1}}],[\"在上面排好序的容器中\",{\"1\":{\"1008\":1}}],[\"在上面有序的容器进行二分查找\",{\"1\":{\"1007\":1}}],[\"在集合容器中查找key\",{\"1\":{\"999\":1}}],[\"在容器末尾删除一个元素\",{\"1\":{\"965\":1}}],[\"在容器末尾增加一个元素\",{\"1\":{\"965\":1}}],[\"在创建对象c的过程中\",{\"1\":{\"943\":1}}],[\"在普通的继承体系中\",{\"1\":{\"943\":1}}],[\"在其中访问虚函数时\",{\"1\":{\"925\":1}}],[\"在其他地方重新又开辟了一块内存\",{\"1\":{\"741\":1}}],[\"在类的operator\",{\"1\":{\"1060\":1}}],[\"在类的构造函数当中\",{\"1\":{\"927\":1}}],[\"在类的外部定义成员函数时\",{\"1\":{\"449\":1}}],[\"在类内的成员函数中访问该类层次中的虚函数\",{\"1\":{\"924\":1}}],[\"在派生类中\",{\"1\":{\"933\":1}}],[\"在派生类中一般要对基类中纯虚函数进行重定义\",{\"1\":{\"900\":1}}],[\"在派生类中对基类成员的访问应当具有唯一性\",{\"1\":{\"652\":1}}],[\"在继承结构中\",{\"1\":{\"883\":1}}],[\"在继承结构中进行上下的类型转换\",{\"1\":{\"678\":1}}],[\"在编写大型c++软件的时候\",{\"1\":{\"861\":1}}],[\"在编译时\",{\"1\":{\"915\":1}}],[\"在编译时候明确变量的类型\",{\"1\":{\"359\":1}}],[\"在编译阶段就确定好调用的函数版本\",{\"1\":{\"884\":1}}],[\"在编译阶段编译器需要根据初始化表达式来推导auto的实际类型\",{\"1\":{\"700\":1}}],[\"在编译期就初始化创建实例\",{\"1\":{\"844\":1}}],[\"在编译期会执行类型检查\",{\"1\":{\"481\":1}}],[\"在编译过程\",{\"1\":{\"501\":1}}],[\"在编译的时候\",{\"1\":{\"276\":1}}],[\"在涉及到自动的问题时\",{\"1\":{\"853\":1}}],[\"在学习了嵌套类之后\",{\"1\":{\"853\":1}}],[\"在拥有共享数据的多条线程并行执行的程序中\",{\"1\":{\"839\":1}}],[\"在判断是靠近\",{\"1\":{\"792\":1}}],[\"在链表中的第\",{\"1\":{\"790\":1}}],[\"在链表的第一个元素之前添加一个值为\",{\"1\":{\"790\":1}}],[\"在链表类中实现这些功能\",{\"1\":{\"790\":1}}],[\"在链接时库文件会提供自己的位置\",{\"1\":{\"1331\":1}}],[\"在链接时\",{\"1\":{\"1331\":1,\"1335\":1}}],[\"在链接语句不需要添加\",{\"1\":{\"516\":1}}],[\"在链接过程\",{\"1\":{\"245\":1}}],[\"在存储的迭代器链表上进行遍历\",{\"1\":{\"747\":1}}],[\"在存储数据的区域是没有浪费的\",{\"1\":{\"354\":1}}],[\"在我们当前环境中\",{\"1\":{\"1814\":1}}],[\"在我们增加或删除后\",{\"1\":{\"747\":1}}],[\"在我们后来把bar的重载加上了之后\",{\"1\":{\"529\":1}}],[\"在同一目录下\",{\"1\":{\"1314\":1}}],[\"在同一个作用域中\",{\"1\":{\"571\":1}}],[\"在同⼀作用域当中的同名成员函数才存在重载关系\",{\"1\":{\"692\":1}}],[\"在执行派生类析构函数时\",{\"1\":{\"675\":1}}],[\"在执行pt1\",{\"1\":{\"463\":2}}],[\"在初始化列表中使用基类的构造来初始化ma\",{\"1\":{\"667\":1}}],[\"在d类对象中\",{\"1\":{\"653\":1}}],[\"在调用时编译器并不知道哪个参数设了默认值\",{\"1\":{\"639\":1}}],[\"在调用点直接把函数代码展开处理了\",{\"1\":{\"502\":1}}],[\"在正常状况下的类型转换\",{\"1\":{\"629\":1}}],[\"在参数传递时\",{\"1\":{\"619\":1}}],[\"在汇编上引用和指针生成的指令一样\",{\"1\":{\"619\":1}}],[\"在汇编里\",{\"1\":{\"614\":1}}],[\"在交换之后\",{\"1\":{\"618\":1}}],[\"在交换之前\",{\"1\":{\"618\":1}}],[\"在定义的\",{\"1\":{\"618\":1}}],[\"在定义的时候必须要进行初始化\",{\"1\":{\"618\":1}}],[\"在定义的成员函数\",{\"1\":{\"449\":1}}],[\"在引用的使用中\",{\"1\":{\"617\":1}}],[\"在引起溢出的那个函数处设一个断点\",{\"1\":{\"240\":1}}],[\"在没有引用之前\",{\"1\":{\"615\":1}}],[\"在没有c++\",{\"0\":{\"530\":1}}],[\"在后面学习了类之后\",{\"1\":{\"614\":1}}],[\"在理解引用概念前\",{\"1\":{\"612\":1}}],[\"在控制台输出\",{\"1\":{\"597\":1}}],[\"在匿名空间中创建的全局变量\",{\"1\":{\"591\":1}}],[\"在本文件使用无名命名空间成员时不必用命名空间限定\",{\"1\":{\"591\":1}}],[\"在声明一个命名空间时\",{\"1\":{\"585\":1}}],[\"在throw抛出异常后\",{\"1\":{\"603\":1}}],[\"在test\",{\"1\":{\"575\":1}}],[\"在typora中iframe是无法登录的\",{\"1\":{\"58\":1}}],[\"在实际项目中\",{\"1\":{\"1758\":1}}],[\"在实际生产环境中\",{\"1\":{\"1745\":1,\"1779\":1}}],[\"在实际开发中\",{\"1\":{\"560\":1}}],[\"在实现了圆锥\",{\"1\":{\"882\":1}}],[\"在实现malloc时要用到linux下的全局变量\",{\"1\":{\"286\":1}}],[\"在被定义的时候是不会被置空的\",{\"1\":{\"531\":1}}],[\"在foo\",{\"1\":{\"528\":1}}],[\"在指定的内存上划分了一块初值为4字节大小的内存\",{\"1\":{\"511\":1}}],[\"在指定的源文件的开头定义\",{\"1\":{\"293\":1}}],[\"在书\",{\"1\":{\"503\":1}}],[\"在降低运行时间上非常有用\",{\"1\":{\"500\":1}}],[\"在大多数的机器上\",{\"1\":{\"500\":1}}],[\"在大多数编译器中\",{\"1\":{\"470\":1}}],[\"在传统的\",{\"1\":{\"494\":1}}],[\"在使用表锁的时候\",{\"0\":{\"1672\":1}}],[\"在使用引用的过程中\",{\"1\":{\"612\":1}}],[\"在使用时\",{\"1\":{\"535\":1}}],[\"在使用中\",{\"1\":{\"481\":1}}],[\"在使用超链接在一个md中跳转之后\",{\"1\":{\"57\":1}}],[\"在复制构造函数一节中已经介绍了为类内的指针成员分配动态内存的相关范例\",{\"1\":{\"459\":1}}],[\"在整个程序结束时调用析构函数\",{\"1\":{\"427\":1}}],[\"在程序中再对该指针赋值\",{\"1\":{\"455\":1}}],[\"在程序中无法对其值修改\",{\"1\":{\"432\":1}}],[\"在程序离开局部对象的作用域时调用对象的析构函数\",{\"1\":{\"427\":1}}],[\"在程序运行过程中\",{\"1\":{\"323\":1}}],[\"在主键索引\",{\"1\":{\"1719\":1}}],[\"在主键索引树和辅助索引树上加锁\",{\"1\":{\"1700\":1,\"1701\":1}}],[\"在主函数main接受程序控制权之前\",{\"1\":{\"427\":1}}],[\"在主题文件夹下打开\",{\"1\":{\"48\":1,\"49\":1,\"51\":1}}],[\"在对象被撤销时被自动调用\",{\"1\":{\"424\":1}}],[\"在堆上开辟了一个常量\",{\"1\":{\"511\":1}}],[\"在堆上定义一个对象\",{\"0\":{\"412\":1}}],[\"在堆中已有的内存块中没有找到满足条件的内存块时执行下面的函数\",{\"1\":{\"286\":1}}],[\"在栈上定义一个对象\",{\"0\":{\"411\":1}}],[\"在满足拷贝构造函数的情况\",{\"1\":{\"399\":1}}],[\"在模板推导的时候\",{\"1\":{\"378\":1}}],[\"在项目属性里设置\",{\"1\":{\"293\":1}}],[\"在linux使用过程中\",{\"1\":{\"1236\":1}}],[\"在linux上测试时\",{\"1\":{\"565\":1}}],[\"在linux\",{\"1\":{\"312\":2,\"1808\":1,\"1809\":1,\"1836\":1}}],[\"在linux系统下面一个程序的堆的管理是通过内存块进行管理的\",{\"1\":{\"285\":1}}],[\"在linux下的master服务器查看general\",{\"1\":{\"1812\":1,\"1813\":1}}],[\"在linux下的mysql\",{\"1\":{\"1811\":1}}],[\"在linux下是通过sbrk\",{\"1\":{\"282\":1}}],[\"在linux下看的难受\",{\"1\":{\"234\":1}}],[\"在64位系统中\",{\"1\":{\"285\":1}}],[\"在分配用户传入的大小的时候\",{\"1\":{\"282\":1,\"285\":1}}],[\"在动态分配分配内存\",{\"1\":{\"282\":1}}],[\"在cmakelists中写上\",{\"1\":{\"1321\":1}}],[\"在c类构造函数的初始化列表中\",{\"1\":{\"943\":1}}],[\"在c语言的世界中\",{\"1\":{\"598\":1}}],[\"在c语言中\",{\"1\":{\"500\":1,\"509\":1,\"526\":1,\"560\":1}}],[\"在c语言中只能通过malloc\",{\"1\":{\"282\":1}}],[\"在c++代码中\",{\"1\":{\"578\":1}}],[\"在c++的头文件中使用\",{\"1\":{\"577\":1}}],[\"在c++的类中\",{\"1\":{\"431\":1}}],[\"在c++\",{\"1\":{\"518\":1}}],[\"在c++中是如果你没有在函数的异常抛出列表指定要抛出的异常\",{\"1\":{\"608\":1}}],[\"在c++中\",{\"1\":{\"450\":1,\"473\":1,\"484\":1,\"490\":1,\"500\":1,\"528\":1,\"608\":1,\"612\":1}}],[\"在c++11标准中\",{\"1\":{\"377\":1}}],[\"在c++11中args被称为\",{\"1\":{\"376\":1}}],[\"在css中\",{\"1\":{\"50\":1}}],[\"在只读数据段上\",{\"1\":{\"267\":1}}],[\"在符号表中找对应的符号是否只出现于\",{\"1\":{\"255\":1}}],[\"在这个过程中\",{\"1\":{\"1878\":1}}],[\"在这个级别和可能发生的\",{\"1\":{\"1631\":1}}],[\"在这种情况下\",{\"1\":{\"1692\":1}}],[\"在这里不再是取地址符号\",{\"1\":{\"612\":1}}],[\"在这里\",{\"1\":{\"463\":1}}],[\"在这里插入图片描述\",{\"1\":{\"250\":1,\"251\":1,\"253\":1,\"257\":1,\"258\":1,\"260\":1,\"263\":1,\"306\":1,\"307\":1,\"345\":1,\"385\":1,\"397\":2,\"422\":1,\"447\":1,\"517\":1,\"630\":1,\"744\":1,\"747\":1,\"979\":1,\"981\":1,\"982\":1,\"998\":1,\"1003\":1,\"1586\":1,\"1682\":1,\"1903\":1,\"1904\":1,\"1915\":1}}],[\"在这不会自动补充\",{\"1\":{\"29\":1}}],[\"在窗口中可以看到函数调用的层次关系\",{\"1\":{\"240\":1}}],[\"在函数的最前面以关键字\",{\"1\":{\"501\":1}}],[\"在函数的调用点直接把函数的代码进行展开处理\",{\"1\":{\"501\":1}}],[\"在函数体内回收资源\",{\"1\":{\"426\":1}}],[\"在函数里定义了一个局部变量\",{\"1\":{\"240\":1}}],[\"在函数执行完毕\",{\"1\":{\"235\":1}}],[\"在函数调用的时候\",{\"1\":{\"500\":1}}],[\"在函数调用之前\",{\"1\":{\"235\":1}}],[\"在函数调用与函数执行完毕后会发生改变\",{\"1\":{\"235\":1}}],[\"在gdb下使用set\",{\"1\":{\"244\":1,\"261\":1}}],[\"在gdb下使用\",{\"1\":{\"234\":1}}],[\"在x86等汇编集合中堆栈与弹栈的操作指令分别为\",{\"1\":{\"232\":1}}],[\"在中间或后面可以使用索引\",{\"1\":{\"1471\":1}}],[\"在中\",{\"1\":{\"163\":1}}],[\"在区域下标内查找是否存在两个值\",{\"1\":{\"162\":1}}],[\"在区间\",{\"1\":{\"96\":1}}],[\"在历史的数据中死循环\",{\"1\":{\"147\":1,\"149\":1}}],[\"在看\",{\"1\":{\"135\":1}}],[\"在\",{\"0\":{\"494\":1},\"1\":{\"62\":1,\"163\":1,\"261\":1,\"281\":1,\"301\":2,\"511\":1,\"601\":1,\"943\":1,\"1099\":1,\"1102\":3,\"1656\":1,\"1706\":1,\"1721\":1,\"1800\":1}}],[\"在试试代码块就可以看到默认预言了\",{\"1\":{\"61\":1}}],[\"在单个代码块添加代码收缩按钮\",{\"0\":{\"53\":1}}],[\"在文件\",{\"1\":{\"52\":1}}],[\"​\",{\"1\":{\"36\":1,\"77\":3,\"235\":1,\"520\":1,\"1502\":2,\"1563\":1}}],[\"兼容性\",{\"1\":{\"33\":1}}],[\"代价十分高\",{\"1\":{\"966\":1}}],[\"代理fixbugvideosite\",{\"1\":{\"830\":2}}],[\"代理proxy模式\",{\"1\":{\"830\":1}}],[\"代理类\",{\"1\":{\"830\":2}}],[\"代理类中有个抽象类的指针\",{\"1\":{\"830\":1}}],[\"代理类也是从基类派生的\",{\"1\":{\"830\":1}}],[\"代理类和委托类是组合关系\",{\"1\":{\"830\":1}}],[\"代理模式\",{\"0\":{\"829\":1,\"830\":1},\"1\":{\"829\":1}}],[\"代表着语句的结束\",{\"1\":{\"1523\":1}}],[\"代表一个打开的连接\",{\"1\":{\"1240\":1}}],[\"代表一个内存空间\",{\"0\":{\"308\":1},\"1\":{\"308\":1}}],[\"代表了t类型的析构函数\",{\"1\":{\"385\":1,\"704\":1,\"1080\":1,\"1087\":1}}],[\"代表所有类型都在下面特殊化处理\",{\"1\":{\"368\":1}}],[\"代表按下前面快捷键后会执行后面的命令\",{\"1\":{\"30\":1}}],[\"代码\",{\"0\":{\"1856\":1}}],[\"代码直接访问的是mycat\",{\"1\":{\"1791\":1}}],[\"代码也不会知道\",{\"1\":{\"1790\":1}}],[\"代码上不需要区分哪个请求是读\",{\"1\":{\"1791\":1}}],[\"代码上的事务操作\",{\"0\":{\"1650\":1}}],[\"代码上是的\",{\"1\":{\"1194\":1}}],[\"代码发生异常了\",{\"1\":{\"1225\":1}}],[\"代码还是有问题的\",{\"1\":{\"1209\":1}}],[\"代码可以跨平台\",{\"1\":{\"1201\":1}}],[\"代码对齐\",{\"1\":{\"1142\":1}}],[\"代码使用\",{\"0\":{\"1028\":1}}],[\"代码设置配置文件\",{\"1\":{\"1026\":1}}],[\"代码设置\",{\"1\":{\"1025\":1}}],[\"代码里面会出现\",{\"1\":{\"861\":1}}],[\"代码一运行就初始化创建实例\",{\"1\":{\"851\":1}}],[\"代码修改为如下\",{\"1\":{\"688\":1}}],[\"代码复用\",{\"1\":{\"682\":1}}],[\"代码二义性\",{\"1\":{\"588\":2}}],[\"代码是这样\",{\"1\":{\"529\":1}}],[\"代码放到另外一个平台就无法编译通过了\",{\"1\":{\"303\":1}}],[\"代码编译展开后宏就相当于这样写了\",{\"1\":{\"274\":1}}],[\"代码中\",{\"0\":{\"271\":1}}],[\"代码中注释部分\",{\"1\":{\"136\":1}}],[\"代码段\",{\"1\":{\"267\":1}}],[\"代码实现\",{\"0\":{\"214\":1,\"731\":1}}],[\"代码块收缩\",{\"0\":{\"55\":1,\"59\":1}}],[\"代码展开\",{\"1\":{\"53\":1,\"54\":1,\"59\":2}}],[\"代码收缩\",{\"1\":{\"53\":2,\"54\":1,\"59\":3}}],[\"代码解释\",{\"0\":{\"30\":1}}],[\"键值就是索引值\",{\"1\":{\"1623\":1}}],[\"键值对个数\",{\"1\":{\"1000\":4}}],[\"键\",{\"1\":{\"30\":2,\"1899\":1}}],[\"键盘\",{\"1\":{\"17\":1}}],[\"井号代表\",{\"1\":{\"30\":1}}],[\"感叹号代表alt键\",{\"1\":{\"30\":1}}],[\"我在\",{\"1\":{\"1820\":1}}],[\"我自己用的是ubuntu\",{\"1\":{\"1818\":1}}],[\"我自己为typora添加一点小功能\",{\"1\":{\"56\":1}}],[\"我消费完了\",{\"1\":{\"1221\":1}}],[\"我生产了一个物品\",{\"1\":{\"1219\":1}}],[\"我里我们实现了\",{\"1\":{\"980\":1}}],[\"我的实例内存地址是\",{\"1\":{\"848\":1,\"850\":1,\"851\":1}}],[\"我知道\",{\"1\":{\"528\":1}}],[\"我有可能被执行\",{\"1\":{\"277\":1}}],[\"我有时候希望返回到超链接的位置\",{\"1\":{\"57\":1}}],[\"我想跳到另外一段代码了\",{\"0\":{\"277\":1},\"1\":{\"277\":1}}],[\"我们打开\",{\"1\":{\"1915\":1}}],[\"我们配置的是表拆分后放在这2个数据节点上\",{\"1\":{\"1892\":1}}],[\"我们分别查看一下linux和windows主机的student表\",{\"1\":{\"1892\":1}}],[\"我们分别查看一下linux和windows主机的user表\",{\"1\":{\"1892\":1}}],[\"我们再通过mycat给student表插入两条数据\",{\"1\":{\"1892\":1}}],[\"我们再看一下类b\",{\"1\":{\"937\":1}}],[\"我们做了数据库读写分离\",{\"1\":{\"1885\":1}}],[\"我们变更一下属主\",{\"1\":{\"1836\":1}}],[\"我们指定ip才能登录\",{\"1\":{\"1821\":1}}],[\"我们是不知道的\",{\"1\":{\"1809\":1}}],[\"我们开启mycat后台服务\",{\"1\":{\"1807\":1}}],[\"我们重启mycat程序\",{\"1\":{\"1805\":1,\"1806\":1}}],[\"我们写代码得时候必须得知道哪个机器是负责写操作的主库\",{\"1\":{\"1790\":1}}],[\"我们写程序时\",{\"1\":{\"509\":1}}],[\"我们只看见了mycat发送的心跳包\",{\"1\":{\"1812\":1}}],[\"我们只需要操作这个逻辑库就可以\",{\"1\":{\"1802\":1}}],[\"我们只有一台mysql服务器\",{\"1\":{\"1790\":1}}],[\"我们只能通过引用来读取数据\",{\"1\":{\"620\":1}}],[\"我们读操作多\",{\"1\":{\"1781\":1}}],[\"我们建库\",{\"1\":{\"1774\":1}}],[\"我们现在把mytest库下的user表删除\",{\"1\":{\"1836\":1}}],[\"我们现在登录mycat\",{\"1\":{\"1812\":1,\"1813\":1,\"1814\":1}}],[\"我们现在\",{\"1\":{\"1774\":1}}],[\"我们现在知道\",{\"1\":{\"1774\":1}}],[\"我们现在有联合索引a\",{\"1\":{\"1736\":1}}],[\"我们查看一下binlog\",{\"1\":{\"1773\":1}}],[\"我们查看一下配置文件\",{\"1\":{\"1769\":1}}],[\"我们一般都不会开启\",{\"1\":{\"1771\":1}}],[\"我们一般都不会开启查询日志\",{\"1\":{\"1767\":1}}],[\"我们一般可以得到每个线程的线程栈信息来分析是否发生的问题之类的\",{\"1\":{\"1218\":1}}],[\"我们根本不用担心\",{\"1\":{\"1763\":1}}],[\"我们根据需要直接实例化这些模板\",{\"1\":{\"963\":1}}],[\"我们说到事务\",{\"1\":{\"1711\":1}}],[\"我们学习知识的时候\",{\"1\":{\"1711\":1}}],[\"我们操作id=8的数据当然可以成功\",{\"1\":{\"1701\":1}}],[\"我们update\",{\"1\":{\"1701\":1}}],[\"我们解释一下\",{\"1\":{\"1700\":1}}],[\"我们尝试给id=7的数据加上共享锁\",{\"1\":{\"1699\":1}}],[\"我们用主键索引id试试能不能update\",{\"1\":{\"1701\":1}}],[\"我们用另一个事务的服务线程给id=7的数据加上排它锁\",{\"1\":{\"1699\":1}}],[\"我们用代码来实现一下菱形继承问题\",{\"1\":{\"688\":1}}],[\"我们插入age=18\",{\"1\":{\"1693\":1}}],[\"我们把linux作为一个主库\",{\"1\":{\"1785\":1}}],[\"我们把事务2\",{\"1\":{\"1686\":1}}],[\"我们把id=7的age改为16\",{\"1\":{\"1682\":1}}],[\"我们把这种现象称为精度丢失\",{\"1\":{\"340\":1}}],[\"我们每打开一个客户端session\",{\"1\":{\"1681\":1}}],[\"我们无法手动获取is或ix锁\",{\"1\":{\"1673\":1}}],[\"我们无法看见\",{\"1\":{\"698\":1}}],[\"我们希望直接去使用表锁\",{\"1\":{\"1669\":1}}],[\"我们希望这样的操作也能作用于自定义类类型\",{\"1\":{\"395\":1}}],[\"我们进行查找的时候都会遍历完所有的桶内节点\",{\"1\":{\"1603\":1}}],[\"我们主要看\",{\"1\":{\"1602\":1}}],[\"我们应该建立合适的索引\",{\"1\":{\"1609\":1}}],[\"我们应该给\",{\"1\":{\"1581\":1}}],[\"我们应该比较为它们在ascii表中的顺序大小\",{\"1\":{\"368\":1}}],[\"我们从什么地方可以获取那些运行时间长\",{\"1\":{\"1572\":1}}],[\"我们直接在queue的基础上\",{\"1\":{\"1219\":1}}],[\"我们直接用一个函数指针的模板部分特例化来做\",{\"1\":{\"1189\":1}}],[\"我们直接看实例\",{\"1\":{\"1002\":1}}],[\"我们需要通过mysqlbinlog进行查看\",{\"1\":{\"1773\":1}}],[\"我们需要等待很长时间才能拿到结果\",{\"1\":{\"1744\":1}}],[\"我们需要设置为手动提交方式\",{\"1\":{\"1640\":1}}],[\"我们需要\",{\"1\":{\"1219\":1}}],[\"我们需要用函数类型来实例化function\",{\"1\":{\"1162\":1}}],[\"我们需要把\",{\"1\":{\"340\":1}}],[\"我们这里学习的意向共享锁和意向排他锁就是用来解决\",{\"1\":{\"1672\":1}}],[\"我们这里使用std\",{\"1\":{\"1127\":1}}],[\"我们这里分配了5个test对象\",{\"1\":{\"715\":1}}],[\"我们将less改为greater即可变为小根堆即可\",{\"1\":{\"984\":1}}],[\"我们通过查看日志\",{\"1\":{\"1776\":1}}],[\"我们通过以下命令查看两个关键信息\",{\"1\":{\"1569\":1}}],[\"我们通过函数指针虽然解决了问题\",{\"1\":{\"981\":1}}],[\"我们通过反汇编查看时候\",{\"1\":{\"630\":1}}],[\"我们传入不同的函数指针来解决\",{\"1\":{\"981\":1}}],[\"我们有时想比较小于\",{\"1\":{\"980\":1}}],[\"我们c语言进行函数调用与c++中两个函数调用\",{\"1\":{\"979\":1}}],[\"我们若开始知道问题的数据量大小\",{\"1\":{\"966\":1}}],[\"我们若添加更多的新的动物\",{\"1\":{\"886\":1}}],[\"我们经常提到stl\",{\"0\":{\"963\":1}}],[\"我们接下来看看这种情况\",{\"1\":{\"943\":1}}],[\"我们接触的第一个c++程序基本上都是这样的\",{\"1\":{\"588\":1}}],[\"我们还可以直接导出\",{\"1\":{\"1836\":1}}],[\"我们还需要在c的构造函数初始化列表最后\",{\"1\":{\"943\":1}}],[\"我们还是前面简单实现的vector容器\",{\"1\":{\"382\":1}}],[\"我们看见了insert数据的sql\",{\"1\":{\"1813\":1}}],[\"我们看到心跳不成功了\",{\"1\":{\"1806\":1}}],[\"我们看到\",{\"1\":{\"1681\":1}}],[\"我们看到c带三个参数的构造函数执行了\",{\"1\":{\"943\":1}}],[\"我们看了auto\",{\"1\":{\"1043\":1}}],[\"我们看一个例子\",{\"1\":{\"528\":1}}],[\"我们称之为覆盖\",{\"1\":{\"913\":1}}],[\"我们称为浅拷贝\",{\"1\":{\"397\":1}}],[\"我们vfptr里面存储的是vftable的地址\",{\"1\":{\"908\":1}}],[\"我们来看一下deque容器基本结构\",{\"1\":{\"968\":1}}],[\"我们来看一下函数调用过程\",{\"1\":{\"906\":1}}],[\"我们来看一个经典的问题\",{\"1\":{\"688\":1}}],[\"我们简单看一下\",{\"1\":{\"906\":1}}],[\"我们之前学习过的函数重载\",{\"1\":{\"883\":1}}],[\"我们很自然的可以想到\",{\"1\":{\"853\":1}}],[\"我们就要进行读写分离的操作\",{\"1\":{\"1790\":1}}],[\"我们就简单画了一个方向\",{\"1\":{\"968\":1}}],[\"我们就可以完美的解决这一问题\",{\"1\":{\"853\":1}}],[\"我们就针对该该类型提供自己的特例化版本\",{\"1\":{\"367\":1}}],[\"我们并不清楚它的数组名\",{\"1\":{\"698\":1}}],[\"我们发现日志的filesize从154字节\",{\"1\":{\"1773\":1}}],[\"我们发现刚开始为空\",{\"1\":{\"966\":1}}],[\"我们发现\",{\"1\":{\"688\":1,\"709\":1}}],[\"我们画一下d对象的内存布局\",{\"1\":{\"688\":1}}],[\"我们多重继承还会出现别的问题\",{\"1\":{\"688\":1}}],[\"我们知道schema\",{\"1\":{\"1892\":1}}],[\"我们知道\",{\"1\":{\"662\":1,\"1669\":1}}],[\"我们知道它调用的是void\",{\"1\":{\"528\":1}}],[\"我们先查看mysql\",{\"1\":{\"1774\":1}}],[\"我们先查看键表的sql以及内容\",{\"1\":{\"1699\":1}}],[\"我们先刷新一下\",{\"1\":{\"1773\":1}}],[\"我们先来看一下\",{\"0\":{\"708\":1}}],[\"我们先来看一个简单的例子\",{\"1\":{\"536\":1}}],[\"我们先定义3个不同的类a\",{\"1\":{\"652\":1}}],[\"我们都把声明语句放到头文件使用\",{\"1\":{\"576\":1}}],[\"我们怎么解决避免这个问题呢\",{\"0\":{\"530\":1}}],[\"我们的mycat和主库跑在同一台linux上\",{\"1\":{\"1799\":1}}],[\"我们的事务由多条sql组成\",{\"1\":{\"1652\":1}}],[\"我们的顺序容器\",{\"1\":{\"1011\":1}}],[\"我们的优先级队列\",{\"1\":{\"984\":1}}],[\"我们的解决方案是采用\",{\"1\":{\"653\":1}}],[\"我们的void\",{\"1\":{\"631\":1}}],[\"我们的需求改变了\",{\"1\":{\"631\":1}}],[\"我们的代码还是能够如预期的一样正确运行\",{\"1\":{\"529\":1}}],[\"我们的游戏项目就遇到这个问题\",{\"1\":{\"528\":1}}],[\"我们找到b\",{\"1\":{\"528\":1}}],[\"我们会使用explain去分析sql语句\",{\"1\":{\"1572\":1}}],[\"我们会进行分类管理\",{\"1\":{\"1313\":1}}],[\"我们会发现出错了\",{\"1\":{\"528\":1}}],[\"我们会在一开始就想办法避免这个问题\",{\"1\":{\"528\":1}}],[\"我们会得到\",{\"1\":{\"310\":1}}],[\"我们使用function\",{\"1\":{\"1168\":1}}],[\"我们使用库中的优先级队列\",{\"1\":{\"992\":1}}],[\"我们使用库中的队列\",{\"1\":{\"991\":1}}],[\"我们使用库中的栈\",{\"1\":{\"990\":1}}],[\"我们使用容器适配器来实现一个栈\",{\"1\":{\"989\":1}}],[\"我们使用整型时会有1024个元素\",{\"1\":{\"968\":1}}],[\"我们使用统一的基类类型来接受派生类的对象\",{\"1\":{\"886\":1}}],[\"我们使用了\",{\"1\":{\"528\":1}}],[\"我们使用null表示\",{\"1\":{\"526\":1}}],[\"我们使用带参数的宏定义这种借助编译器的优化技术来减少程序的执行时间\",{\"1\":{\"500\":1}}],[\"我们也会在其构造函数中显式调用虚基类的构造函数\",{\"1\":{\"943\":1}}],[\"我们也能看到相关的用法\",{\"1\":{\"614\":1}}],[\"我们也都应该对申请出来的内存作手动进行初始化\",{\"1\":{\"509\":1}}],[\"我们也希望该操作能作用于自定义类类型\",{\"1\":{\"463\":1}}],[\"我们尽量将其设置为内联函数\",{\"1\":{\"502\":1}}],[\"我们\",{\"1\":{\"438\":1,\"1120\":1,\"1189\":1,\"1800\":1}}],[\"我们不仅可以通过binlog记录的位置\",{\"1\":{\"1774\":1}}],[\"我们不可能从头开始一条一条explain去分析\",{\"1\":{\"1572\":1}}],[\"我们不断使用如下的方式查询\",{\"1\":{\"1569\":1}}],[\"我们不能再插入主键id=3的数据\",{\"1\":{\"1692\":1}}],[\"我们不能直接把智能指针定义在堆上\",{\"1\":{\"1041\":1}}],[\"我们不能在类的内部初始化静态数据成员\",{\"1\":{\"435\":1}}],[\"我们不需要操心\",{\"1\":{\"698\":1}}],[\"我们不要让他加到末尾\",{\"1\":{\"406\":1}}],[\"我们必须显式定义一个析构函数\",{\"1\":{\"426\":1}}],[\"我们定义指针指向类的成员变量\",{\"1\":{\"410\":1}}],[\"我们析构时只析构有效的元素\",{\"1\":{\"383\":1}}],[\"我们赋给\",{\"1\":{\"340\":1}}],[\"我们自定义一个头文件\",{\"1\":{\"312\":1}}],[\"我们点击菜单栏的调试\",{\"1\":{\"306\":1}}],[\"我们所讲的\",{\"1\":{\"303\":1}}],[\"我们在main\",{\"1\":{\"1915\":1}}],[\"我们在mycat\",{\"1\":{\"1814\":1}}],[\"我们在客户端上的代码不用做任何变更\",{\"1\":{\"1791\":1}}],[\"我们在vector类里面增加一个带右值引用的push\",{\"1\":{\"1127\":1}}],[\"我们在\",{\"1\":{\"1102\":1}}],[\"我们在c++\",{\"1\":{\"529\":1}}],[\"我们在类之外实现\",{\"1\":{\"449\":1}}],[\"我们在编译老的用c语言的开源项目如lua源包的时候\",{\"1\":{\"293\":1}}],[\"我们在写代码的时候都习惯在语句右面加上分号\",{\"1\":{\"274\":1}}],[\"我们可以拿root进行连接\",{\"1\":{\"1799\":1}}],[\"我们可以随时通过redo\",{\"1\":{\"1763\":1}}],[\"我们可以引入数据库连接池\",{\"1\":{\"1745\":1}}],[\"我们可以通过\",{\"1\":{\"1719\":1}}],[\"我们可以通过继承c++标准异常类的方法来定义自己的异常类\",{\"1\":{\"606\":1}}],[\"我们可以在id小于11的地方update\",{\"1\":{\"1688\":1}}],[\"我们可以打开慢查询日志\",{\"1\":{\"1572\":1}}],[\"我们可以查看相关参数指标\",{\"1\":{\"1569\":1}}],[\"我们可以先将\",{\"1\":{\"1315\":1}}],[\"我们可以发现当调用q\",{\"1\":{\"1050\":1}}],[\"我们可以看到\",{\"1\":{\"1041\":1}}],[\"我们可以解决这一问题\",{\"1\":{\"853\":1}}],[\"我们可以将链表的后半部分反转\",{\"1\":{\"756\":1}}],[\"我们可以借助\",{\"1\":{\"599\":1}}],[\"我们可以使用参数\",{\"1\":{\"1251\":1,\"1253\":1}}],[\"我们可以使用函数模板来简化我们的代码量\",{\"1\":{\"1127\":1}}],[\"我们可以使用一些技巧来模拟多态性的概念\",{\"1\":{\"494\":1}}],[\"我们可以使用do\",{\"1\":{\"276\":1}}],[\"我们可以区分清楚是编译错误\",{\"1\":{\"310\":1}}],[\"我们可以按照一定的规则进行添加和删除数据\",{\"1\":{\"232\":1}}],[\"我们可以把⼤的数组分成两个\",{\"1\":{\"202\":1}}],[\"我们可以\",{\"1\":{\"169\":1}}],[\"我们判断前一位是不是一样的元素\",{\"1\":{\"135\":1}}],[\"我们要保证线程间的运行顺序\",{\"1\":{\"1218\":1}}],[\"我们要保证这个操作线程安全\",{\"1\":{\"1208\":1}}],[\"我们要保证它们能够得到正确的初始化\",{\"1\":{\"943\":1}}],[\"我们要做的是\",{\"1\":{\"135\":1}}],[\"我们要查看函数变量的定义原型\",{\"1\":{\"41\":1}}],[\"我就说我测试了这么长时间都不管用\",{\"1\":{\"30\":1}}],[\"我一般主张将技能清单写入到工作经历里边去\",{\"1\":{\"0\":1}}],[\"紫色键值存放的就是name\",{\"1\":{\"1623\":1}}],[\"紫色\",{\"1\":{\"29\":1}}],[\"青色\",{\"1\":{\"29\":1}}],[\"绿色\",{\"1\":{\"29\":1}}],[\"黑色\",{\"1\":{\"29\":1}}],[\"粘贴\",{\"1\":{\"29\":1}}],[\"vm\",{\"1\":{\"1820\":6}}],[\"vmware\",{\"1\":{\"1285\":2}}],[\"vmwaretools\",{\"1\":{\"1285\":1}}],[\"v或\",{\"1\":{\"1237\":2}}],[\"v选中\",{\"1\":{\"1142\":1}}],[\"vbtable第一行为向上的偏移量\",{\"1\":{\"937\":1}}],[\"vbtable第一行为0\",{\"1\":{\"937\":1}}],[\"vbtable\",{\"1\":{\"933\":1,\"937\":1}}],[\"vbptr离虚基类数据的偏移量\",{\"1\":{\"937\":1}}],[\"vbptr指向的是vbtable\",{\"1\":{\"937\":1}}],[\"vbptr\",{\"1\":{\"933\":1,\"937\":1}}],[\"vftable的地址写入到虚函数指针中\",{\"1\":{\"908\":1}}],[\"vftable\",{\"1\":{\"886\":3,\"908\":3,\"933\":1}}],[\"vfptr是有效的\",{\"1\":{\"908\":1}}],[\"vfptr指向base\",{\"1\":{\"908\":1}}],[\"vfptr指针需要依赖对象\",{\"1\":{\"875\":1}}],[\"vfptr\",{\"1\":{\"875\":1,\"908\":1,\"914\":1,\"933\":1}}],[\"vgatohdmiadapter\",{\"1\":{\"832\":3}}],[\"vga接口\",{\"1\":{\"832\":1}}],[\"vga接口类\",{\"1\":{\"832\":1}}],[\"vga接口的电脑\",{\"1\":{\"832\":1}}],[\"vga\",{\"1\":{\"832\":6}}],[\"vc\",{\"1\":{\"312\":1}}],[\"volatile\",{\"1\":{\"296\":1,\"848\":1,\"849\":1,\"1082\":2,\"1093\":1,\"1096\":1,\"1099\":1,\"1102\":2,\"1233\":2}}],[\"void>\",{\"1\":{\"1173\":1}}],[\"void\",{\"1\":{\"60\":5,\"67\":2,\"70\":1,\"101\":6,\"104\":1,\"107\":1,\"110\":1,\"118\":1,\"121\":1,\"182\":1,\"185\":2,\"188\":4,\"191\":5,\"194\":4,\"199\":4,\"202\":4,\"205\":2,\"214\":2,\"217\":2,\"220\":2,\"224\":3,\"240\":2,\"286\":5,\"287\":2,\"296\":1,\"355\":3,\"370\":2,\"371\":1,\"372\":1,\"377\":1,\"378\":6,\"385\":7,\"388\":6,\"389\":3,\"392\":1,\"405\":1,\"406\":3,\"410\":2,\"413\":2,\"414\":1,\"421\":2,\"422\":1,\"433\":1,\"434\":2,\"435\":1,\"439\":7,\"440\":5,\"449\":4,\"450\":4,\"459\":5,\"476\":6,\"483\":2,\"484\":2,\"493\":5,\"494\":6,\"497\":3,\"504\":3,\"515\":4,\"516\":3,\"518\":4,\"522\":1,\"523\":1,\"524\":1,\"526\":3,\"528\":4,\"529\":3,\"530\":1,\"535\":1,\"536\":1,\"544\":1,\"547\":2,\"548\":2,\"560\":3,\"563\":4,\"585\":1,\"588\":1,\"589\":2,\"590\":2,\"591\":1,\"592\":3,\"594\":17,\"601\":3,\"602\":1,\"607\":4,\"612\":1,\"615\":2,\"616\":1,\"618\":7,\"629\":1,\"631\":7,\"633\":4,\"637\":3,\"640\":2,\"641\":7,\"652\":4,\"653\":3,\"669\":1,\"670\":1,\"672\":1,\"678\":1,\"692\":2,\"695\":8,\"699\":1,\"704\":8,\"710\":4,\"711\":4,\"717\":1,\"718\":1,\"722\":1,\"731\":3,\"736\":1,\"747\":3,\"751\":5,\"791\":6,\"792\":4,\"802\":1,\"810\":2,\"817\":15,\"819\":5,\"821\":5,\"826\":5,\"830\":13,\"831\":7,\"832\":6,\"848\":4,\"849\":1,\"850\":2,\"851\":4,\"852\":1,\"854\":1,\"856\":1,\"857\":2,\"862\":3,\"864\":2,\"867\":6,\"871\":6,\"886\":8,\"889\":11,\"890\":11,\"891\":14,\"894\":13,\"898\":6,\"900\":3,\"905\":4,\"906\":2,\"907\":4,\"908\":3,\"913\":4,\"919\":2,\"943\":3,\"948\":2,\"949\":1,\"953\":3,\"954\":3,\"989\":2,\"1031\":3,\"1032\":18,\"1041\":1,\"1050\":2,\"1055\":3,\"1057\":4,\"1060\":2,\"1076\":3,\"1080\":12,\"1086\":7,\"1087\":6,\"1093\":2,\"1096\":2,\"1099\":1,\"1102\":6,\"1114\":1,\"1115\":1,\"1127\":13,\"1147\":1,\"1148\":1,\"1151\":2,\"1154\":1,\"1158\":1,\"1162\":2,\"1164\":1,\"1165\":2,\"1167\":1,\"1168\":5,\"1173\":2,\"1189\":4,\"1207\":2,\"1208\":1,\"1209\":3,\"1210\":1,\"1219\":6,\"1233\":1,\"1375\":1,\"1381\":1,\"1846\":1,\"1848\":2,\"1849\":3,\"1851\":2,\"1859\":6,\"1875\":3,\"1902\":1,\"1903\":1,\"1904\":1,\"1905\":1}}],[\"vscode使用\",{\"0\":{\"1309\":1}}],[\"vscode下载相应插件\",{\"1\":{\"1306\":1}}],[\"vscode环境安装cmake\",{\"0\":{\"1306\":1}}],[\"vsp\",{\"1\":{\"1139\":1}}],[\"vs下通过调试进入new表达式内部系统函数\",{\"1\":{\"518\":1}}],[\"vs编译环境如下图所示\",{\"1\":{\"312\":1}}],[\"vs\",{\"0\":{\"306\":1,\"958\":1},\"1\":{\"293\":1}}],[\"view\",{\"1\":{\"1656\":15}}],[\"vi\",{\"1\":{\"1133\":1,\"1282\":1,\"1284\":1,\"1291\":1,\"1820\":1}}],[\"vim的配置和使用\",{\"1\":{\"1292\":1}}],[\"vimplus\",{\"1\":{\"1287\":3}}],[\"vim配置\",{\"2\":{\"1145\":1}}],[\"vim中添加colorscheme\",{\"1\":{\"1143\":1}}],[\"vim神级配置\",{\"1\":{\"1141\":1}}],[\"vim添加以下内容\",{\"1\":{\"1133\":1,\"1291\":1}}],[\"vimrcs\",{\"0\":{\"1135\":1},\"1\":{\"1143\":1}}],[\"vimrc\",{\"0\":{\"1288\":1},\"1\":{\"1132\":2,\"1290\":2}}],[\"vimrc的配置和使用\",{\"0\":{\"1130\":1}}],[\"vim\",{\"0\":{\"1132\":1,\"1135\":2,\"1290\":1,\"1941\":1},\"1\":{\"1030\":1,\"1132\":2,\"1133\":2,\"1135\":1,\"1141\":1,\"1143\":4,\"1280\":1,\"1287\":4,\"1290\":2,\"1291\":2,\"1408\":1,\"1410\":1,\"1411\":2,\"1555\":1}}],[\"video\",{\"1\":{\"830\":4}}],[\"videosite\",{\"1\":{\"830\":6}}],[\"vipvideositeproxy\",{\"1\":{\"830\":3}}],[\"vip电影\",{\"1\":{\"830\":4}}],[\"vipmovie\",{\"1\":{\"830\":4}}],[\"virtual~base\",{\"1\":{\"948\":1}}],[\"virtual修饰了成员方法是虚函数\",{\"1\":{\"932\":1}}],[\"virtual作用\",{\"0\":{\"932\":1}}],[\"virtual\",{\"1\":{\"239\":1,\"606\":1,\"631\":1,\"653\":2,\"688\":2,\"692\":1,\"693\":2,\"695\":3,\"830\":12,\"831\":1,\"832\":2,\"862\":1,\"866\":1,\"867\":4,\"871\":1,\"876\":2,\"886\":1,\"889\":10,\"890\":6,\"891\":14,\"894\":12,\"898\":5,\"900\":1,\"905\":1,\"906\":2,\"907\":4,\"908\":1,\"912\":2,\"913\":3,\"914\":1,\"919\":1,\"933\":1,\"939\":2,\"943\":1,\"948\":2,\"949\":1,\"954\":2}}],[\"visited\",{\"1\":{\"178\":2}}],[\"v3\",{\"1\":{\"107\":3}}],[\"v2\",{\"1\":{\"107\":7,\"110\":5}}],[\"v1\",{\"1\":{\"107\":7,\"110\":5}}],[\"vendor\",{\"1\":{\"1820\":1}}],[\"vec5\",{\"1\":{\"1188\":1}}],[\"vec4\",{\"1\":{\"1188\":1}}],[\"vec3\",{\"1\":{\"1188\":1}}],[\"vec1\",{\"1\":{\"1188\":1}}],[\"vec2\",{\"1\":{\"1045\":2,\"1188\":1}}],[\"vec的operator\",{\"1\":{\"966\":3}}],[\"vec\",{\"1\":{\"104\":2,\"107\":2,\"110\":2,\"118\":3,\"191\":4,\"355\":6,\"382\":1,\"385\":5,\"704\":7,\"742\":3,\"743\":3,\"745\":5,\"746\":5,\"747\":29,\"755\":5,\"966\":35,\"1007\":20,\"1008\":4,\"1011\":13,\"1045\":10,\"1124\":4,\"1127\":3,\"1147\":9,\"1148\":16,\"1177\":4,\"1178\":5,\"1179\":2,\"1905\":5,\"1909\":4}}],[\"vector使用右值的拷贝构造函数\",{\"1\":{\"1127\":1}}],[\"vector需要大片的连续内存\",{\"1\":{\"993\":1}}],[\"vector的声明\",{\"1\":{\"1079\":1}}],[\"vector的\",{\"1\":{\"993\":1}}],[\"vector与list容器之间的区别\",{\"0\":{\"974\":1}}],[\"vector与deque容器之间的区别\",{\"0\":{\"973\":1}}],[\"vector为o\",{\"1\":{\"973\":1}}],[\"vector底层是一个动态开辟的数组\",{\"1\":{\"973\":1}}],[\"vector特点\",{\"1\":{\"973\":1,\"974\":1}}],[\"vector中没有该方法\",{\"1\":{\"969\":1,\"970\":1}}],[\"vector容器\",{\"0\":{\"964\":1}}],[\"vector迭代器的实现\",{\"0\":{\"704\":1},\"1\":{\"1087\":2}}],[\"vector会申请一块更大的内存块\",{\"1\":{\"354\":1}}],[\"vector\",{\"0\":{\"962\":1,\"971\":1},\"1\":{\"104\":2,\"107\":2,\"110\":2,\"118\":1,\"170\":1,\"188\":2,\"191\":1,\"194\":1,\"199\":1,\"202\":1,\"205\":1,\"214\":1,\"217\":1,\"220\":1,\"355\":5,\"385\":3,\"604\":1,\"704\":3,\"1079\":2,\"1086\":6,\"1087\":1,\"1127\":6,\"1188\":7}}],[\"vector<int\",{\"1\":{\"1188\":3}}],[\"vector<int>vec\",{\"1\":{\"742\":1,\"743\":1,\"745\":1,\"746\":1}}],[\"vector<int>\",{\"1\":{\"73\":1,\"77\":1,\"78\":1,\"81\":1,\"84\":1,\"87\":3,\"93\":1,\"94\":1,\"96\":2,\"97\":2,\"104\":5,\"107\":12,\"110\":17,\"114\":1,\"115\":1,\"118\":2,\"121\":1,\"125\":2,\"126\":2,\"129\":1,\"133\":2,\"137\":1,\"141\":2,\"142\":3,\"143\":2,\"153\":1,\"154\":1,\"155\":1,\"158\":1,\"162\":1,\"170\":3,\"171\":4,\"178\":1,\"179\":1,\"188\":5,\"191\":7,\"194\":4,\"199\":4,\"202\":5,\"205\":2,\"214\":6,\"217\":2,\"220\":2,\"355\":1,\"704\":2,\"747\":6,\"755\":1,\"966\":5,\"984\":1,\"1007\":2,\"1011\":8,\"1147\":1,\"1148\":1,\"1188\":1,\"1905\":1,\"1909\":2}}],[\"vector<r\",{\"1\":{\"1188\":4}}],[\"vector<data>\",{\"1\":{\"1183\":1}}],[\"vector<char\",{\"1\":{\"1188\":3}}],[\"vector<char>\",{\"1\":{\"67\":2}}],[\"vector<cmystring>\",{\"1\":{\"1124\":1,\"1127\":1}}],[\"vector<auto\",{\"1\":{\"1045\":2}}],[\"vector<\",{\"1\":{\"984\":1}}],[\"vector<student>\",{\"1\":{\"784\":5}}],[\"vector<std\",{\"1\":{\"60\":13}}],[\"vector<listnode\",{\"1\":{\"782\":1,\"783\":2,\"784\":2}}],[\"vector<ty\",{\"1\":{\"1188\":2}}],[\"vector<thread>\",{\"1\":{\"1151\":1}}],[\"vector<thread\",{\"1\":{\"1151\":1}}],[\"vector<t\",{\"1\":{\"747\":2}}],[\"vector<test>\",{\"1\":{\"382\":1,\"385\":1}}],[\"vector<t>\",{\"1\":{\"355\":3,\"385\":3,\"704\":3}}],[\"vector<vector<int>>\",{\"1\":{\"81\":2,\"104\":1,\"133\":2,\"137\":2,\"191\":2}}],[\"verbose\",{\"1\":{\"1237\":1}}],[\"verify\",{\"1\":{\"747\":5}}],[\"verify检查有效性\",{\"1\":{\"747\":1}}],[\"vertical\",{\"1\":{\"51\":1}}],[\"version=\",{\"1\":{\"1888\":1,\"1891\":1}}],[\"versions\",{\"1\":{\"1395\":1}}],[\"version\",{\"1\":{\"44\":1,\"572\":1,\"1082\":1,\"1237\":1,\"1305\":3,\"1312\":4,\"1314\":1,\"1315\":1,\"1316\":1,\"1317\":1,\"1318\":1,\"1322\":1,\"1508\":1,\"1656\":1,\"1798\":1}}],[\"valgrind\",{\"0\":{\"1035\":1},\"1\":{\"1035\":3,\"1896\":1}}],[\"val不会重复\",{\"1\":{\"999\":1}}],[\"val2\",{\"1\":{\"584\":1,\"1183\":2}}],[\"val1\",{\"1\":{\"584\":1,\"591\":1,\"1183\":2}}],[\"validate\",{\"1\":{\"1407\":18}}],[\"valid\",{\"1\":{\"286\":6}}],[\"val\",{\"1\":{\"77\":2,\"78\":3,\"101\":4,\"115\":4,\"121\":4,\"182\":6,\"224\":2,\"355\":2,\"385\":6,\"406\":2,\"423\":3,\"480\":1,\"585\":1,\"704\":8,\"742\":1,\"745\":1,\"747\":4,\"751\":2,\"755\":4,\"756\":4,\"759\":7,\"762\":4,\"768\":2,\"771\":2,\"774\":4,\"782\":4,\"783\":4,\"784\":4,\"787\":4,\"790\":6,\"791\":20,\"792\":15,\"795\":4,\"798\":4,\"802\":4,\"817\":15,\"819\":8,\"821\":8,\"989\":2,\"999\":3,\"1007\":3,\"1008\":2,\"1080\":5,\"1087\":6,\"1115\":2,\"1116\":3,\"1127\":13,\"1148\":8,\"1177\":2,\"1178\":2,\"1194\":1,\"1219\":12}}],[\"value格式\",{\"1\":{\"1900\":1}}],[\"values\",{\"1\":{\"1384\":1,\"1428\":2,\"1475\":3,\"1477\":1,\"1490\":3,\"1523\":1,\"1537\":3,\"1733\":4,\"1734\":3,\"1735\":8,\"1851\":2,\"1856\":1,\"1878\":1}}],[\"value5\",{\"1\":{\"497\":2}}],[\"value4\",{\"1\":{\"497\":2}}],[\"value3\",{\"1\":{\"497\":2}}],[\"value2\",{\"1\":{\"497\":2}}],[\"value1\",{\"1\":{\"487\":2,\"497\":2}}],[\"valuediff\",{\"1\":{\"161\":3,\"162\":19}}],[\"value\",{\"1\":{\"59\":6,\"178\":2,\"185\":2,\"355\":1,\"487\":2,\"497\":6,\"984\":1,\"1000\":1,\"1001\":1,\"1002\":1,\"1086\":4,\"1407\":2,\"1452\":1,\"1839\":11,\"1849\":11,\"1875\":11,\"1878\":2,\"1899\":1,\"1904\":1}}],[\"varchar和text类型的字段上\",{\"1\":{\"1610\":1}}],[\"varchar\",{\"1\":{\"1428\":2,\"1437\":1,\"1537\":2,\"1551\":1,\"1552\":1,\"1614\":4}}],[\"varchar与char的区别\",{\"0\":{\"1426\":1}}],[\"varchar使用的时候要指定大小\",{\"1\":{\"1425\":1}}],[\"variables查看或者设置全局变量的值\",{\"1\":{\"1574\":1}}],[\"variables\",{\"1\":{\"1407\":2,\"1409\":1,\"1569\":2,\"1574\":1,\"1577\":1,\"1578\":1,\"1768\":2,\"1771\":1}}],[\"variable=value\",{\"1\":{\"1340\":1}}],[\"variable>\",{\"1\":{\"1219\":1,\"1848\":1,\"1859\":1,\"1875\":1}}],[\"variable\",{\"1\":{\"1202\":1,\"1219\":1,\"1227\":1,\"1340\":1,\"1407\":2,\"1848\":2,\"1859\":2,\"1875\":2}}],[\"variable指明了当前\",{\"1\":{\"599\":1}}],[\"variable2\",{\"1\":{\"599\":1}}],[\"variable1\",{\"1\":{\"599\":1}}],[\"var\",{\"0\":{\"1296\":1},\"1\":{\"53\":1,\"54\":8,\"59\":44,\"359\":1,\"620\":2,\"621\":2,\"1340\":2,\"1411\":2,\"1556\":1,\"1574\":1,\"1580\":1,\"1758\":1}}],[\"v\",{\"1\":{\"29\":1,\"239\":1,\"745\":4,\"746\":4,\"747\":8,\"985\":2,\"999\":2,\"1001\":4,\"1002\":2,\"1007\":10,\"1008\":2,\"1011\":2,\"1142\":1,\"1261\":2,\"1334\":1,\"1773\":1,\"1909\":2}}],[\"^rc|awk\",{\"1\":{\"1405\":1}}],[\"^=\",{\"1\":{\"730\":1}}],[\"^~~~~~~~~~~~~~~~~~\",{\"1\":{\"234\":1}}],[\"^\",{\"1\":{\"29\":3,\"30\":1,\"59\":1}}],[\"橙色orange\",{\"1\":{\"29\":1}}],[\"橙色\",{\"1\":{\"29\":2}}],[\"解析sql词法以及语法分析\",{\"1\":{\"1881\":1}}],[\"解析器\",{\"1\":{\"1881\":2}}],[\"解析binlog日志文件\",{\"1\":{\"1772\":1}}],[\"解析0x6fffff\",{\"1\":{\"1299\":1}}],[\"解析\",{\"1\":{\"1299\":1,\"1906\":1}}],[\"解析60c0c0\",{\"1\":{\"1299\":1}}],[\"解析2001\",{\"1\":{\"1299\":1}}],[\"解压mycat包放到合适的目录下\",{\"1\":{\"1800\":1}}],[\"解压安装包\",{\"0\":{\"1396\":1}}],[\"解压看文件后缀选择相应工具\",{\"1\":{\"1263\":1}}],[\"解压\",{\"1\":{\"1261\":1}}],[\"解压缩\",{\"1\":{\"1260\":1}}],[\"解压后的\",{\"1\":{\"5\":1}}],[\"解引用\",{\"1\":{\"953\":1}}],[\"解引用只能访问基类的部分\",{\"1\":{\"678\":1}}],[\"解这道题两个关键点\",{\"1\":{\"795\":1}}],[\"解决的方案有两种\",{\"1\":{\"1717\":1}}],[\"解决死锁办法\",{\"1\":{\"1707\":1}}],[\"解决幻读\",{\"1\":{\"1686\":1}}],[\"解决不可重复读\",{\"0\":{\"1663\":1}}],[\"解决脏读\",{\"0\":{\"1658\":1,\"1662\":1}}],[\"解决哈希冲突的方式\",{\"1\":{\"1603\":1}}],[\"解决迭代器失效底层原理\",{\"0\":{\"747\":1}}],[\"解决增加问题\",{\"0\":{\"746\":1}}],[\"解决失效问题2\",{\"0\":{\"746\":1}}],[\"解决失效问题1\",{\"0\":{\"745\":1}}],[\"解决删除问题\",{\"0\":{\"745\":1}}],[\"解决方案也是用\",{\"1\":{\"765\":1}}],[\"解决方案\",{\"1\":{\"744\":1,\"948\":1}}],[\"解决方法\",{\"0\":{\"1121\":1},\"1\":{\"614\":1,\"1016\":1,\"1209\":1,\"1232\":2,\"1233\":1,\"1293\":1}}],[\"解决该问题的方式比较简单\",{\"1\":{\"652\":1}}],[\"解决大块数据或对象的传递效率和空间不如意的问题\",{\"1\":{\"617\":1}}],[\"解决办法就是将多值属性放入一个新表\",{\"1\":{\"1464\":1}}],[\"解决办法\",{\"0\":{\"1123\":1},\"1\":{\"516\":1,\"1056\":1,\"1207\":1}}],[\"解决办法大致说来也有两种\",{\"1\":{\"240\":1}}],[\"解决思路\",{\"0\":{\"384\":1}}],[\"解决强类型语言的严格性和灵活性之间的冲突\",{\"1\":{\"359\":1}}],[\"解决中文输入法问题\",{\"1\":{\"29\":2}}],[\"解释的值\",{\"1\":{\"1344\":1}}],[\"解释一下状态\",{\"0\":{\"1240\":1}}],[\"解释二\",{\"1\":{\"553\":1}}],[\"解释方式\",{\"1\":{\"317\":1,\"326\":1}}],[\"解释\",{\"1\":{\"129\":1,\"169\":1,\"177\":1}}],[\"解除typora的登录限制功能\",{\"1\":{\"59\":1}}],[\"桌面新建txt文件\",{\"1\":{\"29\":1}}],[\"点击cmake\",{\"1\":{\"1306\":1}}],[\"点击后程序直接停止运行\",{\"1\":{\"306\":1}}],[\"点击后\",{\"1\":{\"306\":1}}],[\"点击该按钮一次\",{\"1\":{\"306\":1}}],[\"点击程序设置\",{\"1\":{\"66\":1}}],[\"点\",{\"1\":{\"28\":1}}],[\"会实际影响到两张物理表\",{\"1\":{\"1892\":1}}],[\"会\",{\"1\":{\"1881\":1}}],[\"会仅仅读取前面的\",{\"1\":{\"1878\":1}}],[\"会切换到备份的写库继续工作\",{\"1\":{\"1803\":1}}],[\"会发现不是明文\",{\"1\":{\"1773\":1}}],[\"会发生精度丢失\",{\"1\":{\"340\":1}}],[\"会根据redo\",{\"1\":{\"1760\":1}}],[\"会更慢的达到刷新的时机\",{\"1\":{\"1758\":1}}],[\"会主动关闭连接\",{\"1\":{\"1754\":1}}],[\"会加上\",{\"1\":{\"1717\":1}}],[\"会出现死锁\",{\"1\":{\"1713\":1}}],[\"会给符合条件的已有数据记录的索引项加锁\",{\"1\":{\"1686\":1}}],[\"会给的非静态成员函数都加一个this指针\",{\"1\":{\"392\":1}}],[\"会把connection资源直接delete掉\",{\"1\":{\"1849\":1,\"1859\":1,\"1872\":1}}],[\"会把已经commit的数据\",{\"1\":{\"1656\":1}}],[\"会把这些小的内存块挂到\",{\"1\":{\"1105\":1}}],[\"会涉及到类型转换\",{\"1\":{\"1617\":1}}],[\"会涉及线程安全问题\",{\"1\":{\"1219\":1}}],[\"会造成索引文件的改动\",{\"1\":{\"1609\":1}}],[\"会造成sql查询时\",{\"1\":{\"1609\":1}}],[\"会造成内存泄漏\",{\"1\":{\"1040\":1}}],[\"会产生哈希冲突\",{\"1\":{\"1603\":1}}],[\"会产生二义性\",{\"1\":{\"653\":1}}],[\"会对or进行优化成union\",{\"1\":{\"1594\":1}}],[\"会对temp进行复制\",{\"1\":{\"616\":1}}],[\"会使用redo\",{\"1\":{\"1758\":1}}],[\"会使用索引\",{\"1\":{\"1592\":1}}],[\"会使得本线程挂起\",{\"1\":{\"1020\":1}}],[\"会使得我们的程序进程的\",{\"1\":{\"750\":1}}],[\"会自动给\",{\"1\":{\"1614\":1}}],[\"会自动创建一个唯一键索引\",{\"1\":{\"1521\":1}}],[\"会自动调用其析构函数\",{\"1\":{\"853\":1}}],[\"会以超级用户权限将vim编辑器中的内容写入到当前编辑的文件中\",{\"1\":{\"1410\":1}}],[\"会尝试保存当前文件\",{\"1\":{\"1410\":1}}],[\"会列出从linenum开始的源代码\",{\"1\":{\"1340\":1}}],[\"会列出functionname函数的源代码\",{\"1\":{\"1340\":1}}],[\"会打印variable的值\",{\"1\":{\"1340\":1}}],[\"会删除编号为num的断点\",{\"1\":{\"1340\":1}}],[\"会删掉所有这个值的元素\",{\"1\":{\"162\":1}}],[\"会在filename文件的linenum行设置断点\",{\"1\":{\"1340\":1}}],[\"会在函数functionname的入口处设置断点\",{\"1\":{\"1340\":1}}],[\"会继续执行\",{\"1\":{\"1318\":2}}],[\"会扫描参数\",{\"1\":{\"1299\":1}}],[\"会将variable的值设置为value\",{\"1\":{\"1340\":1}}],[\"会将main\",{\"1\":{\"1261\":1}}],[\"会将形参默认值压栈\",{\"1\":{\"906\":1}}],[\"会导致sql的执行效率低\",{\"1\":{\"1744\":1}}],[\"会导致\",{\"1\":{\"1209\":1,\"1320\":1}}],[\"会导致容器扩容\",{\"1\":{\"965\":1}}],[\"会随着cpu对线程不同的调用顺序\",{\"1\":{\"1208\":1}}],[\"会修改\",{\"1\":{\"1099\":1}}],[\"会指向下一个空闲chunk块的起始地址\",{\"1\":{\"1082\":1}}],[\"会指示编译器这部分代码按c语言\",{\"1\":{\"577\":1}}],[\"会调用派生类的show\",{\"1\":{\"906\":1}}],[\"会调用拷贝构造函数\",{\"1\":{\"398\":3}}],[\"会被刷新\",{\"1\":{\"1762\":1}}],[\"会被挂在\",{\"1\":{\"1102\":1}}],[\"会被编译器优化\",{\"1\":{\"1066\":1}}],[\"会被加入到第一个虚函数表之中\",{\"1\":{\"889\":1}}],[\"会被视为重定义\",{\"1\":{\"563\":1}}],[\"会无休止的增加开发成本\",{\"1\":{\"882\":1}}],[\"会到4字节来取一下对象的个数\",{\"1\":{\"715\":1}}],[\"会提高效率\",{\"1\":{\"638\":1}}],[\"会立即跳转到与异常相匹配的catch块中\",{\"1\":{\"608\":1}}],[\"会立刻被\",{\"1\":{\"599\":1}}],[\"会抛出异常\",{\"1\":{\"605\":1}}],[\"会抛出该异常\",{\"1\":{\"604\":6}}],[\"会抛出out\",{\"1\":{\"539\":1}}],[\"会默认按照c的链接规范进行处理\",{\"1\":{\"578\":1}}],[\"会检查下标是否越界\",{\"1\":{\"597\":1}}],[\"会检查\",{\"1\":{\"539\":1}}],[\"会引起未定义的行为\",{\"1\":{\"539\":1}}],[\"会差上4字节\",{\"0\":{\"520\":1}}],[\"会传入\",{\"1\":{\"517\":1}}],[\"会进行类型安全检查\",{\"1\":{\"497\":1}}],[\"会进行入栈操作\",{\"0\":{\"235\":1}}],[\"会多执行一次拷贝构造函数\",{\"1\":{\"465\":1}}],[\"会有专门的线程去负责把buffer\",{\"1\":{\"1762\":1}}],[\"会有专门的线程在合适的时间\",{\"1\":{\"1760\":1}}],[\"会有using\",{\"1\":{\"1566\":1}}],[\"会有来自两条不同路径的共同基类\",{\"1\":{\"653\":1}}],[\"会有内存对齐\",{\"1\":{\"435\":1}}],[\"会有一定的开销\",{\"1\":{\"22\":1}}],[\"会返回报错\",{\"1\":{\"400\":1}}],[\"会满足拷贝构造函数的用\",{\"1\":{\"399\":1}}],[\"会显示当前函数的汇编代码\",{\"1\":{\"261\":1}}],[\"会为开辟的栈帧中初始化为0xcccccccc\",{\"1\":{\"234\":1}}],[\"会剩最后一个\",{\"1\":{\"81\":1}}],[\"会看到两个json文件\",{\"1\":{\"62\":1}}],[\"会弹出打开方式选择框\",{\"1\":{\"28\":1}}],[\"+∞\",{\"1\":{\"1719\":1}}],[\"+排序\",{\"1\":{\"194\":1}}],[\"+10\",{\"1\":{\"163\":1}}],[\"++a\",{\"1\":{\"1238\":1}}],[\"++first\",{\"1\":{\"1148\":1}}],[\"++fast\",{\"1\":{\"73\":1,\"77\":1}}],[\"++rit\",{\"1\":{\"1011\":1}}],[\"++n\",{\"1\":{\"774\":1}}],[\"++运算符重载前检查有效性\",{\"1\":{\"747\":1}}],[\"++++++++++++++很重要很重要很重要很重要\",{\"1\":{\"736\":1}}],[\"++++++++++++++++++++++++++++++\",{\"1\":{\"731\":1}}],[\"++c4\",{\"1\":{\"731\":1}}],[\"++countvec\",{\"1\":{\"214\":1}}],[\"++count\",{\"1\":{\"115\":1,\"802\":2}}],[\"++k\",{\"1\":{\"202\":3}}],[\"++begin\",{\"1\":{\"179\":1}}],[\"++ptmp\",{\"1\":{\"1127\":1}}],[\"++p\",{\"1\":{\"385\":3,\"704\":3,\"751\":1}}],[\"++p2\",{\"1\":{\"110\":2}}],[\"++p1\",{\"1\":{\"110\":2}}],[\"++\",{\"1\":{\"101\":2,\"155\":1,\"166\":1,\"174\":1,\"178\":1,\"185\":1,\"224\":1,\"388\":1,\"699\":1,\"791\":3,\"792\":3,\"1001\":1,\"1086\":1}}],[\"++len\",{\"1\":{\"787\":1}}],[\"++lenb\",{\"1\":{\"771\":1}}],[\"++lena\",{\"1\":{\"771\":1}}],[\"++left\",{\"1\":{\"78\":1,\"143\":1,\"220\":2}}],[\"++loop\",{\"1\":{\"81\":1}}],[\"++son\",{\"1\":{\"194\":1}}],[\"++starty\",{\"1\":{\"81\":1}}],[\"++startx\",{\"1\":{\"81\":1}}],[\"++slow\",{\"1\":{\"73\":1}}],[\"++offset\",{\"1\":{\"81\":1}}],[\"++it2\",{\"1\":{\"966\":2}}],[\"++it1\",{\"1\":{\"966\":6,\"999\":2}}],[\"++it\",{\"1\":{\"698\":2,\"699\":1,\"704\":1,\"742\":1,\"743\":1,\"745\":1,\"746\":2,\"747\":6,\"1001\":1,\"1002\":2,\"1147\":1,\"1148\":1}}],[\"++idx\",{\"1\":{\"185\":1,\"512\":1,\"536\":1,\"547\":1,\"1031\":1}}],[\"++i\",{\"1\":{\"81\":1,\"101\":5,\"104\":1,\"115\":1,\"125\":1,\"133\":1,\"137\":1,\"141\":1,\"142\":1,\"158\":1,\"162\":1,\"166\":3,\"188\":2,\"191\":4,\"199\":1,\"202\":2,\"205\":1,\"214\":1,\"217\":1,\"355\":3,\"385\":3,\"406\":1,\"704\":5,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":6,\"751\":1,\"755\":1,\"782\":1,\"783\":1,\"792\":2,\"810\":3,\"817\":1,\"819\":1,\"966\":3,\"984\":1,\"985\":1,\"990\":1,\"991\":1,\"992\":1,\"999\":3,\"1147\":1,\"1148\":1,\"1151\":3,\"1177\":1,\"1208\":1,\"1219\":4,\"1233\":2,\"1839\":1,\"1849\":1,\"1851\":2,\"1859\":1,\"1875\":1}}],[\"++j\",{\"1\":{\"81\":1,\"137\":2,\"188\":1,\"191\":2,\"202\":2,\"217\":1}}],[\"++word\",{\"1\":{\"8\":1}}],[\"+imaname\",{\"1\":{\"60\":1}}],[\"+=\",{\"1\":{\"59\":2,\"73\":1,\"148\":1,\"149\":1,\"214\":1,\"435\":1,\"439\":1,\"730\":1,\"731\":5,\"1102\":4,\"1133\":1,\"1291\":1}}],[\"+\",{\"0\":{\"179\":1},\"1\":{\"27\":1,\"30\":1,\"45\":2,\"56\":1,\"59\":7,\"60\":4,\"61\":1,\"73\":3,\"81\":4,\"84\":2,\"96\":4,\"97\":4,\"101\":2,\"126\":1,\"129\":1,\"132\":2,\"133\":4,\"135\":2,\"136\":11,\"137\":4,\"141\":2,\"142\":5,\"143\":5,\"162\":8,\"178\":3,\"179\":1,\"185\":2,\"188\":2,\"191\":1,\"194\":4,\"199\":2,\"202\":3,\"205\":2,\"214\":2,\"217\":1,\"220\":1,\"234\":2,\"238\":1,\"246\":1,\"282\":1,\"285\":1,\"286\":4,\"345\":1,\"355\":6,\"362\":1,\"378\":1,\"385\":7,\"397\":2,\"405\":3,\"406\":6,\"422\":1,\"426\":1,\"435\":1,\"439\":1,\"459\":1,\"464\":2,\"500\":13,\"506\":1,\"535\":2,\"536\":3,\"547\":4,\"548\":3,\"562\":1,\"567\":1,\"568\":1,\"569\":1,\"570\":2,\"571\":8,\"616\":2,\"618\":2,\"638\":1,\"642\":9,\"662\":11,\"695\":2,\"699\":6,\"704\":7,\"731\":6,\"736\":7,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":6,\"751\":2,\"756\":1,\"774\":2,\"783\":2,\"787\":1,\"792\":1,\"802\":1,\"876\":2,\"894\":4,\"898\":2,\"949\":2,\"966\":5,\"990\":1,\"991\":1,\"992\":1,\"999\":3,\"1001\":2,\"1002\":1,\"1007\":2,\"1008\":1,\"1066\":1,\"1090\":11,\"1093\":1,\"1096\":1,\"1099\":3,\"1102\":5,\"1120\":3,\"1122\":4,\"1123\":12,\"1127\":8,\"1136\":1,\"1137\":1,\"1139\":2,\"1147\":1,\"1148\":4,\"1154\":2,\"1158\":1,\"1165\":1,\"1166\":2,\"1173\":2,\"1177\":1,\"1188\":1,\"1189\":2,\"1345\":2,\"1407\":18,\"1469\":1,\"1656\":1,\"1665\":1,\"1686\":1,\"1688\":1,\"1839\":2,\"1847\":2,\"1849\":2,\"1856\":2,\"1875\":2,\"1878\":2}}],[\"将js对象中数组类型直接放入map容器中\",{\"1\":{\"1909\":1}}],[\"将js对象中数组类型直接放入vector容器中\",{\"1\":{\"1909\":1}}],[\"将dict类型的数据转成str\",{\"0\":{\"1903\":1}}],[\"将单张表的数据切分到多个服务器上去\",{\"1\":{\"1890\":1}}],[\"将不常用的\",{\"1\":{\"1889\":1}}],[\"将binlog内容发送到从服务器\",{\"1\":{\"1784\":1}}],[\"将b资源的引用计数从2减为1\",{\"1\":{\"1056\":1}}],[\"将二进制日志内容发送到从服务器\",{\"1\":{\"1782\":1}}],[\"将二元函数对象转换为一元函数对象\",{\"1\":{\"1148\":1}}],[\"将二元函数对象的一个参数绑定\",{\"1\":{\"1146\":1}}],[\"将张三的余额回滚为事务执行前的状态\",{\"1\":{\"1639\":1}}],[\"将文件插入库中\",{\"1\":{\"1334\":1}}],[\"将所有警告当作错误处理\",{\"1\":{\"1327\":1}}],[\"将add目录的源文件编译成动态库\",{\"1\":{\"1315\":1}}],[\"将a资源的引用计数从2减为1\",{\"1\":{\"1056\":1}}],[\"将名为\",{\"1\":{\"1312\":1}}],[\"将ubuntu的网络设置为静态的\",{\"1\":{\"1279\":1}}],[\"将master的ip\",{\"1\":{\"1833\":1}}],[\"将main\",{\"1\":{\"1261\":1}}],[\"将mutex互斥锁释放了\",{\"1\":{\"1221\":1}}],[\"将压缩文件进行解压\",{\"1\":{\"1261\":1}}],[\"将test打包并压缩\",{\"1\":{\"1260\":1}}],[\"将file\",{\"1\":{\"1260\":1}}],[\"将互斥锁释放\",{\"1\":{\"1221\":1}}],[\"将锁封装了\",{\"1\":{\"1210\":1}}],[\"将函数的类型保存下来使用\",{\"1\":{\"1168\":1}}],[\"将当前对象this绑定上去\",{\"1\":{\"1151\":1}}],[\"将线程句柄存储起来用于等待完成\",{\"1\":{\"1151\":1}}],[\"将70按顺序插入到vec容器中\",{\"0\":{\"1148\":1},\"1\":{\"1148\":1}}],[\"将右边的资源直接窃取过来\",{\"1\":{\"1121\":2}}],[\"将参数从右往左压栈\",{\"1\":{\"1063\":1}}],[\"将id=23的age改成23\",{\"1\":{\"1682\":1}}],[\"将include添加到工程属性中的附加包含目录中\",{\"1\":{\"1029\":1}}],[\"将include整个拷贝到我们的工程目录下\",{\"1\":{\"1029\":1}}],[\"将if\",{\"1\":{\"605\":1}}],[\"将日志输出到windows事件日志中去\",{\"1\":{\"1019\":1}}],[\"将上面的反向迭代器改为常量的反向迭代器\",{\"1\":{\"1011\":1}}],[\"将上面普通的正向迭代器换为常量的正向迭代器\",{\"1\":{\"1011\":1}}],[\"将48按序插入到vector中\",{\"1\":{\"1008\":2}}],[\"将容器中所有偶数打印出来\",{\"1\":{\"1007\":1}}],[\"将数字进行去重打印\",{\"1\":{\"1001\":1}}],[\"将数据类型作为参数\",{\"1\":{\"359\":1}}],[\"将大根堆结构看作一棵树\",{\"1\":{\"994\":1}}],[\"将vfptr存的地址\",{\"1\":{\"954\":1}}],[\"将派生类对象的前4个字节\",{\"1\":{\"954\":1}}],[\"将基类base的析构函数设置为虚函数\",{\"1\":{\"949\":1}}],[\"将基类的析构函数定义为虚析构函数\",{\"1\":{\"948\":1}}],[\"将基类的对象内存清为0\",{\"1\":{\"908\":1}}],[\"将基类的10压栈\",{\"1\":{\"906\":1}}],[\"将工厂方法写成抽象工厂\",{\"1\":{\"867\":1}}],[\"将工程文件放在源码的附近\",{\"0\":{\"34\":1}}],[\"将类名设为首字母大写\",{\"1\":{\"864\":1}}],[\"将指针所指向的类的内部\",{\"1\":{\"826\":1}}],[\"将值为\",{\"1\":{\"790\":1}}],[\"将链表每个节点向右移动\",{\"1\":{\"787\":1}}],[\"将下一个结点做这个list的head压入队列\",{\"1\":{\"784\":1}}],[\"将头结点压入队列\",{\"1\":{\"784\":1}}],[\"将两个升序链表合并为一个新的\",{\"1\":{\"762\":1}}],[\"将两个排序好的⼦序列合并成⼀个最终的排序序列\",{\"1\":{\"202\":1}}],[\"将每个对象空间组织成链表\",{\"1\":{\"751\":1}}],[\"将迭代器成员变量初始化\",{\"1\":{\"747\":1}}],[\"将知道了是5个并将这块内存平均分为5份\",{\"1\":{\"715\":1}}],[\"将其参数细分\",{\"1\":{\"1189\":1}}],[\"将其函数类型留下来\",{\"1\":{\"1166\":1}}],[\"将其拷贝构造和赋值构造成为私有函数\",{\"1\":{\"848\":1,\"851\":1}}],[\"将其构造和析构成为私有的\",{\"1\":{\"848\":1,\"851\":1}}],[\"将其每一份对象起始地址传给相应的析构函数\",{\"1\":{\"715\":1}}],[\"将其转为反汇编后\",{\"1\":{\"709\":1}}],[\"将其遍历一遍\",{\"1\":{\"698\":1}}],[\"将其抽象\",{\"1\":{\"448\":1}}],[\"将会执行用户定义的派生类的拷贝构造函数或者重载赋值函数\",{\"1\":{\"662\":1}}],[\"将会引起调用的二义性\",{\"1\":{\"641\":1}}],[\"将一个事物内部的操作与其它事务的操作隔离起来\",{\"1\":{\"1644\":1}}],[\"将一个基类对象指针\",{\"1\":{\"631\":1}}],[\"将一个元素放入队列的尾部\",{\"1\":{\"182\":1}}],[\"将students表重命名为xuesheng\",{\"1\":{\"1552\":1}}],[\"将std\",{\"1\":{\"605\":1}}],[\"将src复制给dest\",{\"1\":{\"535\":1}}],[\"将catch\",{\"1\":{\"605\":1}}],[\"将自己的全局变量和全局函数放到\",{\"1\":{\"590\":1}}],[\"将new\",{\"1\":{\"520\":1}}],[\"将内联函数放入头文件\",{\"0\":{\"504\":1}}],[\"将对象的析构和内存分离开\",{\"1\":{\"384\":1}}],[\"将该块标志设为可用\",{\"1\":{\"287\":1}}],[\"将进程的虚拟地址映射到物理地址空间\",{\"1\":{\"263\":1}}],[\"将栈顶指针指向栈底\",{\"1\":{\"238\":1}}],[\"将esp指向新的栈顶\",{\"1\":{\"238\":1}}],[\"将新的栈底ebp指向原来的栈顶esp\",{\"1\":{\"238\":1}}],[\"将调用方函数站点地址压进来\",{\"1\":{\"908\":1}}],[\"将调用函数\",{\"1\":{\"238\":1}}],[\"将调用者的函数\",{\"1\":{\"235\":1}}],[\"将出栈内容\",{\"1\":{\"234\":1}}],[\"将目标内存推入栈顶\",{\"1\":{\"232\":1}}],[\"将已有序的⼦序列合并\",{\"1\":{\"202\":1}}],[\"将⼀个⼤的⽆序数组有序\",{\"1\":{\"202\":1}}],[\"将整数按位数切割成不同的数字\",{\"1\":{\"191\":1}}],[\"将各元素平方按非递减顺序排列\",{\"1\":{\"87\":1}}],[\"将1到n²按顺时针顺序填入n×n的正方形矩阵\",{\"1\":{\"81\":1}}],[\"将后缀改为\",{\"1\":{\"29\":1}}],[\"将\",{\"1\":{\"27\":1,\"383\":1,\"530\":2,\"1046\":1,\"1047\":1,\"1090\":2,\"1334\":1}}],[\"脚本开机自启\",{\"0\":{\"27\":1}}],[\"是二进制序列化的10分之一\",{\"1\":{\"1913\":1}}],[\"是json的1\",{\"1\":{\"1901\":1}}],[\"是一种轻量级的\",{\"1\":{\"1896\":1}}],[\"是一个范围条件的检索\",{\"1\":{\"1686\":1}}],[\"是一个常数\",{\"1\":{\"1521\":1}}],[\"是一个结构体变量\",{\"1\":{\"1346\":1}}],[\"是一个namespace\",{\"1\":{\"1207\":1}}],[\"是一个宏定义\",{\"1\":{\"1194\":1}}],[\"是一个\",{\"1\":{\"1162\":1}}],[\"是一个立即数\",{\"1\":{\"620\":1}}],[\"是一个函数模板\",{\"1\":{\"365\":1,\"366\":1,\"368\":1}}],[\"是一个类对象\",{\"1\":{\"240\":1}}],[\"是一个包一个包的发送\",{\"1\":{\"22\":1}}],[\"是因为可以更好访问成员变量\",{\"1\":{\"1848\":1,\"1859\":1,\"1875\":1}}],[\"是我们在单机环境下\",{\"1\":{\"1790\":1}}],[\"是查询不出来这条数据的\",{\"1\":{\"1717\":1}}],[\"是怎么解决幻读的\",{\"0\":{\"1717\":1}}],[\"是由并发控制实现的\",{\"1\":{\"1712\":1}}],[\"是由组成的\",{\"1\":{\"562\":1}}],[\"是如果使用相同的索引字段\",{\"1\":{\"1700\":1}}],[\"是会发生幻读的\",{\"1\":{\"1693\":1}}],[\"是哪个事务改的db\",{\"1\":{\"1681\":1}}],[\"是当前读\",{\"1\":{\"1665\":1}}],[\"是需要重新生成快照的\",{\"1\":{\"1656\":1}}],[\"是mysql中基于乐观锁理论实现隔离级别的方式\",{\"1\":{\"1656\":1}}],[\"是最高的事务隔离级别\",{\"1\":{\"1631\":1}}],[\"是存储引擎提高查询的数据结构\",{\"1\":{\"1608\":1}}],[\"是<\",{\"1\":{\"1573\":1}}],[\"是innodb对b+树二级索引的一个优化措施\",{\"1\":{\"1569\":1}}],[\"是满足where过滤后每个表剩余的数据的量\",{\"1\":{\"1537\":1}}],[\"是索引\",{\"1\":{\"1521\":1}}],[\"是只找前两行还是全部查找后返回第二行\",{\"1\":{\"1518\":1}}],[\"是联合主键\",{\"1\":{\"1461\":1}}],[\"是建立在关系模型基础上的数据库系统\",{\"1\":{\"1451\":1}}],[\"是要执行的sql语句\",{\"1\":{\"1376\":1}}],[\"是之前连接后返回的指针\",{\"1\":{\"1376\":1}}],[\"是数据页的数目\",{\"1\":{\"1622\":1}}],[\"是数据库的端口\",{\"1\":{\"1374\":1}}],[\"是数据库的名字\",{\"1\":{\"1374\":1}}],[\"是数组的长度\",{\"1\":{\"143\":1}}],[\"是用户的密码\",{\"1\":{\"1374\":1}}],[\"是用户定义的数据类型\",{\"1\":{\"449\":1}}],[\"是该结构体中的一个成员\",{\"1\":{\"1346\":1}}],[\"是程序中的变量\",{\"1\":{\"1345\":1}}],[\"是程序员命名的\",{\"1\":{\"583\":1}}],[\"是google\",{\"1\":{\"1913\":1}}],[\"是gdb\",{\"1\":{\"1341\":1}}],[\"是getstring返回时候调用拷贝构造返回main函数栈帧的临时对象\",{\"1\":{\"1120\":1}}],[\"是来干嘛的\",{\"1\":{\"1318\":1}}],[\"是网址的通配符\",{\"1\":{\"1239\":1}}],[\"是栈上的局部对象\",{\"1\":{\"1210\":1}}],[\"是c的bind1st和bind2nd+二元函数对象\",{\"1\":{\"1195\":1}}],[\"是char\",{\"1\":{\"1099\":1}}],[\"是运算符重载函数\",{\"1\":{\"1173\":1}}],[\"是函数对象\",{\"1\":{\"1166\":1}}],[\"是初始化还是赋值\",{\"1\":{\"1115\":1}}],[\"是逗号表达式\",{\"1\":{\"1114\":1}}],[\"是没有使用到索引\",{\"1\":{\"1776\":1}}],[\"是没有名字的\",{\"1\":{\"1110\":1,\"1111\":1}}],[\"是没有涉及到操作系统硬件资源的接口的\",{\"1\":{\"303\":1}}],[\"是什么问题\",{\"1\":{\"1056\":1}}],[\"是1为空\",{\"1\":{\"966\":1}}],[\"是虚继承\",{\"1\":{\"932\":1}}],[\"是虚拟的\",{\"1\":{\"267\":1}}],[\"是静态绑定\",{\"1\":{\"927\":1}}],[\"是在执行\",{\"1\":{\"1377\":1}}],[\"是在就需要确定好的\",{\"1\":{\"907\":1}}],[\"是在运行时期才确定的\",{\"1\":{\"907\":1}}],[\"是动态绑定\",{\"1\":{\"906\":1}}],[\"是面向对象设计语言的基本特征之一\",{\"1\":{\"881\":1}}],[\"是可以完成功能扩展的\",{\"1\":{\"831\":2}}],[\"是可以不加的\",{\"1\":{\"136\":1}}],[\"是专门用于定义重载运算符的函数的\",{\"1\":{\"727\":1}}],[\"是右值\",{\"1\":{\"620\":1}}],[\"是对目标对象的直接操作\",{\"1\":{\"619\":1}}],[\"是为了让编程简单\",{\"1\":{\"637\":1}}],[\"是为了确保在更多情况下的兼容性\",{\"1\":{\"578\":1}}],[\"是为了支持连续的operator=赋值操作\",{\"1\":{\"405\":1}}],[\"是写在cpp文件中的\",{\"1\":{\"570\":1}}],[\"是诸多安全问题的根本原因\",{\"1\":{\"536\":1}}],[\"是指程序尝试写入超出其所分配的内存范围的区域\",{\"1\":{\"531\":1}}],[\"是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象\",{\"1\":{\"448\":1}}],[\"是类作用域里的整型变量\",{\"1\":{\"410\":1}}],[\"是新增的最强大的特性之一\",{\"1\":{\"375\":1}}],[\"是无法做减法操作\",{\"1\":{\"344\":1}}],[\"是通过配置文件的方式对日志进行配置\",{\"1\":{\"1026\":1}}],[\"是通过一个\",{\"1\":{\"826\":1}}],[\"是通过\",{\"1\":{\"339\":1,\"1717\":2}}],[\"是停止执行按钮shift\",{\"1\":{\"306\":1}}],[\"是继续执行按钮\",{\"1\":{\"306\":1}}],[\"是单步执行按钮f10\",{\"1\":{\"306\":1}}],[\"是透明的\",{\"1\":{\"267\":1}}],[\"是物理的\",{\"1\":{\"267\":1}}],[\"是不确定的\",{\"1\":{\"1218\":1}}],[\"是不能够使用成员方法的\",{\"1\":{\"1151\":1}}],[\"是不能直接进行赋值的\",{\"1\":{\"1115\":1}}],[\"是不能进行比较运算的\",{\"1\":{\"741\":1}}],[\"是不是commit的时候\",{\"0\":{\"1760\":1}}],[\"是不是只要构造函数不为私有就ok\",{\"1\":{\"717\":1}}],[\"是不是快乐数\",{\"1\":{\"146\":1}}],[\"是不可以的\",{\"1\":{\"630\":1}}],[\"是不可变的\",{\"1\":{\"625\":1}}],[\"是不会出现这个错误的\",{\"1\":{\"240\":1}}],[\"是pair\",{\"1\":{\"178\":1}}],[\"是否登录成功\",{\"1\":{\"1915\":1}}],[\"是否有内存泄漏\",{\"1\":{\"1896\":1}}],[\"是否超时\",{\"1\":{\"1859\":1}}],[\"是否在\",{\"1\":{\"1656\":1}}],[\"是否越界\",{\"1\":{\"1423\":1}}],[\"是否是\",{\"1\":{\"166\":1}}],[\"是否相同\",{\"1\":{\"135\":2}}],[\"是\",{\"1\":{\"146\":1,\"311\":1,\"339\":1,\"597\":1,\"599\":1,\"632\":1,\"1315\":1,\"1334\":1}}],[\"是比较它的前一个\",{\"1\":{\"135\":1}}],[\"是判断nums\",{\"1\":{\"135\":1}}],[\"是有边界的\",{\"1\":{\"22\":1}}],[\"是流式传输\",{\"1\":{\"22\":1}}],[\"7安装protobuf3\",{\"1\":{\"1914\":1}}],[\"7版本以上\",{\"1\":{\"1796\":1}}],[\"7和8\",{\"1\":{\"1758\":1}}],[\"7优化group\",{\"0\":{\"1737\":1}}],[\"7的优化器后\",{\"1\":{\"1713\":1}}],[\"7的安装\",{\"0\":{\"1388\":1}}],[\"7过滤出的数据占了整张表的一大半\",{\"1\":{\"1690\":1}}],[\"7实际情况需要具体分析用的到底是行锁还是表锁\",{\"0\":{\"1690\":1}}],[\"7以后\",{\"1\":{\"1569\":1}}],[\"7以前\",{\"1\":{\"1569\":1}}],[\"7分析explain可以看到涉及到了外排序\",{\"1\":{\"1528\":1}}],[\"7340031\",{\"1\":{\"1299\":1}}],[\"73\",{\"1\":{\"817\":1}}],[\"70\",{\"1\":{\"1082\":1,\"1114\":2,\"1148\":6,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1}}],[\"700\",{\"1\":{\"1025\":1}}],[\"707\",{\"0\":{\"790\":1},\"1\":{\"790\":1}}],[\"704\",{\"0\":{\"84\":1},\"1\":{\"84\":1}}],[\"7558\",{\"1\":{\"239\":2}}],[\"75rem\",{\"1\":{\"51\":1}}],[\"78\",{\"1\":{\"224\":2,\"1007\":2,\"1008\":1}}],[\"76\",{\"1\":{\"101\":4}}],[\"77\",{\"1\":{\"101\":1,\"817\":1}}],[\"7\",{\"0\":{\"1378\":1,\"1393\":1,\"1394\":1,\"1395\":1,\"1397\":1,\"1424\":1,\"1502\":1,\"1527\":1,\"1528\":1,\"1600\":1,\"1750\":1},\"1\":{\"22\":1,\"29\":1,\"104\":4,\"107\":4,\"110\":2,\"129\":1,\"163\":5,\"177\":1,\"191\":1,\"234\":1,\"340\":1,\"378\":3,\"618\":1,\"747\":1,\"810\":2,\"817\":4,\"1032\":1,\"1090\":4,\"1114\":1,\"1115\":1,\"1310\":1,\"1393\":1,\"1395\":1,\"1396\":1,\"1397\":10,\"1405\":1,\"1407\":2,\"1423\":1,\"1594\":1,\"1600\":1,\"1632\":1,\"1682\":1,\"1719\":2,\"1828\":3}}],[\"也避免查询时\",{\"1\":{\"1889\":1}}],[\"也经常称为多版本数据库\",{\"1\":{\"1656\":1}}],[\"也应该能够恢复数据\",{\"1\":{\"1644\":1}}],[\"也需要考虑关闭自适应哈希索引\",{\"1\":{\"1569\":1}}],[\"也需要加上类的作用域\",{\"1\":{\"410\":1}}],[\"也减少了mysql\",{\"1\":{\"1535\":1}}],[\"也要新建一个\",{\"1\":{\"1316\":1}}],[\"也要采用\",{\"1\":{\"512\":1}}],[\"也被修改\",{\"1\":{\"1271\":1}}],[\"也只能传unique\",{\"1\":{\"1227\":1}}],[\"也\",{\"1\":{\"1047\":1}}],[\"也成为代理模式\",{\"1\":{\"989\":1}}],[\"也会写binlog\",{\"1\":{\"1781\":1}}],[\"也会有一些附带的问题\",{\"1\":{\"1745\":1}}],[\"也会对userid\",{\"1\":{\"1686\":1}}],[\"也会对这个\",{\"1\":{\"1686\":1}}],[\"也会导致容器扩容\",{\"1\":{\"965\":1}}],[\"也会很容易的想到\",{\"1\":{\"285\":1}}],[\"也仍然是虚函数\",{\"1\":{\"913\":1}}],[\"也叫晚期联编\",{\"1\":{\"883\":1}}],[\"也叫发布\",{\"1\":{\"871\":1}}],[\"也称为静态多态\",{\"1\":{\"883\":1}}],[\"也称为磁盘文件\",{\"1\":{\"17\":1}}],[\"也难免会遇到内存泄漏的问题\",{\"1\":{\"853\":1}}],[\"也存储在静态存储区\",{\"1\":{\"850\":1}}],[\"也检测不到\",{\"1\":{\"599\":2}}],[\"也即终止程序执行\",{\"1\":{\"597\":1}}],[\"也不是一瞬间就能完整\",{\"1\":{\"1761\":1}}],[\"也不会在当前事务表现出来\",{\"1\":{\"1635\":1}}],[\"也不知道到底还有没有含有zhang的数据\",{\"1\":{\"1591\":1}}],[\"也不能反祖\",{\"1\":{\"1486\":1}}],[\"也不能被转换为const\",{\"1\":{\"490\":1}}],[\"也不要在头文件中定义函数\",{\"1\":{\"574\":1}}],[\"也不应该知道函数是否需要内联\",{\"1\":{\"504\":1}}],[\"也在本行销毁\",{\"1\":{\"459\":1}}],[\"也有只影响当前session的变量\",{\"1\":{\"1577\":1}}],[\"也有可能失败\",{\"1\":{\"1057\":1}}],[\"也有声明\",{\"1\":{\"456\":1}}],[\"也有许多不同点\",{\"1\":{\"449\":1}}],[\"也没有参数\",{\"1\":{\"425\":1}}],[\"也可直接写0\",{\"1\":{\"1374\":1}}],[\"也可以是他们的\",{\"1\":{\"1899\":1}}],[\"也可以是指系统中可用内存不足\",{\"1\":{\"531\":1}}],[\"也可以创建新的用户进行连接\",{\"1\":{\"1799\":1}}],[\"也可以找到mysql的配置文件\",{\"1\":{\"1750\":1}}],[\"也可以提高导入的效率\",{\"1\":{\"1731\":1}}],[\"也可以授予多个权限只回收部分权限\",{\"1\":{\"1486\":1}}],[\"也可以成功\",{\"1\":{\"1333\":1}}],[\"也可以不写\",{\"1\":{\"1318\":1}}],[\"也可以不预先指定大小\",{\"1\":{\"354\":1}}],[\"也可以说function是对一个函数\",{\"1\":{\"1166\":1}}],[\"也可以留下\",{\"1\":{\"1165\":1}}],[\"也可以给其它字节数使用\",{\"1\":{\"1105\":1}}],[\"也可以\",{\"1\":{\"1011\":1}}],[\"也可以队头入\",{\"1\":{\"968\":1}}],[\"也可以在工厂方法中使用管理\",{\"1\":{\"864\":1}}],[\"也可以通过binlog记录的时间得到需要恢复的区间\",{\"1\":{\"1774\":1}}],[\"也可以通过set命令修改cmake\",{\"1\":{\"1317\":1}}],[\"也可以通过\",{\"1\":{\"695\":2}}],[\"也可以通过申请动态内存给指针初始化\",{\"1\":{\"455\":1}}],[\"也可以完成指针之间的转换\",{\"1\":{\"629\":1}}],[\"也可以有多级指针\",{\"1\":{\"619\":1}}],[\"也可以发生在\",{\"1\":{\"600\":1}}],[\"也可以像数组一样被操作\",{\"1\":{\"354\":1}}],[\"也可以查看符号表信息\",{\"1\":{\"248\":1}}],[\"也可以g++\",{\"1\":{\"244\":1}}],[\"也可能是\",{\"1\":{\"146\":1}}],[\"也必须为它可能用到的一些临时变量分配空间\",{\"1\":{\"235\":1}}],[\"也是左闭右开区间\",{\"1\":{\"1774\":1}}],[\"也是提高数据库性能的一种方式\",{\"1\":{\"1569\":1}}],[\"也是只能等值查询\",{\"1\":{\"1569\":1}}],[\"也是tab键\",{\"1\":{\"1410\":1}}],[\"也是最常用的\",{\"1\":{\"1026\":1}}],[\"也是静态绑定\",{\"1\":{\"927\":1}}],[\"也是\",{\"1\":{\"709\":1}}],[\"也是容器\",{\"1\":{\"698\":1}}],[\"也是对每个定义做一份拷贝\",{\"1\":{\"504\":1}}],[\"也是计算的唯一形式\",{\"1\":{\"445\":1}}],[\"也是将main的栈底重新赋值给ebp\",{\"1\":{\"238\":1}}],[\"也是栈的大小\",{\"1\":{\"224\":1}}],[\"也是可通过的\",{\"1\":{\"169\":1}}],[\"也是有好处的\",{\"1\":{\"22\":1}}],[\"也就是进入队列了\",{\"1\":{\"1859\":1}}],[\"也就是mysql\",{\"1\":{\"1792\":1}}],[\"也就是所有已提交的和未提交的事务中最大的事务\",{\"1\":{\"1656\":1}}],[\"也就是可重复读隔离级别下\",{\"1\":{\"1635\":1}}],[\"也就是消费者线程\",{\"1\":{\"1221\":1}}],[\"也就是函数对象\",{\"1\":{\"1154\":2}}],[\"也就是函数参数指定的大小+内存控制块的大小\",{\"1\":{\"286\":1}}],[\"也就是一个小的内存池了\",{\"1\":{\"1102\":1}}],[\"也就是即将被分配出去的首地址\",{\"1\":{\"1102\":1}}],[\"也就是不管分配多少字节的内存\",{\"1\":{\"1102\":1}}],[\"也就是多个对象\",{\"1\":{\"871\":1}}],[\"也就是多个对象都依赖一个对象\",{\"1\":{\"871\":1}}],[\"也就是throw后接的表达式类型\",{\"1\":{\"608\":1}}],[\"也就是我们常说的程序崩溃\",{\"1\":{\"597\":1}}],[\"也就是在overload\",{\"1\":{\"528\":1}}],[\"也就是\",{\"1\":{\"310\":1,\"866\":1,\"1096\":1,\"1656\":1}}],[\"也就是4g\",{\"1\":{\"308\":1}}],[\"也就是1m\",{\"1\":{\"308\":1}}],[\"也就是堆中最后一个内存块的末地址\",{\"1\":{\"286\":1}}],[\"也就是堆中的第一个内存块\",{\"1\":{\"286\":1}}],[\"也就是将堆分成了很多大小不一的内存块\",{\"1\":{\"285\":1}}],[\"也就是说可以减少维护数据一致性的工作\",{\"1\":{\"1464\":1}}],[\"也就是说内存有一个数据读到cpu\",{\"1\":{\"1232\":1}}],[\"也就是说如果函数的对象或者基类对象的引用或者基类对象的指针类型\",{\"1\":{\"678\":1}}],[\"也就是说此时函数中对形参的各种操作实际上是对实参本身进行操作\",{\"1\":{\"615\":1}}],[\"也就是说在编译的时候就确定了\",{\"1\":{\"378\":1}}],[\"也就是说\",{\"1\":{\"283\":1,\"1688\":1,\"1689\":1}}],[\"也就是说函数返回的指针是指向堆里面的一块内存\",{\"1\":{\"282\":1}}],[\"也就是动态链接库\",{\"1\":{\"267\":1}}],[\"也就是只有\",{\"1\":{\"182\":1}}],[\"也就是变化的区间在\",{\"1\":{\"147\":1}}],[\"也就是类似于数组的连续存储\",{\"1\":{\"91\":1}}],[\"也指定右键菜单新建相应选项名为\",{\"1\":{\"44\":1}}],[\"首位置添加一个student\",{\"1\":{\"1552\":1}}],[\"首先配置主从复制的时候\",{\"1\":{\"1830\":1}}],[\"首先slave开始一个工作线程\",{\"1\":{\"1784\":1}}],[\"首先需要\",{\"1\":{\"1776\":1}}],[\"首先根据条件取出排序字段和行指针信息\",{\"1\":{\"1736\":1}}],[\"首先开启一个事务\",{\"1\":{\"1699\":1}}],[\"首先事务1需要给表的第10行数据加x锁\",{\"1\":{\"1673\":1}}],[\"首先事务b查询余额\",{\"1\":{\"1639\":1}}],[\"首先明确的是\",{\"1\":{\"1426\":1}}],[\"首先在系统终端中查看mysql的依赖项\",{\"1\":{\"1405\":1}}],[\"首先\",{\"1\":{\"1250\":1,\"1410\":1,\"1586\":1}}],[\"首先消费者线程拿到互斥锁\",{\"1\":{\"1221\":1}}],[\"首先申请空间\",{\"1\":{\"1127\":1}}],[\"首先释放数组中的有效元素\",{\"1\":{\"1127\":1}}],[\"首先释放自己占有的外部资源\",{\"1\":{\"736\":1}}],[\"首先要在main函数栈帧\",{\"1\":{\"1115\":1}}],[\"首先要执行所有基类的构造函数\",{\"1\":{\"651\":1}}],[\"首先调用基类构造\",{\"1\":{\"908\":1}}],[\"首先调用基类的构造\",{\"1\":{\"908\":1}}],[\"首先将其作用域设置为局部而不是全局\",{\"1\":{\"593\":1}}],[\"首先来看一下string类型常用的构造函数\",{\"1\":{\"537\":1}}],[\"首先我们需要知道mysql主要是从以下3个方面进行优化\",{\"1\":{\"1743\":1}}],[\"首先我们先不考虑虚继承\",{\"1\":{\"937\":1}}],[\"首先我们先来看一下常量\",{\"1\":{\"323\":1}}],[\"首先我们编写源代码f\",{\"1\":{\"310\":1}}],[\"首先我们可以想到\",{\"1\":{\"95\":1}}],[\"首先实用为主\",{\"1\":{\"6\":1}}],[\"首部在没有使用选项字段时是20个字节\",{\"1\":{\"22\":1}}],[\"要修改这张表\",{\"1\":{\"1713\":1}}],[\"要禁止虚读产生\",{\"1\":{\"1677\":1}}],[\"要禁止幻读产生\",{\"1\":{\"1631\":1}}],[\"要么就是stop\",{\"1\":{\"1830\":1}}],[\"要么stop\",{\"1\":{\"1830\":1}}],[\"要么等待\",{\"1\":{\"1706\":1}}],[\"要么全部满足\",{\"1\":{\"1706\":1}}],[\"要么全部成功\",{\"1\":{\"1649\":1}}],[\"要么全部失败\",{\"1\":{\"1649\":2}}],[\"要么全不执行\",{\"1\":{\"1644\":1}}],[\"要么全执行\",{\"1\":{\"1644\":1}}],[\"要么显式定义了一个\",{\"1\":{\"459\":1}}],[\"要彻底解决幻读\",{\"1\":{\"1635\":1}}],[\"要给userid加索引\",{\"1\":{\"1586\":1}}],[\"要是不使用间隙锁\",{\"1\":{\"1686\":1}}],[\"要是在不同的分区操作\",{\"1\":{\"1569\":1}}],[\"要是各个线程在同一个分区\",{\"1\":{\"1569\":1}}],[\"要是没有分配成功则返回null\",{\"1\":{\"286\":1}}],[\"要看where过滤时有没有用到\",{\"1\":{\"1537\":1}}],[\"要看派生类是用class定义的还是struct定义的\",{\"1\":{\"659\":1}}],[\"要对多条记录的同样的数据进行更新删除\",{\"1\":{\"1459\":1}}],[\"要检查的内存地址\",{\"1\":{\"1347\":1}}],[\"要区分的\",{\"1\":{\"1194\":1}}],[\"要调用delete\",{\"1\":{\"1114\":1}}],[\"要调用delete才析构对象\",{\"1\":{\"1114\":1}}],[\"要加上库文件\",{\"1\":{\"1030\":1}}],[\"要先进行query\",{\"1\":{\"970\":1}}],[\"要考虑派生类b的内存布局时\",{\"1\":{\"937\":1}}],[\"要使用this指针\",{\"1\":{\"924\":1}}],[\"要成为虚函数\",{\"1\":{\"875\":1}}],[\"要不就是操控空指针\",{\"1\":{\"771\":1}}],[\"要达到以上的效果\",{\"1\":{\"717\":1}}],[\"要为函数的每个参数给定对应的实参\",{\"1\":{\"637\":1}}],[\"要转成指针看\",{\"1\":{\"625\":1}}],[\"要注意以下几点\",{\"1\":{\"612\":1}}],[\"要注意是否需要修改属性\",{\"1\":{\"101\":1}}],[\"要保证程序是安全的\",{\"0\":{\"597\":1}}],[\"要在此处引用\",{\"1\":{\"574\":1}}],[\"要4的整数倍\",{\"1\":{\"557\":1}}],[\"要记得采用\",{\"1\":{\"512\":1}}],[\"要从原理上解释\",{\"1\":{\"502\":1}}],[\"要比读一条等价的条件表达式并解释它的含义要容易得多\",{\"1\":{\"500\":1}}],[\"要放在里面\",{\"1\":{\"435\":1}}],[\"要放在实现文件里面\",{\"1\":{\"435\":1}}],[\"要算上\",{\"1\":{\"405\":1}}],[\"要求一个类只能创建堆对象\",{\"0\":{\"718\":1}}],[\"要求一个类\",{\"0\":{\"717\":1}}],[\"要求基类函数\",{\"1\":{\"693\":1}}],[\"要求\",{\"1\":{\"377\":1}}],[\"要释放的内存块首地址\",{\"1\":{\"287\":1}}],[\"要确保了移动最少元素\",{\"1\":{\"78\":1}}],[\"要展现的文字\",{\"1\":{\"56\":1}}],[\"要实现这么多控制所以tcp首部长度较长\",{\"1\":{\"22\":1}}],[\"要写上最优联系时间\",{\"1\":{\"0\":1}}],[\"46a5eb2d893d4b059475252bb4a70b69\",{\"1\":{\"1776\":1}}],[\"46e8\",{\"1\":{\"509\":1}}],[\"4k\",{\"1\":{\"1622\":2}}],[\"4字节时\",{\"1\":{\"1622\":1}}],[\"4nf\",{\"0\":{\"1464\":1}}],[\"4xb\",{\"1\":{\"1348\":1}}],[\"43\",{\"1\":{\"1007\":2,\"1008\":1}}],[\"44\",{\"1\":{\"966\":2,\"1278\":1}}],[\"444\",{\"1\":{\"497\":1}}],[\"4ch为当前函数开辟栈帧\",{\"1\":{\"908\":1}}],[\"4ch\",{\"1\":{\"908\":1}}],[\"4cb4\",{\"1\":{\"479\":1}}],[\"4aa5\",{\"1\":{\"636\":1}}],[\"4aaf\",{\"1\":{\"473\":1}}],[\"42\",{\"1\":{\"1007\":2,\"1008\":1}}],[\"4269\",{\"1\":{\"636\":1}}],[\"4294967296个\",{\"1\":{\"308\":1}}],[\"472f\",{\"1\":{\"597\":1}}],[\"4f9d\",{\"1\":{\"479\":1}}],[\"49d2\",{\"1\":{\"473\":1}}],[\"4静态的数据成员不占类的大小\",{\"1\":{\"435\":1,\"439\":1}}],[\"4和\",{\"1\":{\"435\":1}}],[\"4>\",{\"1\":{\"371\":2}}],[\"402653184\",{\"1\":{\"1752\":1}}],[\"40m\",{\"1\":{\"1282\":1}}],[\"4096\",{\"1\":{\"1271\":5}}],[\"400\",{\"1\":{\"497\":1,\"1025\":1}}],[\"40\",{\"1\":{\"368\":1,\"413\":1,\"511\":1,\"557\":1,\"638\":2,\"821\":2,\"1113\":1,\"1114\":2}}],[\"4byte\",{\"1\":{\"339\":1}}],[\"4ebd\",{\"1\":{\"601\":1}}],[\"4e0\",{\"1\":{\"338\":1}}],[\"4e\",{\"1\":{\"338\":1}}],[\"4个字节有libc\",{\"1\":{\"1622\":1}}],[\"4个字节\",{\"1\":{\"308\":1,\"934\":1}}],[\"41ec0262\",{\"1\":{\"509\":1}}],[\"41\",{\"1\":{\"239\":2}}],[\"4582\",{\"1\":{\"1820\":1}}],[\"456\",{\"1\":{\"349\":1}}],[\"45\",{\"1\":{\"101\":4,\"966\":2}}],[\"4544e7fbc99146958a485af81a2458cc\",{\"1\":{\"63\":1}}],[\"48dg\",{\"1\":{\"1142\":1}}],[\"48ed\",{\"1\":{\"500\":1}}],[\"48\",{\"1\":{\"101\":4,\"371\":1,\"1008\":4}}],[\"4rem\",{\"1\":{\"51\":1}}],[\"4\",{\"0\":{\"1197\":1,\"1221\":1,\"1228\":1,\"1375\":1,\"1493\":1,\"1497\":1,\"1580\":1,\"1665\":1,\"1800\":1,\"1907\":1,\"1908\":1},\"1\":{\"22\":1,\"29\":1,\"50\":1,\"104\":8,\"107\":2,\"110\":1,\"129\":5,\"163\":1,\"169\":5,\"182\":1,\"199\":1,\"234\":1,\"264\":1,\"323\":2,\"371\":3,\"378\":5,\"434\":1,\"439\":1,\"455\":1,\"458\":6,\"459\":3,\"463\":2,\"464\":1,\"500\":3,\"506\":1,\"515\":1,\"517\":2,\"548\":1,\"553\":1,\"616\":1,\"618\":1,\"638\":2,\"642\":1,\"730\":1,\"747\":1,\"756\":1,\"802\":1,\"810\":2,\"830\":1,\"857\":1,\"889\":1,\"953\":1,\"965\":1,\"966\":1,\"968\":1,\"969\":1,\"970\":1,\"973\":2,\"974\":1,\"990\":1,\"991\":1,\"992\":1,\"1007\":2,\"1008\":1,\"1082\":1,\"1090\":1,\"1102\":1,\"1114\":1,\"1115\":1,\"1168\":3,\"1238\":1,\"1310\":1,\"1407\":1,\"1424\":1,\"1507\":1,\"1537\":4,\"1552\":4,\"1719\":2,\"1735\":1,\"1736\":2,\"1773\":1,\"1904\":1,\"1908\":1,\"1915\":1}}],[\"uroot\",{\"1\":{\"1774\":2}}],[\"ur\",{\"1\":{\"1738\":2}}],[\"url=\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"url4\",{\"1\":{\"1250\":1}}],[\"url3\",{\"1\":{\"1250\":1}}],[\"url2\",{\"1\":{\"1250\":1}}],[\"url1\",{\"1\":{\"1250\":1}}],[\"url\",{\"1\":{\"1248\":1,\"1252\":1,\"1254\":2,\"1256\":1}}],[\"uid有索引\",{\"1\":{\"1623\":1}}],[\"uid+cid\",{\"1\":{\"1610\":1}}],[\"uid<5\",{\"1\":{\"1563\":1}}],[\"uid=5\",{\"1\":{\"1563\":1,\"1623\":1}}],[\"uid=b\",{\"1\":{\"1540\":1,\"1541\":2,\"1543\":1,\"1544\":2}}],[\"uid=a\",{\"1\":{\"1537\":1}}],[\"uid=c\",{\"1\":{\"1537\":1}}],[\"uid=1\",{\"1\":{\"1537\":4}}],[\"uid\",{\"1\":{\"1415\":3,\"1537\":10,\"1538\":3,\"1540\":1,\"1541\":2,\"1543\":1,\"1544\":5,\"1564\":1}}],[\"uint64\",{\"1\":{\"1378\":1}}],[\"util\",{\"1\":{\"1361\":1,\"1365\":1}}],[\"utf\",{\"1\":{\"60\":1,\"572\":1}}],[\"ubuntu下protobuf安装使用\",{\"1\":{\"1914\":1}}],[\"ubuntu20\",{\"0\":{\"1394\":1}}],[\"ubuntu18\",{\"0\":{\"1393\":1,\"1404\":1},\"1\":{\"1393\":1,\"1394\":1}}],[\"ubuntu\",{\"1\":{\"1284\":11,\"1820\":6,\"1914\":1},\"2\":{\"1297\":1}}],[\"u或\",{\"1\":{\"1237\":1}}],[\"uncommi\",{\"0\":{\"1633\":1}}],[\"uncommitted隔离级别\",{\"1\":{\"1633\":1}}],[\"uncommitted\",{\"1\":{\"1631\":1}}],[\"unable\",{\"0\":{\"1295\":1}}],[\"unzip\",{\"1\":{\"1262\":1}}],[\"unzip命令处理\",{\"0\":{\"1262\":1}}],[\"until\",{\"1\":{\"1207\":1}}],[\"unlock可以把mtx给释放掉\",{\"1\":{\"1227\":1}}],[\"unlock\",{\"1\":{\"1096\":1,\"1209\":3,\"1210\":1,\"1219\":1,\"1225\":1,\"1226\":1,\"1671\":1}}],[\"unlimited\",{\"1\":{\"239\":6,\"1338\":3}}],[\"unknow\",{\"1\":{\"871\":3}}],[\"unknown\",{\"1\":{\"601\":6}}],[\"universe\",{\"1\":{\"1284\":8}}],[\"universal\",{\"1\":{\"1131\":1,\"1289\":1}}],[\"uniq\",{\"1\":{\"1238\":2}}],[\"unique保证索引不重复\",{\"1\":{\"1434\":1}}],[\"unique\",{\"0\":{\"1047\":1,\"1211\":1,\"1212\":1,\"1227\":1},\"1\":{\"830\":3,\"848\":2,\"849\":1,\"864\":3,\"866\":4,\"867\":6,\"1042\":1,\"1047\":6,\"1060\":5,\"1202\":1,\"1219\":3,\"1220\":1,\"1227\":1,\"1437\":1,\"1551\":1,\"1614\":2,\"1730\":2,\"1848\":1,\"1849\":4,\"1859\":4,\"1863\":1,\"1869\":1,\"1870\":1,\"1872\":2,\"1875\":2}}],[\"unicode\",{\"1\":{\"572\":1}}],[\"unix下gcc编译器\",{\"1\":{\"1071\":1}}],[\"unix\",{\"1\":{\"301\":4,\"1237\":2,\"1334\":1,\"1374\":2,\"1427\":1,\"1443\":1}}],[\"unix和c语言的发展史\",{\"0\":{\"301\":1}}],[\"union连接的两个select查询\",{\"1\":{\"1618\":1}}],[\"union默认去重\",{\"1\":{\"1514\":1}}],[\"union\",{\"0\":{\"1514\":1},\"1\":{\"296\":1,\"555\":1,\"1082\":2,\"1502\":2,\"1514\":2,\"1618\":3,\"1739\":1}}],[\"undo\",{\"0\":{\"1677\":1,\"1678\":1,\"1679\":1,\"1680\":1,\"1681\":1,\"1682\":1,\"1761\":1},\"1\":{\"1645\":1,\"1656\":1,\"1679\":2,\"1680\":1,\"1757\":1,\"1758\":1,\"1761\":1,\"1881\":1}}],[\"undisplay\",{\"1\":{\"1341\":2}}],[\"und\",{\"1\":{\"246\":2}}],[\"underlying\",{\"1\":{\"1080\":1}}],[\"underlines\",{\"1\":{\"51\":1}}],[\"underline\",{\"1\":{\"48\":1,\"50\":2}}],[\"underflow\",{\"1\":{\"604\":1}}],[\"undefined\",{\"1\":{\"59\":1}}],[\"unordered\",{\"0\":{\"171\":1},\"1\":{\"104\":2,\"107\":2,\"110\":4,\"125\":1,\"129\":1,\"137\":1,\"141\":1,\"149\":1,\"153\":1,\"154\":1,\"158\":1,\"170\":2,\"171\":2,\"178\":1,\"871\":1,\"999\":8,\"1000\":10,\"1001\":2}}],[\"unsigned\",{\"1\":{\"101\":1,\"296\":1,\"1374\":2,\"1380\":1,\"1382\":1,\"1437\":1,\"1537\":7,\"1551\":1,\"1839\":1,\"1846\":1,\"1847\":1,\"1848\":1,\"1856\":2,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"ulimit\",{\"1\":{\"1338\":3}}],[\"ul\",{\"1\":{\"59\":2}}],[\"u\",{\"1\":{\"48\":2,\"239\":1,\"572\":8,\"1255\":1,\"1282\":1,\"1347\":1,\"1397\":1,\"1403\":1,\"1408\":1,\"1738\":2,\"1774\":1,\"1836\":6}}],[\"us\",{\"1\":{\"1255\":1}}],[\"usr\",{\"1\":{\"234\":1,\"312\":1,\"1015\":2,\"1016\":4,\"1030\":1,\"1133\":1,\"1291\":1,\"1305\":1,\"1306\":1,\"1332\":3,\"1399\":1,\"1800\":2,\"1820\":6,\"1856\":1}}],[\"use\",{\"1\":{\"1056\":6,\"1057\":5,\"1079\":1,\"1080\":1,\"1102\":1,\"1377\":1,\"1407\":1,\"1506\":1,\"1507\":1,\"1847\":1,\"1856\":1}}],[\"usedpicnames\",{\"1\":{\"60\":6}}],[\"user>\",{\"1\":{\"1888\":1,\"1891\":1}}],[\"userdb\",{\"1\":{\"1891\":1}}],[\"userdb1对应mytest1\",{\"1\":{\"1888\":1}}],[\"userdb1\",{\"1\":{\"1888\":1}}],[\"userdb2对应mytest2\",{\"1\":{\"1888\":1}}],[\"userdb2\",{\"1\":{\"1888\":1}}],[\"userdb2这两个逻辑库\",{\"1\":{\"1888\":1}}],[\"userdb2<\",{\"1\":{\"1888\":1}}],[\"userdb是给客户端操作的逻辑库\",{\"1\":{\"1802\":1}}],[\"username=root\",{\"1\":{\"1844\":1,\"1878\":1}}],[\"username\",{\"1\":{\"1839\":4,\"1848\":1,\"1849\":4,\"1859\":3,\"1875\":5,\"1878\":1}}],[\"user表示一个普通的表\",{\"1\":{\"1891\":1}}],[\"user表和数据全部恢复出来了\",{\"1\":{\"1836\":1}}],[\"user表中设置一下密码\",{\"1\":{\"1826\":1}}],[\"user捞出来在从库执行这个sql\",{\"1\":{\"1830\":1}}],[\"user`\",{\"1\":{\"1729\":1}}],[\"userid\",{\"1\":{\"1686\":3}}],[\"user=\",{\"1\":{\"1407\":1,\"1825\":1,\"1829\":1,\"1888\":2,\"1891\":2}}],[\"user=username\",{\"1\":{\"1254\":1}}],[\"user是用户名\",{\"1\":{\"1374\":1}}],[\"user\",{\"1\":{\"48\":1,\"49\":1,\"51\":1,\"63\":1,\"239\":1,\"312\":1,\"1255\":2,\"1374\":1,\"1407\":4,\"1415\":2,\"1437\":1,\"1447\":10,\"1469\":1,\"1475\":3,\"1478\":1,\"1480\":4,\"1508\":1,\"1511\":9,\"1512\":1,\"1513\":2,\"1514\":3,\"1515\":4,\"1516\":3,\"1523\":4,\"1525\":3,\"1526\":3,\"1539\":6,\"1543\":1,\"1544\":1,\"1551\":4,\"1581\":2,\"1671\":2,\"1686\":2,\"1688\":1,\"1689\":1,\"1693\":1,\"1738\":12,\"1803\":1,\"1821\":3,\"1830\":1,\"1836\":6,\"1846\":1,\"1847\":2,\"1851\":2,\"1856\":4,\"1878\":1,\"1888\":2,\"1891\":3}}],[\"using编译指令\",{\"0\":{\"588\":1},\"1\":{\"588\":1,\"594\":2}}],[\"using声明机制的作用域是从using语句开始\",{\"1\":{\"590\":1}}],[\"using声明机制👍\",{\"0\":{\"590\":1}}],[\"using声明机制\",{\"1\":{\"587\":1,\"590\":1,\"594\":1}}],[\"using\",{\"1\":{\"8\":2,\"11\":2,\"101\":4,\"104\":5,\"107\":5,\"110\":5,\"118\":3,\"163\":1,\"185\":2,\"188\":7,\"191\":3,\"194\":4,\"199\":2,\"202\":1,\"205\":2,\"214\":3,\"217\":2,\"220\":2,\"224\":2,\"267\":1,\"378\":3,\"405\":1,\"406\":1,\"433\":2,\"434\":2,\"459\":2,\"468\":2,\"476\":1,\"497\":2,\"500\":2,\"506\":2,\"515\":2,\"536\":1,\"547\":3,\"548\":2,\"557\":2,\"569\":2,\"571\":2,\"588\":2,\"590\":4,\"592\":1,\"594\":10,\"597\":1,\"599\":1,\"601\":4,\"602\":3,\"605\":1,\"606\":1,\"618\":2,\"633\":2,\"642\":2,\"662\":4,\"731\":1,\"736\":1,\"751\":1,\"810\":2,\"817\":4,\"819\":2,\"821\":2,\"830\":1,\"831\":1,\"832\":1,\"871\":1,\"889\":2,\"891\":2,\"894\":2,\"953\":1,\"984\":1,\"1020\":1,\"1031\":3,\"1032\":8,\"1041\":1,\"1055\":1,\"1060\":1,\"1115\":1,\"1123\":1,\"1147\":1,\"1148\":1,\"1151\":2,\"1154\":1,\"1155\":1,\"1158\":4,\"1168\":1,\"1183\":2,\"1188\":1,\"1207\":1,\"1209\":1,\"1219\":1,\"1233\":1,\"1600\":1,\"1618\":2,\"1736\":3,\"1839\":5,\"1846\":1,\"1847\":2,\"1848\":9,\"1849\":2,\"1856\":5,\"1859\":12,\"1875\":11,\"1878\":7,\"1901\":1,\"1915\":1}}],[\"upgrade\",{\"1\":{\"1284\":1,\"1397\":1}}],[\"update等写操作\",{\"1\":{\"1790\":1}}],[\"update找到了id=24的数据\",{\"1\":{\"1665\":1}}],[\"update这些操作\",{\"1\":{\"1656\":1,\"1665\":1}}],[\"update语句通常都要添加where子句\",{\"1\":{\"1479\":1}}],[\"update修改\",{\"0\":{\"1478\":1}}],[\"updates\",{\"1\":{\"1284\":2}}],[\"update\",{\"0\":{\"1296\":1},\"1\":{\"1016\":1,\"1284\":2,\"1295\":1,\"1296\":1,\"1384\":1,\"1393\":1,\"1397\":1,\"1407\":2,\"1469\":1,\"1478\":1,\"1485\":1,\"1486\":1,\"1492\":2,\"1548\":1,\"1635\":1,\"1656\":1,\"1665\":2,\"1686\":1,\"1698\":1,\"1700\":1,\"1701\":1,\"1717\":2,\"1718\":1,\"1772\":1,\"1846\":2,\"1847\":2,\"1851\":2,\"1856\":5,\"1878\":1}}],[\"upper\",{\"1\":{\"162\":1,\"163\":2}}],[\"upadjust\",{\"1\":{\"121\":1}}],[\"up\",{\"1\":{\"29\":2,\"1076\":2,\"1090\":2,\"1096\":2,\"1102\":1}}],[\"udp\",{\"1\":{\"22\":1,\"1237\":1}}],[\"udp支持一对一\",{\"1\":{\"22\":1}}],[\"udp既然没那么多控制功能\",{\"1\":{\"22\":1}}],[\"udp首部只有8个字节\",{\"1\":{\"22\":1}}],[\"udp则没有\",{\"1\":{\"22\":1}}],[\"udp的数据大小如果大于mtu大小\",{\"1\":{\"22\":1}}],[\"3b\",{\"1\":{\"1878\":2}}],[\"3d\",{\"1\":{\"1878\":1}}],[\"3m\",{\"1\":{\"1820\":1}}],[\"39\",{\"1\":{\"1820\":1}}],[\"367\",{\"1\":{\"1820\":1}}],[\"36\",{\"1\":{\"1774\":1}}],[\"3624224\",{\"1\":{\"1299\":1}}],[\"3nf\",{\"0\":{\"1462\":1}}],[\"3海量数据\",{\"0\":{\"1001\":1}}],[\"35\",{\"1\":{\"819\":2,\"1282\":1}}],[\"33060\",{\"1\":{\"1820\":1}}],[\"3306\",{\"1\":{\"1238\":1,\"1374\":1,\"1383\":1,\"1384\":1,\"1385\":1,\"1820\":2,\"1828\":1,\"1839\":1,\"1848\":1,\"1851\":3,\"1856\":1,\"1859\":1,\"1875\":1,\"1878\":2,\"1888\":2,\"1891\":2}}],[\"33\",{\"1\":{\"819\":2,\"1282\":1,\"1856\":1,\"1878\":1}}],[\"333\",{\"1\":{\"459\":1,\"497\":1,\"547\":1}}],[\"3等去近似一个小数的\",{\"1\":{\"339\":1}}],[\"31\",{\"1\":{\"338\":2,\"1007\":2,\"1008\":1,\"1773\":1,\"1796\":1}}],[\"314e1\",{\"1\":{\"338\":2}}],[\"3e\",{\"1\":{\"338\":1}}],[\"320\",{\"1\":{\"1102\":1}}],[\"32\",{\"0\":{\"1397\":1},\"1\":{\"547\":1,\"557\":1,\"1282\":1,\"1396\":1,\"1397\":10,\"1774\":1}}],[\"32bit\",{\"1\":{\"285\":1,\"339\":1}}],[\"32位\",{\"1\":{\"1347\":1}}],[\"32位为4\",{\"1\":{\"535\":1}}],[\"32位的cpu\",{\"1\":{\"308\":1}}],[\"32位操作系统只是改变这个编号的长短\",{\"1\":{\"308\":1}}],[\"32位中为12\",{\"1\":{\"285\":1}}],[\"32位系统\",{\"1\":{\"283\":1}}],[\"30分钟\",{\"1\":{\"1754\":1}}],[\"3034373b35e141b6aac48e4e377c245e\",{\"1\":{\"1664\":1}}],[\"30个人围成一圆圈\",{\"1\":{\"811\":1}}],[\"300\",{\"1\":{\"497\":1,\"1025\":1,\"1155\":1,\"1166\":1}}],[\"30000\",{\"1\":{\"59\":1}}],[\"30出现\",{\"1\":{\"485\":1}}],[\"30\",{\"1\":{\"301\":2,\"368\":1,\"412\":1,\"480\":1,\"483\":4,\"484\":6,\"614\":1,\"621\":1,\"622\":1,\"638\":2,\"678\":1,\"731\":1,\"821\":1,\"943\":1,\"999\":1,\"1040\":1,\"1045\":1,\"1111\":2,\"1112\":4,\"1113\":3,\"1114\":4,\"1154\":1,\"1165\":1,\"1173\":2,\"1271\":1,\"1384\":1}}],[\"30k\",{\"1\":{\"283\":1}}],[\"384m\",{\"1\":{\"1752\":1}}],[\"38\",{\"1\":{\"234\":1}}],[\"383\",{\"0\":{\"174\":1},\"1\":{\"174\":1}}],[\"345\",{\"1\":{\"633\":2}}],[\"349\",{\"0\":{\"169\":1},\"1\":{\"110\":2,\"169\":1}}],[\"34\",{\"1\":{\"101\":4,\"118\":1,\"163\":1,\"1774\":1,\"1851\":2}}],[\"344\",{\"0\":{\"67\":1}}],[\"3px\",{\"1\":{\"49\":1}}],[\"3rem\",{\"1\":{\"49\":1,\"51\":1}}],[\"37为例\",{\"0\":{\"1395\":1}}],[\"37\",{\"1\":{\"29\":1,\"1395\":1}}],[\"3\",{\"0\":{\"695\":1,\"832\":1,\"1047\":1,\"1116\":1,\"1183\":1,\"1196\":1,\"1206\":1,\"1208\":1,\"1220\":1,\"1227\":1,\"1374\":1,\"1492\":1,\"1496\":1,\"1579\":1,\"1660\":1,\"1664\":1,\"1681\":1,\"1731\":1,\"1735\":1,\"1799\":1,\"1813\":1,\"1822\":1,\"1826\":1,\"1830\":1,\"1900\":1,\"1902\":1,\"1904\":1,\"1905\":2},\"1\":{\"22\":1,\"29\":3,\"45\":1,\"50\":2,\"60\":1,\"95\":1,\"101\":1,\"104\":7,\"107\":2,\"110\":2,\"129\":3,\"177\":4,\"182\":1,\"202\":1,\"224\":1,\"244\":1,\"264\":1,\"323\":3,\"338\":3,\"371\":3,\"378\":5,\"389\":1,\"434\":1,\"455\":1,\"458\":6,\"459\":5,\"463\":2,\"464\":1,\"500\":3,\"506\":1,\"515\":1,\"548\":1,\"553\":1,\"578\":1,\"594\":2,\"616\":1,\"618\":3,\"642\":1,\"658\":1,\"721\":1,\"730\":1,\"731\":1,\"747\":1,\"756\":1,\"802\":1,\"810\":4,\"830\":1,\"871\":3,\"889\":1,\"891\":1,\"898\":1,\"965\":1,\"968\":1,\"969\":1,\"970\":1,\"973\":1,\"990\":1,\"991\":1,\"992\":1,\"1031\":1,\"1032\":1,\"1114\":2,\"1115\":1,\"1127\":1,\"1168\":3,\"1207\":1,\"1208\":1,\"1233\":1,\"1238\":1,\"1239\":1,\"1249\":1,\"1252\":1,\"1253\":1,\"1271\":2,\"1285\":1,\"1287\":1,\"1299\":1,\"1305\":4,\"1310\":1,\"1312\":1,\"1315\":1,\"1322\":1,\"1367\":1,\"1507\":1,\"1516\":4,\"1537\":7,\"1548\":1,\"1552\":2,\"1615\":1,\"1719\":2,\"1733\":2,\"1734\":1,\"1735\":2,\"1736\":5,\"1773\":1,\"1803\":1,\"1878\":1,\"1904\":1,\"1905\":3,\"1908\":1,\"1909\":2,\"1914\":1,\"1915\":2}}],[\"二倍扩容\",{\"1\":{\"1127\":1}}],[\"二级索引成为热数据\",{\"1\":{\"1569\":1}}],[\"二级索引\",{\"0\":{\"1564\":1},\"1\":{\"1610\":1}}],[\"二级指针\",{\"1\":{\"1099\":1}}],[\"二级空间配置器重要成员解读\",{\"0\":{\"1082\":1}}],[\"二级空间配置器\",{\"0\":{\"1081\":1}}],[\"二级空间配置器内存管理类\",{\"1\":{\"1079\":1}}],[\"二元函数对象\",{\"1\":{\"982\":2,\"1008\":1,\"1147\":1,\"1148\":2}}],[\"二\",{\"0\":{\"967\":1,\"983\":1,\"990\":1,\"1002\":1,\"1008\":1,\"1657\":1,\"1673\":1,\"1678\":1,\"1687\":1,\"1713\":1,\"1732\":1,\"1745\":1,\"1759\":1,\"1769\":1,\"1801\":1,\"1819\":1,\"1886\":1,\"1897\":1,\"1914\":1}}],[\"二哈\",{\"1\":{\"905\":1}}],[\"二叉堆\",{\"1\":{\"784\":1}}],[\"二义性\",{\"1\":{\"642\":2}}],[\"二是使用errno宏\",{\"1\":{\"598\":1}}],[\"二进制日志对于灾难时的数据恢复起着极其重要的作用\",{\"1\":{\"1772\":1}}],[\"二进制日志\",{\"0\":{\"1772\":1},\"1\":{\"1767\":1,\"1772\":1}}],[\"二进制整数\",{\"1\":{\"1347\":1}}],[\"二进制可执行文件输出位置\",{\"1\":{\"1310\":1}}],[\"二进制\",{\"1\":{\"1299\":1}}],[\"二进制文件\",{\"1\":{\"572\":1}}],[\"二进制读取\",{\"1\":{\"17\":1}}],[\"二春来了\",{\"1\":{\"530\":1}}],[\"二分搜索o\",{\"1\":{\"100\":1}}],[\"二分查找要求数据结构必须是顺序表\",{\"1\":{\"91\":1}}],[\"二分查找总结\",{\"0\":{\"90\":1}}],[\"二分查找\",{\"0\":{\"84\":1,\"142\":1},\"1\":{\"84\":1},\"2\":{\"86\":1,\"99\":1,\"145\":1,\"165\":1}}],[\"二者的区别本质上就是tcp提供的一些控制功能\",{\"1\":{\"22\":1}}],[\"读请求转发到b\",{\"1\":{\"1790\":1}}],[\"读写磁盘数据\",{\"1\":{\"1881\":1}}],[\"读写操作都被转发到了备用的windows上的mysql\",{\"1\":{\"1814\":1}}],[\"读写操作会全部转发到m2\",{\"1\":{\"1814\":1}}],[\"读写分离才基于主从复制\",{\"1\":{\"1890\":1}}],[\"读写分离基于主从复制\",{\"1\":{\"1797\":1}}],[\"读写分离配置实践\",{\"0\":{\"1795\":1}}],[\"读写分离\",{\"1\":{\"1791\":1,\"1803\":1}}],[\"读写分离就是在主服务器上修改\",{\"1\":{\"1790\":1}}],[\"读写分离原理\",{\"0\":{\"1789\":1}}],[\"读写分离概念\",{\"0\":{\"1781\":1,\"1790\":1}}],[\"读写慢\",{\"1\":{\"16\":1}}],[\"读锁\",{\"1\":{\"1697\":1}}],[\"读最新的commit状态的数据\",{\"1\":{\"1665\":1}}],[\"读操作可以分为两类\",{\"1\":{\"1656\":1}}],[\"读索引文件到内存上\",{\"1\":{\"1626\":1}}],[\"读索引文件\",{\"1\":{\"1623\":1}}],[\"读到内存中\",{\"1\":{\"1622\":1}}],[\"读清题意\",{\"1\":{\"762\":1}}],[\"读取值为实例化对象\",{\"1\":{\"1914\":1}}],[\"读取出错或读取文件时文件为空\",{\"1\":{\"1878\":1}}],[\"读取到换行符\",{\"1\":{\"1878\":1}}],[\"读取到的换行符会保持文件中的原始形式\",{\"1\":{\"17\":1}}],[\"读取了未commit的数据\",{\"1\":{\"1712\":1}}],[\"读取的是最新版本\",{\"1\":{\"1656\":1}}],[\"读取的是记录的最新版本\",{\"1\":{\"1656\":1}}],[\"读取磁盘\",{\"1\":{\"290\":1}}],[\"读取md文件的内容\",{\"1\":{\"60\":1}}],[\"rdbms\",{\"1\":{\"1451\":1}}],[\"rd1\",{\"1\":{\"920\":2}}],[\"rm\",{\"1\":{\"1272\":2,\"1332\":1,\"1356\":2,\"1359\":1,\"1365\":1,\"1366\":2,\"1367\":1}}],[\"rw\",{\"1\":{\"1271\":8,\"1569\":1}}],[\"rn|head\",{\"1\":{\"1238\":2}}],[\"rn\",{\"1\":{\"1238\":1}}],[\"r或\",{\"1\":{\"1237\":1}}],[\"rule=\",{\"1\":{\"1891\":1}}],[\"rule\",{\"1\":{\"1143\":1,\"1886\":1}}],[\"running\",{\"1\":{\"1820\":1}}],[\"runinthread\",{\"1\":{\"1151\":3}}],[\"run\",{\"1\":{\"261\":1,\"751\":1,\"957\":1,\"1340\":1}}],[\"runtime\",{\"0\":{\"1135\":1},\"1\":{\"182\":1,\"600\":1,\"604\":1,\"605\":2,\"1132\":2,\"1133\":1,\"1143\":1,\"1290\":2,\"1291\":1}}],[\"rf\",{\"1\":{\"1359\":1}}],[\"rfvz\",{\"1\":{\"1260\":1}}],[\"rfappender\",{\"1\":{\"1032\":4}}],[\"rfind\",{\"1\":{\"546\":4}}],[\"rfind系列\",{\"1\":{\"546\":1}}],[\"rtti\",{\"1\":{\"957\":1}}],[\"rtti介绍及使用示例\",{\"1\":{\"957\":1}}],[\"rtti应用\",{\"1\":{\"957\":1}}],[\"rtti运行时的类型信息\",{\"0\":{\"957\":1}}],[\"rtti类型\",{\"1\":{\"956\":1}}],[\"rtti信息\",{\"1\":{\"631\":2}}],[\"rb2\",{\"1\":{\"922\":2}}],[\"rb1\",{\"1\":{\"922\":2}}],[\"rbegin\",{\"1\":{\"539\":2,\"1011\":5}}],[\"r>\",{\"1\":{\"389\":1}}],[\"rhs\",{\"1\":{\"355\":13,\"385\":14,\"396\":3,\"397\":6,\"439\":2,\"463\":3,\"464\":8,\"535\":2,\"537\":3,\"541\":5,\"545\":6,\"548\":7,\"662\":45,\"699\":4,\"704\":14,\"722\":8,\"731\":7,\"736\":4,\"1122\":6,\"1123\":9}}],[\"rit\",{\"1\":{\"1011\":6}}],[\"ritchie\",{\"1\":{\"301\":3}}],[\"rightnext\",{\"1\":{\"802\":2}}],[\"right是编号不是下标\",{\"1\":{\"802\":1}}],[\"rightbound\",{\"1\":{\"162\":2}}],[\"right<=left\",{\"1\":{\"136\":1}}],[\"right||\",{\"1\":{\"97\":1}}],[\"right要跳到下一个位置\",{\"1\":{\"78\":1}}],[\"right遇到val跳过\",{\"1\":{\"78\":1}}],[\"right\",{\"1\":{\"51\":1,\"67\":3,\"70\":9,\"73\":1,\"78\":11,\"84\":4,\"87\":6,\"96\":7,\"97\":12,\"126\":5,\"133\":11,\"135\":1,\"136\":24,\"142\":6,\"143\":9,\"202\":8,\"220\":10,\"783\":5,\"801\":3,\"802\":6,\"1102\":1,\"1148\":1,\"1500\":1,\"1544\":1}}],[\"raw\",{\"1\":{\"1237\":1}}],[\"radixsort2\",{\"1\":{\"191\":2}}],[\"radixsort\",{\"1\":{\"191\":2}}],[\"radius\",{\"1\":{\"49\":1,\"51\":1,\"898\":6}}],[\"range异常类实例\",{\"1\":{\"605\":1}}],[\"range异常\",{\"1\":{\"539\":1}}],[\"range\",{\"1\":{\"214\":2,\"604\":2,\"605\":2,\"1521\":1,\"1618\":1,\"1890\":1}}],[\"ransomnote\",{\"1\":{\"174\":5}}],[\"rand\",{\"1\":{\"70\":1,\"101\":1,\"188\":1,\"191\":2,\"355\":1,\"406\":1,\"704\":1,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":6,\"817\":1,\"819\":1,\"966\":5,\"984\":1,\"985\":1,\"990\":1,\"991\":1,\"992\":1,\"999\":3,\"1001\":2,\"1002\":1,\"1011\":2,\"1147\":1,\"1148\":1,\"1177\":1}}],[\"role\",{\"1\":{\"1738\":4}}],[\"roll\",{\"1\":{\"1656\":1,\"1681\":3,\"1682\":1}}],[\"rollback\",{\"1\":{\"1640\":2,\"1649\":1,\"1671\":1}}],[\"rollback了\",{\"1\":{\"1639\":1}}],[\"rollingfileappender123\",{\"1\":{\"1031\":1}}],[\"rollingfileappender\",{\"1\":{\"1019\":1,\"1031\":3,\"1032\":4}}],[\"rose\",{\"1\":{\"1735\":1}}],[\"row\",{\"1\":{\"1379\":2,\"1385\":5,\"1656\":1,\"1681\":2}}],[\"rows\",{\"1\":{\"1378\":1,\"1385\":1,\"1407\":4,\"1521\":1,\"1773\":1,\"1799\":2}}],[\"route\",{\"1\":{\"1237\":1}}],[\"routine\",{\"1\":{\"493\":2}}],[\"round\",{\"1\":{\"1076\":2,\"1090\":2,\"1096\":2,\"1102\":1}}],[\"rotateright\",{\"1\":{\"787\":1}}],[\"rodata\",{\"1\":{\"267\":1}}],[\"roboto\",{\"1\":{\"49\":2}}],[\"root用户默认是localhost\",{\"1\":{\"1799\":1}}],[\"rootappender=fileappender\",{\"1\":{\"1026\":1}}],[\"rootappender\",{\"1\":{\"1026\":4}}],[\"rootcategory=debug\",{\"1\":{\"1026\":1}}],[\"root\",{\"1\":{\"44\":3,\"60\":1,\"1018\":7,\"1019\":1,\"1020\":5,\"1025\":1,\"1031\":26,\"1374\":1,\"1383\":2,\"1384\":2,\"1385\":2,\"1397\":1,\"1403\":1,\"1407\":1,\"1408\":2,\"1447\":1,\"1556\":2,\"1729\":1,\"1774\":1,\"1799\":2,\"1820\":4,\"1836\":1,\"1851\":3,\"1856\":1,\"1878\":1,\"1888\":3,\"1891\":3}}],[\"rgb\",{\"1\":{\"49\":2}}],[\"r输入regedit打开注册表\",{\"1\":{\"45\":1}}],[\"r\",{\"1\":{\"17\":2,\"27\":1,\"29\":1,\"60\":1,\"97\":1,\"214\":2,\"234\":1,\"239\":1,\"389\":5,\"572\":1,\"731\":2,\"1158\":9,\"1188\":2,\"1189\":6,\"1271\":4,\"1272\":2,\"1334\":1,\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":1}}],[\"reqb\",{\"1\":{\"1915\":2}}],[\"req\",{\"1\":{\"1915\":6}}],[\"requirements\",{\"1\":{\"1407\":2}}],[\"required\",{\"1\":{\"1312\":4,\"1314\":1,\"1315\":1,\"1316\":1,\"1317\":1,\"1318\":1,\"1322\":1}}],[\"request\",{\"1\":{\"1240\":3}}],[\"requests\",{\"1\":{\"1102\":1,\"1240\":1}}],[\"rename\",{\"1\":{\"1552\":2}}],[\"rend\",{\"1\":{\"539\":2,\"1011\":2}}],[\"revoke\",{\"1\":{\"1486\":1,\"1548\":1}}],[\"reversebetween\",{\"1\":{\"802\":1}}],[\"reverselinklist\",{\"1\":{\"802\":2}}],[\"reverselist\",{\"1\":{\"756\":3,\"777\":2}}],[\"reverse\",{\"1\":{\"539\":4,\"698\":2,\"1011\":4}}],[\"reversestring\",{\"1\":{\"67\":2}}],[\"rehash\",{\"1\":{\"1410\":1}}],[\"rebuild\",{\"1\":{\"1355\":1,\"1365\":2,\"1367\":2}}],[\"reboot\",{\"1\":{\"1296\":1}}],[\"remedy\",{\"1\":{\"1102\":1}}],[\"removeall\",{\"1\":{\"817\":3}}],[\"removenthfromend\",{\"1\":{\"774\":2}}],[\"removeelements\",{\"1\":{\"759\":1}}],[\"removeelement\",{\"1\":{\"77\":1,\"78\":1}}],[\"remove\",{\"1\":{\"60\":1,\"817\":3,\"819\":2,\"821\":4,\"1287\":1,\"1405\":1}}],[\"removefile\",{\"1\":{\"60\":2}}],[\"removechild\",{\"1\":{\"59\":1}}],[\"removechilds\",{\"1\":{\"59\":4}}],[\"removeitem\",{\"1\":{\"59\":1}}],[\"replication\",{\"1\":{\"1821\":2,\"1828\":1}}],[\"replacement\",{\"1\":{\"1361\":1}}],[\"replaced\",{\"1\":{\"1361\":1}}],[\"repeatable\",{\"0\":{\"1635\":1},\"1\":{\"1631\":1,\"1640\":1,\"1677\":1}}],[\"reportallclasslayout\",{\"1\":{\"936\":1}}],[\"reportsingleclasslayout类名\",{\"1\":{\"936\":1}}],[\"rep\",{\"1\":{\"908\":2}}],[\"rec\",{\"1\":{\"1719\":1}}],[\"record\",{\"1\":{\"1686\":2,\"1693\":1,\"1719\":2}}],[\"recurse可以包含所有子文件夹下的文件\",{\"1\":{\"1312\":1}}],[\"receive\",{\"1\":{\"1240\":1}}],[\"received\",{\"1\":{\"1240\":5}}],[\"rectangle\",{\"1\":{\"898\":3}}],[\"recvbuf\",{\"1\":{\"1907\":2,\"1908\":2,\"1909\":2}}],[\"recv\",{\"1\":{\"871\":8}}],[\"reinterpret\",{\"0\":{\"632\":1},\"1\":{\"628\":1,\"632\":2}}],[\"reload\",{\"1\":{\"1818\":1}}],[\"relocatable\",{\"1\":{\"572\":1}}],[\"relay\",{\"1\":{\"1783\":1,\"1784\":1}}],[\"relwithdebinfo\",{\"1\":{\"1320\":1}}],[\"release\",{\"1\":{\"271\":1,\"1310\":3,\"1320\":3}}],[\"refreshalivetime\",{\"1\":{\"1846\":1,\"1859\":1}}],[\"refill函数中填写next域\",{\"1\":{\"1102\":2}}],[\"refill源码\",{\"0\":{\"1099\":1}}],[\"refill\",{\"1\":{\"1096\":1,\"1099\":1}}],[\"refill直接构造chunk后分配\",{\"1\":{\"1096\":1}}],[\"refcnt<t>\",{\"1\":{\"1055\":2}}],[\"refcnt\",{\"1\":{\"1055\":2}}],[\"refderived\",{\"1\":{\"678\":1}}],[\"refbase\",{\"1\":{\"678\":1}}],[\"ref2\",{\"1\":{\"612\":1,\"618\":1}}],[\"ref1\",{\"1\":{\"612\":1}}],[\"refer\",{\"1\":{\"600\":1}}],[\"reference\",{\"1\":{\"539\":4}}],[\"ref\",{\"1\":{\"433\":2,\"618\":13,\"662\":4,\"1113\":1,\"1521\":4,\"1618\":2}}],[\"reallocate\",{\"0\":{\"1076\":1},\"1\":{\"1076\":1}}],[\"realloc\",{\"1\":{\"406\":1,\"1076\":1}}],[\"real\",{\"1\":{\"239\":1,\"731\":2,\"1374\":1,\"1376\":1,\"1383\":1,\"1384\":1,\"1385\":1,\"1847\":1,\"1856\":1}}],[\"rear++的时候\",{\"1\":{\"406\":1}}],[\"rear++\",{\"1\":{\"185\":1}}],[\"rear\",{\"1\":{\"185\":7,\"406\":15,\"751\":6}}],[\"rear在进行变化的时候\",{\"1\":{\"185\":1}}],[\"readhost标签在writehost内\",{\"1\":{\"1803\":1}}],[\"readhost\",{\"1\":{\"1803\":1}}],[\"read隔离级别\",{\"0\":{\"1635\":1}}],[\"readelf\",{\"1\":{\"248\":1,\"251\":1,\"252\":2,\"262\":1}}],[\"read\",{\"0\":{\"1634\":1},\"1\":{\"60\":1,\"1631\":3,\"1639\":3,\"1640\":1,\"1656\":15,\"1671\":1,\"1677\":2}}],[\"readmdfilecontent\",{\"1\":{\"60\":2}}],[\"ret4\",{\"1\":{\"107\":2}}],[\"ret3\",{\"1\":{\"107\":2,\"110\":2}}],[\"ret2\",{\"1\":{\"107\":2,\"110\":2}}],[\"ret\",{\"1\":{\"104\":4,\"107\":2,\"110\":2,\"142\":3,\"234\":4,\"236\":2,\"238\":1,\"246\":1,\"567\":3,\"568\":3,\"569\":3,\"570\":3,\"638\":4,\"1096\":5,\"1299\":3,\"1856\":2,\"1878\":2}}],[\"return完\",{\"1\":{\"1113\":1}}],[\"return\",{\"1\":{\"8\":1,\"11\":1,\"59\":3,\"60\":13,\"70\":1,\"73\":2,\"77\":1,\"78\":1,\"81\":1,\"84\":2,\"87\":1,\"93\":1,\"94\":1,\"96\":4,\"97\":5,\"101\":6,\"104\":1,\"107\":2,\"110\":3,\"114\":1,\"115\":1,\"118\":2,\"125\":3,\"126\":2,\"129\":1,\"133\":2,\"137\":1,\"141\":2,\"142\":5,\"143\":3,\"148\":2,\"149\":3,\"153\":2,\"154\":2,\"155\":2,\"158\":2,\"162\":2,\"163\":2,\"166\":2,\"170\":1,\"171\":1,\"174\":2,\"178\":1,\"179\":1,\"182\":4,\"185\":9,\"191\":1,\"205\":1,\"214\":2,\"220\":1,\"224\":3,\"234\":4,\"246\":2,\"277\":2,\"286\":2,\"287\":1,\"296\":1,\"323\":1,\"355\":8,\"362\":1,\"365\":4,\"366\":3,\"368\":3,\"371\":1,\"372\":1,\"378\":3,\"385\":9,\"388\":3,\"405\":3,\"406\":7,\"411\":1,\"412\":1,\"413\":1,\"421\":1,\"422\":1,\"426\":1,\"433\":1,\"434\":1,\"439\":1,\"449\":1,\"459\":1,\"463\":1,\"464\":2,\"468\":1,\"476\":1,\"483\":2,\"484\":2,\"494\":1,\"497\":1,\"500\":3,\"501\":1,\"506\":2,\"515\":1,\"516\":3,\"530\":2,\"547\":1,\"548\":2,\"557\":1,\"563\":5,\"567\":2,\"568\":2,\"569\":2,\"570\":3,\"571\":6,\"575\":1,\"576\":1,\"588\":3,\"592\":1,\"594\":7,\"597\":1,\"599\":1,\"601\":4,\"602\":1,\"605\":1,\"606\":3,\"614\":1,\"616\":4,\"618\":5,\"621\":1,\"631\":1,\"633\":1,\"638\":2,\"642\":7,\"653\":1,\"662\":10,\"667\":1,\"688\":2,\"695\":3,\"699\":15,\"704\":15,\"710\":2,\"722\":2,\"731\":8,\"736\":12,\"742\":1,\"746\":1,\"747\":6,\"751\":5,\"755\":2,\"756\":5,\"759\":1,\"762\":1,\"765\":2,\"768\":2,\"771\":2,\"774\":4,\"777\":3,\"782\":5,\"783\":8,\"784\":7,\"787\":3,\"791\":4,\"792\":5,\"795\":1,\"798\":2,\"802\":1,\"806\":1,\"810\":1,\"817\":3,\"819\":3,\"821\":3,\"830\":1,\"831\":1,\"832\":1,\"848\":1,\"849\":1,\"850\":1,\"851\":1,\"852\":1,\"854\":1,\"855\":1,\"856\":1,\"857\":1,\"864\":5,\"866\":3,\"867\":5,\"871\":1,\"886\":1,\"889\":1,\"890\":1,\"891\":1,\"894\":1,\"898\":3,\"900\":6,\"905\":1,\"906\":1,\"907\":1,\"908\":1,\"913\":1,\"948\":1,\"953\":1,\"980\":2,\"981\":4,\"982\":4,\"984\":1,\"989\":1,\"1002\":5,\"1008\":1,\"1011\":3,\"1020\":1,\"1031\":1,\"1032\":2,\"1040\":1,\"1041\":4,\"1043\":1,\"1045\":1,\"1047\":2,\"1050\":2,\"1055\":7,\"1060\":1,\"1066\":1,\"1076\":3,\"1080\":3,\"1087\":2,\"1090\":4,\"1096\":1,\"1099\":2,\"1102\":6,\"1110\":2,\"1111\":1,\"1112\":1,\"1113\":1,\"1115\":3,\"1116\":3,\"1120\":5,\"1121\":2,\"1122\":3,\"1123\":11,\"1127\":7,\"1147\":1,\"1148\":5,\"1151\":2,\"1154\":3,\"1155\":1,\"1158\":5,\"1165\":1,\"1166\":2,\"1168\":1,\"1173\":3,\"1177\":1,\"1178\":1,\"1183\":2,\"1186\":2,\"1187\":1,\"1188\":2,\"1189\":2,\"1207\":1,\"1208\":1,\"1219\":4,\"1225\":1,\"1226\":1,\"1233\":1,\"1299\":2,\"1321\":1,\"1383\":1,\"1384\":1,\"1385\":1,\"1839\":4,\"1846\":1,\"1847\":4,\"1849\":6,\"1851\":1,\"1856\":4,\"1859\":4,\"1869\":1,\"1871\":1,\"1872\":1,\"1875\":4,\"1878\":4,\"1907\":2,\"1908\":2,\"1909\":2,\"1915\":1}}],[\"restart\",{\"1\":{\"1408\":1,\"1769\":1,\"1799\":3,\"1820\":1}}],[\"restricted\",{\"1\":{\"1284\":8}}],[\"restrict\",{\"1\":{\"1096\":1,\"1878\":2}}],[\"reserve函数可以预留空间\",{\"1\":{\"973\":1,\"974\":1}}],[\"reserve\",{\"1\":{\"966\":2,\"1124\":1}}],[\"reserve预留空间\",{\"1\":{\"966\":1}}],[\"reset\",{\"1\":{\"51\":15}}],[\"resolution的时候\",{\"1\":{\"528\":1}}],[\"resources\",{\"1\":{\"52\":1,\"61\":1}}],[\"resize\",{\"1\":{\"191\":2,\"214\":1,\"406\":2,\"966\":2}}],[\"res\",{\"1\":{\"178\":6,\"179\":4,\"762\":16,\"782\":5,\"783\":4,\"792\":2,\"1377\":2,\"1378\":2,\"1379\":1,\"1381\":1,\"1384\":2,\"1385\":8,\"1846\":1,\"1847\":1,\"1856\":2}}],[\"result分配出去\",{\"1\":{\"1096\":1}}],[\"result下没有挂着空闲的chunk块\",{\"1\":{\"1096\":1}}],[\"result为第一个chunk块地址\",{\"1\":{\"1096\":1}}],[\"result指向重新分配的空间\",{\"1\":{\"1076\":1}}],[\"resultset\",{\"1\":{\"170\":4,\"171\":4}}],[\"result内的结果照片会在比对开始自动清空\",{\"1\":{\"5\":1}}],[\"result\",{\"1\":{\"4\":1,\"51\":1,\"59\":3,\"73\":5,\"81\":7,\"104\":4,\"107\":4,\"110\":11,\"133\":4,\"137\":3,\"214\":6,\"1076\":5,\"1080\":4,\"1096\":4,\"1099\":3,\"1102\":15,\"1377\":2,\"1378\":1,\"1379\":1,\"1381\":2,\"1385\":2,\"1618\":1,\"1847\":1,\"1856\":1}}],[\"register\",{\"1\":{\"296\":1}}],[\"registry\",{\"1\":{\"44\":1}}],[\"regresult\",{\"1\":{\"59\":3}}],[\"regexp\",{\"1\":{\"59\":1}}],[\"reg就行\",{\"1\":{\"44\":1}}],[\"reg\",{\"1\":{\"44\":1,\"59\":2}}],[\"redirecting\",{\"1\":{\"1799\":1}}],[\"redis是基于内存的数据库\",{\"1\":{\"1745\":1}}],[\"redis\",{\"0\":{\"25\":1},\"1\":{\"1452\":1,\"1864\":1}}],[\"redo\",{\"0\":{\"1748\":1,\"1758\":1},\"1\":{\"1645\":1,\"1650\":1,\"1677\":1,\"1679\":1,\"1748\":1,\"1758\":4,\"1762\":2,\"1881\":1}}],[\"red\",{\"1\":{\"29\":2,\"48\":2,\"688\":1}}],[\"磁盘结构\",{\"0\":{\"1759\":1}}],[\"磁盘读取是按块读取\",{\"1\":{\"1623\":1}}],[\"磁盘i\",{\"1\":{\"1623\":1}}],[\"磁盘io加载索引花费时间\",{\"1\":{\"1886\":1}}],[\"磁盘io\",{\"1\":{\"1623\":1}}],[\"磁盘io次数就少\",{\"1\":{\"1621\":1}}],[\"磁盘io花费要少\",{\"1\":{\"1602\":1}}],[\"磁盘io速度慢\",{\"1\":{\"1455\":1}}],[\"磁盘\",{\"1\":{\"17\":1}}],[\"每台服务器可以均衡写请求的次数\",{\"1\":{\"1885\":1}}],[\"每门课程考试的平均成绩+课程信息\",{\"1\":{\"1538\":1}}],[\"每条信息有\",{\"1\":{\"1385\":1}}],[\"每天生成一个新文件\",{\"1\":{\"1019\":1}}],[\"每数到第九个人就将他扔入大海\",{\"1\":{\"811\":1}}],[\"每到这个时候我们就会想到用malloc\",{\"1\":{\"509\":1}}],[\"每当慢指针\",{\"1\":{\"765\":1}}],[\"每当创建该对象时调用构造函数\",{\"1\":{\"427\":1}}],[\"每当程序流程到达该对象的定义处就调用构造函数\",{\"1\":{\"427\":1}}],[\"每当程序开始运行\",{\"1\":{\"427\":1}}],[\"每个\",{\"1\":{\"1899\":1}}],[\"每个服务器具有一部分库与表\",{\"1\":{\"1890\":1}}],[\"每个语句执行前都会重新生成一快照\",{\"1\":{\"1656\":1}}],[\"每个版本的记录除了数据本身之外\",{\"1\":{\"1656\":1}}],[\"每个节点的数据都是有序的\",{\"1\":{\"1623\":1}}],[\"每个分区都会有自己的锁\",{\"1\":{\"1569\":1}}],[\"每个表只有一个候选键\",{\"1\":{\"1463\":1}}],[\"每个表格称为一个\",{\"1\":{\"1451\":1}}],[\"每个关系都有一个唯一的标识符\",{\"1\":{\"1451\":1}}],[\"每个关系由行\",{\"1\":{\"1451\":1}}],[\"每个源文件生成可执行程序\",{\"0\":{\"1366\":1}}],[\"每个线程受cpu的调度\",{\"1\":{\"1218\":1}}],[\"每个线程在1个指令周期之内是要保证完成的\",{\"1\":{\"1208\":1}}],[\"每个chunk块的头信息\",{\"1\":{\"1082\":1}}],[\"每个category可以添加多个appender\",{\"1\":{\"1022\":1}}],[\"每个category负责记录自己的日志\",{\"1\":{\"1022\":1}}],[\"每个append都包含一个layout\",{\"1\":{\"1022\":1}}],[\"每个appender指定了一个日志的目的地\",{\"1\":{\"1022\":1}}],[\"每个基类都有自己的虚函数表\",{\"1\":{\"889\":1}}],[\"每个链表都已经按升序排列\",{\"1\":{\"780\":1}}],[\"每个指针遍历两个链表各一次\",{\"1\":{\"771\":1}}],[\"每个名字空间都是一个名字空间域\",{\"1\":{\"583\":1}}],[\"每个测试都保证以相同的方式实现\",{\"1\":{\"500\":1}}],[\"每个成员在初始化列表之中\",{\"1\":{\"422\":1}}],[\"每个对象都有自己的成员变量\",{\"1\":{\"392\":1}}],[\"每个结点称为目录项\",{\"1\":{\"17\":1}}],[\"每调用一次\",{\"1\":{\"240\":1}}],[\"每一种实现都包含了相应语言的编译器以及库文件\",{\"1\":{\"1913\":1}}],[\"每一种容器都有自己的迭代器\",{\"1\":{\"698\":1}}],[\"每一行记录实际上有多个版本\",{\"1\":{\"1656\":1}}],[\"每一列保持原子特性\",{\"1\":{\"1460\":1}}],[\"每一边都可以进行插入\",{\"1\":{\"968\":1}}],[\"每一张虚函数表都会加载到内存的\",{\"1\":{\"915\":1}}],[\"每一次select都会产生一个新的数据快照\",{\"1\":{\"1658\":1}}],[\"每一次数据花费的时间也不平均\",{\"1\":{\"1626\":1}}],[\"每一次访问的就是这三个不同对象的虚函数表\",{\"1\":{\"886\":1}}],[\"每一次将该数替换为它每个位置上的数字的平方和\",{\"1\":{\"146\":1}}],[\"每一个事务必须满足下面的4个特性\",{\"1\":{\"1644\":1}}],[\"每一个非叶子节点只存放key\",{\"1\":{\"1626\":1}}],[\"每一个非叶子节点上\",{\"1\":{\"1626\":1}}],[\"每一个都要用到\",{\"1\":{\"1590\":1}}],[\"每一个员工的email都是唯一的\",{\"1\":{\"1463\":1}}],[\"每一个第二维是连续的\",{\"1\":{\"972\":1}}],[\"每一个函数进来首先push\",{\"1\":{\"908\":1}}],[\"每一个函数或线程独有的栈空间\",{\"1\":{\"267\":1}}],[\"每一个节点存放的key值更多\",{\"1\":{\"1626\":1}}],[\"每一个节点除了数据域\",{\"1\":{\"816\":1,\"818\":1,\"820\":1,\"823\":1}}],[\"每一个节点多出存放地址的空间\",{\"1\":{\"815\":1}}],[\"每一个节点都是在堆内存上独立new出来的\",{\"1\":{\"815\":1}}],[\"每一个test对象有一个整型成员变量\",{\"1\":{\"715\":1}}],[\"每一圈从\",{\"1\":{\"81\":1}}],[\"每次插入用id模上存在的机器数\",{\"1\":{\"1891\":1}}],[\"每次插入一条\",{\"0\":{\"1476\":1}}],[\"每次查询都使用第一次生成的数据快照\",{\"1\":{\"1656\":1}}],[\"每次查询都会重新生成数据快照\",{\"1\":{\"1656\":1}}],[\"每次程序停止时\",{\"1\":{\"1342\":1,\"1344\":1,\"1345\":1,\"1346\":1}}],[\"每次只有1个线程去做减减操作\",{\"1\":{\"1208\":1}}],[\"每次运行结果都存在差异\",{\"1\":{\"1208\":1}}],[\"每次都使用malloc和free\",{\"1\":{\"1079\":1}}],[\"每次第一个参数的位置也是不确定的\",{\"1\":{\"1063\":1}}],[\"每次改动符号有些麻烦\",{\"1\":{\"980\":1}}],[\"每次层构造函数都会执行刚才的步骤\",{\"1\":{\"908\":1}}],[\"每次创建对象的时候\",{\"1\":{\"861\":1}}],[\"每次循环跳跃空间大小为sizeof\",{\"1\":{\"751\":1}}],[\"每次要使用某个名称空间中的实体时\",{\"1\":{\"589\":1}}],[\"每次+2\",{\"1\":{\"81\":1}}],[\"每次比对只需要改动wt内的模板序列和sequence内的测序结果\",{\"1\":{\"5\":1}}],[\"每次比对只能放该基因的模板序列\",{\"1\":{\"5\":1}}],[\"而网络中tcp传输数据时为字节流\",{\"1\":{\"1896\":1}}],[\"而预留1个字符的空间来存储字符串结束符\",{\"1\":{\"1878\":1}}],[\"而此时连接的数量已达上限maxsize\",{\"1\":{\"1866\":1}}],[\"而此时没有空闲的连接可供使用\",{\"1\":{\"1865\":1}}],[\"而master的mytest库已经有user表了\",{\"1\":{\"1830\":1}}],[\"而myisam不支持事务\",{\"1\":{\"1649\":1}}],[\"而myisam不会\",{\"0\":{\"1558\":1},\"1\":{\"1610\":1}}],[\"而虚拟机无法ping通物理机\",{\"1\":{\"1818\":1}}],[\"而虚函数在运行时才动态绑定\",{\"1\":{\"876\":1}}],[\"而缓存容量有限\",{\"1\":{\"1760\":1}}],[\"而主键索引树上的记录加了锁\",{\"1\":{\"1701\":1}}],[\"而22\",{\"1\":{\"1693\":1}}],[\"而导致的效率低下问题\",{\"1\":{\"1672\":1}}],[\"而导致无法编译通过\",{\"1\":{\"293\":1}}],[\"而使得其他执行事务的线程也无法获得锁而永远阻塞\",{\"1\":{\"1636\":1}}],[\"而b+树的非叶子节点只存关键字\",{\"1\":{\"1627\":1}}],[\"而我们用age作为过滤条件没有用到索引\",{\"1\":{\"1700\":1}}],[\"而我们输入where\",{\"1\":{\"1617\":1}}],[\"而我们p2出错是给用户返回的存对象开始的起始地址\",{\"1\":{\"715\":1}}],[\"而平衡树的增删改查的时间复杂度是o\",{\"1\":{\"1601\":1}}],[\"而innodb索引和数据是存放在一起的\",{\"1\":{\"1558\":1}}],[\"而api设置的相应等待时间为5s\",{\"1\":{\"1551\":1}}],[\"而at\",{\"1\":{\"539\":1}}],[\"而第二种方法虽然麻烦点\",{\"1\":{\"1511\":1}}],[\"而varchar的存储方式是\",{\"1\":{\"1426\":1}}],[\"而varchar的长度是可变的\",{\"1\":{\"1426\":1}}],[\"而varchar是以空间效率为首位的\",{\"1\":{\"1426\":1}}],[\"而varchar就立马把长度变为4了\",{\"1\":{\"1426\":1}}],[\"而在哈希表中\",{\"1\":{\"1603\":1}}],[\"而在\",{\"1\":{\"1319\":1}}],[\"而在库里面都是二元的\",{\"1\":{\"1148\":1}}],[\"而产生不同的运行结果\",{\"1\":{\"1208\":1,\"1217\":1}}],[\"而形参是t是正在定义的test对象\",{\"1\":{\"1115\":1}}],[\"而sex就两种\",{\"1\":{\"1587\":1}}],[\"而set命令设置cmake\",{\"1\":{\"1317\":1}}],[\"而sgi\",{\"1\":{\"1079\":1}}],[\"而str\",{\"1\":{\"597\":1}}],[\"而其他则不能\",{\"1\":{\"1025\":1}}],[\"而deque的第二维不是连续的\",{\"1\":{\"994\":1}}],[\"而deque只需要分段的内存\",{\"1\":{\"993\":1}}],[\"而优先级队列为什么底层依赖vector\",{\"0\":{\"993\":1}}],[\"而与指针本身的类型无关\",{\"1\":{\"920\":1}}],[\"而该虚函数表就像一个数组\",{\"1\":{\"914\":1}}],[\"而该指针在构造函数中初始化时已经申请了堆空间的资源\",{\"1\":{\"426\":1}}],[\"而一个派生类继承了该基类\",{\"1\":{\"913\":1}}],[\"而gcc\",{\"1\":{\"908\":1}}],[\"而只是一条跳转指令\",{\"1\":{\"889\":1}}],[\"而多态对代码具有很好的可扩充性\",{\"1\":{\"882\":1}}],[\"而多态除了代码的复用性外\",{\"1\":{\"882\":1}}],[\"而降低耦合度\",{\"1\":{\"882\":1}}],[\"而基类有显示定义构造函数\",{\"0\":{\"670\":1}}],[\"而基类没有显示定义构造函数\",{\"0\":{\"669\":1},\"1\":{\"669\":1}}],[\"而后对\",{\"1\":{\"665\":1}}],[\"而两对象间的\",{\"1\":{\"662\":1}}],[\"而的拷贝构造函数\",{\"1\":{\"662\":1}}],[\"而左值本身就有内存\",{\"1\":{\"621\":1}}],[\"而用户创建的\",{\"1\":{\"621\":1}}],[\"而非匿名对象\",{\"1\":{\"621\":1}}],[\"而非简单的将实参变量或对象的值拷贝给形参\",{\"1\":{\"615\":1}}],[\"而引用本身就是目标变量的别名\",{\"1\":{\"617\":1}}],[\"而引用则不需要这样\",{\"1\":{\"615\":1}}],[\"而引用既然可以作为其他变量的别名而存在\",{\"1\":{\"615\":1}}],[\"而有些函数返回0表示成功\",{\"1\":{\"598\":1}}],[\"而有的人擅长c++\",{\"1\":{\"577\":1}}],[\"而对象需要内存还要构造函数构造才叫对象\",{\"1\":{\"1073\":1}}],[\"而对齐的内存访问仅需要一次访问\",{\"1\":{\"553\":1}}],[\"而对于在头文件中仅有函数声明是不够的\",{\"1\":{\"504\":1}}],[\"而又为了解决空指针的问题\",{\"1\":{\"527\":1}}],[\"而operator\",{\"1\":{\"518\":1}}],[\"而c语言并不支持函数重载\",{\"1\":{\"577\":1}}],[\"而c文件中函数生成符号不带参数类型\",{\"1\":{\"568\":1}}],[\"而c程序只能用malloc\",{\"1\":{\"514\":1}}],[\"而const常量是在\",{\"1\":{\"481\":1}}],[\"而数组需要\",{\"1\":{\"513\":1,\"708\":1}}],[\"而言\",{\"1\":{\"504\":1,\"506\":1}}],[\"而正确的姿势如下\",{\"1\":{\"504\":1}}],[\"而propertyconfigurator\",{\"1\":{\"1026\":1}}],[\"而p1出错\",{\"1\":{\"715\":1}}],[\"而p是一个指向可能修改其指向的int值的指针的指针\",{\"1\":{\"490\":1}}],[\"而pt2对象还不存在\",{\"1\":{\"395\":1}}],[\"而模板有个特点\",{\"1\":{\"476\":1}}],[\"而零值转换为false\",{\"1\":{\"473\":1}}],[\"而空基类的一个字节并不会加到子类中去\",{\"1\":{\"470\":1}}],[\"而这时如果有某个机器挂掉了\",{\"1\":{\"1790\":1}}],[\"而这样的东西在c++程\",{\"1\":{\"628\":1}}],[\"而这样写则不行\",{\"1\":{\"240\":1}}],[\"而这里如果是使用0来表示空指针\",{\"1\":{\"528\":1}}],[\"而这里会调用的就是复制构造函数\",{\"1\":{\"395\":1}}],[\"而成员函数之所以能把属于此类的各个对象的数据区别开\",{\"1\":{\"392\":1}}],[\"而不会影响windows主机上的表\",{\"1\":{\"1892\":1}}],[\"而不会在追加到mysql\",{\"1\":{\"1774\":1}}],[\"而不会再自动调用基类的拷贝构造函数和基类的重载对象赋值运算符\",{\"1\":{\"662\":1}}],[\"而不可重复读和幻读不一定出问题\",{\"1\":{\"1639\":1}}],[\"而不能让索引值的长度key\",{\"1\":{\"1615\":1}}],[\"而不能去构造对象\",{\"1\":{\"383\":1}}],[\"而不通过域名服务器\",{\"1\":{\"1237\":1}}],[\"而不需要程序员自己手动去释放呢\",{\"1\":{\"853\":1}}],[\"而不推荐使用static\",{\"1\":{\"591\":1}}],[\"而不存放\",{\"1\":{\"574\":1}}],[\"而不是数据\",{\"1\":{\"1763\":1}}],[\"而不是记录锁的意思\",{\"1\":{\"1719\":1}}],[\"而不是给表的行记录加锁实现的\",{\"1\":{\"1713\":1}}],[\"而不是快照读\",{\"1\":{\"1665\":1}}],[\"而不是回滚到初始状态set\",{\"1\":{\"1640\":1}}],[\"而不是拿到数据地址后再访问\",{\"1\":{\"1569\":1}}],[\"而不是软链接的路径\",{\"1\":{\"1271\":1}}],[\"而不是右值的\",{\"1\":{\"1127\":1}}],[\"而不是内存空间的重新分配\",{\"1\":{\"1121\":1}}],[\"而不是指针\",{\"1\":{\"1041\":1}}],[\"而不是说baseclass就是虚基类\",{\"1\":{\"933\":1}}],[\"而不是根据指针指向的对象类型\",{\"1\":{\"920\":1}}],[\"而不是\",{\"1\":{\"795\":1}}],[\"而不是直接定义外部全局变量或者静态全局变量\",{\"1\":{\"593\":1}}],[\"而不是c++的\",{\"1\":{\"577\":1}}],[\"而不是c++\",{\"1\":{\"577\":1}}],[\"而不是一种\",{\"1\":{\"504\":1}}],[\"而不是nums\",{\"1\":{\"202\":1}}],[\"而不是=\",{\"1\":{\"84\":1}}],[\"而报警告和错误\",{\"1\":{\"293\":1}}],[\"而实现的根本是通过系统调用实现的\",{\"1\":{\"282\":1}}],[\"而且它\",{\"1\":{\"1913\":1}}],[\"而且架构设计更加复杂\",{\"1\":{\"1885\":1}}],[\"而且主库上binlog没有产生更多的内容\",{\"1\":{\"1784\":1}}],[\"而且与order\",{\"1\":{\"1737\":1}}],[\"而且总是一次获得所需的全部锁\",{\"1\":{\"1706\":1}}],[\"而且把表记录之间以及后边空洞的地方也加上了\",{\"1\":{\"1688\":1}}],[\"而且可能造成其他事务长时间等待和锁冲突\",{\"1\":{\"1670\":1}}],[\"而且有的时候\",{\"1\":{\"1669\":1}}],[\"而且有可能使得代码难懂\",{\"1\":{\"277\":1}}],[\"而且只产生这一次快照\",{\"1\":{\"1662\":1,\"1663\":1}}],[\"而且只能分配\",{\"1\":{\"1102\":1}}],[\"而且是一个节点一个节点构建\",{\"1\":{\"1626\":1}}],[\"而且基类的方法是virtual虚函数\",{\"1\":{\"915\":1}}],[\"而且也不符合实际情况\",{\"1\":{\"866\":1}}],[\"而且能实现在函数中指定的新的功能\",{\"1\":{\"727\":1}}],[\"而且别人不知道分装了new\",{\"1\":{\"618\":1}}],[\"而且出现错误之后\",{\"1\":{\"588\":1}}],[\"而且极易引发程序漏洞\",{\"1\":{\"536\":1}}],[\"而且必须为每个源文件拷贝一份定义\",{\"1\":{\"504\":1}}],[\"而且编译器不会自动创建默认的基类构造函数调用\",{\"1\":{\"423\":1}}],[\"而且\",{\"1\":{\"353\":1,\"410\":1}}],[\"而且你\",{\"1\":{\"140\":1}}],[\"而是把连接归还到连接池中\",{\"1\":{\"1866\":1}}],[\"而是把当前connection再归还到连接池当中\",{\"1\":{\"1865\":1}}],[\"而是把记录事务完整操作的redo\",{\"1\":{\"1762\":1}}],[\"而是把对象的创建都封装在了simplefactory类的createproduct方法当中\",{\"1\":{\"863\":1}}],[\"而是使用表锁\",{\"1\":{\"1700\":1,\"1713\":1}}],[\"而是纯粹通过mvcc的快照读实现的\",{\"1\":{\"1682\":1}}],[\"而是创建\",{\"1\":{\"1656\":1}}],[\"而是无效的脏数据\",{\"1\":{\"1639\":1}}],[\"而是\",{\"1\":{\"1511\":1}}],[\"而是空间配置器程序调用\",{\"1\":{\"1102\":1}}],[\"而是对象\",{\"1\":{\"1073\":1}}],[\"而是执行了函数\",{\"1\":{\"943\":1}}],[\"而是一个\",{\"1\":{\"700\":1}}],[\"而是由定义派生类时指定的基类顺序\",{\"1\":{\"651\":1}}],[\"而是由成员变量在类中被决定的\",{\"1\":{\"422\":1}}],[\"而是存储在寄存器中\",{\"1\":{\"620\":1}}],[\"而是引用符号\",{\"1\":{\"612\":1}}],[\"而是的\",{\"1\":{\"553\":1}}],[\"而是通过调用operator\",{\"1\":{\"518\":1}}],[\"而是叫\",{\"1\":{\"483\":1}}],[\"而是此类的所有对象这个成员函数体\",{\"1\":{\"392\":1}}],[\"而是用户提供的\",{\"1\":{\"367\":1}}],[\"而是利用mmap系统调用\",{\"1\":{\"284\":1}}],[\"而是做一个地址映射\",{\"1\":{\"263\":1}}],[\"而是缩小搜索区间的上界\",{\"1\":{\"96\":1}}],[\"而ebp寄存器是固定的\",{\"1\":{\"233\":1}}],[\"而元素值代表应该放置的位置\",{\"1\":{\"214\":1}}],[\"而双指针技术是\",{\"1\":{\"126\":1}}],[\"而tcp则是一对一的两点服务\",{\"1\":{\"22\":1}}],[\"而udp是尽最大努力交付\",{\"1\":{\"22\":1}}],[\"而维护状态就需要连接\",{\"1\":{\"22\":1}}],[\"而\",{\"1\":{\"16\":1,\"267\":1,\"300\":1,\"302\":1,\"597\":1,\"631\":1,\"1116\":1}}],[\"旨在提升应用程序在不同unix系统环境之间的可移植性\",{\"1\":{\"16\":1}}],[\"它独立于平台语言\",{\"1\":{\"1913\":1}}],[\"它数据压缩编码传输\",{\"1\":{\"1901\":1}}],[\"它通过阻塞的方式获取连接的时间如果超过connectiontimeout时间\",{\"1\":{\"1865\":1}}],[\"它对应的从库也就不能用了\",{\"1\":{\"1791\":1}}],[\"它对参数进行了高度的泛化\",{\"1\":{\"375\":1}}],[\"它描述了数据的更改过程\",{\"1\":{\"1772\":1}}],[\"它记录了mysqld\",{\"1\":{\"1770\":1}}],[\"它不会影响事务的提交\",{\"1\":{\"1762\":1}}],[\"它不知道这个名字作用域后面的iterator是类型还是变量\",{\"1\":{\"1147\":1}}],[\"它随着事务开始\",{\"1\":{\"1758\":1}}],[\"它防止脏读\",{\"1\":{\"1631\":1}}],[\"它表示数据之间的联系\",{\"1\":{\"1451\":1}}],[\"它返回一个指向结果集结构的指针\",{\"1\":{\"1377\":1}}],[\"它将被重新初始化\",{\"1\":{\"1373\":1}}],[\"它将再调用operator\",{\"1\":{\"519\":1}}],[\"它仍然以download\",{\"1\":{\"1251\":1}}],[\"它好不容易占1次cpu的时间片\",{\"1\":{\"1233\":1}}],[\"它还要不断从内存上取东西做运算\",{\"1\":{\"1233\":1}}],[\"它还提供了一对lock和unlock方法\",{\"1\":{\"1227\":1}}],[\"它把左值引用的拷贝构造函数和赋值函数都删除掉了\",{\"1\":{\"1227\":1}}],[\"它把\",{\"1\":{\"1226\":1}}],[\"它没有实现自己的迭代器\",{\"1\":{\"989\":1}}],[\"它是一种\",{\"1\":{\"1913\":1}}],[\"它是一个宏定义\",{\"1\":{\"1079\":1}}],[\"它是一个结构体维护了一个链表\",{\"1\":{\"747\":1}}],[\"它是\",{\"1\":{\"1898\":1}}],[\"它是不允许其他线程再去使用总线的\",{\"1\":{\"1232\":1}}],[\"它是另外一个容器的封装\",{\"1\":{\"989\":1}}],[\"它自动推导变量类型是根据\",{\"1\":{\"700\":1}}],[\"它由一个括号加上一个标识符组成\",{\"1\":{\"628\":1}}],[\"它允许改变指针的值\",{\"1\":{\"625\":1}}],[\"它抛出的异常会被\",{\"1\":{\"601\":1}}],[\"它后面的\",{\"1\":{\"599\":1}}],[\"它就需要\",{\"1\":{\"826\":1}}],[\"它就\",{\"1\":{\"599\":1}}],[\"它只是一个可以访问类内成员的普通函数\",{\"1\":{\"876\":1}}],[\"它只是\",{\"1\":{\"599\":1}}],[\"它只能在本文件的作用域内有效\",{\"1\":{\"591\":1}}],[\"它更是一个整形常量\",{\"1\":{\"528\":1}}],[\"它同样束手无策\",{\"1\":{\"509\":1}}],[\"它附属于子类\",{\"1\":{\"470\":1}}],[\"它们原来是合在一块的\",{\"1\":{\"1888\":1}}],[\"它们都是继承自同一个根\",{\"1\":{\"1022\":1}}],[\"它们都在vec\",{\"1\":{\"747\":1}}],[\"它们中间与末尾插入删除一样为o\",{\"1\":{\"973\":1}}],[\"它们所调用的虚函数是自己类中定义的函数\",{\"1\":{\"925\":1}}],[\"它们是以父子类层次结构组织起来的\",{\"1\":{\"604\":1}}],[\"它们也没出现什么问题\",{\"1\":{\"524\":1}}],[\"它们的目的都是为了代码重用\",{\"1\":{\"882\":1}}],[\"它们的析构函数其实上是可调可不调的\",{\"1\":{\"524\":1}}],[\"它们的交集\",{\"1\":{\"169\":1}}],[\"它们之间可用下面的图展示\",{\"1\":{\"520\":1}}],[\"它们只能在构造函数初始化列表中进行初始化\",{\"1\":{\"432\":1}}],[\"它能表示\",{\"1\":{\"375\":1}}],[\"它被设计成\",{\"1\":{\"354\":1}}],[\"它可以像数组一样被操作\",{\"1\":{\"353\":1}}],[\"它可以通过删除一些元素或不删除元素\",{\"1\":{\"177\":1}}],[\"它会在多主多从的配置中找下一套主从配置来使用\",{\"1\":{\"1803\":1}}],[\"它会把指定目录下的所有源文件都加进来\",{\"1\":{\"1312\":1}}],[\"它会根据下标来返回字符串的一个字符\",{\"1\":{\"597\":1}}],[\"它会同时完成这两件事\",{\"1\":{\"383\":1}}],[\"它会恢复为系统默认值\",{\"1\":{\"239\":1}}],[\"它会将机器代码转化为汇编代码\",{\"1\":{\"228\":1}}],[\"它使用的是先进后出的原则\",{\"1\":{\"232\":1}}],[\"它的索引和数据是一起存放的\",{\"1\":{\"1557\":1}}],[\"它的方法全部由底层依赖的容器进行实现的\",{\"1\":{\"989\":1}}],[\"它的实现中就用到了嵌套类\",{\"1\":{\"826\":1}}],[\"它的下一个人又从1开始报数\",{\"1\":{\"810\":1}}],[\"它的作用域是从匿名命名空间声明开始到本文件结束\",{\"1\":{\"591\":1}}],[\"它的默认值是随机的\",{\"1\":{\"531\":1}}],[\"它的长度为\",{\"1\":{\"129\":1}}],[\"它的目标是确保不同的编译器在遵循iso\",{\"1\":{\"16\":1}}],[\"它包含两部分\",{\"1\":{\"16\":1}}],[\"但要详细且专业的说的话\",{\"1\":{\"1878\":1}}],[\"但以下地方需要保持相同\",{\"1\":{\"1803\":1}}],[\"但后台的i\",{\"1\":{\"1762\":1}}],[\"但后面也不能赋值了\",{\"1\":{\"483\":1}}],[\"但只要我们的redo\",{\"1\":{\"1762\":1}}],[\"但幻读是仍然会出现的\",{\"1\":{\"1677\":1}}],[\"但个别情况下也使用表级锁\",{\"1\":{\"1670\":1}}],[\"但没有完全防止\",{\"1\":{\"1635\":1}}],[\"但没有重写\",{\"1\":{\"900\":1}}],[\"但实际上mysql采用的是b+树结构\",{\"1\":{\"1623\":1}}],[\"但实际上大多数时候是存不满的\",{\"1\":{\"354\":1}}],[\"但同时也\",{\"1\":{\"1609\":1}}],[\"但不基于主从复制\",{\"1\":{\"1890\":1}}],[\"但不是每次都获取行锁\",{\"1\":{\"1669\":1}}],[\"但不一定实际使用到\",{\"1\":{\"1521\":1}}],[\"但不建议采用\",{\"1\":{\"522\":1}}],[\"但请注意它们还是有区别的\",{\"1\":{\"1317\":1}}],[\"但必须满足容器申请1个内存块的要求\",{\"1\":{\"1102\":1}}],[\"但其二级空间配置器allocator采用了基于freelist自由链表原理的\",{\"1\":{\"1079\":1}}],[\"但即使主线程终止了\",{\"1\":{\"1050\":1}}],[\"但即便如此\",{\"1\":{\"524\":1}}],[\"但搜索的时间为o\",{\"1\":{\"974\":1}}],[\"但所有的二维不是连续的\",{\"1\":{\"972\":1}}],[\"但析构函数可以定义为虚函数\",{\"1\":{\"946\":1}}],[\"但a带一个参数的构造函数\",{\"1\":{\"943\":1}}],[\"但ma被移动\",{\"1\":{\"937\":1}}],[\"但内存布局没有变化\",{\"1\":{\"937\":1}}],[\"但绝不会调用任何在派生类中重定义的虚函数\",{\"1\":{\"925\":1}}],[\"但最前面进行元素添加时候deque为o\",{\"1\":{\"973\":1}}],[\"但最终的结果是25行的test调用\",{\"1\":{\"913\":1}}],[\"但最终调用的是基类的方法还是派生类的方法取决于形成的汇编指令是静态绑定还是动态绑定\",{\"1\":{\"907\":1}}],[\"但最好初始化\",{\"1\":{\"619\":1}}],[\"但可以由其派生出新的类\",{\"1\":{\"900\":1}}],[\"但可能会丢包和乱序\",{\"1\":{\"22\":1}}],[\"但类无法为纯虚函数提供一个合理的缺省实现\",{\"1\":{\"898\":1}}],[\"但虚函数一定要创建虚函数表\",{\"1\":{\"876\":1}}],[\"但遍历了链表\",{\"1\":{\"802\":1}}],[\"但凡遇到这种情况\",{\"1\":{\"795\":1}}],[\"但如果使用相同的索引字段作为过滤条件\",{\"1\":{\"1713\":1}}],[\"但如果我们给b的继承方式访问限定符前面加了一个virtual关键字\",{\"1\":{\"934\":1}}],[\"但如果我们去掉break时候\",{\"1\":{\"742\":1,\"743\":1}}],[\"但如果指向derive2对象\",{\"1\":{\"631\":1}}],[\"但有两个例外\",{\"1\":{\"728\":1}}],[\"但底层实际是从0x100开辟的\",{\"1\":{\"715\":1}}],[\"但delete真正执行指令时\",{\"1\":{\"715\":1}}],[\"但释放数据内存时需要加\",{\"1\":{\"708\":1}}],[\"但释放数据内存时需要加中括号\",{\"1\":{\"513\":1}}],[\"但强转会涉及内存的\",{\"1\":{\"678\":1}}],[\"但基类没有默认的无参构造函数\",{\"0\":{\"672\":1},\"1\":{\"672\":1}}],[\"但c++可以给参数定义默认值\",{\"1\":{\"637\":1}}],[\"但错误的使用reinterpret\",{\"1\":{\"632\":1}}],[\"但使用常引用后\",{\"1\":{\"620\":1}}],[\"但使用指针的过程中\",{\"1\":{\"615\":1}}],[\"但至少要有一个\",{\"1\":{\"599\":2}}],[\"但在多基继承时\",{\"1\":{\"652\":1}}],[\"但在混合使用c和c++的情况下\",{\"1\":{\"578\":1}}],[\"但在c++里为函数对象\",{\"1\":{\"978\":1}}],[\"但在c++中\",{\"1\":{\"560\":1}}],[\"但在c++程序中最好还是不要使用它们\",{\"1\":{\"536\":1}}],[\"但第二个函数的参数是指向常量int的指针\",{\"1\":{\"563\":1}}],[\"但这也会导致一些本不影响查询结果的语句也执行失败\",{\"1\":{\"1693\":1}}],[\"但这在一定程度上提高了代码的安全性\",{\"1\":{\"922\":1}}],[\"但这种写法很怪\",{\"1\":{\"618\":1}}],[\"但这种说法并不准确\",{\"1\":{\"614\":1}}],[\"但这两种变量可以有多种类型\",{\"1\":{\"560\":1}}],[\"但这里有一个问题\",{\"1\":{\"135\":1}}],[\"但由于\",{\"1\":{\"1701\":1}}],[\"但由于string字符串实际上是类对象\",{\"1\":{\"538\":1}}],[\"但由于goto不符合软件工程的结构化\",{\"1\":{\"277\":1}}],[\"但编译器内部还是试图去访问p5前4字节的内存\",{\"1\":{\"523\":1}}],[\"但未清理干净\",{\"1\":{\"523\":1}}],[\"但\",{\"1\":{\"509\":1,\"615\":1,\"629\":2,\"943\":1,\"981\":1,\"1635\":1}}],[\"但对这一块申请出来的内存\",{\"1\":{\"509\":1}}],[\"但对于每个基因要对几十个甚至上百个样品测序结果比对步骤太繁琐\",{\"1\":{\"3\":1}}],[\"但相比于放在源文件中\",{\"1\":{\"504\":1}}],[\"但此时只有定义的那个源文件可以用它\",{\"1\":{\"504\":1}}],[\"但我们创建账户登录时不写这个ip\",{\"1\":{\"1821\":1}}],[\"但我们实际使用时并不用关注它\",{\"1\":{\"362\":1}}],[\"但我不知道你会怎样实现它\",{\"1\":{\"898\":1}}],[\"但我认为\",{\"1\":{\"504\":1}}],[\"但始终变不到\",{\"1\":{\"146\":1,\"147\":1}}],[\"但并非越多越好\",{\"1\":{\"1610\":1}}],[\"但并不分配存储单元\",{\"1\":{\"574\":1}}],[\"但并没有减少\",{\"1\":{\"136\":1}}],[\"但并未定义函数的具体实现\",{\"1\":{\"16\":1}}],[\"但细想一下\",{\"1\":{\"136\":1}}],[\"但三元组内的元素是可以重复的\",{\"1\":{\"135\":1}}],[\"但是使用起来比json稍复杂一些\",{\"1\":{\"1901\":1}}],[\"但是使用该函数的人通常不希望链表结构被更改\",{\"1\":{\"756\":1}}],[\"但是手慢没有抢到队列中的连接\",{\"1\":{\"1871\":1}}],[\"但是要注意线程安全问题\",{\"1\":{\"1870\":1}}],[\"但是要获取互斥锁才能继续向下执行\",{\"1\":{\"1219\":2}}],[\"但是新创建的连接数量上限是maxsize\",{\"1\":{\"1865\":1}}],[\"但是新的投影仪都是只支持hdmi接口\",{\"1\":{\"832\":1}}],[\"但是实际工作却不能这样\",{\"1\":{\"1818\":1}}],[\"但是排序效率比两次扫描算法要高\",{\"1\":{\"1736\":1}}],[\"但是它很大程度上避免幻读现象\",{\"1\":{\"1717\":1}}],[\"但是它不够灵活\",{\"1\":{\"980\":1}}],[\"但是经过mysql5\",{\"1\":{\"1713\":1}}],[\"但是name也是通过辅助索引树找到对应的主键\",{\"1\":{\"1701\":1}}],[\"但是new完之后p2返回的地址是0x104地址\",{\"1\":{\"715\":1}}],[\"但是new与delete能混用吗\",{\"0\":{\"712\":1}}],[\"但是发现这行记录已经被共享锁锁住了\",{\"1\":{\"1701\":1}}],[\"但是操作了id<=11的部分\",{\"1\":{\"1688\":1}}],[\"但是更新产生的幻读问题\",{\"1\":{\"1631\":1}}],[\"但是仍然会出现\",{\"1\":{\"1631\":1}}],[\"但是好处在于\",{\"1\":{\"1623\":1}}],[\"但是当用户量级上升\",{\"1\":{\"1885\":1}}],[\"但是当\",{\"1\":{\"1622\":1}}],[\"但是由于表的数据量太大\",{\"1\":{\"1776\":1}}],[\"但是由于\",{\"1\":{\"1573\":1}}],[\"但是真正的企业级项目有\",{\"1\":{\"1572\":1}}],[\"但是group\",{\"1\":{\"1512\":1}}],[\"但是安全程度更高\",{\"1\":{\"1511\":1}}],[\"但是学院电话只依赖于所在学院\",{\"1\":{\"1462\":1}}],[\"但是学分字段只和课程名称有关\",{\"1\":{\"1461\":1}}],[\"但是会跳过生成的步骤\",{\"1\":{\"1318\":1}}],[\"但是堆和数据段都是共享的\",{\"1\":{\"1233\":1}}],[\"但是做不到生产一个消费一个\",{\"1\":{\"1219\":1}}],[\"但是毕竟逻辑意义不一样\",{\"1\":{\"1194\":1}}],[\"但是a变量以传引用的方式捕获\",{\"1\":{\"1172\":1}}],[\"但是a在编译时都直接替换成20\",{\"1\":{\"484\":1}}],[\"但是上面的方法不免显得有点了\",{\"1\":{\"1127\":1}}],[\"但是上述的使用方式并不好\",{\"1\":{\"576\":1}}],[\"但是够分配size个字节\",{\"1\":{\"1102\":1}}],[\"但是还有其他智能指针在使用这个资源\",{\"1\":{\"1054\":1}}],[\"但是还少了空间配置器allocator\",{\"1\":{\"355\":1}}],[\"但是第二句cout\",{\"1\":{\"1045\":1}}],[\"但是有些情况我们不知道具体偏移量是多少\",{\"1\":{\"1539\":1}}],[\"但是有些appender类没有设置互斥\",{\"1\":{\"1019\":1}}],[\"但是有一个被广泛认同的说法\",{\"1\":{\"621\":1}}],[\"但是unordered\",{\"1\":{\"999\":1}}],[\"但是现在多了一个vbptr\",{\"1\":{\"937\":1}}],[\"但是此时派生类的虚函数表里只有基类的虚函数地址\",{\"1\":{\"921\":1}}],[\"但是是不是public\",{\"1\":{\"907\":1}}],[\"但是为什么调用的派生类的方法\",{\"1\":{\"906\":1}}],[\"但是可以定义指针和引用变量\",{\"1\":{\"901\":1}}],[\"但是作为另一个类的友元\",{\"1\":{\"876\":1}}],[\"但是代码中有太多的子类添加进来了\",{\"1\":{\"831\":2}}],[\"但是无法回退到前一个节点\",{\"1\":{\"816\":1}}],[\"但是无法访问\",{\"1\":{\"658\":1}}],[\"但是delete\",{\"1\":{\"715\":1}}],[\"但是基类函数不是虚函数\",{\"1\":{\"695\":1}}],[\"但是多重继承中也会出现问题\",{\"1\":{\"688\":1}}],[\"但是传统的c语言风格的类型转换没有区分这些\",{\"1\":{\"628\":1}}],[\"但是char也为此付出的是空间的代价\",{\"1\":{\"1426\":1}}],[\"但是c风格的类型转换有不少的缺点\",{\"1\":{\"628\":1}}],[\"但是c下面却不行\",{\"1\":{\"562\":1}}],[\"但是q却是一个指向指针的引用\",{\"1\":{\"625\":1}}],[\"但是编译器阻止对它本身的任何访问\",{\"1\":{\"614\":1}}],[\"但是这些表还是在同一个库中\",{\"1\":{\"1890\":1}}],[\"但是这些记录并不存在\",{\"1\":{\"1686\":1}}],[\"但是这两个组合在一起就是唯一的\",{\"1\":{\"1537\":1}}],[\"但是这个子线程运行完还是没运行完都和这个主线程没关系了\",{\"1\":{\"1207\":1}}],[\"但是这个bark\",{\"1\":{\"886\":1}}],[\"但是这里\",{\"1\":{\"981\":1}}],[\"但是这里我们就把\",{\"1\":{\"979\":1}}],[\"但是这样可能会令你的程序略微晦涩难懂\",{\"1\":{\"598\":1}}],[\"但是这并不意味着\",{\"1\":{\"312\":1}}],[\"但是程序能够正常运行\",{\"1\":{\"597\":1}}],[\"但是我们选择重新创建一个新的账号\",{\"1\":{\"1821\":1}}],[\"但是我们在代码中并没有处理\",{\"1\":{\"597\":1}}],[\"但是我们并没有避免这个问题\",{\"1\":{\"529\":1}}],[\"但是我们很快就会发现b\",{\"1\":{\"528\":1}}],[\"但是出错的时候\",{\"1\":{\"528\":1}}],[\"但是突然在某个时候我们功能扩展\",{\"1\":{\"528\":1}}],[\"但是注意\",{\"1\":{\"520\":1}}],[\"但是体现了高质量c++\",{\"1\":{\"504\":1}}],[\"但是看不到函数的定义\",{\"1\":{\"504\":1}}],[\"但是内联函数不需要开销\",{\"1\":{\"502\":1}}],[\"但是写成函数有一个潜在的\",{\"1\":{\"500\":1}}],[\"但是默认情况下访问非const版本\",{\"1\":{\"440\":1}}],[\"但是如果我们交换一下基类与派生类的访问限定符\",{\"1\":{\"907\":1}}],[\"但是如果我们将单个元素与delete\",{\"1\":{\"714\":1}}],[\"但是如果通过const\",{\"1\":{\"630\":1}}],[\"但是如果基类没有提供无参构造函数\",{\"1\":{\"423\":1}}],[\"但是如果使用new的话\",{\"1\":{\"383\":1}}],[\"但是没办法放\",{\"1\":{\"406\":1}}],[\"但是对象有\",{\"1\":{\"397\":1}}],[\"但是对于链表\",{\"1\":{\"91\":1}}],[\"但是共享一套成员方法代码\",{\"1\":{\"392\":1}}],[\"但是里面有效的元素可能只有几个\",{\"1\":{\"383\":1}}],[\"但是却\",{\"1\":{\"382\":1}}],[\"但是却是\",{\"1\":{\"340\":1}}],[\"但是在逻辑上还是一个\",{\"1\":{\"1891\":1}}],[\"但是在某些情况下\",{\"1\":{\"1736\":1}}],[\"但是在快照创建前提交的\",{\"1\":{\"1656\":1}}],[\"但是在快照创建后提交的\",{\"1\":{\"1656\":1}}],[\"但是在多个指令完全由cpu的调度决定的\",{\"1\":{\"1208\":1}}],[\"但是在转换成汇编指令之前\",{\"1\":{\"630\":1}}],[\"但是在函数参数中const修饰符并不影响函数的签名\",{\"1\":{\"563\":1}}],[\"但是在的\",{\"1\":{\"363\":1}}],[\"但是在使用的时候直接使用let\",{\"1\":{\"359\":1}}],[\"但是不包括数据查询语句\",{\"1\":{\"1772\":1}}],[\"但是不能获取排他锁\",{\"1\":{\"1701\":1}}],[\"但是不能防止update更新产生的虚读问题\",{\"1\":{\"1677\":1}}],[\"但是不足size的情况\",{\"1\":{\"1102\":1}}],[\"但是不安全\",{\"1\":{\"359\":1}}],[\"但是不够灵活\",{\"1\":{\"359\":1}}],[\"但是不支持文档之间的跳转\",{\"1\":{\"56\":1}}],[\"但是\",{\"1\":{\"70\":1,\"124\":1,\"303\":1,\"490\":1,\"631\":1,\"695\":1,\"1090\":1,\"1697\":1}}],[\"但是打开之后不卡顿了\",{\"1\":{\"63\":1}}],[\"但保证顺序和可靠\",{\"1\":{\"22\":1}}],[\"以mysql为例\",{\"1\":{\"1762\":1}}],[\"以防止锁冲突导致死锁问题\",{\"1\":{\"1706\":1}}],[\"以上的select相当于给name为zhangsan的数据加上了行共享锁\",{\"1\":{\"1701\":1}}],[\"以age降序\",{\"1\":{\"1525\":1}}],[\"以age升序\",{\"1\":{\"1525\":1}}],[\"以ascii字符格式显示\",{\"1\":{\"1347\":1}}],[\"以ascii字符串格式显示\",{\"1\":{\"1347\":1}}],[\"以分号结尾\",{\"1\":{\"1407\":2}}],[\"以空格分隔\",{\"1\":{\"1356\":1}}],[\"以不会存在的文件名作为目标\",{\"1\":{\"1355\":1}}],[\"以二进制格式查看内存内容\",{\"1\":{\"1348\":1}}],[\"以汇编指令格式显示\",{\"1\":{\"1347\":1}}],[\"以前用的null是宏定义\",{\"1\":{\"1194\":1}}],[\"以值传递的方式捕获外部变量a和b\",{\"1\":{\"1172\":1}}],[\"以传引用的方式捕获外部的所有变量\",{\"1\":{\"1172\":1}}],[\"以传值的方式捕获外部的所有变量\",{\"1\":{\"1172\":2}}],[\"以管理员身份登录终端\",{\"1\":{\"1030\":1}}],[\"以编号1\",{\"1\":{\"810\":1}}],[\"以调用基类构造函数完成基类数据成员的初始化\",{\"1\":{\"673\":1}}],[\"以避免潜在的问题\",{\"1\":{\"578\":1}}],[\"以避免与普通指针混淆\",{\"1\":{\"530\":1}}],[\"以c语言的方式编译的int\",{\"1\":{\"572\":1}}],[\"以区间\",{\"1\":{\"537\":1}}],[\"以区别于构造函数\",{\"1\":{\"425\":1}}],[\"以此获得对象个数\",{\"1\":{\"523\":1}}],[\"以下的例子是从网络下载一个文件并保存在当前目录\",{\"1\":{\"1249\":1}}],[\"以下为非成员函数\",{\"1\":{\"541\":1}}],[\"以下摘自\",{\"1\":{\"505\":1}}],[\"以下均为我熟练使用的技能\",{\"1\":{\"0\":1}}],[\"以来编译器自己针对这些类型的模板实例化已经不满足代码的逻辑要求了\",{\"1\":{\"367\":1}}],[\"以2的倍数增长\",{\"1\":{\"354\":1}}],[\"以0作为八进制数的前缀\",{\"1\":{\"349\":1}}],[\"以及当前写日志的位置\",{\"1\":{\"1822\":1}}],[\"以及连接数据源的状态等\",{\"1\":{\"1792\":1}}],[\"以及提升了服务器安全\",{\"1\":{\"1790\":1}}],[\"以及服务器在运行过程中发生任何严重错误\",{\"1\":{\"1770\":1}}],[\"以及不缓存的数据\",{\"1\":{\"1750\":1}}],[\"以及按照不同的格式\",{\"1\":{\"1347\":1}}],[\"以及调用顺序\",{\"1\":{\"1109\":1}}],[\"以及其他特性的运行和操作\",{\"1\":{\"882\":1}}],[\"以及指针与足够大的整数类型之间的转换\",{\"1\":{\"632\":1}}],[\"以及具体的出错信息\",{\"1\":{\"599\":1}}],[\"以及\",{\"0\":{\"1593\":1},\"1\":{\"301\":1,\"454\":1,\"1708\":1}}],[\"以及c标准函数库\",{\"1\":{\"16\":1}}],[\"以后再select都不会再生成快照\",{\"1\":{\"1663\":1}}],[\"以后去查询\",{\"1\":{\"1658\":1}}],[\"以后每个数据成员的对齐按照\",{\"1\":{\"555\":1}}],[\"以后\",{\"1\":{\"283\":1,\"284\":1,\"1644\":1}}],[\"以\",{\"1\":{\"239\":1,\"301\":1,\"547\":1}}],[\"以便于在执行完毕后恢复现场是还原ebp的值\",{\"1\":{\"235\":1}}],[\"以便稳定排序\",{\"1\":{\"214\":1}}],[\"以长度为\",{\"1\":{\"140\":1}}],[\"可从库的mytest根本就没有user表\",{\"1\":{\"1830\":1}}],[\"可在my\",{\"1\":{\"1821\":1}}],[\"可尝试使用service\",{\"1\":{\"1799\":1}}],[\"可供开发人员分析耗时sql\",{\"1\":{\"1767\":1}}],[\"可用于数据恢复\",{\"1\":{\"1767\":1}}],[\"可用的起始和末尾地址\",{\"1\":{\"1102\":1}}],[\"可加速读写\",{\"1\":{\"1758\":1}}],[\"可存放索引缓存\",{\"1\":{\"1758\":1}}],[\"可想而知地了\",{\"1\":{\"1700\":1}}],[\"可解决幻读问题\",{\"1\":{\"1686\":1}}],[\"可不是像串行化一样通过sx锁或间隙锁实现\",{\"1\":{\"1682\":1}}],[\"可不可以只遍历一次呢\",{\"1\":{\"802\":1}}],[\"可重复读这两个隔离级别\",{\"1\":{\"1712\":1}}],[\"可重复读隔离级别\",{\"0\":{\"1664\":1,\"1665\":1},\"1\":{\"1635\":1,\"1656\":1,\"1708\":1}}],[\"可重复读\",{\"1\":{\"1631\":1,\"1665\":1,\"1677\":1,\"1717\":1}}],[\"可重定义的文件\",{\"1\":{\"251\":1}}],[\"可通过该列计算查询中使用的索引的长度\",{\"1\":{\"1521\":1}}],[\"可谓是以空间换取时间效率\",{\"1\":{\"1426\":1}}],[\"可使用\",{\"1\":{\"1310\":1}}],[\"可变参模板\",{\"1\":{\"1158\":1}}],[\"可变参数函数\",{\"1\":{\"1063\":1}}],[\"可变模板参数的优势\",{\"0\":{\"378\":1}}],[\"可变模板参数\",{\"0\":{\"375\":1}}],[\"可创建虚拟头节点简化操作\",{\"1\":{\"790\":1}}],[\"可调用的函数操作符的对象\",{\"1\":{\"784\":1}}],[\"可见性就会发生改变\",{\"1\":{\"1656\":1}}],[\"可见\",{\"1\":{\"1656\":1}}],[\"可见立即数\",{\"1\":{\"621\":1}}],[\"可见域\",{\"0\":{\"586\":1}}],[\"可看出此时以c方式生成符号\",{\"1\":{\"568\":1}}],[\"可为什么p\",{\"0\":{\"520\":1}}],[\"可转换成\",{\"1\":{\"491\":1}}],[\"可修改为如下方可通过编译🍗\",{\"1\":{\"490\":1}}],[\"可是不建议用goto语句\",{\"1\":{\"277\":1}}],[\"可执行程序的大小\",{\"1\":{\"1331\":1}}],[\"可执行的\",{\"1\":{\"252\":1}}],[\"可执行文件本身的全路径\",{\"1\":{\"1310\":1}}],[\"可执行文件放入bin目录中\",{\"1\":{\"1309\":1}}],[\"可执行文件\",{\"0\":{\"256\":1},\"1\":{\"251\":1}}],[\"可执行文件的组成格式是什么样的\",{\"1\":{\"244\":1}}],[\"可写的\",{\"1\":{\"252\":1}}],[\"可能包含更多的表资源和行资源的锁\",{\"1\":{\"1724\":1}}],[\"可能不会用到索引\",{\"1\":{\"1587\":1}}],[\"可能出现的就是这个报错\",{\"1\":{\"1407\":1}}],[\"可能遇到的报错\",{\"0\":{\"1294\":1}}],[\"可能引起扩容\",{\"1\":{\"969\":2,\"970\":2}}],[\"可能带有默认参数\",{\"1\":{\"641\":1}}],[\"可能会出现这种情况\",{\"1\":{\"1871\":1}}],[\"可能会出现没有预料的列出现\",{\"1\":{\"1511\":1}}],[\"可能会产生问题\",{\"1\":{\"1459\":1}}],[\"可能会有朋友会误认为智能指针是定义在堆\",{\"1\":{\"1041\":1}}],[\"可能会抛出任何类型的异常\",{\"1\":{\"607\":1}}],[\"可能会报错如下\",{\"1\":{\"234\":1}}],[\"可能抛出异常的语句\",{\"1\":{\"599\":1}}],[\"可能有的人比较擅长c语言\",{\"1\":{\"577\":1}}],[\"可能因为一些老的\",{\"1\":{\"293\":1}}],[\"可能直接导致\",{\"1\":{\"136\":1}}],[\"可以是括起来的或者\",{\"1\":{\"1899\":1}}],[\"可以是定义或声明\",{\"1\":{\"585\":1}}],[\"可以消费连接了\",{\"1\":{\"1849\":1,\"1859\":1,\"1875\":1}}],[\"可以支持更大的并发\",{\"1\":{\"1781\":1}}],[\"可以支持rtti类型识别的上下转换及识别\",{\"1\":{\"631\":1}}],[\"可以实现容灾\",{\"1\":{\"1780\":1}}],[\"可以实现跳转到标题\",{\"1\":{\"56\":1}}],[\"可以首先查看此日志\",{\"1\":{\"1770\":1}}],[\"可以分配大量的内存专门作为innodb的buffer\",{\"1\":{\"1758\":1}}],[\"可以分配出去一个小的内存池\",{\"1\":{\"1102\":1}}],[\"可以设置为0\",{\"1\":{\"1776\":1}}],[\"可以设置比较大的redo\",{\"1\":{\"1758\":1}}],[\"可以设置客户端的\",{\"1\":{\"1754\":1}}],[\"可以设置一个回调函数\",{\"1\":{\"1102\":1}}],[\"可以查看mysql查询缓存的使用状况\",{\"1\":{\"1750\":1}}],[\"可以查看日志\",{\"0\":{\"1411\":1}}],[\"可以考虑开启查询缓存\",{\"1\":{\"1750\":1}}],[\"可以提高导入的效率\",{\"1\":{\"1730\":1}}],[\"可以提高查询速度\",{\"1\":{\"1610\":1}}],[\"可以成功获取id=8的共享锁和排它锁\",{\"1\":{\"1699\":1}}],[\"可以对a进行但\",{\"1\":{\"1697\":1}}],[\"可以读取\",{\"1\":{\"1656\":1}}],[\"可以放在缓存\",{\"1\":{\"1864\":1}}],[\"可以放到\",{\"1\":{\"1800\":1}}],[\"可以放到相邻的4个页面上\",{\"1\":{\"1603\":1}}],[\"可以放心读数据\",{\"1\":{\"1635\":1}}],[\"可以加索引\",{\"1\":{\"1617\":1}}],[\"可以加作用域访问b或c中的成员\",{\"1\":{\"653\":1}}],[\"可以给任何类型的字段创建普通索引\",{\"1\":{\"1610\":1}}],[\"可以匹配任意的数据\",{\"1\":{\"1591\":1}}],[\"可以根据不同的分表算法进行拆分\",{\"1\":{\"1886\":1}}],[\"可以根据物理机的条件\",{\"1\":{\"1748\":1}}],[\"可以根据前缀的匹配缩小搜索范围\",{\"1\":{\"1591\":1}}],[\"可以根据右值\",{\"1\":{\"1194\":1}}],[\"可以利用索引进行\",{\"1\":{\"1591\":1}}],[\"可以先修改root密码\",{\"1\":{\"1556\":1}}],[\"可以先在本地文本编辑器写\",{\"1\":{\"1475\":1}}],[\"可以再细分为省\",{\"1\":{\"1460\":1}}],[\"可以重复\",{\"1\":{\"1437\":1}}],[\"可以重复的去使用\",{\"1\":{\"1154\":1}}],[\"可以为空\",{\"1\":{\"1434\":1,\"1437\":1,\"1610\":1}}],[\"可以发现上述表中存在大量的冗余信息=\",{\"1\":{\"1417\":1}}],[\"可以发现main函数内第一条指令地址就是前面的入口地址\",{\"1\":{\"260\":1}}],[\"可以选择先清除mysql\",{\"1\":{\"1405\":1}}],[\"可以立刻保存在客户端中收到的所有数据\",{\"1\":{\"1377\":1}}],[\"可以作某个规则的目标\",{\"1\":{\"1360\":1}}],[\"可以确保当程序崩溃时\",{\"1\":{\"1338\":1}}],[\"可以多个客户端版本共用一个服务端\",{\"1\":{\"1332\":1}}],[\"可以依据自己的需求进行改变\",{\"1\":{\"1309\":1}}],[\"可以跨平台\",{\"1\":{\"1303\":1}}],[\"可以在网络中进行\",{\"1\":{\"1903\":1}}],[\"可以在任意的mysql库上去重建库表及数据\",{\"1\":{\"1836\":1}}],[\"可以在mysql数据库下的mysql库的user表中更改允许登录的ip\",{\"1\":{\"1828\":1}}],[\"可以在mysql中进行如下修改\",{\"1\":{\"1407\":1}}],[\"可以在多个文件间进行\",{\"1\":{\"1267\":1}}],[\"可以在声明时进行初始化\",{\"0\":{\"458\":1}}],[\"可以精确做线程间的同步通信\",{\"1\":{\"1219\":1}}],[\"可以遍历数组\",{\"1\":{\"1194\":1}}],[\"可以接收外部自定义的函数对象\",{\"1\":{\"1183\":1}}],[\"可以接受派生类对象\",{\"1\":{\"1011\":1}}],[\"可以省略\",{\"1\":{\"1172\":1,\"1537\":1,\"1543\":1}}],[\"可以进行类型的推演\",{\"1\":{\"1148\":1}}],[\"可以辅助画图理解\",{\"1\":{\"1105\":1}}],[\"可以不满足分配20个块的要求\",{\"1\":{\"1102\":1}}],[\"可以看作一个反向代理服务器\",{\"1\":{\"1809\":1}}],[\"可以看见\",{\"1\":{\"1665\":1,\"1814\":1}}],[\"可以看到图中\",{\"1\":{\"1791\":1}}],[\"可以看到一个客户端读到了另一个客户端未提交的数据\",{\"1\":{\"1633\":1}}],[\"可以看到有很多问题\",{\"1\":{\"1208\":1}}],[\"可以看到\",{\"1\":{\"1079\":1,\"1635\":1}}],[\"可以看出\",{\"1\":{\"599\":1}}],[\"可以看出返回的是p1\",{\"1\":{\"517\":1}}],[\"可以看出每个符号都有其对应的虚拟地址以及所在的区域\",{\"1\":{\"257\":1}}],[\"可以留下lamda表达式的类型\",{\"1\":{\"1060\":1}}],[\"可以正常释放资源\",{\"1\":{\"1056\":1}}],[\"可以正常打印出10\",{\"1\":{\"1045\":1}}],[\"可以直接用临时对象拷贝构造\",{\"1\":{\"1127\":1}}],[\"可以直接使用在多线程的环境下\",{\"1\":{\"1055\":1}}],[\"可以直接写\",{\"1\":{\"594\":1}}],[\"可以自动推演模板类型参数\",{\"1\":{\"1154\":1}}],[\"可以自动产生临时量\",{\"1\":{\"622\":1}}],[\"可以自行添加合适的函数对象\",{\"1\":{\"1007\":1}}],[\"可以存储重复的元素\",{\"1\":{\"1002\":2}}],[\"可以修饰继承方式\",{\"1\":{\"932\":1}}],[\"可以修改临时量的内存c\",{\"1\":{\"622\":1}}],[\"可以修改指针所指变量的值\",{\"1\":{\"497\":1}}],[\"可以修改指针所指内容的值\",{\"1\":{\"488\":1}}],[\"可以得出结论\",{\"1\":{\"916\":1}}],[\"可以保证程序的扩展性\",{\"1\":{\"882\":1}}],[\"可以保证以c方式生成符号\",{\"1\":{\"570\":1}}],[\"可以让对象自动释放\",{\"1\":{\"853\":1}}],[\"可以让代码块编程一行\",{\"1\":{\"59\":1}}],[\"可以全局访问\",{\"1\":{\"841\":1}}],[\"可以借助\",{\"1\":{\"791\":1}}],[\"可以认为是确定函数的类型\",{\"1\":{\"784\":1}}],[\"可以封装一个友元类\",{\"1\":{\"723\":1}}],[\"可以复用多个基类的代码到派生类中\",{\"1\":{\"688\":1}}],[\"可以声明指向派生类的对象\",{\"1\":{\"678\":1}}],[\"可以声明一个变量\",{\"1\":{\"574\":1}}],[\"可以把它用于分布式应用之间的数据通信或者异构环境下的数据交换\",{\"1\":{\"1913\":1}}],[\"可以把binlog的内容写入relay\",{\"1\":{\"1783\":1}}],[\"可以把limit查询转换成某个位置的查询\",{\"1\":{\"1740\":1}}],[\"可以把绑定到派生类的对象\",{\"1\":{\"678\":1}}],[\"可以把给基类的对象\",{\"1\":{\"678\":1}}],[\"可以\",{\"1\":{\"630\":1,\"982\":1,\"1154\":1,\"1481\":1,\"1736\":1}}],[\"可以取地址的\",{\"1\":{\"621\":1}}],[\"可以处理的异常类型\",{\"1\":{\"599\":1}}],[\"可以简单的理解为一个全局整型变量\",{\"1\":{\"598\":1}}],[\"可以将引用理解成一种\",{\"1\":{\"922\":1}}],[\"可以将实现文件编译成库文件\",{\"1\":{\"826\":1}}],[\"可以将其混用\",{\"1\":{\"713\":1}}],[\"可以将命名空间中的实体全部引出来\",{\"1\":{\"594\":2}}],[\"可以将成员函数用const修饰\",{\"1\":{\"440\":1}}],[\"可以嵌套定义\",{\"1\":{\"585\":1}}],[\"可以有2种构造方式\",{\"1\":{\"1115\":1}}],[\"可以有一组\",{\"1\":{\"560\":1}}],[\"可以有重复值\",{\"0\":{\"95\":1}}],[\"可以被转换为const\",{\"1\":{\"490\":1}}],[\"可以隐式转换为\",{\"1\":{\"490\":1}}],[\"可以改变指针本身\",{\"1\":{\"497\":2}}],[\"可以改变指针的指向\",{\"1\":{\"488\":1}}],[\"可以改变p1指针的指向\",{\"1\":{\"488\":1}}],[\"可以改变元素的相对顺序\",{\"1\":{\"78\":1}}],[\"可以当数组下标\",{\"1\":{\"484\":1}}],[\"可以减小犯错误的概率\",{\"1\":{\"481\":1}}],[\"可以试试使用free去进行释放会发生什么\",{\"1\":{\"459\":1}}],[\"可以用于诸如网络传输\",{\"1\":{\"1913\":1}}],[\"可以用json\",{\"1\":{\"1906\":1}}],[\"可以用show\",{\"1\":{\"1574\":1}}],[\"可以用explain\",{\"1\":{\"1544\":1}}],[\"可以用not\",{\"1\":{\"1434\":1}}],[\"可以用new和delete表达式为对象分配动态存储区\",{\"1\":{\"459\":1}}],[\"可以用该方法关闭连接\",{\"1\":{\"1375\":1}}],[\"可以用下述可选的关键字指定消息类型\",{\"1\":{\"1318\":1}}],[\"可以用最小的代价平滑的升级库文件\",{\"1\":{\"826\":1}}],[\"可以用作数组下标\",{\"1\":{\"484\":1}}],[\"可以用这个属性值也可以去掉已经有下划线或删除线或顶划线的样式\",{\"1\":{\"50\":1}}],[\"可以说\",{\"1\":{\"449\":1}}],[\"可以调用非const版本的成员函数\",{\"1\":{\"440\":1}}],[\"可以去掉吗\",{\"0\":{\"399\":1,\"400\":1}}],[\"可以写例子看看\",{\"1\":{\"372\":1}}],[\"可以指定一块连续的空间\",{\"1\":{\"354\":1}}],[\"可以很容易想到malloc\",{\"1\":{\"285\":1}}],[\"可以使用带超时时间的mutex互斥锁来实现连接超时时间\",{\"1\":{\"1866\":1}}],[\"可以使用undo\",{\"1\":{\"1757\":1}}],[\"可以使用以下命令\",{\"1\":{\"1671\":1}}],[\"可以使用索引排序或者分组的查询\",{\"1\":{\"1618\":1}}],[\"可以使用索引过滤\",{\"1\":{\"1541\":1}}],[\"可以使用show\",{\"1\":{\"1569\":1}}],[\"可以使用shared\",{\"1\":{\"1050\":1}}],[\"可以使用having对order\",{\"1\":{\"1526\":1}}],[\"可以使用distinct\",{\"1\":{\"1512\":1}}],[\"可以使用ld\",{\"1\":{\"1331\":1}}],[\"可以使用可变模板参数代替\",{\"1\":{\"1158\":1}}],[\"可以使用友元形式进行设计\",{\"0\":{\"854\":1}}],[\"可以使用类名加作用域限定符进行调用\",{\"1\":{\"439\":1}}],[\"可以使用\",{\"1\":{\"261\":1,\"504\":1,\"506\":1}}],[\"可以使用二分查找查询边界\",{\"1\":{\"162\":1}}],[\"可以使用二分查找法\",{\"1\":{\"142\":1}}],[\"可以通过show\",{\"1\":{\"1830\":1}}],[\"可以通过set命令设置上面的缓存参数开启mysql查询缓存功能\",{\"1\":{\"1750\":1}}],[\"可以通过读写分离\",{\"1\":{\"1790\":1}}],[\"可以通过redis提供的api精确控制要缓存的数据\",{\"1\":{\"1750\":1}}],[\"可以通过以下命令\",{\"1\":{\"1750\":1}}],[\"可以通过变量innodb\",{\"1\":{\"1747\":1}}],[\"可以通过简单的\",{\"1\":{\"1303\":1}}],[\"可以通过netstat命令进行简单查询\",{\"1\":{\"1236\":1}}],[\"可以通过编译器的编译\",{\"1\":{\"1202\":1}}],[\"可以通过function函数对象类型\",{\"1\":{\"1154\":1}}],[\"可以通过typeid\",{\"1\":{\"957\":1}}],[\"可以通过下述方法解决\",{\"1\":{\"620\":1}}],[\"可以通过重载new和delete来解决内存泄漏\",{\"1\":{\"517\":1}}],[\"可以通过定义一个包含函数指针的结构体\",{\"1\":{\"494\":1}}],[\"可以通过继承和虚函数来实现\",{\"1\":{\"494\":1}}],[\"可以通过\",{\"0\":{\"494\":1},\"1\":{\"1299\":1}}],[\"可以通过转换变为int类型\",{\"1\":{\"473\":1}}],[\"可以通过ebp+12字节找到b的值\",{\"1\":{\"238\":1}}],[\"可以通过二分法拿到某一个目标值\",{\"1\":{\"95\":1}}],[\"可以相向的双指针\",{\"1\":{\"78\":1}}],[\"可以快速找出整个工程中所有的标记\",{\"1\":{\"41\":1}}],[\"可以右击选择jump\",{\"1\":{\"41\":1}}],[\"可以随机存储数据\",{\"1\":{\"17\":1}}],[\"可以长期存储的数据\",{\"1\":{\"16\":1}}],[\"可注明\",{\"1\":{\"0\":1}}],[\"广义上的文件指的是一类容量大\",{\"1\":{\"16\":1}}],[\"广州\",{\"1\":{\"0\":1}}],[\"狭义上的文件\",{\"1\":{\"16\":1}}],[\"9c810ccb629b445eaa9205e384e5e415\",{\"1\":{\"1773\":1}}],[\"9cf222f1743c\",{\"1\":{\"636\":1}}],[\"9538\",{\"1\":{\"1820\":2}}],[\"95\",{\"1\":{\"1537\":1}}],[\"9433aa85c0e746a89a74883d5a0daa01\",{\"1\":{\"1776\":1}}],[\"94\",{\"1\":{\"1537\":1}}],[\"94d6bd99e2ad\",{\"1\":{\"479\":1}}],[\"9066管理端口\",{\"0\":{\"1808\":1}}],[\"9066端口和8066端口\",{\"0\":{\"1807\":1}}],[\"90\",{\"1\":{\"1114\":2,\"1537\":1}}],[\"905\",{\"0\":{\"70\":1},\"1\":{\"70\":1}}],[\"9~16\",{\"1\":{\"1090\":3}}],[\"9及gcc\",{\"1\":{\"1016\":1}}],[\"98\",{\"1\":{\"819\":2}}],[\"92\",{\"0\":{\"801\":1},\"1\":{\"801\":1}}],[\"9f81\",{\"1\":{\"473\":1}}],[\"932c\",{\"1\":{\"500\":1}}],[\"93\",{\"1\":{\"283\":1,\"1537\":1}}],[\"99\",{\"1\":{\"188\":1,\"191\":1,\"819\":2,\"1537\":2}}],[\"9999999999\",{\"1\":{\"147\":1}}],[\"9^2\",{\"1\":{\"147\":1}}],[\"96f676ac\",{\"1\":{\"636\":1}}],[\"96\",{\"1\":{\"101\":4}}],[\"977\",{\"0\":{\"87\":1},\"1\":{\"87\":1}}],[\"9em\",{\"1\":{\"53\":2,\"54\":1,\"59\":3}}],[\"9rem\",{\"1\":{\"49\":1,\"51\":1}}],[\"9\",{\"0\":{\"1380\":1},\"1\":{\"11\":1,\"104\":3,\"107\":3,\"110\":2,\"129\":1,\"169\":5,\"234\":1,\"235\":1,\"378\":3,\"618\":1,\"747\":1,\"1007\":2,\"1008\":1,\"1016\":5,\"1032\":1,\"1114\":1,\"1115\":1,\"1296\":1,\"1310\":1,\"1719\":2,\"1774\":1}}],[\"数量是不限的\",{\"1\":{\"1610\":1}}],[\"数到m的那个人又出列\",{\"1\":{\"810\":1}}],[\"数到m的那个人出列\",{\"1\":{\"810\":1}}],[\"数目\",{\"1\":{\"692\":1}}],[\"数码取值为0～7\",{\"1\":{\"349\":1}}],[\"数值函数\",{\"0\":{\"1442\":1}}],[\"数值类型\",{\"0\":{\"1421\":1}}],[\"数值指针\",{\"1\":{\"493\":1}}],[\"数值范围\",{\"1\":{\"170\":1}}],[\"数值各个位上的数字的平方和\",{\"1\":{\"148\":1}}],[\"数值的范围\",{\"1\":{\"104\":1,\"107\":1,\"110\":1}}],[\"数组类型数据反序列化\",{\"0\":{\"1908\":1}}],[\"数组尽量使用vector可以动态地调整大小\",{\"1\":{\"1904\":1}}],[\"数组可以包含多个对象\",{\"1\":{\"1898\":1}}],[\"数组可能会很长\",{\"1\":{\"383\":1}}],[\"数组对应位置挂的内存池最大的\",{\"1\":{\"1082\":1}}],[\"数组增加删除为o\",{\"1\":{\"974\":1}}],[\"数组+双指针\",{\"0\":{\"755\":1}}],[\"数组越界\",{\"1\":{\"597\":1}}],[\"数组定义\",{\"1\":{\"535\":1}}],[\"数组new\",{\"1\":{\"517\":1}}],[\"数组nums中原地移除值为val的元素\",{\"1\":{\"76\":1}}],[\"数组指针\",{\"0\":{\"493\":1},\"1\":{\"493\":1,\"497\":1}}],[\"数组名char\",{\"1\":{\"535\":1}}],[\"数组名\",{\"1\":{\"457\":1}}],[\"数组的大小\",{\"1\":{\"1197\":1}}],[\"数组的子序列是一个由数组派生出来的序列\",{\"1\":{\"177\":1}}],[\"数组的实现\",{\"0\":{\"101\":1}}],[\"数组做哈希表\",{\"0\":{\"170\":1}}],[\"数组中同一个元素在答案里不能重复出现\",{\"1\":{\"124\":1}}],[\"数组中所有元素都相同或数组大小小于2\",{\"1\":{\"118\":1}}],[\"数组扩容消耗比较大\",{\"1\":{\"100\":1}}],[\"数组基础\",{\"0\":{\"100\":1}}],[\"数组是覆盖不是swap\",{\"1\":{\"78\":1}}],[\"数组\",{\"0\":{\"1918\":1},\"1\":{\"1899\":1},\"2\":{\"69\":1,\"72\":1,\"75\":1,\"80\":1,\"83\":1,\"86\":1,\"89\":1,\"99\":1,\"103\":1,\"106\":1,\"109\":1,\"112\":1,\"117\":1,\"120\":1,\"168\":1,\"173\":1,\"758\":1}}],[\"数据存储等诸多领域\",{\"1\":{\"1913\":1}}],[\"数据序列化\",{\"1\":{\"1915\":1},\"2\":{\"1911\":1}}],[\"数据序列化实例\",{\"0\":{\"1901\":1}}],[\"数据反序列化实例\",{\"0\":{\"1906\":1}}],[\"数据由逗号\",{\"1\":{\"1898\":1}}],[\"数据较大\",{\"1\":{\"1889\":1}}],[\"数据节点以及数据库主机名称都可以随便取\",{\"1\":{\"1803\":1}}],[\"数据节点\",{\"1\":{\"1803\":1}}],[\"数据会同步到从服务器\",{\"1\":{\"1790\":1}}],[\"数据备份\",{\"0\":{\"1956\":1},\"2\":{\"1778\":1,\"1838\":1}}],[\"数据已经全部恢复了\",{\"1\":{\"1774\":1}}],[\"数据恢复的时候使用\",{\"1\":{\"1773\":1}}],[\"数据操纵语言\",{\"1\":{\"1772\":1}}],[\"数据操纵语句\",{\"1\":{\"1548\":1}}],[\"数据目录\",{\"1\":{\"1770\":1}}],[\"数据仍然可以恢复\",{\"1\":{\"1762\":1}}],[\"数据通常保存在buffer\",{\"1\":{\"1762\":1}}],[\"数据页状态的更改\",{\"1\":{\"1762\":1}}],[\"数据就可以恢复\",{\"1\":{\"1762\":1}}],[\"数据缓存等\",{\"1\":{\"1758\":1}}],[\"数据有被修改\",{\"0\":{\"1760\":1}}],[\"数据有序插入\",{\"0\":{\"1735\":1}}],[\"数据有2种状态\",{\"1\":{\"1658\":1}}],[\"数据处于prepare状态\",{\"1\":{\"1658\":1}}],[\"数据处理完成\",{\"1\":{\"1385\":1}}],[\"数据快照\",{\"1\":{\"1656\":1}}],[\"数据将恢复到事务开始前的状态\",{\"1\":{\"1650\":1}}],[\"数据的更新会记录在binlog\",{\"1\":{\"1781\":1}}],[\"数据的状态还是prepare\",{\"1\":{\"1763\":1}}],[\"数据的安全性最低\",{\"1\":{\"1712\":1}}],[\"数据的安全性和事务的并发性\",{\"1\":{\"1644\":1}}],[\"数据的集合\",{\"1\":{\"1490\":1}}],[\"数据都是不会变的\",{\"1\":{\"1635\":1}}],[\"数据在内存的其他位置\",{\"1\":{\"1603\":1}}],[\"数据和索引是单独存放的\",{\"1\":{\"1557\":1}}],[\"数据以及索引的存储方式\",{\"1\":{\"1555\":1}}],[\"数据以表格的形式存储\",{\"1\":{\"1451\":1}}],[\"数据控制语句\",{\"1\":{\"1548\":1}}],[\"数据定义语言\",{\"1\":{\"1548\":1,\"1772\":1}}],[\"数据量太大造成的\",{\"1\":{\"1889\":1}}],[\"数据量太大导致索引文件过大\",{\"1\":{\"1886\":1}}],[\"数据量\",{\"1\":{\"1537\":1}}],[\"数据集合3\",{\"1\":{\"1490\":1}}],[\"数据集合2\",{\"1\":{\"1490\":1}}],[\"数据集合1\",{\"1\":{\"1490\":1}}],[\"数据3\",{\"1\":{\"1490\":1}}],[\"数据2\",{\"1\":{\"1490\":1}}],[\"数据1\",{\"1\":{\"1490\":1}}],[\"数据越大优先级越高\",{\"1\":{\"992\":1}}],[\"数据从大到小依次出队\",{\"1\":{\"992\":1}}],[\"数据下标的随机访问vec\",{\"1\":{\"965\":1}}],[\"数据对象\",{\"1\":{\"871\":1,\"1907\":1}}],[\"数据结构\",{\"1\":{\"553\":1}}],[\"数据结构与算法\",{\"2\":{\"68\":1,\"71\":1,\"74\":1,\"79\":1,\"82\":1,\"85\":1,\"88\":1,\"98\":1,\"102\":1,\"105\":1,\"108\":1,\"111\":1,\"116\":1,\"119\":1,\"127\":1,\"130\":1,\"138\":1,\"144\":1,\"150\":1,\"156\":1,\"159\":1,\"164\":1,\"167\":1,\"172\":1,\"175\":1,\"180\":1,\"183\":1,\"189\":1,\"192\":1,\"197\":1,\"200\":1,\"203\":1,\"206\":1,\"215\":1,\"218\":1,\"221\":1,\"757\":1,\"760\":1,\"763\":1,\"766\":1,\"769\":1,\"772\":1,\"775\":1,\"778\":1,\"785\":1,\"788\":1,\"793\":1,\"796\":1,\"799\":1,\"804\":1,\"807\":1,\"813\":1,\"824\":1}}],[\"数据库主机\",{\"1\":{\"1888\":1,\"1891\":1}}],[\"数据库架构演变\",{\"1\":{\"1885\":1}}],[\"数据库编程部分的实现\",{\"0\":{\"1854\":1}}],[\"数据库操作代码\",{\"1\":{\"1866\":1}}],[\"数据库操作的封装实现\",{\"0\":{\"1847\":1}}],[\"数据库操作头文件\",{\"0\":{\"1846\":1}}],[\"数据库连接池的配置文件\",{\"1\":{\"1844\":1,\"1878\":1}}],[\"数据库的连接操作\",{\"1\":{\"1846\":1,\"1856\":1}}],[\"数据库的性能到瓶颈了\",{\"1\":{\"1790\":1}}],[\"数据库的一致性状态必须由用户来负责\",{\"1\":{\"1644\":1}}],[\"数据库最重要的是日志\",{\"1\":{\"1763\":1}}],[\"数据库引擎可以通过命令临时修改\",{\"1\":{\"1652\":1}}],[\"数据库引擎会比较用a=1过滤的数据和b=2过滤的数据\",{\"1\":{\"1589\":1}}],[\"数据库数据必须保持一致性状态\",{\"1\":{\"1644\":1}}],[\"数据库索引是存储在磁盘上的\",{\"1\":{\"1621\":1}}],[\"数据库版本\",{\"1\":{\"1508\":1}}],[\"数据库下清屏语句\",{\"1\":{\"1508\":1}}],[\"数据库中的死锁\",{\"0\":{\"1706\":1}}],[\"数据库中添加的用户\",{\"1\":{\"1374\":1}}],[\"数据库中字符串使用的是单引号\",{\"1\":{\"535\":1}}],[\"数据库相关\",{\"1\":{\"0\":1}}],[\"数据成员只有一个指针\",{\"1\":{\"826\":1}}],[\"数据成员对齐规则\",{\"0\":{\"555\":1}}],[\"数据成员\",{\"1\":{\"449\":1,\"450\":2}}],[\"数据\",{\"1\":{\"449\":1,\"1491\":1,\"1494\":1,\"1622\":1}}],[\"数据类型为int\",{\"1\":{\"1552\":1}}],[\"数据类型为date\",{\"1\":{\"1552\":1}}],[\"数据类型为varchar\",{\"1\":{\"1552\":1}}],[\"数据类型作用\",{\"1\":{\"326\":1}}],[\"数据类型\",{\"0\":{\"317\":1,\"326\":1}}],[\"数据段\",{\"1\":{\"267\":2}}],[\"数据加载到指定段\",{\"1\":{\"263\":1}}],[\"数字yg\",{\"1\":{\"1142\":1}}],[\"数字dg\",{\"1\":{\"1142\":1}}],[\"数字没出现过\",{\"1\":{\"1001\":1}}],[\"数字和下划线三种字符组成\",{\"1\":{\"316\":1}}],[\"数字个数为\",{\"1\":{\"11\":1}}],[\"数字\",{\"0\":{\"11\":1}}],[\"z=s\",{\"1\":{\"1878\":1}}],[\"zxvf\",{\"1\":{\"1285\":1,\"1305\":1}}],[\"z使用gzip文件\",{\"1\":{\"1260\":1}}],[\"zip文件\",{\"0\":{\"1262\":1}}],[\"zip\",{\"1\":{\"1249\":1,\"1251\":1,\"1252\":1,\"1253\":1,\"1262\":1}}],[\"zhihu\",{\"1\":{\"1828\":1,\"1869\":1}}],[\"zhangsan\",{\"1\":{\"1428\":1,\"1537\":1,\"1569\":1,\"1603\":1,\"1700\":1,\"1902\":1,\"1903\":1,\"1904\":3,\"1907\":1,\"1908\":3}}],[\"zhang\",{\"1\":{\"1415\":2,\"1475\":3,\"1478\":1,\"1511\":2,\"1591\":1,\"1603\":1,\"1915\":1}}],[\"zh\",{\"1\":{\"1249\":1,\"1252\":1,\"1253\":1}}],[\"zhjvawrzyw5zzmfsbgjhy2s\",{\"1\":{\"1082\":1}}],[\"zeros\",{\"1\":{\"1082\":1}}],[\"zstl8\",{\"1\":{\"572\":1}}],[\"zstl19piecewise\",{\"1\":{\"572\":1}}],[\"znst8ios\",{\"1\":{\"572\":2}}],[\"z41\",{\"1\":{\"572\":1}}],[\"z4funcpki\",{\"1\":{\"563\":1}}],[\"z4funcpi\",{\"1\":{\"563\":1}}],[\"z3addiii\",{\"1\":{\"572\":1}}],[\"z3addfif\",{\"1\":{\"572\":1}}],[\"z3addfff\",{\"1\":{\"572\":1}}],[\"z3addff\",{\"1\":{\"572\":1}}],[\"z3sumii\",{\"1\":{\"246\":2}}],[\"zone=public\",{\"1\":{\"1818\":1}}],[\"zone\",{\"1\":{\"267\":4}}],[\"zw\",{\"1\":{\"239\":2,\"1271\":25}}],[\"z\",{\"1\":{\"8\":2,\"11\":2,\"571\":6,\"642\":4,\"1287\":1}}],[\">userdb<\",{\"1\":{\"1891\":1}}],[\">userdb1\",{\"1\":{\"1888\":1}}],[\">update\",{\"1\":{\"1851\":2}}],[\">123456<\",{\"1\":{\"1888\":1,\"1891\":1}}],[\">loadconfigfile\",{\"1\":{\"1878\":1}}],[\">refreshalivetime\",{\"1\":{\"1849\":3,\"1859\":3}}],[\">710字节\",{\"1\":{\"1773\":1}}],[\">如果connect\",{\"1\":{\"1754\":1}}],[\">如果wait\",{\"1\":{\"1754\":1}}],[\">快照读依赖的是的undo\",{\"1\":{\"1677\":1}}],[\">返回值\",{\"1\":{\"1172\":2}}],[\">~\",{\"1\":{\"1080\":1,\"1086\":1}}],[\">~t\",{\"1\":{\"385\":1,\"704\":1,\"1080\":1,\"1087\":1,\"1127\":1}}],[\">warn\",{\"1\":{\"1032\":2}}],[\">虚函数名\",{\"1\":{\"925\":1}}],[\">虚函数地址\",{\"1\":{\"875\":1}}],[\">error\",{\"1\":{\"1032\":2}}],[\">ebp当前函数栈帧初始化为0\",{\"1\":{\"908\":1}}],[\">ebp\",{\"1\":{\"908\":1}}],[\">empty\",{\"1\":{\"182\":1}}],[\">display\",{\"1\":{\"913\":1}}],[\">d\",{\"1\":{\"890\":2}}],[\">dog\",{\"1\":{\"886\":1}}],[\">defref\",{\"1\":{\"1055\":2}}],[\">debug\",{\"1\":{\"1032\":2}}],[\">deleteatindex\",{\"1\":{\"791\":1,\"792\":1}}],[\">derive02func\",{\"1\":{\"631\":1}}],[\">handle\",{\"1\":{\"871\":1}}],[\">t1\",{\"1\":{\"1114\":1}}],[\">t5\",{\"1\":{\"1114\":1}}],[\">t4\",{\"1\":{\"1114\":1}}],[\">t2\",{\"1\":{\"1114\":1}}],[\">t3\",{\"1\":{\"1114\":1}}],[\">test\",{\"1\":{\"1112\":3}}],[\">testa\",{\"1\":{\"1050\":3,\"1057\":2}}],[\">tempaltename\",{\"1\":{\"6\":1}}],[\">ticketmovie\",{\"1\":{\"830\":1}}],[\">getconnection\",{\"1\":{\"1851\":2}}],[\">getalivetime\",{\"1\":{\"1849\":1,\"1859\":1}}],[\">getqueue\",{\"1\":{\"1020\":1}}],[\">getmilespergallon\",{\"1\":{\"900\":1}}],[\">get\",{\"1\":{\"791\":1,\"792\":1,\"1219\":2}}],[\">void\",{\"1\":{\"1007\":1,\"1060\":2,\"1173\":1}}],[\">vipmovie\",{\"1\":{\"830\":2}}],[\">val不是cur\",{\"1\":{\"759\":1}}],[\">val\",{\"1\":{\"755\":1,\"756\":3,\"759\":1,\"762\":6,\"782\":2,\"783\":2,\"784\":2,\"791\":1,\"792\":1,\"795\":1}}],[\">vftable\",{\"1\":{\"631\":2,\"875\":1}}],[\">vfptr\",{\"1\":{\"631\":2}}],[\">next\",{\"1\":{\"755\":1,\"756\":12,\"759\":10,\"762\":14,\"765\":4,\"768\":6,\"771\":8,\"774\":15,\"777\":10,\"782\":8,\"783\":8,\"784\":5,\"787\":8,\"791\":16,\"792\":11,\"795\":9,\"798\":10,\"802\":11,\"806\":3}}],[\">bool\",{\"1\":{\"1008\":1,\"1177\":1,\"1178\":1,\"1183\":1}}],[\">bark\",{\"1\":{\"886\":1,\"905\":2}}],[\">b\",{\"1\":{\"695\":1,\"724\":1,\"890\":3,\"1177\":1}}],[\">addref\",{\"1\":{\"1055\":2}}],[\">addatindex\",{\"1\":{\"791\":1,\"792\":1}}],[\">addattail\",{\"1\":{\"791\":1,\"792\":1}}],[\">addathead\",{\"1\":{\"791\":1,\"792\":1}}],[\">add\",{\"1\":{\"695\":2}}],[\">a\",{\"1\":{\"695\":1,\"890\":3}}],[\">我们的\",{\"1\":{\"688\":1}}],[\">first\",{\"1\":{\"1000\":1,\"1001\":1,\"1002\":1}}],[\">f\",{\"1\":{\"889\":1,\"891\":2}}],[\">freemovie\",{\"1\":{\"830\":3}}],[\">fun\",{\"1\":{\"695\":1}}],[\">func\",{\"1\":{\"631\":3,\"1057\":2}}],[\">f5\",{\"1\":{\"306\":1}}],[\">>=\",{\"1\":{\"730\":1}}],[\">>\",{\"1\":{\"476\":2,\"601\":2,\"602\":2,\"731\":3,\"736\":2,\"784\":3,\"871\":2,\"1060\":2,\"1102\":1,\"1168\":2,\"1271\":1}}],[\">成员方法\",{\"1\":{\"446\":1}}],[\">成员变量\",{\"1\":{\"446\":1}}],[\">m\",{\"1\":{\"405\":1}}],[\">magic\",{\"1\":{\"323\":1}}],[\">数据成员的方式\",{\"1\":{\"392\":1}}],[\">预处理到文件\",{\"1\":{\"311\":1}}],[\">预处理器定义\",{\"1\":{\"293\":1}}],[\">预处理器\",{\"1\":{\"293\":1}}],[\">属性\",{\"1\":{\"311\":1}}],[\">勾选行号\",{\"1\":{\"309\":1}}],[\">打开监视\",{\"1\":{\"306\":1}}],[\">编辑最下面加上一行\",{\"1\":{\"293\":1}}],[\">connection\",{\"1\":{\"1839\":1,\"1849\":2,\"1859\":2,\"1875\":2}}],[\">const\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1}}],[\">cat\",{\"1\":{\"886\":1}}],[\">createcarlight\",{\"1\":{\"867\":2}}],[\">createcar\",{\"1\":{\"864\":4,\"866\":2,\"867\":2}}],[\">c\",{\"1\":{\"293\":1,\"311\":1,\"724\":1,\"890\":3}}],[\">配置属性\",{\"1\":{\"293\":1,\"311\":1}}],[\">start\",{\"1\":{\"1151\":1}}],[\">setthreshold\",{\"1\":{\"1025\":1}}],[\">setconversionpattern\",{\"1\":{\"1021\":1,\"1031\":4,\"1032\":2}}],[\">setlayout\",{\"1\":{\"1020\":1,\"1021\":1,\"1031\":6,\"1032\":2}}],[\">second++\",{\"1\":{\"1001\":1}}],[\">second\",{\"1\":{\"125\":1,\"871\":2,\"1000\":1,\"1001\":2,\"1002\":1,\"1168\":1}}],[\">show\",{\"1\":{\"831\":6,\"864\":4,\"866\":2,\"867\":4,\"906\":1,\"907\":3,\"908\":2,\"920\":3,\"948\":1,\"953\":4,\"954\":2,\"1041\":2,\"1055\":1}}],[\">speak\",{\"1\":{\"494\":1}}],[\">size\",{\"1\":{\"286\":3}}],[\">int\",{\"1\":{\"1166\":2,\"1173\":1,\"1839\":1,\"1849\":1,\"1875\":1}}],[\">info\",{\"1\":{\"1032\":2}}],[\">initwithstring\",{\"1\":{\"271\":1}}],[\">is\",{\"1\":{\"286\":3,\"287\":1}}],[\">put\",{\"1\":{\"1219\":2}}],[\">push\",{\"1\":{\"182\":1}}],[\">p4\",{\"1\":{\"1114\":1}}],[\">p2\",{\"1\":{\"1114\":1}}],[\">ptr1\",{\"1\":{\"1056\":2,\"1057\":1}}],[\">ptr2\",{\"1\":{\"1056\":2,\"1057\":1}}],[\">pig\",{\"1\":{\"886\":1}}],[\">play\",{\"1\":{\"832\":2}}],[\">pre\",{\"1\":{\"792\":12}}],[\">printlineimpl\",{\"1\":{\"826\":1}}],[\">print\",{\"1\":{\"455\":1,\"459\":3,\"678\":2,\"949\":1}}],[\">peek\",{\"1\":{\"182\":1}}],[\">pop\",{\"1\":{\"182\":1}}],[\">兼容性\",{\"1\":{\"65\":1}}],[\">常规\",{\"1\":{\"65\":1}}],[\">选项\",{\"1\":{\"65\":1}}],[\"><\",{\"1\":{\"61\":1}}],[\">添加\",{\"1\":{\"46\":1}}],[\">添加或编辑自定义的短语\",{\"1\":{\"46\":1}}],[\">用户自定义的短语\",{\"1\":{\"46\":1}}],[\">词库和自学习\",{\"1\":{\"46\":1}}],[\">\",{\"1\":{\"29\":1,\"45\":1,\"62\":8,\"63\":4,\"81\":2,\"87\":1,\"96\":1,\"101\":1,\"110\":1,\"118\":2,\"121\":2,\"126\":1,\"133\":3,\"135\":1,\"136\":8,\"137\":1,\"142\":4,\"143\":3,\"147\":3,\"154\":1,\"155\":1,\"162\":1,\"174\":1,\"179\":1,\"188\":1,\"191\":2,\"194\":3,\"199\":1,\"205\":1,\"214\":1,\"234\":1,\"236\":1,\"309\":1,\"355\":2,\"360\":2,\"365\":3,\"366\":5,\"368\":4,\"370\":1,\"392\":2,\"412\":2,\"414\":1,\"440\":4,\"459\":2,\"500\":1,\"501\":1,\"528\":1,\"547\":1,\"563\":4,\"571\":1,\"599\":2,\"625\":3,\"629\":2,\"630\":2,\"631\":1,\"632\":1,\"633\":2,\"678\":2,\"699\":1,\"709\":2,\"731\":10,\"736\":5,\"747\":16,\"751\":12,\"771\":1,\"782\":1,\"783\":3,\"784\":6,\"791\":1,\"792\":1,\"810\":9,\"817\":31,\"819\":21,\"821\":28,\"826\":1,\"871\":1,\"908\":2,\"980\":1,\"981\":1,\"982\":1,\"984\":1,\"985\":1,\"1001\":1,\"1008\":1,\"1041\":2,\"1055\":2,\"1076\":3,\"1079\":3,\"1080\":1,\"1086\":2,\"1093\":2,\"1096\":3,\"1099\":2,\"1102\":3,\"1105\":1,\"1148\":1,\"1151\":3,\"1155\":1,\"1158\":5,\"1164\":1,\"1165\":2,\"1166\":1,\"1167\":1,\"1183\":2,\"1186\":1,\"1187\":3,\"1188\":12,\"1208\":1,\"1209\":4,\"1210\":2,\"1250\":1,\"1271\":3,\"1521\":9,\"1523\":1,\"1592\":1,\"1618\":1,\"1686\":1,\"1740\":1,\"1754\":2,\"1828\":2,\"1836\":6,\"1839\":1,\"1848\":1,\"1849\":2,\"1859\":3,\"1875\":1,\"1878\":1,\"1888\":18,\"1891\":18}}],[\">在这台电脑上查找其他应用\",{\"1\":{\"28\":1}}],[\">=\",{\"1\":{\"8\":2,\"11\":3,\"60\":1,\"73\":1,\"87\":1,\"101\":2,\"194\":1,\"199\":1,\"205\":1,\"214\":1,\"220\":2,\"286\":1,\"704\":1,\"791\":2,\"792\":2,\"1102\":2}}],[\"<writehost\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"<heartbeat>select\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"<datahost\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"<datanode\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"<deque>\",{\"1\":{\"969\":1}}],[\"<property\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"<pthread\",{\"1\":{\"493\":1}}],[\"<user\",{\"1\":{\"1888\":1,\"1891\":1}}],[\"<unistd\",{\"1\":{\"1299\":1,\"1384\":1,\"1385\":1}}],[\"<unordered\",{\"1\":{\"104\":1,\"107\":1,\"110\":1,\"871\":1,\"999\":1,\"1000\":1}}],[\"<网络类型>\",{\"1\":{\"1237\":1}}],[\"<atomic>\",{\"1\":{\"1233\":2,\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1}}],[\"<algorithm>泛型算法\",{\"1\":{\"1007\":1}}],[\"<algorithm>\",{\"1\":{\"60\":1,\"214\":1,\"1146\":1,\"1147\":1,\"1148\":1,\"1168\":1}}],[\"<queue>\",{\"1\":{\"1183\":1,\"1219\":1,\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"<指定大小的内存>\",{\"1\":{\"1102\":1}}],[\"<int\",{\"1\":{\"1079\":1,\"1080\":1,\"1102\":1}}],[\"<iostream>\",{\"1\":{\"8\":1,\"11\":1,\"60\":1,\"101\":1,\"104\":1,\"107\":1,\"110\":1,\"118\":1,\"185\":1,\"188\":1,\"191\":1,\"194\":1,\"214\":1,\"224\":1,\"234\":1,\"378\":1,\"405\":1,\"406\":1,\"433\":1,\"434\":1,\"459\":1,\"468\":1,\"476\":1,\"497\":1,\"500\":1,\"506\":1,\"515\":1,\"547\":1,\"548\":1,\"557\":1,\"569\":1,\"571\":1,\"588\":2,\"590\":1,\"594\":6,\"597\":1,\"599\":1,\"601\":4,\"602\":1,\"605\":1,\"606\":1,\"614\":1,\"618\":1,\"621\":1,\"633\":1,\"642\":1,\"662\":2,\"731\":1,\"751\":1,\"810\":1,\"817\":2,\"819\":1,\"821\":1,\"830\":1,\"831\":1,\"832\":1,\"849\":1,\"852\":1,\"871\":1,\"889\":1,\"891\":1,\"894\":1,\"953\":1,\"1031\":1,\"1032\":1,\"1041\":1,\"1055\":1,\"1060\":1,\"1115\":1,\"1123\":1,\"1147\":1,\"1148\":1,\"1151\":1,\"1154\":1,\"1158\":1,\"1168\":1,\"1183\":1,\"1188\":1,\"1207\":1,\"1209\":1,\"1219\":1,\"1233\":1,\"1299\":2,\"1321\":1,\"1839\":1,\"1847\":1,\"1849\":1,\"1856\":2,\"1859\":1,\"1875\":1,\"1878\":2,\"1915\":1}}],[\"<bool\",{\"1\":{\"1076\":1,\"1079\":1,\"1081\":1,\"1082\":5,\"1090\":1,\"1096\":1,\"1099\":1,\"1102\":1}}],[\"<bits\",{\"1\":{\"234\":1}}],[\"<log4cpp\",{\"1\":{\"1031\":8,\"1032\":5}}],[\"<list>\",{\"1\":{\"871\":1,\"970\":1,\"1209\":1,\"1233\":1}}],[\"<mycat\",{\"1\":{\"1888\":1,\"1891\":1}}],[\"<mysql\",{\"1\":{\"1372\":2,\"1383\":1,\"1384\":1,\"1385\":1,\"1399\":1,\"1846\":1,\"1856\":1,\"1859\":1}}],[\"<map>\",{\"1\":{\"1002\":1,\"1168\":1}}],[\"<mutex>\",{\"0\":{\"1209\":1},\"1\":{\"849\":1,\"852\":1,\"1209\":1,\"1219\":1,\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"<memory>头文件\",{\"1\":{\"1042\":1}}],[\"<memory>\",{\"1\":{\"830\":1,\"831\":1,\"849\":1,\"852\":1,\"864\":1,\"1055\":1,\"1060\":1,\"1151\":1,\"1154\":1,\"1848\":1,\"1859\":1,\"1875\":1}}],[\"<exception>\",{\"1\":{\"599\":1,\"601\":3,\"606\":1}}],[\"<模板参数列表>\",{\"1\":{\"362\":1}}],[\"<table\",{\"1\":{\"1891\":2}}],[\"<tab>查看已安装的主题有哪些\",{\"1\":{\"1143\":1}}],[\"<tab>\",{\"1\":{\"1133\":1,\"1353\":1}}],[\"<thread>\",{\"1\":{\"1060\":1,\"1151\":1,\"1154\":1,\"1207\":1,\"1209\":1,\"1219\":1,\"1233\":1,\"1848\":1,\"1859\":1,\"1875\":1}}],[\"<typeinfo\",{\"1\":{\"614\":1}}],[\"<typeinfo>\",{\"1\":{\"492\":1,\"563\":1,\"614\":1,\"621\":1,\"953\":1,\"1151\":1,\"1154\":1,\"1158\":1}}],[\"<typename\",{\"1\":{\"355\":1,\"360\":1,\"362\":1,\"370\":2,\"371\":1,\"372\":1,\"378\":3,\"385\":2,\"388\":7,\"704\":2,\"1080\":1,\"1087\":2,\"1127\":1,\"1189\":1}}],[\"<time\",{\"1\":{\"101\":1,\"817\":1}}],[\"<>\",{\"1\":{\"312\":1}}],[\"<+53>\",{\"1\":{\"234\":1}}],[\"<+52>\",{\"1\":{\"234\":1}}],[\"<+47>\",{\"1\":{\"234\":1}}],[\"<+44>\",{\"1\":{\"234\":1,\"236\":1}}],[\"<+41>\",{\"1\":{\"234\":1,\"236\":1}}],[\"<+36>\",{\"1\":{\"234\":1,\"236\":1}}],[\"<+33>\",{\"1\":{\"234\":1,\"236\":1}}],[\"<+30>\",{\"1\":{\"234\":1,\"236\":1}}],[\"<+38>\",{\"1\":{\"234\":1}}],[\"<+37>\",{\"1\":{\"234\":1}}],[\"<+34>\",{\"1\":{\"234\":1}}],[\"<+31>\",{\"1\":{\"234\":1}}],[\"<+3>\",{\"1\":{\"234\":2,\"235\":1}}],[\"<+29>\",{\"1\":{\"234\":1}}],[\"<+26>\",{\"1\":{\"234\":1}}],[\"<+23>\",{\"1\":{\"234\":2,\"236\":1}}],[\"<+16>\",{\"1\":{\"234\":2,\"236\":1}}],[\"<+11>\",{\"1\":{\"234\":2}}],[\"<+1>\",{\"1\":{\"234\":2,\"235\":1}}],[\"<+6>\",{\"1\":{\"234\":2}}],[\"<+0>\",{\"1\":{\"234\":2,\"235\":1}}],[\"<cassert>\",{\"1\":{\"1321\":1}}],[\"<condition\",{\"1\":{\"1219\":1,\"1848\":1,\"1859\":1,\"1875\":1}}],[\"<class\",{\"1\":{\"360\":1,\"378\":1,\"389\":1,\"1079\":1,\"1080\":1,\"1086\":6}}],[\"<climits>\",{\"1\":{\"118\":1,\"191\":1,\"214\":1}}],[\"<cstdio>\",{\"1\":{\"1188\":1,\"1299\":1}}],[\"<cstdlib>\",{\"1\":{\"188\":1,\"191\":1,\"1299\":1}}],[\"<cstring>\",{\"1\":{\"202\":1,\"224\":1,\"1299\":1}}],[\"<ctime>\",{\"1\":{\"188\":1,\"191\":1,\"751\":1,\"1147\":1,\"1148\":1,\"1168\":1,\"1846\":1,\"1859\":1}}],[\"<schema\",{\"1\":{\"1888\":2,\"1891\":1}}],[\"<set>\",{\"1\":{\"1002\":1}}],[\"<sum\",{\"1\":{\"234\":1,\"236\":1}}],[\"<stdio\",{\"1\":{\"277\":2,\"293\":1,\"323\":1,\"338\":1,\"476\":1,\"494\":1,\"570\":1,\"594\":1,\"1383\":1,\"1384\":1,\"1385\":1}}],[\"<stdexcept>\",{\"1\":{\"224\":1,\"605\":1,\"606\":1}}],[\"<stdlib\",{\"1\":{\"101\":1,\"277\":2,\"515\":1,\"571\":1,\"817\":1,\"1299\":1,\"1384\":1,\"1385\":1}}],[\"<string>\",{\"1\":{\"191\":1,\"378\":1,\"547\":1,\"597\":1,\"599\":1,\"601\":3,\"832\":1,\"871\":1,\"1032\":1,\"1151\":1,\"1154\":1,\"1158\":1,\"1168\":1,\"1299\":1,\"1839\":1,\"1846\":1,\"1848\":1,\"1856\":1,\"1859\":2,\"1875\":1,\"1878\":1,\"1915\":1}}],[\"<string\",{\"1\":{\"101\":1,\"547\":1,\"548\":1,\"571\":1,\"662\":2}}],[\"<sstream>\",{\"1\":{\"60\":1}}],[\"<vector>\",{\"1\":{\"60\":1,\"104\":1,\"107\":1,\"110\":1,\"118\":1,\"188\":2,\"191\":1,\"194\":1,\"199\":1,\"202\":1,\"205\":1,\"214\":1,\"217\":1,\"220\":1,\"965\":1,\"1060\":1,\"1147\":1,\"1148\":1,\"1151\":1,\"1154\":1,\"1168\":1}}],[\"<functional>\",{\"1\":{\"1060\":1,\"1146\":1,\"1147\":1,\"1148\":1,\"1151\":1,\"1154\":1,\"1158\":1,\"1168\":1,\"1183\":1,\"1848\":1,\"1859\":1,\"1875\":1}}],[\"<functional>绑定器\",{\"1\":{\"1008\":1}}],[\"<fstream>\",{\"1\":{\"60\":1}}],[\"<font\",{\"1\":{\"29\":1,\"688\":1}}],[\"<\",{\"1\":{\"29\":2,\"45\":1,\"59\":2,\"67\":2,\"70\":5,\"73\":1,\"77\":1,\"78\":2,\"81\":3,\"84\":2,\"93\":1,\"94\":2,\"96\":1,\"97\":3,\"101\":7,\"104\":1,\"110\":2,\"115\":1,\"118\":2,\"125\":1,\"126\":2,\"133\":5,\"136\":4,\"137\":3,\"140\":1,\"141\":1,\"142\":2,\"143\":4,\"158\":1,\"162\":1,\"166\":3,\"179\":1,\"188\":3,\"191\":6,\"194\":2,\"199\":2,\"202\":2,\"205\":3,\"214\":2,\"217\":4,\"220\":5,\"234\":2,\"330\":4,\"406\":1,\"494\":1,\"699\":1,\"704\":1,\"736\":2,\"747\":1,\"751\":2,\"755\":1,\"762\":1,\"782\":2,\"783\":2,\"784\":4,\"791\":3,\"792\":5,\"795\":1,\"802\":2,\"810\":2,\"817\":1,\"819\":1,\"908\":1,\"981\":1,\"982\":1,\"1002\":1,\"1008\":2,\"1031\":1,\"1127\":4,\"1147\":1,\"1148\":2,\"1151\":3,\"1177\":1,\"1178\":1,\"1233\":2,\"1385\":2,\"1592\":1,\"1839\":1,\"1849\":2,\"1851\":4,\"1859\":2,\"1875\":2,\"1888\":14,\"1891\":14}}],[\"<=>\",{\"1\":{\"255\":1}}],[\"<=\",{\"1\":{\"8\":2,\"11\":3,\"78\":4,\"93\":1,\"97\":1,\"140\":2,\"142\":1,\"158\":2,\"161\":10,\"162\":14,\"170\":4,\"202\":4,\"220\":1,\"441\":1,\"490\":1,\"491\":7,\"492\":15,\"625\":4,\"747\":1,\"792\":1,\"801\":1,\"810\":1,\"1011\":1,\"1102\":1,\"1208\":1,\"1219\":4}}],[\"<<typeid\",{\"1\":{\"1189\":4}}],[\"<<pque\",{\"1\":{\"992\":1}}],[\"<<que\",{\"1\":{\"991\":1}}],[\"<<=\",{\"1\":{\"730\":1}}],[\"<<std\",{\"1\":{\"1321\":2}}],[\"<<s1\",{\"1\":{\"990\":1}}],[\"<<sf\",{\"1\":{\"267\":1}}],[\"<<sc<<\",{\"1\":{\"267\":1}}],[\"<<f<<\",{\"1\":{\"267\":1}}],[\"<<endl\",{\"1\":{\"163\":4,\"366\":2,\"368\":1,\"518\":2,\"521\":2,\"599\":2,\"601\":5,\"662\":4,\"710\":2,\"711\":2,\"1007\":2,\"1020\":2,\"1189\":4}}],[\"<<num\",{\"1\":{\"163\":4}}],[\"<<\",{\"1\":{\"8\":5,\"11\":11,\"60\":3,\"70\":6,\"101\":6,\"104\":3,\"107\":5,\"110\":3,\"118\":9,\"185\":37,\"188\":3,\"191\":3,\"214\":3,\"224\":10,\"267\":3,\"355\":3,\"362\":2,\"364\":6,\"365\":2,\"366\":4,\"368\":6,\"371\":9,\"372\":9,\"378\":12,\"382\":4,\"385\":12,\"388\":4,\"389\":3,\"392\":6,\"397\":2,\"406\":3,\"410\":4,\"411\":2,\"412\":2,\"413\":6,\"421\":10,\"422\":19,\"426\":4,\"433\":13,\"434\":14,\"435\":9,\"439\":16,\"440\":19,\"459\":17,\"464\":2,\"468\":3,\"476\":6,\"492\":4,\"497\":4,\"500\":9,\"506\":3,\"510\":2,\"515\":5,\"516\":8,\"517\":7,\"536\":19,\"547\":39,\"548\":12,\"557\":24,\"563\":10,\"567\":3,\"568\":3,\"569\":3,\"588\":2,\"589\":5,\"590\":5,\"592\":14,\"594\":41,\"601\":6,\"602\":7,\"605\":6,\"606\":4,\"618\":39,\"621\":6,\"631\":8,\"633\":13,\"637\":6,\"642\":12,\"649\":4,\"650\":4,\"652\":6,\"662\":86,\"667\":12,\"669\":4,\"670\":2,\"672\":4,\"678\":7,\"688\":32,\"695\":20,\"698\":3,\"699\":4,\"701\":3,\"704\":9,\"710\":4,\"711\":4,\"714\":4,\"722\":5,\"731\":14,\"736\":1,\"745\":6,\"746\":6,\"747\":16,\"751\":4,\"756\":2,\"810\":3,\"817\":7,\"819\":5,\"821\":4,\"826\":2,\"830\":14,\"831\":9,\"832\":4,\"848\":7,\"849\":6,\"850\":7,\"851\":7,\"852\":6,\"854\":8,\"855\":8,\"856\":4,\"857\":4,\"862\":6,\"864\":9,\"867\":10,\"871\":17,\"886\":9,\"889\":34,\"890\":23,\"891\":36,\"894\":32,\"898\":5,\"900\":14,\"905\":9,\"906\":6,\"907\":8,\"908\":8,\"913\":6,\"919\":4,\"943\":21,\"948\":20,\"949\":8,\"953\":14,\"954\":6,\"966\":37,\"980\":4,\"981\":4,\"982\":4,\"984\":3,\"985\":3,\"990\":4,\"991\":4,\"992\":4,\"999\":14,\"1000\":17,\"1001\":8,\"1002\":23,\"1007\":19,\"1008\":3,\"1011\":9,\"1032\":4,\"1041\":4,\"1045\":8,\"1050\":2,\"1055\":8,\"1056\":28,\"1057\":30,\"1060\":8,\"1110\":10,\"1111\":4,\"1112\":4,\"1113\":6,\"1114\":8,\"1115\":8,\"1120\":10,\"1121\":4,\"1123\":19,\"1124\":4,\"1127\":4,\"1147\":3,\"1148\":3,\"1151\":3,\"1154\":6,\"1155\":2,\"1158\":4,\"1164\":2,\"1165\":4,\"1166\":2,\"1167\":2,\"1168\":27,\"1173\":8,\"1177\":3,\"1178\":3,\"1179\":3,\"1186\":2,\"1187\":2,\"1188\":14,\"1189\":10,\"1207\":6,\"1208\":10,\"1209\":24,\"1210\":8,\"1219\":16,\"1233\":3,\"1299\":5,\"1839\":4,\"1845\":8,\"1849\":4,\"1851\":10,\"1856\":8,\"1875\":4,\"1878\":4,\"1902\":2,\"1903\":2,\"1904\":2,\"1905\":2,\"1907\":8,\"1908\":6,\"1909\":8,\"1915\":9}}],[\"fgets函数用法\",{\"1\":{\"1878\":1}}],[\"fgets\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":10}}],[\"f60d9030542748d68ba123288bd2f366\",{\"1\":{\"1758\":1}}],[\"feof\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":3}}],[\"female\",{\"1\":{\"1428\":2,\"1437\":1,\"1475\":1,\"1551\":1,\"1614\":4}}],[\"fetch\",{\"1\":{\"1379\":1,\"1385\":1}}],[\"feng\",{\"1\":{\"1155\":1}}],[\"fences\",{\"1\":{\"49\":3}}],[\"f参数来指定makefile文件\",{\"1\":{\"1363\":1}}],[\"fpic\",{\"0\":{\"1333\":1},\"1\":{\"1331\":1,\"1332\":1,\"1333\":1}}],[\"f或\",{\"1\":{\"1237\":1}}],[\"ftp\",{\"1\":{\"1254\":3}}],[\"ftp下载\",{\"0\":{\"1254\":1}}],[\"fty>\",{\"1\":{\"1158\":1}}],[\"ftqq\",{\"1\":{\"0\":1}}],[\"fclose\",{\"1\":{\"1060\":2}}],[\"fc0b\",{\"1\":{\"597\":1}}],[\"fnumber\",{\"1\":{\"629\":3,\"633\":5}}],[\"fno\",{\"1\":{\"398\":1}}],[\"ffffff\",{\"1\":{\"1082\":1,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1}}],[\"ff\",{\"1\":{\"557\":3}}],[\"f5\",{\"1\":{\"306\":1,\"1135\":1}}],[\"f\",{\"0\":{\"1363\":1},\"1\":{\"239\":1,\"267\":3,\"310\":5,\"338\":1,\"377\":1,\"526\":1,\"889\":8,\"891\":9,\"894\":4,\"943\":2,\"1136\":1,\"1238\":3,\"1244\":1,\"1253\":1,\"1347\":1,\"1356\":2,\"1363\":1,\"1365\":1,\"1397\":2,\"1415\":2}}],[\"fucntion\",{\"1\":{\"914\":1}}],[\"fun2\",{\"1\":{\"1189\":2}}],[\"funtion的作用\",{\"1\":{\"1168\":1}}],[\"fun\",{\"1\":{\"692\":4,\"693\":2,\"695\":16,\"1066\":2,\"1067\":1}}],[\"func>\",{\"1\":{\"1183\":1}}],[\"func5\",{\"1\":{\"1167\":2}}],[\"func4\",{\"1\":{\"616\":2,\"641\":3,\"1166\":2}}],[\"func3\",{\"1\":{\"616\":1,\"641\":4,\"1165\":2,\"1173\":1,\"1174\":1,\"1175\":1,\"1189\":1}}],[\"func2\",{\"1\":{\"616\":1,\"618\":1,\"640\":2,\"1158\":2,\"1165\":3,\"1173\":2,\"1851\":1}}],[\"func1\",{\"1\":{\"616\":1,\"618\":2,\"637\":3,\"1155\":3,\"1158\":3,\"1164\":3,\"1173\":2,\"1851\":5}}],[\"func<double>\",{\"1\":{\"372\":1}}],[\"func<int>\",{\"1\":{\"372\":1}}],[\"func\",{\"1\":{\"372\":5,\"410\":4,\"413\":4,\"414\":1,\"415\":1,\"563\":4,\"591\":1,\"601\":6,\"631\":8,\"784\":2,\"1032\":12,\"1057\":2,\"1151\":6,\"1183\":1,\"1189\":6}}],[\"functionname\",{\"1\":{\"1340\":2}}],[\"function使用举例\",{\"0\":{\"1168\":1}}],[\"function也可以将类的成员方法留下来\",{\"0\":{\"1167\":1},\"1\":{\"1166\":1}}],[\"function是对一个函数\",{\"0\":{\"1166\":1}}],[\"function不仅仅可以留下\",{\"1\":{\"1165\":1}}],[\"function可以直接将函数类型留下来\",{\"1\":{\"1154\":1}}],[\"function函数对象\",{\"2\":{\"1153\":1,\"1160\":1,\"1170\":1}}],[\"function函数对象类型的应用\",{\"0\":{\"1161\":1}}],[\"function函数对象类型的实现原理\",{\"1\":{\"1158\":1}}],[\"function函数对象类型实现原理\",{\"0\":{\"1158\":1}}],[\"function函数对象类型\",{\"1\":{\"1060\":1}}],[\"function<int\",{\"1\":{\"1165\":1,\"1166\":1}}],[\"function<void\",{\"1\":{\"1060\":2,\"1151\":2,\"1155\":1,\"1158\":1,\"1164\":1,\"1165\":1,\"1167\":1,\"1168\":1}}],[\"function<bool\",{\"1\":{\"784\":4,\"1183\":1}}],[\"function\",{\"1\":{\"53\":2,\"54\":2,\"59\":20,\"234\":2,\"560\":1,\"849\":2,\"852\":2,\"894\":5,\"1032\":4,\"1161\":1,\"1188\":1,\"1195\":1,\"1361\":1}}],[\"full\",{\"1\":{\"185\":5,\"355\":2,\"385\":2,\"388\":4,\"406\":2,\"704\":2,\"1087\":1,\"1127\":4,\"1500\":1}}],[\"f1\",{\"1\":{\"97\":1,\"891\":4,\"1238\":1}}],[\"f2\",{\"1\":{\"96\":1,\"97\":1,\"891\":4}}],[\"frm\",{\"1\":{\"1557\":1}}],[\"friend\",{\"1\":{\"662\":4,\"699\":2,\"721\":2,\"722\":2,\"723\":1,\"731\":3,\"736\":3,\"784\":1,\"854\":1,\"1002\":2,\"1096\":1,\"1123\":2}}],[\"free分别记录内存池\",{\"1\":{\"1102\":1}}],[\"free都是static\",{\"1\":{\"1102\":1}}],[\"free区间内给用户分配\",{\"1\":{\"1102\":1}}],[\"free变量\",{\"1\":{\"1102\":1}}],[\"free指向剩余可以内存首地址\",{\"1\":{\"1102\":1}}],[\"free指向为malloc空间的尾地址\",{\"1\":{\"1102\":1}}],[\"free指向分配后\",{\"1\":{\"1102\":1}}],[\"free之间的备用内存不够分配20个\",{\"1\":{\"1099\":1}}],[\"freelists上\",{\"1\":{\"1102\":1}}],[\"freelist\",{\"1\":{\"1090\":2,\"1093\":2,\"1096\":1,\"1099\":2,\"1102\":2}}],[\"free相等\",{\"1\":{\"1082\":1}}],[\"free和\",{\"1\":{\"1082\":1,\"1099\":1,\"1102\":1}}],[\"free和delete的区别\",{\"1\":{\"513\":1,\"708\":1}}],[\"free管理\",{\"1\":{\"1082\":1}}],[\"free管理动态内存\",{\"1\":{\"514\":1}}],[\"freevideositeproxy\",{\"1\":{\"830\":3}}],[\"freemovie\",{\"1\":{\"830\":4}}],[\"free配套使用\",{\"0\":{\"521\":1}}],[\"free用法一样\",{\"1\":{\"519\":1}}],[\"free是c里面的库函数\",{\"1\":{\"515\":1}}],[\"free与new\",{\"1\":{\"515\":1}}],[\"free呢\",{\"0\":{\"514\":1}}],[\"free只有一步\",{\"1\":{\"513\":1,\"708\":1}}],[\"free的区别是\",{\"0\":{\"513\":1}}],[\"free的底层实现\",{\"0\":{\"280\":1}}],[\"free实现\",{\"0\":{\"287\":1}}],[\"free\",{\"0\":{\"514\":1},\"1\":{\"282\":1,\"285\":1,\"287\":2,\"385\":1,\"459\":1,\"509\":1,\"515\":2,\"516\":1,\"523\":1,\"524\":1,\"535\":1,\"547\":1,\"571\":1,\"572\":1,\"633\":1,\"704\":1,\"711\":2,\"715\":1,\"1079\":1,\"1080\":2,\"1082\":9,\"1087\":1,\"1090\":2,\"1093\":9,\"1096\":11,\"1099\":14,\"1102\":53,\"1105\":2,\"1127\":1,\"1381\":1,\"1385\":1,\"1706\":1}}],[\"front指向队首元素前一个位置\",{\"1\":{\"751\":1}}],[\"front\",{\"1\":{\"185\":11,\"406\":17,\"751\":13,\"817\":6,\"969\":2,\"970\":2,\"991\":2,\"1020\":1,\"1219\":2,\"1849\":3,\"1859\":2,\"1869\":1,\"1870\":1,\"1872\":1}}],[\"front与队尾指针\",{\"1\":{\"185\":1}}],[\"from\",{\"1\":{\"59\":2,\"182\":1,\"234\":1,\"485\":1,\"1020\":1,\"1361\":1,\"1384\":1,\"1385\":1,\"1447\":1,\"1471\":1,\"1480\":4,\"1486\":1,\"1491\":2,\"1494\":3,\"1495\":1,\"1496\":3,\"1497\":1,\"1500\":9,\"1501\":3,\"1502\":4,\"1511\":9,\"1512\":1,\"1513\":2,\"1514\":3,\"1515\":4,\"1516\":3,\"1525\":3,\"1526\":3,\"1531\":2,\"1537\":4,\"1538\":9,\"1539\":6,\"1540\":1,\"1541\":2,\"1543\":1,\"1544\":5,\"1563\":4,\"1564\":3,\"1566\":1,\"1569\":3,\"1581\":1,\"1592\":2,\"1599\":1,\"1603\":2,\"1623\":1,\"1686\":1,\"1688\":2,\"1689\":2,\"1693\":1,\"1719\":1,\"1720\":1,\"1738\":4,\"1740\":4,\"1836\":2,\"1902\":1,\"1903\":1,\"1907\":1}}],[\"frame\",{\"1\":{\"52\":2,\"59\":1}}],[\"fappender\",{\"1\":{\"1032\":1}}],[\"factory抽象工厂了\",{\"1\":{\"866\":1}}],[\"factory就是在这样的需求下诞生的\",{\"1\":{\"861\":1}}],[\"factory\",{\"0\":{\"861\":1,\"865\":1,\"867\":1},\"1\":{\"861\":1,\"864\":6,\"866\":4}}],[\"fault\",{\"1\":{\"289\":1}}],[\"fatal\",{\"1\":{\"234\":1,\"1018\":1,\"1025\":3,\"1031\":6,\"1318\":1}}],[\"fast首先走n\",{\"1\":{\"774\":1}}],[\"fast\",{\"1\":{\"73\":4,\"77\":4,\"148\":4,\"756\":5,\"765\":10,\"768\":9,\"774\":13,\"787\":6,\"798\":12,\"806\":7}}],[\"false为0\",{\"1\":{\"473\":1}}],[\"false\",{\"1\":{\"54\":1,\"59\":2,\"60\":1,\"146\":1,\"149\":1,\"152\":1,\"153\":1,\"154\":1,\"155\":1,\"158\":2,\"161\":1,\"162\":1,\"166\":1,\"174\":2,\"182\":2,\"188\":1,\"277\":1,\"473\":2,\"754\":1,\"755\":1,\"756\":1,\"765\":1,\"817\":1,\"819\":1,\"821\":1,\"1233\":1,\"1839\":1,\"1847\":1,\"1849\":1,\"1856\":1,\"1875\":1,\"1878\":1,\"1888\":2,\"1891\":1}}],[\"family\",{\"1\":{\"49\":3}}],[\"fixbug\",{\"1\":{\"1915\":2}}],[\"fixbugvideosite\",{\"1\":{\"830\":3}}],[\"fifo\",{\"1\":{\"1859\":1}}],[\"firewall\",{\"1\":{\"1818\":3}}],[\"firewalld\",{\"1\":{\"1818\":6}}],[\"first与last处于最中间的位置\",{\"1\":{\"968\":1}}],[\"first++\",{\"1\":{\"1127\":1}}],[\"first+i\",{\"1\":{\"385\":2,\"704\":2}}],[\"first+1的值\",{\"1\":{\"178\":1}}],[\"first+1\",{\"1\":{\"178\":2}}],[\"first指针指向的数组的有效元素析构\",{\"1\":{\"385\":2,\"704\":2}}],[\"first指针指向的数组每一个元素都当作有效的test对象析构了一遍\",{\"1\":{\"383\":1}}],[\"first指针指向的堆内存\",{\"1\":{\"384\":1}}],[\"first\",{\"1\":{\"355\":27,\"385\":38,\"537\":2,\"541\":1,\"543\":1,\"704\":40,\"747\":2,\"751\":3,\"1127\":27,\"1148\":5,\"1168\":1,\"1552\":2,\"1909\":1}}],[\"firstbyte\",{\"1\":{\"287\":3}}],[\"firstchild\",{\"1\":{\"53\":2,\"59\":2}}],[\"filtered\",{\"1\":{\"1521\":1}}],[\"file=\",{\"1\":{\"1825\":1,\"1829\":1}}],[\"file5\",{\"1\":{\"1271\":2}}],[\"file3\",{\"1\":{\"1271\":2,\"1329\":1}}],[\"file2也被修改\",{\"1\":{\"1271\":1}}],[\"file2为创建的软链接名\",{\"0\":{\"1271\":1}}],[\"file2\",{\"1\":{\"1270\":1,\"1271\":6,\"1329\":1,\"1334\":2}}],[\"file1\",{\"1\":{\"1260\":1,\"1270\":1,\"1271\":12,\"1329\":1,\"1334\":2}}],[\"filelist\",{\"1\":{\"1250\":2}}],[\"fileencodings=utf\",{\"1\":{\"1133\":1,\"1291\":1}}],[\"fileappender1234\",{\"1\":{\"1031\":1}}],[\"fileappender\",{\"1\":{\"1019\":2,\"1031\":3}}],[\"filename=d\",{\"1\":{\"1026\":2}}],[\"filename\",{\"1\":{\"60\":2,\"1032\":6,\"1262\":1,\"1326\":2,\"1327\":1,\"1328\":1,\"1330\":1,\"1331\":2,\"1340\":1}}],[\"filesort的排序操作\",{\"1\":{\"1736\":1}}],[\"filesort一定要优化\",{\"1\":{\"1566\":1}}],[\"filesort\",{\"0\":{\"1586\":1},\"1\":{\"1566\":1,\"1736\":3}}],[\"files\",{\"1\":{\"60\":2,\"239\":1}}],[\"filepath\",{\"1\":{\"60\":1}}],[\"file\",{\"1\":{\"45\":1,\"227\":1,\"234\":2,\"239\":3,\"312\":1,\"1032\":16,\"1060\":3,\"1252\":1,\"1260\":1,\"1312\":1,\"1361\":1,\"1395\":1,\"1407\":2,\"1825\":1,\"1839\":2,\"1845\":1,\"1848\":2,\"1849\":2,\"1856\":1,\"1875\":4,\"1878\":3}}],[\"file结构体是满足isoc标准的文件流\",{\"1\":{\"16\":1}}],[\"fields\",{\"1\":{\"1729\":1}}],[\"field\",{\"1\":{\"1380\":1,\"1385\":1}}],[\"fib\",{\"1\":{\"1237\":1}}],[\"fin\",{\"1\":{\"1240\":10}}],[\"finish\",{\"1\":{\"1086\":5,\"1340\":1}}],[\"findelement\",{\"1\":{\"792\":4}}],[\"findfromend\",{\"1\":{\"774\":2,\"787\":2,\"806\":1}}],[\"find系列\",{\"1\":{\"546\":1}}],[\"find查找和count查找\",{\"1\":{\"178\":1}}],[\"findlhs\",{\"1\":{\"178\":1,\"179\":1}}],[\"find返回的是迭代器不是bool\",{\"1\":{\"171\":1}}],[\"find1and2big\",{\"1\":{\"118\":2}}],[\"findmd\",{\"1\":{\"60\":3}}],[\"find\",{\"1\":{\"60\":2,\"101\":4,\"110\":1,\"125\":1,\"153\":1,\"158\":1,\"162\":2,\"171\":1,\"178\":1,\"536\":1,\"546\":4,\"817\":4,\"819\":2,\"821\":2,\"871\":2,\"999\":2,\"1000\":1,\"1001\":1,\"1007\":3,\"1008\":2,\"1148\":4,\"1168\":1,\"1178\":1,\"1839\":2,\"1849\":2,\"1875\":2,\"1878\":3}}],[\"findtop\",{\"1\":{\"59\":3}}],[\"figure\",{\"1\":{\"898\":4}}],[\"fisthalfend\",{\"1\":{\"756\":4}}],[\"fisrt\",{\"1\":{\"355\":1}}],[\"fitst\",{\"1\":{\"355\":1}}],[\"flush\",{\"1\":{\"1407\":1,\"1408\":1,\"1762\":1,\"1799\":1,\"1821\":1}}],[\"flazz\",{\"1\":{\"1143\":1}}],[\"flavor\",{\"1\":{\"234\":1,\"244\":2,\"261\":1}}],[\"flag标志\",{\"1\":{\"252\":1}}],[\"flags变量则是分别只针对\",{\"1\":{\"1317\":1}}],[\"flags或cmake\",{\"1\":{\"1317\":2}}],[\"flags\",{\"1\":{\"63\":1,\"1310\":4,\"1317\":3}}],[\"flag\",{\"1\":{\"8\":4,\"60\":2,\"188\":4,\"852\":1}}],[\"float等\",{\"1\":{\"560\":1}}],[\"float存储为例\",{\"1\":{\"339\":1}}],[\"float\",{\"1\":{\"51\":1,\"296\":1,\"340\":1,\"439\":4,\"449\":3,\"450\":4,\"497\":1,\"557\":1,\"560\":2,\"571\":10,\"629\":3,\"633\":2,\"722\":4,\"1423\":1,\"1537\":1}}],[\"fopen\",{\"1\":{\"1060\":2,\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":1}}],[\"found\",{\"1\":{\"606\":2}}],[\"foo\",{\"1\":{\"504\":2,\"526\":1,\"528\":1,\"529\":2,\"578\":2,\"585\":1}}],[\"footer\",{\"1\":{\"54\":4,\"59\":11}}],[\"foreign\",{\"1\":{\"1437\":1}}],[\"foreach方式来遍历容器内部元素的值\",{\"1\":{\"701\":1}}],[\"foreach\",{\"0\":{\"701\":1},\"1\":{\"53\":1,\"54\":2,\"59\":7}}],[\"forward<ty>\",{\"1\":{\"1127\":3}}],[\"forward完美转发\",{\"1\":{\"1127\":1}}],[\"form\",{\"1\":{\"1907\":1}}],[\"format\",{\"1\":{\"1063\":1,\"1443\":1}}],[\"forms\",{\"1\":{\"59\":1}}],[\"for循环\",{\"0\":{\"401\":1}}],[\"for\",{\"0\":{\"1179\":1,\"1871\":1},\"1\":{\"51\":2,\"59\":2,\"60\":6,\"67\":1,\"70\":3,\"77\":1,\"81\":4,\"87\":1,\"101\":6,\"104\":4,\"107\":3,\"110\":4,\"115\":1,\"118\":2,\"125\":1,\"129\":2,\"133\":1,\"137\":2,\"141\":1,\"142\":1,\"153\":1,\"155\":1,\"158\":1,\"162\":1,\"166\":3,\"170\":2,\"171\":1,\"174\":3,\"178\":3,\"179\":1,\"185\":1,\"188\":4,\"191\":13,\"194\":2,\"199\":3,\"205\":1,\"214\":5,\"217\":2,\"234\":2,\"285\":2,\"296\":1,\"355\":4,\"385\":6,\"406\":4,\"494\":1,\"512\":1,\"536\":1,\"547\":1,\"698\":1,\"699\":1,\"701\":1,\"704\":10,\"742\":2,\"743\":2,\"745\":3,\"746\":4,\"747\":12,\"751\":2,\"755\":3,\"756\":1,\"759\":1,\"762\":1,\"768\":1,\"771\":1,\"774\":1,\"782\":2,\"783\":2,\"784\":2,\"787\":1,\"792\":2,\"795\":1,\"798\":1,\"802\":2,\"810\":3,\"817\":1,\"819\":1,\"871\":2,\"965\":1,\"966\":13,\"984\":1,\"985\":2,\"990\":1,\"991\":1,\"992\":1,\"999\":6,\"1001\":6,\"1002\":4,\"1007\":9,\"1008\":1,\"1011\":5,\"1015\":1,\"1050\":3,\"1082\":1,\"1099\":1,\"1102\":2,\"1127\":5,\"1147\":2,\"1148\":3,\"1151\":4,\"1168\":1,\"1177\":2,\"1178\":1,\"1179\":1,\"1194\":2,\"1202\":1,\"1207\":3,\"1208\":3,\"1209\":3,\"1210\":1,\"1219\":8,\"1233\":4,\"1238\":1,\"1240\":5,\"1362\":2,\"1366\":1,\"1385\":2,\"1622\":1,\"1656\":1,\"1665\":1,\"1686\":1,\"1698\":1,\"1700\":1,\"1701\":2,\"1717\":2,\"1718\":1,\"1736\":2,\"1839\":1,\"1849\":3,\"1851\":4,\"1859\":3,\"1869\":1,\"1871\":4,\"1872\":1,\"1875\":1,\"1896\":1,\"1906\":1,\"1909\":2}}],[\"focused\",{\"1\":{\"51\":2}}],[\"focus\",{\"1\":{\"51\":12}}],[\"fontsize\",{\"1\":{\"271\":1}}],[\"fontname\",{\"1\":{\"271\":1}}],[\"font\",{\"1\":{\"49\":7,\"50\":2,\"51\":8}}],[\"font>\",{\"1\":{\"29\":1,\"688\":1,\"1761\":1,\"1822\":1}}],[\"f搜\",{\"1\":{\"45\":1}}],[\"07\",{\"0\":{\"1933\":1,\"1953\":1}}],[\"0777\",{\"1\":{\"1299\":1}}],[\"06\",{\"0\":{\"1929\":1,\"1952\":1},\"1\":{\"1774\":1}}],[\"06demo\",{\"1\":{\"1318\":1}}],[\"0aff49012e1e4ad5ba404436fed4022e\",{\"1\":{\"1773\":1}}],[\"0ah\",{\"1\":{\"234\":1,\"267\":2,\"906\":1}}],[\"0一样\",{\"1\":{\"1758\":1}}],[\"0没有\",{\"0\":{\"1527\":1}}],[\"09\",{\"0\":{\"1934\":1,\"1956\":1},\"1\":{\"1271\":1,\"1537\":2}}],[\"0这条规则\",{\"1\":{\"1239\":1}}],[\"0为默认路由\",{\"1\":{\"1239\":1}}],[\"0为非空\",{\"1\":{\"966\":1}}],[\"0代表本机上可用的任意地址\",{\"1\":{\"1239\":1}}],[\"0的字符串\",{\"1\":{\"1120\":1}}],[\"0>\",{\"1\":{\"1081\":1}}],[\"04安装mysql异常问题\",{\"0\":{\"1404\":1}}],[\"04下安装mysql\",{\"1\":{\"1393\":1,\"1394\":1}}],[\"04下安装mysql5\",{\"0\":{\"1393\":1,\"1394\":1}}],[\"04demo\",{\"1\":{\"1316\":1}}],[\"04\",{\"0\":{\"1922\":1,\"1926\":1,\"1945\":1,\"1950\":1},\"1\":{\"1032\":8,\"1284\":1,\"1395\":2,\"1396\":1,\"1397\":10,\"1537\":12,\"1747\":1,\"1774\":3,\"1818\":2}}],[\"059\",{\"1\":{\"1032\":2}}],[\"058\",{\"1\":{\"1032\":2}}],[\"057\",{\"1\":{\"1032\":3}}],[\"056\",{\"1\":{\"1032\":1}}],[\"05\",{\"0\":{\"1930\":1,\"1951\":1},\"1\":{\"965\":1,\"1087\":1,\"1774\":1}}],[\"05em\",{\"1\":{\"50\":1}}],[\"0||index\",{\"1\":{\"791\":1,\"792\":2}}],[\"02\",{\"0\":{\"1928\":1,\"1931\":1,\"1941\":1,\"1948\":1},\"1\":{\"678\":1,\"692\":1,\"707\":1,\"750\":1,\"1032\":8,\"1121\":1,\"1774\":1}}],[\"023\",{\"1\":{\"349\":1}}],[\"0ii\",{\"1\":{\"572\":1}}],[\"0结尾\",{\"1\":{\"547\":1}}],[\"0表示\",{\"1\":{\"527\":1}}],[\"0表示不可用\",{\"1\":{\"286\":1}}],[\"0e4cd626492a\",{\"1\":{\"509\":1}}],[\"0e4h\",{\"1\":{\"235\":1}}],[\"0bfb\",{\"1\":{\"509\":1}}],[\"08\",{\"0\":{\"1954\":1},\"1\":{\"371\":1,\"1271\":3,\"1407\":1}}],[\"0cch\",{\"1\":{\"238\":1}}],[\"0ch\",{\"1\":{\"233\":2}}],[\"0f8108ch\",{\"0\":{\"238\":1}}],[\"0x6fffff\",{\"1\":{\"1299\":1}}],[\"0x7ffc1abeae5c\",{\"1\":{\"633\":4}}],[\"0x7fffffff\",{\"1\":{\"605\":1}}],[\"0x7ffe6ef931ed\",{\"1\":{\"468\":1}}],[\"0x7ffe6ef931ee\",{\"1\":{\"468\":1}}],[\"0x7ffe6ef931ef\",{\"1\":{\"468\":1}}],[\"0x8\",{\"1\":{\"234\":3,\"236\":3}}],[\"0xa\",{\"1\":{\"234\":1,\"236\":1}}],[\"0xcccccccc\",{\"1\":{\"908\":1}}],[\"0xc\",{\"1\":{\"234\":2,\"236\":2}}],[\"0x0018ff44是一个整数需要强转\",{\"1\":{\"624\":1}}],[\"0x0018ff44\",{\"1\":{\"624\":3}}],[\"0x00000001\",{\"1\":{\"307\":1}}],[\"0x00000000到0x08048000是系统预留的空间\",{\"1\":{\"267\":1}}],[\"0x00000000004008ee\",{\"1\":{\"261\":1}}],[\"0x0不可以访问\",{\"1\":{\"251\":1}}],[\"0x0\",{\"1\":{\"234\":2,\"251\":1}}],[\"0x01\",{\"1\":{\"70\":2}}],[\"0x401000\",{\"1\":{\"1348\":1}}],[\"0x456\",{\"1\":{\"349\":1}}],[\"0x4\",{\"1\":{\"234\":4,\"236\":1}}],[\"0x12345678\",{\"1\":{\"1344\":2,\"1348\":3}}],[\"0x123\",{\"1\":{\"323\":1}}],[\"0x14\",{\"1\":{\"234\":1,\"236\":1}}],[\"0x19c1\",{\"1\":{\"234\":1}}],[\"0x19e8\",{\"1\":{\"234\":1}}],[\"0x100\",{\"1\":{\"490\":1}}],[\"0x10\",{\"1\":{\"234\":2,\"235\":1}}],[\"0x56555639\",{\"1\":{\"234\":1}}],[\"0x56555638\",{\"1\":{\"234\":1}}],[\"0x56555633\",{\"1\":{\"234\":1}}],[\"0x56555630\",{\"1\":{\"234\":1,\"236\":1}}],[\"0x5655562d\",{\"1\":{\"234\":1,\"236\":1}}],[\"0x56555628\",{\"1\":{\"234\":1,\"236\":1}}],[\"0x56555625\",{\"1\":{\"234\":1,\"236\":1}}],[\"0x56555622\",{\"1\":{\"234\":1,\"236\":1}}],[\"0x5655561b\",{\"1\":{\"234\":1,\"236\":1}}],[\"0x56555614\",{\"1\":{\"234\":1,\"236\":1}}],[\"0x5655560f\",{\"1\":{\"234\":1}}],[\"0x5655560a\",{\"1\":{\"234\":1}}],[\"0x56555607\",{\"1\":{\"234\":1}}],[\"0x56555605\",{\"1\":{\"234\":1}}],[\"0x56555604\",{\"1\":{\"234\":1}}],[\"0x56555603\",{\"1\":{\"234\":1}}],[\"0x56555602\",{\"1\":{\"234\":1}}],[\"0x565556b7\",{\"1\":{\"234\":2}}],[\"0x565555ff\",{\"1\":{\"234\":1}}],[\"0x565555fc\",{\"1\":{\"234\":1}}],[\"0x565555fa\",{\"1\":{\"234\":1}}],[\"0x565555f7\",{\"1\":{\"234\":1}}],[\"0x565555f4\",{\"1\":{\"234\":1}}],[\"0x565555ed\",{\"1\":{\"234\":1}}],[\"0x565555e8\",{\"1\":{\"234\":1}}],[\"0x565555e3\",{\"1\":{\"234\":1}}],[\"0x565555e0\",{\"1\":{\"234\":1,\"235\":1}}],[\"0x565555de\",{\"1\":{\"234\":1,\"235\":1}}],[\"0x565555dd\",{\"1\":{\"234\":2,\"235\":1,\"236\":1}}],[\"03demo\",{\"1\":{\"1313\":1}}],[\"03\",{\"0\":{\"1920\":1,\"1927\":1,\"1946\":1,\"1949\":1},\"1\":{\"110\":1,\"496\":1,\"673\":1,\"1032\":8,\"1773\":2}}],[\"0px\",{\"1\":{\"48\":1}}],[\"00s\",{\"1\":{\"1740\":1}}],[\"00003\",{\"1\":{\"1774\":2}}],[\"00003文件中\",{\"1\":{\"1774\":1}}],[\"00004文件中\",{\"1\":{\"1774\":1}}],[\"00001011\",{\"1\":{\"1090\":1}}],[\"00001000\",{\"1\":{\"1090\":2}}],[\"000006\",{\"1\":{\"1829\":1}}],[\"000007\",{\"1\":{\"1825\":1}}],[\"000003中拿出区间内所有的操作\",{\"1\":{\"1774\":1}}],[\"000003\",{\"1\":{\"1773\":2,\"1774\":2}}],[\"00000111\",{\"1\":{\"1090\":1}}],[\"00000000\",{\"1\":{\"1090\":12}}],[\"00000000000000de\",{\"1\":{\"572\":1}}],[\"0000000000000014\",{\"1\":{\"572\":1}}],[\"000000000000006e\",{\"1\":{\"572\":1}}],[\"000000000000004a\",{\"1\":{\"572\":1}}],[\"0000000000000030\",{\"1\":{\"572\":1}}],[\"0000000000000090\",{\"1\":{\"572\":1}}],[\"0000000000000000\",{\"1\":{\"572\":3}}],[\"0000000000000127\",{\"1\":{\"572\":1}}],[\"003\",{\"1\":{\"338\":1}}],[\"00f\",{\"1\":{\"50\":1}}],[\"00\",{\"0\":{\"1924\":1},\"1\":{\"44\":1,\"307\":3,\"1063\":1,\"1296\":6,\"1407\":3,\"1773\":6,\"1799\":2}}],[\"01秒\",{\"1\":{\"1776\":1}}],[\"01caeb58b8a141a390482e91923d36bc\",{\"1\":{\"1771\":1}}],[\"01612b2h\",{\"1\":{\"953\":2}}],[\"01612dah\",{\"1\":{\"953\":2}}],[\"0157f6c4\",{\"1\":{\"517\":1}}],[\"0157f6c0\",{\"1\":{\"517\":1}}],[\"01\",{\"0\":{\"1918\":1,\"1925\":1,\"1944\":1,\"1947\":1},\"1\":{\"29\":1,\"45\":2,\"46\":1,\"307\":1,\"1610\":1,\"1773\":1}}],[\"0\",{\"0\":{\"270\":1,\"275\":1,\"525\":1,\"1529\":1,\"1751\":1},\"1\":{\"8\":5,\"11\":5,\"29\":1,\"48\":6,\"49\":11,\"51\":6,\"54\":1,\"59\":9,\"60\":6,\"61\":1,\"67\":2,\"70\":5,\"73\":4,\"77\":2,\"78\":1,\"81\":4,\"84\":1,\"87\":3,\"96\":2,\"97\":4,\"101\":15,\"104\":3,\"107\":2,\"110\":3,\"115\":2,\"118\":1,\"121\":1,\"125\":1,\"126\":1,\"129\":3,\"132\":2,\"133\":5,\"135\":1,\"136\":10,\"137\":3,\"141\":1,\"142\":2,\"143\":2,\"148\":1,\"149\":1,\"158\":1,\"161\":1,\"162\":1,\"163\":1,\"166\":5,\"170\":2,\"174\":1,\"178\":1,\"179\":3,\"185\":3,\"188\":3,\"191\":8,\"194\":5,\"199\":2,\"205\":1,\"214\":5,\"217\":1,\"224\":5,\"234\":5,\"238\":1,\"239\":3,\"244\":1,\"246\":1,\"271\":1,\"275\":1,\"276\":2,\"277\":6,\"285\":1,\"286\":2,\"323\":1,\"338\":3,\"339\":1,\"355\":1,\"365\":1,\"366\":2,\"368\":2,\"378\":3,\"385\":1,\"405\":4,\"406\":5,\"411\":1,\"412\":1,\"413\":1,\"421\":3,\"422\":6,\"432\":4,\"433\":7,\"434\":5,\"435\":1,\"439\":1,\"449\":1,\"459\":8,\"468\":1,\"473\":2,\"476\":2,\"483\":2,\"484\":2,\"494\":3,\"497\":1,\"500\":1,\"506\":1,\"509\":1,\"511\":1,\"512\":1,\"515\":5,\"516\":1,\"517\":2,\"526\":3,\"528\":2,\"530\":3,\"535\":5,\"536\":1,\"538\":2,\"542\":1,\"546\":4,\"547\":7,\"548\":1,\"557\":1,\"563\":5,\"567\":1,\"568\":1,\"569\":1,\"570\":1,\"571\":2,\"575\":1,\"576\":1,\"584\":1,\"585\":1,\"588\":2,\"592\":1,\"594\":9,\"597\":2,\"599\":1,\"601\":5,\"602\":2,\"605\":3,\"606\":1,\"614\":1,\"618\":10,\"621\":1,\"629\":1,\"631\":2,\"633\":1,\"637\":2,\"638\":1,\"640\":3,\"641\":5,\"642\":7,\"653\":1,\"662\":2,\"667\":1,\"688\":2,\"695\":3,\"699\":4,\"704\":2,\"715\":1,\"722\":2,\"731\":3,\"736\":7,\"742\":2,\"743\":1,\"745\":1,\"746\":2,\"747\":4,\"751\":2,\"755\":2,\"756\":1,\"759\":2,\"762\":1,\"771\":2,\"774\":1,\"782\":2,\"783\":2,\"784\":1,\"787\":3,\"791\":6,\"792\":6,\"795\":1,\"798\":1,\"802\":2,\"810\":1,\"812\":2,\"817\":3,\"819\":2,\"821\":1,\"826\":2,\"830\":4,\"831\":2,\"832\":3,\"862\":1,\"864\":2,\"866\":2,\"867\":5,\"871\":3,\"886\":1,\"889\":1,\"890\":1,\"891\":1,\"894\":6,\"898\":4,\"900\":8,\"905\":12,\"906\":1,\"907\":1,\"908\":2,\"913\":1,\"919\":2,\"948\":1,\"953\":1,\"954\":1,\"966\":3,\"973\":1,\"974\":1,\"980\":1,\"981\":1,\"982\":1,\"984\":1,\"1001\":2,\"1002\":3,\"1007\":3,\"1011\":4,\"1020\":1,\"1025\":2,\"1031\":2,\"1032\":1,\"1040\":1,\"1041\":2,\"1043\":1,\"1045\":5,\"1047\":1,\"1050\":2,\"1055\":3,\"1060\":1,\"1080\":4,\"1082\":19,\"1090\":1,\"1096\":3,\"1099\":1,\"1102\":6,\"1110\":1,\"1111\":1,\"1112\":1,\"1113\":1,\"1115\":1,\"1116\":1,\"1120\":2,\"1123\":1,\"1127\":4,\"1147\":2,\"1148\":2,\"1151\":4,\"1154\":1,\"1155\":1,\"1158\":2,\"1168\":2,\"1173\":1,\"1177\":1,\"1179\":1,\"1183\":1,\"1186\":1,\"1187\":1,\"1188\":1,\"1194\":1,\"1207\":1,\"1208\":2,\"1209\":4,\"1210\":2,\"1219\":2,\"1225\":1,\"1226\":1,\"1233\":4,\"1239\":17,\"1252\":1,\"1255\":2,\"1271\":3,\"1278\":1,\"1282\":1,\"1299\":3,\"1321\":1,\"1332\":6,\"1348\":1,\"1374\":2,\"1383\":2,\"1384\":7,\"1385\":12,\"1394\":1,\"1407\":6,\"1408\":2,\"1516\":1,\"1523\":1,\"1537\":12,\"1592\":1,\"1594\":1,\"1632\":1,\"1799\":4,\"1803\":1,\"1818\":1,\"1820\":18,\"1828\":3,\"1839\":4,\"1844\":2,\"1847\":1,\"1849\":4,\"1851\":13,\"1856\":4,\"1859\":1,\"1875\":4,\"1878\":11,\"1888\":7,\"1891\":7,\"1907\":1,\"1908\":1,\"1909\":1,\"1915\":1},\"2\":{\"279\":1}}],[\"=8k有8k字节\",{\"1\":{\"1622\":1}}],[\"=gcc\",{\"1\":{\"1366\":1}}],[\"=g++\",{\"1\":{\"1360\":1,\"1367\":1}}],[\"=one\",{\"1\":{\"1362\":1}}],[\"=$\",{\"1\":{\"1360\":1,\"1361\":1,\"1365\":1,\"1366\":4,\"1367\":2}}],[\"=main\",{\"1\":{\"1360\":3,\"1367\":1}}],[\"=map1\",{\"1\":{\"1001\":1}}],[\"=变量内容\",{\"1\":{\"1356\":1}}],[\"=tmp\",{\"1\":{\"1173\":1,\"1175\":1}}],[\"=temp\",{\"1\":{\"777\":1}}],[\"=cmystring\",{\"1\":{\"1127\":1}}],[\"=log4cpp\",{\"1\":{\"1020\":1}}],[\"=strqappender\",{\"1\":{\"1020\":1}}],[\"=str1\",{\"1\":{\"698\":1,\"699\":1}}],[\"=stumap\",{\"1\":{\"1002\":1}}],[\"=set1\",{\"1\":{\"999\":2,\"1002\":1}}],[\"=b\",{\"1\":{\"777\":1}}],[\"=headb\",{\"1\":{\"771\":1}}],[\"=运算符号重载前要检查迭代器的有效性\",{\"1\":{\"747\":1}}],[\"=vec\",{\"1\":{\"704\":1,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":4,\"966\":7,\"1011\":2}}],[\"=end\",{\"1\":{\"698\":1}}],[\"=10\",{\"1\":{\"620\":1}}],[\"=a\",{\"1\":{\"620\":1}}],[\"=初始化表达式\",{\"1\":{\"455\":1}}],[\"=nums\",{\"1\":{\"77\":1}}],[\"=nullptr\",{\"1\":{\"747\":1}}],[\"=null\",{\"1\":{\"59\":1}}],[\"=0\",{\"1\":{\"59\":1}}],[\"=>hello2\",{\"1\":{\"1165\":1}}],[\"=>hello1\",{\"1\":{\"1164\":1}}],[\"=>value\",{\"1\":{\"1000\":2}}],[\"=>double\",{\"1\":{\"885\":1}}],[\"=>int\",{\"1\":{\"885\":1}}],[\"=>\",{\"1\":{\"53\":2,\"54\":4,\"59\":12,\"234\":1,\"236\":1,\"405\":1,\"490\":1,\"563\":1,\"871\":1,\"1090\":2,\"1154\":2,\"1194\":1,\"1227\":1,\"1232\":1,\"1849\":1,\"1859\":1,\"1875\":1,\"1907\":1,\"1915\":2}}],[\"==当我们用指针调用show\",{\"1\":{\"908\":1}}],[\"==派生类构造函数压完栈初始化后会将\",{\"1\":{\"908\":1}}],[\"=============================\",{\"1\":{\"830\":1}}],[\"==🍗🍗🍗\",{\"1\":{\"490\":1}}],[\"==const\",{\"1\":{\"490\":1}}],[\"==target\",{\"1\":{\"96\":1}}],[\"==\",{\"1\":{\"8\":2,\"11\":1,\"59\":9,\"60\":4,\"70\":3,\"73\":1,\"78\":1,\"81\":1,\"84\":1,\"93\":1,\"94\":1,\"96\":2,\"101\":4,\"104\":1,\"107\":1,\"110\":2,\"115\":2,\"118\":1,\"126\":1,\"132\":1,\"133\":3,\"135\":2,\"136\":5,\"137\":2,\"142\":1,\"143\":1,\"148\":1,\"149\":1,\"158\":1,\"170\":1,\"179\":1,\"185\":2,\"224\":4,\"271\":1,\"273\":2,\"274\":1,\"286\":1,\"355\":3,\"385\":3,\"388\":2,\"405\":1,\"406\":3,\"494\":1,\"601\":1,\"602\":1,\"605\":2,\"606\":1,\"699\":2,\"704\":3,\"710\":2,\"736\":3,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":8,\"751\":3,\"756\":2,\"759\":1,\"765\":1,\"768\":1,\"771\":1,\"774\":1,\"777\":1,\"783\":1,\"787\":3,\"798\":1,\"810\":1,\"817\":3,\"819\":4,\"821\":2,\"848\":2,\"849\":2,\"854\":1,\"855\":1,\"856\":1,\"871\":1,\"966\":2,\"999\":1,\"1001\":1,\"1007\":1,\"1011\":1,\"1055\":3,\"1076\":1,\"1080\":1,\"1096\":1,\"1099\":2,\"1102\":3,\"1120\":1,\"1121\":1,\"1123\":2,\"1127\":3,\"1168\":1,\"1179\":1,\"1299\":1,\"1321\":1,\"1384\":1,\"1385\":4,\"1839\":11,\"1849\":12,\"1859\":1,\"1871\":1,\"1872\":1,\"1875\":11,\"1878\":2}}],[\"=\",{\"0\":{\"1357\":2},\"1\":{\"8\":6,\"11\":5,\"29\":2,\"44\":5,\"53\":10,\"54\":21,\"59\":92,\"60\":26,\"67\":4,\"70\":5,\"73\":7,\"77\":3,\"78\":4,\"81\":12,\"84\":5,\"87\":5,\"93\":1,\"94\":1,\"96\":12,\"97\":11,\"101\":24,\"104\":7,\"107\":11,\"110\":11,\"115\":5,\"118\":6,\"121\":4,\"125\":4,\"126\":3,\"129\":6,\"132\":3,\"133\":4,\"137\":3,\"141\":2,\"142\":5,\"143\":2,\"147\":1,\"148\":8,\"149\":4,\"153\":1,\"158\":4,\"161\":1,\"162\":4,\"163\":1,\"166\":5,\"169\":4,\"170\":2,\"171\":1,\"177\":1,\"178\":4,\"179\":4,\"182\":8,\"185\":8,\"188\":7,\"191\":27,\"194\":7,\"199\":11,\"202\":8,\"205\":5,\"214\":11,\"217\":6,\"220\":6,\"224\":7,\"234\":10,\"236\":4,\"238\":1,\"240\":1,\"246\":5,\"249\":2,\"251\":1,\"267\":1,\"271\":3,\"277\":4,\"282\":1,\"285\":1,\"286\":14,\"287\":2,\"308\":2,\"323\":4,\"338\":1,\"339\":1,\"345\":1,\"355\":28,\"359\":1,\"364\":2,\"368\":2,\"371\":12,\"372\":4,\"378\":14,\"385\":32,\"388\":4,\"389\":1,\"395\":3,\"397\":1,\"405\":14,\"406\":40,\"411\":2,\"412\":3,\"413\":2,\"414\":2,\"421\":4,\"422\":5,\"426\":1,\"432\":7,\"433\":10,\"434\":4,\"435\":2,\"439\":3,\"440\":5,\"449\":2,\"450\":2,\"455\":4,\"458\":6,\"459\":20,\"463\":11,\"464\":7,\"468\":8,\"473\":9,\"476\":2,\"480\":3,\"483\":5,\"484\":9,\"485\":5,\"487\":5,\"488\":10,\"489\":7,\"490\":10,\"492\":28,\"494\":6,\"497\":24,\"500\":9,\"506\":3,\"510\":2,\"511\":5,\"512\":5,\"515\":14,\"516\":2,\"517\":3,\"518\":4,\"520\":1,\"521\":2,\"522\":2,\"523\":3,\"524\":3,\"526\":2,\"530\":1,\"535\":13,\"536\":13,\"538\":1,\"542\":2,\"545\":1,\"546\":6,\"547\":42,\"548\":9,\"557\":8,\"563\":2,\"567\":2,\"568\":2,\"569\":2,\"570\":2,\"571\":2,\"574\":1,\"575\":1,\"584\":1,\"585\":1,\"589\":2,\"590\":2,\"591\":1,\"592\":7,\"594\":19,\"597\":3,\"599\":3,\"602\":2,\"605\":3,\"612\":3,\"613\":1,\"614\":4,\"615\":6,\"616\":7,\"618\":49,\"620\":4,\"621\":11,\"622\":2,\"624\":4,\"625\":9,\"628\":1,\"629\":10,\"630\":9,\"631\":3,\"632\":2,\"633\":18,\"637\":4,\"638\":8,\"639\":4,\"640\":4,\"641\":5,\"642\":10,\"653\":2,\"662\":33,\"678\":9,\"695\":1,\"698\":3,\"699\":15,\"700\":3,\"704\":38,\"709\":1,\"710\":2,\"713\":2,\"714\":5,\"717\":1,\"718\":1,\"722\":2,\"728\":1,\"729\":1,\"730\":6,\"731\":12,\"736\":19,\"742\":1,\"743\":1,\"745\":2,\"746\":2,\"747\":29,\"751\":27,\"755\":6,\"756\":20,\"759\":8,\"762\":28,\"765\":4,\"768\":8,\"771\":21,\"774\":19,\"777\":17,\"782\":15,\"783\":18,\"784\":8,\"787\":15,\"791\":23,\"792\":33,\"795\":17,\"798\":10,\"802\":21,\"806\":5,\"810\":18,\"817\":42,\"819\":28,\"821\":27,\"826\":3,\"830\":5,\"831\":6,\"832\":6,\"848\":4,\"849\":3,\"850\":2,\"851\":2,\"852\":2,\"854\":4,\"855\":2,\"856\":4,\"857\":5,\"862\":3,\"864\":5,\"866\":1,\"867\":5,\"871\":10,\"889\":7,\"890\":3,\"891\":2,\"894\":10,\"898\":5,\"900\":1,\"905\":13,\"906\":4,\"907\":2,\"908\":2,\"919\":2,\"920\":4,\"922\":2,\"948\":1,\"949\":3,\"953\":3,\"954\":3,\"966\":13,\"984\":3,\"985\":2,\"999\":4,\"1000\":4,\"1001\":8,\"1002\":3,\"1007\":4,\"1008\":2,\"1011\":10,\"1018\":2,\"1019\":1,\"1020\":1,\"1021\":1,\"1025\":10,\"1031\":16,\"1032\":4,\"1040\":2,\"1041\":4,\"1043\":2,\"1045\":2,\"1047\":1,\"1050\":3,\"1055\":9,\"1056\":4,\"1057\":4,\"1066\":1,\"1067\":1,\"1076\":2,\"1079\":1,\"1080\":4,\"1082\":8,\"1086\":3,\"1087\":2,\"1090\":10,\"1093\":4,\"1096\":8,\"1099\":11,\"1102\":27,\"1110\":4,\"1111\":4,\"1112\":6,\"1113\":8,\"1114\":15,\"1115\":5,\"1116\":3,\"1120\":10,\"1121\":4,\"1122\":2,\"1123\":20,\"1124\":1,\"1127\":33,\"1142\":1,\"1147\":3,\"1148\":8,\"1151\":3,\"1155\":1,\"1158\":3,\"1164\":1,\"1165\":2,\"1166\":1,\"1167\":1,\"1168\":2,\"1171\":1,\"1172\":2,\"1173\":11,\"1174\":6,\"1175\":5,\"1177\":1,\"1178\":2,\"1180\":1,\"1183\":3,\"1188\":2,\"1195\":1,\"1208\":2,\"1209\":4,\"1219\":10,\"1229\":3,\"1233\":5,\"1299\":8,\"1318\":6,\"1357\":6,\"1360\":1,\"1361\":4,\"1365\":4,\"1367\":2,\"1384\":7,\"1385\":10,\"1407\":1,\"1408\":1,\"1469\":1,\"1471\":1,\"1491\":1,\"1492\":3,\"1494\":1,\"1500\":3,\"1501\":1,\"1538\":2,\"1569\":3,\"1582\":1,\"1623\":5,\"1738\":2,\"1740\":1,\"1752\":1,\"1754\":1,\"1839\":21,\"1846\":1,\"1847\":4,\"1849\":23,\"1851\":17,\"1856\":6,\"1859\":5,\"1875\":22,\"1878\":12,\"1900\":1,\"1901\":1,\"1902\":4,\"1903\":6,\"1904\":5,\"1905\":2,\"1907\":7,\"1908\":6,\"1909\":8,\"1915\":6}}],[\"5s\",{\"1\":{\"1820\":1}}],[\"51s\",{\"1\":{\"1740\":1}}],[\"512\",{\"1\":{\"239\":1}}],[\"5及只有的版本改为了innodb\",{\"1\":{\"1557\":1}}],[\"5版本前默认的存储引擎是myisam\",{\"1\":{\"1557\":1}}],[\"54\",{\"1\":{\"1271\":2}}],[\"52\",{\"1\":{\"1007\":2,\"1008\":1}}],[\"50\",{\"1\":{\"511\":1,\"953\":1,\"954\":1,\"1016\":1,\"1055\":1,\"1082\":1,\"1113\":1,\"1114\":15,\"1165\":1,\"1425\":1,\"1437\":1,\"1537\":2,\"1551\":1,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1,\"1820\":3}}],[\"5000\",{\"1\":{\"1851\":1}}],[\"500\",{\"1\":{\"497\":1,\"1025\":1}}],[\"565\",{\"1\":{\"1773\":1}}],[\"56\",{\"1\":{\"1007\":2,\"1008\":1,\"1537\":1,\"1820\":2}}],[\"5600\",{\"1\":{\"449\":1}}],[\"5699\",{\"1\":{\"397\":1,\"439\":1,\"464\":1}}],[\"555\",{\"1\":{\"497\":1}}],[\"55\",{\"1\":{\"378\":1,\"1820\":1}}],[\"55rem\",{\"1\":{\"49\":1}}],[\"58acce702aa9441a86491432ea8315c3\",{\"1\":{\"1773\":1}}],[\"58\",{\"1\":{\"371\":1}}],[\"534\",{\"1\":{\"1255\":2}}],[\"53\",{\"1\":{\"101\":4,\"1271\":2}}],[\"594\",{\"0\":{\"177\":1},\"1\":{\"177\":1}}],[\"59\",{\"0\":{\"81\":1},\"1\":{\"81\":2,\"1271\":1,\"1537\":1}}],[\"5px\",{\"1\":{\"49\":1}}],[\"5rem\",{\"1\":{\"49\":1,\"51\":2}}],[\"5\",{\"0\":{\"1198\":1,\"1229\":1,\"1376\":1,\"1498\":1,\"1581\":1},\"1\":{\"8\":1,\"22\":1,\"29\":1,\"44\":1,\"50\":1,\"59\":1,\"104\":2,\"107\":5,\"110\":4,\"129\":1,\"169\":1,\"177\":2,\"338\":1,\"365\":2,\"368\":3,\"378\":3,\"389\":1,\"406\":1,\"455\":1,\"458\":2,\"459\":3,\"500\":3,\"517\":2,\"536\":1,\"594\":1,\"618\":2,\"642\":1,\"714\":2,\"747\":1,\"802\":1,\"810\":2,\"830\":1,\"884\":2,\"885\":2,\"965\":1,\"990\":1,\"991\":1,\"992\":1,\"1031\":1,\"1032\":1,\"1114\":3,\"1115\":1,\"1168\":3,\"1238\":1,\"1255\":1,\"1271\":1,\"1310\":1,\"1395\":1,\"1396\":1,\"1397\":10,\"1405\":1,\"1507\":1,\"1537\":4,\"1557\":2,\"1594\":1,\"1719\":2,\"1735\":1,\"1736\":2,\"1758\":1,\"1828\":3,\"1878\":2,\"1904\":1,\"1908\":1}}],[\"o线程保持一致\",{\"1\":{\"1784\":1}}],[\"o线程接收的事件写入中继日志\",{\"1\":{\"1784\":1}}],[\"o线程会主动连接master\",{\"1\":{\"1784\":1}}],[\"o线程会异步地将这些页刷新到磁盘\",{\"1\":{\"1762\":1}}],[\"o线程\",{\"1\":{\"1784\":2}}],[\"o就越少\",{\"1\":{\"1752\":1}}],[\"o次数\",{\"1\":{\"1748\":1}}],[\"o次数少\",{\"1\":{\"1627\":1}}],[\"o往磁盘上写\",{\"1\":{\"1645\":1}}],[\"o把一个磁盘块的数据全部存储下来\",{\"1\":{\"1623\":1}}],[\"o造成cpu负荷太重\",{\"1\":{\"1609\":1}}],[\"o操作\",{\"1\":{\"1609\":1,\"1736\":1,\"1762\":1}}],[\"o复用+可伸缩的线程池\",{\"1\":{\"1454\":1}}],[\"o匹配出来\",{\"1\":{\"1360\":1}}],[\"o用\",{\"1\":{\"1360\":1}}],[\"o3\",{\"1\":{\"1327\":1}}],[\"option命令\",{\"1\":{\"1318\":1}}],[\"option\",{\"1\":{\"1318\":5,\"1408\":1,\"1799\":1}}],[\"options\",{\"1\":{\"1317\":1}}],[\"options命令添加的编译选项是针对\",{\"1\":{\"1317\":1}}],[\"options来操作\",{\"1\":{\"1317\":1}}],[\"operetor\",{\"1\":{\"1173\":1}}],[\"operational\",{\"1\":{\"1820\":1}}],[\"operating\",{\"1\":{\"16\":1}}],[\"operator是关键字\",{\"1\":{\"727\":1}}],[\"operator<=\",{\"1\":{\"545\":1}}],[\"operator<\",{\"1\":{\"545\":1,\"699\":1,\"736\":1,\"784\":1,\"1002\":1}}],[\"operator<<\",{\"1\":{\"476\":2,\"662\":8,\"699\":2,\"731\":2,\"736\":2,\"1002\":4,\"1123\":2}}],[\"operator>>\",{\"1\":{\"731\":2,\"736\":2}}],[\"operator>=\",{\"1\":{\"545\":1}}],[\"operator>\",{\"1\":{\"545\":1,\"699\":1,\"736\":1}}],[\"operator++\",{\"1\":{\"699\":1,\"704\":1,\"731\":2,\"747\":1}}],[\"operator+\",{\"0\":{\"1122\":1},\"1\":{\"541\":5,\"699\":2,\"731\":3,\"736\":1,\"1122\":2,\"1123\":3}}],[\"operator+=\",{\"1\":{\"541\":3,\"731\":1}}],[\"operator\",{\"0\":{\"710\":1,\"711\":1},\"1\":{\"516\":3,\"518\":4,\"519\":5,\"530\":3,\"539\":2,\"545\":1,\"604\":1,\"699\":4,\"704\":4,\"709\":2,\"710\":5,\"711\":5,\"718\":1,\"727\":1,\"736\":2,\"747\":3,\"751\":2,\"784\":1,\"854\":2,\"856\":1,\"857\":1,\"982\":2,\"1000\":2,\"1011\":2,\"1041\":3,\"1055\":3,\"1060\":4,\"1115\":1,\"1148\":5,\"1158\":4,\"1164\":1,\"1165\":1,\"1173\":2}}],[\"operator=出语句调用~test\",{\"1\":{\"1114\":1}}],[\"operator==\",{\"1\":{\"545\":1,\"699\":1,\"736\":1}}],[\"operator=\",{\"1\":{\"355\":1,\"385\":1,\"405\":2,\"406\":2,\"439\":1,\"463\":2,\"464\":2,\"548\":2,\"662\":9,\"699\":1,\"704\":1,\"731\":1,\"736\":3,\"848\":1,\"850\":1,\"851\":1,\"1032\":1,\"1055\":1,\"1110\":2,\"1111\":2,\"1114\":4,\"1115\":2,\"1120\":3,\"1121\":3,\"1123\":4,\"1127\":1}}],[\"openclounddb表示我们看到的是一个云状数据库\",{\"1\":{\"1809\":1}}],[\"open\",{\"1\":{\"60\":1,\"239\":1,\"1284\":1}}],[\"o来指定一个文件名\",{\"1\":{\"1251\":1}}],[\"o或\",{\"1\":{\"1237\":1}}],[\"on或off\",{\"1\":{\"1318\":1}}],[\"one\",{\"1\":{\"1143\":1,\"1219\":1,\"1362\":1}}],[\"on\",{\"1\":{\"1102\":1,\"1133\":1,\"1291\":1,\"1318\":1,\"1408\":1,\"1447\":4,\"1485\":1,\"1486\":1,\"1500\":3,\"1501\":1,\"1537\":4,\"1538\":9,\"1539\":1,\"1540\":1,\"1541\":2,\"1543\":1,\"1544\":2,\"1581\":1,\"1582\":1,\"1600\":1,\"1603\":1,\"1614\":3,\"1738\":1,\"1799\":1,\"1821\":1,\"1828\":1}}],[\"once形式\",{\"0\":{\"857\":1}}],[\"once\",{\"0\":{\"852\":1},\"1\":{\"852\":2,\"857\":8}}],[\"onclick\",{\"1\":{\"53\":1,\"54\":2,\"59\":5}}],[\"oom\",{\"1\":{\"1080\":1,\"1102\":5,\"1105\":1}}],[\"oop语言的四大特征是什么\",{\"0\":{\"448\":1}}],[\"oop编程方法\",{\"0\":{\"446\":1}}],[\"oil\",{\"1\":{\"900\":11}}],[\"o2\",{\"1\":{\"501\":1,\"1327\":2}}],[\"ok\",{\"1\":{\"440\":1,\"476\":1,\"485\":1,\"488\":2,\"490\":2,\"491\":2,\"492\":7,\"497\":3,\"548\":1,\"621\":1,\"640\":1,\"652\":3,\"678\":3,\"717\":1,\"718\":1,\"729\":1,\"894\":2,\"1407\":2,\"1799\":2}}],[\"otherwise\",{\"1\":{\"1082\":1}}],[\"otherclass\",{\"1\":{\"423\":3}}],[\"other\",{\"1\":{\"405\":7,\"423\":2}}],[\"obser\",{\"1\":{\"871\":4}}],[\"observer3\",{\"1\":{\"871\":6}}],[\"observer2\",{\"1\":{\"871\":5}}],[\"observer1\",{\"1\":{\"871\":6}}],[\"observer\",{\"1\":{\"871\":10}}],[\"obout\",{\"1\":{\"389\":2}}],[\"obin\",{\"1\":{\"389\":2}}],[\"objs\",{\"1\":{\"1360\":4,\"1361\":1,\"1365\":4,\"1367\":3}}],[\"obj文件\",{\"1\":{\"311\":1}}],[\"objdump\",{\"0\":{\"260\":1},\"1\":{\"227\":1,\"228\":2,\"234\":2,\"248\":1,\"253\":1,\"260\":1,\"501\":1,\"516\":1}}],[\"obj\",{\"1\":{\"182\":5,\"310\":5,\"422\":4,\"731\":3,\"791\":6,\"792\":6,\"1082\":6,\"1093\":3,\"1096\":2,\"1099\":19,\"1102\":5}}],[\"object\",{\"1\":{\"182\":1,\"791\":1,\"792\":1}}],[\"o多了program\",{\"1\":{\"262\":1}}],[\"o中各个段进行合并\",{\"1\":{\"255\":1}}],[\"o和sum\",{\"1\":{\"255\":1}}],[\"o的操作次数是最少的\",{\"1\":{\"1623\":1}}],[\"o的次数\",{\"1\":{\"1603\":1,\"1604\":1}}],[\"o的二进制文件\",{\"1\":{\"572\":1}}],[\"o的\",{\"0\":{\"253\":1}}],[\"o符号表\",{\"0\":{\"249\":1,\"250\":1}}],[\"o文件段的合并\",{\"1\":{\"255\":1}}],[\"o文件的组成\",{\"1\":{\"251\":1}}],[\"o文件的组成格式是什么样的\",{\"1\":{\"244\":1}}],[\"o文件头\",{\"0\":{\"251\":1}}],[\"o文件对应的段进行合并\",{\"1\":{\"245\":1}}],[\"off\",{\"1\":{\"1318\":3,\"1407\":2}}],[\"offset为x末端\",{\"1\":{\"81\":1}}],[\"offset\",{\"1\":{\"81\":8,\"572\":1,\"1516\":1}}],[\"offsettop\",{\"1\":{\"59\":5}}],[\"of\",{\"1\":{\"234\":4,\"476\":1,\"531\":1,\"539\":1,\"571\":1,\"577\":1,\"584\":1,\"585\":1,\"589\":1,\"590\":1,\"591\":1,\"592\":2,\"594\":7,\"599\":2,\"604\":1,\"605\":3,\"682\":2,\"1082\":1,\"1086\":1,\"1102\":2,\"1252\":1}}],[\"osappender\",{\"1\":{\"1032\":5}}],[\"ostreamappender123\",{\"1\":{\"1031\":4}}],[\"ostreamappender\",{\"1\":{\"1019\":1,\"1020\":1,\"1031\":9,\"1032\":4}}],[\"ostream\",{\"1\":{\"662\":16,\"699\":4,\"731\":4,\"736\":4,\"1002\":8,\"1123\":4}}],[\"os\",{\"1\":{\"60\":6,\"662\":16}}],[\"ol\",{\"1\":{\"59\":2}}],[\"ol元素中的特殊处理\",{\"1\":{\"59\":1}}],[\"oldsize\",{\"1\":{\"968\":1}}],[\"old\",{\"1\":{\"0\":1,\"1076\":9}}],[\"out=out\",{\"1\":{\"1915\":1}}],[\"outer\",{\"1\":{\"1543\":2,\"1544\":1}}],[\"outerhtml\",{\"1\":{\"59\":1}}],[\"out可以定义输出变量\",{\"1\":{\"1523\":1}}],[\"out跟踪代码\",{\"1\":{\"1217\":1}}],[\"outofrandge\",{\"1\":{\"736\":2}}],[\"outofrangeexception\",{\"1\":{\"704\":1}}],[\"outside<int>\",{\"1\":{\"389\":2}}],[\"outside\",{\"1\":{\"389\":3}}],[\"out包含很多段\",{\"1\":{\"263\":1}}],[\"out位于磁盘中\",{\"1\":{\"263\":1}}],[\"out\",{\"0\":{\"257\":1,\"259\":1},\"1\":{\"224\":1,\"262\":2,\"371\":1,\"378\":1,\"422\":1,\"433\":1,\"468\":1,\"516\":1,\"531\":1,\"599\":2,\"604\":1,\"605\":4,\"606\":1,\"614\":1,\"621\":1,\"699\":4,\"731\":4,\"736\":4,\"1002\":8,\"1032\":1,\"1123\":3,\"1202\":1,\"1338\":1,\"1360\":2}}],[\"outtext\",{\"1\":{\"59\":2}}],[\"outline\",{\"1\":{\"51\":20}}],[\"output=decode\",{\"1\":{\"1773\":1}}],[\"outputname\",{\"1\":{\"1326\":2,\"1327\":1,\"1328\":1,\"1329\":1,\"1331\":2}}],[\"output\",{\"1\":{\"8\":1,\"1253\":1,\"1310\":2,\"1316\":6,\"1317\":1,\"1318\":1,\"1330\":1,\"1773\":1}}],[\"over\",{\"1\":{\"1102\":1}}],[\"overload\",{\"0\":{\"692\":1}}],[\"overloading\",{\"1\":{\"560\":1}}],[\"overline\",{\"1\":{\"50\":1}}],[\"overflow\",{\"1\":{\"240\":2,\"531\":1,\"604\":1}}],[\"override\",{\"0\":{\"693\":1},\"1\":{\"51\":2,\"693\":1,\"695\":1,\"913\":1}}],[\"or可以用索引了\",{\"1\":{\"1594\":1}}],[\"or不能使用索引\",{\"0\":{\"1594\":1}}],[\"oracle默认工作级别\",{\"1\":{\"1677\":1}}],[\"oracle默认\",{\"1\":{\"1631\":1}}],[\"oracle\",{\"1\":{\"1452\":1}}],[\"orange\",{\"1\":{\"29\":2}}],[\"org\",{\"1\":{\"1249\":1,\"1252\":1,\"1253\":1}}],[\"or\",{\"1\":{\"234\":1,\"312\":1,\"1102\":1,\"1514\":1,\"1521\":1,\"1592\":1,\"1594\":1,\"1739\":1}}],[\"original\",{\"1\":{\"1361\":2}}],[\"origin\",{\"1\":{\"59\":1}}],[\"orderid\",{\"1\":{\"1543\":1,\"1544\":1}}],[\"orderlist\",{\"1\":{\"1543\":1,\"1544\":1}}],[\"orders\",{\"1\":{\"1428\":2}}],[\"order\",{\"1\":{\"45\":1,\"1496\":3,\"1525\":4,\"1530\":1,\"1531\":1,\"1538\":3,\"1566\":1,\"1737\":1,\"1740\":1}}],[\"o\",{\"0\":{\"1251\":1},\"1\":{\"29\":1,\"67\":1,\"101\":4,\"126\":4,\"129\":1,\"143\":2,\"195\":1,\"214\":2,\"234\":7,\"244\":1,\"247\":2,\"248\":3,\"251\":1,\"252\":2,\"253\":1,\"255\":3,\"260\":1,\"289\":1,\"501\":1,\"535\":1,\"547\":1,\"567\":1,\"568\":6,\"569\":1,\"570\":1,\"572\":3,\"704\":1,\"755\":2,\"756\":1,\"771\":2,\"802\":1,\"1251\":1,\"1326\":2,\"1327\":3,\"1328\":1,\"1329\":1,\"1330\":2,\"1331\":9,\"1332\":1,\"1334\":4,\"1335\":4,\"1347\":1,\"1359\":1,\"1360\":14,\"1361\":1,\"1365\":4,\"1366\":2,\"1367\":4,\"1603\":2,\"1623\":1,\"1645\":1,\"1856\":1}}],[\"n的结果集\",{\"1\":{\"1618\":1}}],[\"n>也是一个临时表\",{\"1\":{\"1618\":1}}],[\"n为int型输入变量\",{\"1\":{\"1523\":1}}],[\"n为奇数\",{\"1\":{\"81\":1}}],[\"ndebug\",{\"1\":{\"1321\":1}}],[\"ndebug宏\",{\"0\":{\"1321\":1}}],[\"nt\",{\"1\":{\"1255\":1}}],[\"ntlp\",{\"1\":{\"1238\":1}}],[\"nteventlogappender\",{\"1\":{\"1019\":1}}],[\"n|grep\",{\"1\":{\"1238\":1}}],[\"nr\",{\"1\":{\"1238\":2}}],[\"nr|head\",{\"1\":{\"1238\":1}}],[\"n20\",{\"1\":{\"1238\":3}}],[\"nlohmann\",{\"1\":{\"1896\":1,\"1901\":1}}],[\"nlogn\",{\"1\":{\"114\":1,\"142\":1,\"195\":1,\"202\":1}}],[\"nlp\",{\"1\":{\"1238\":1}}],[\"n或\",{\"1\":{\"1237\":2}}],[\"night\",{\"1\":{\"1904\":2,\"1908\":1}}],[\"nickname\",{\"1\":{\"1437\":1,\"1525\":3}}],[\"ni\",{\"1\":{\"1155\":1}}],[\"nn\",{\"1\":{\"1138\":2}}],[\"nnn\",{\"1\":{\"1124\":1,\"1127\":1}}],[\"n就是越过了一个\",{\"1\":{\"1099\":1}}],[\"n个字节应该在内存池哪个块分配\",{\"1\":{\"1096\":1}}],[\"n字节的元素\",{\"1\":{\"1099\":1}}],[\"n字节的chunk时\",{\"1\":{\"1099\":1}}],[\"n字节chunk的内存池\",{\"1\":{\"1099\":1}}],[\"n字节chunk块的时候\",{\"1\":{\"1099\":1}}],[\"n字节chunk块的内存池\",{\"1\":{\"1099\":1}}],[\"n字节chunk块到内存池\",{\"1\":{\"1093\":1}}],[\"n字节在\",{\"1\":{\"1093\":1,\"1099\":1}}],[\"n字节内存空间到内存池\",{\"1\":{\"1093\":1}}],[\"nfreelists\",{\"1\":{\"1082\":5}}],[\"n分别表示\",{\"1\":{\"810\":1}}],[\"n和n\",{\"1\":{\"774\":1}}],[\"n是分别是链表\",{\"1\":{\"771\":1}}],[\"n步\",{\"1\":{\"771\":1}}],[\"npos\",{\"1\":{\"542\":1,\"546\":2}}],[\"nerd\",{\"0\":{\"1138\":1}}],[\"necessary\",{\"1\":{\"1082\":1}}],[\"next域填写完成\",{\"1\":{\"1099\":1}}],[\"next\",{\"1\":{\"747\":9,\"751\":13,\"755\":6,\"756\":6,\"759\":6,\"762\":6,\"768\":2,\"771\":2,\"774\":6,\"782\":6,\"783\":6,\"784\":6,\"787\":6,\"791\":4,\"792\":4,\"795\":9,\"798\":6,\"802\":6,\"810\":12,\"817\":31,\"819\":22,\"821\":23,\"1099\":7,\"1340\":1,\"1686\":1,\"1717\":3,\"1719\":13}}],[\"nexti\",{\"1\":{\"261\":1}}],[\"network\",{\"2\":{\"1910\":1,\"1916\":1}}],[\"netstat\",{\"1\":{\"1238\":13,\"1398\":1,\"1616\":1,\"1820\":1}}],[\"netstat命令各个参数\",{\"0\":{\"1237\":1}}],[\"netlink或\",{\"1\":{\"1237\":1}}],[\"net\",{\"1\":{\"597\":1,\"599\":1,\"1014\":1,\"1015\":1,\"1280\":1,\"1878\":1}}],[\"newmake\",{\"1\":{\"1363\":1}}],[\"new出来的资源无法释放\",{\"1\":{\"1056\":1}}],[\"newlog4cpp\",{\"1\":{\"1020\":2}}],[\"newnode\",{\"1\":{\"762\":8,\"792\":9,\"810\":2,\"817\":4,\"819\":7,\"821\":8}}],[\"new不私有\",{\"1\":{\"718\":1}}],[\"new不仅仅也有malloc功能\",{\"1\":{\"513\":1,\"708\":1}}],[\"new操作没有对应的delete\",{\"1\":{\"716\":1}}],[\"new的实现\",{\"0\":{\"710\":1}}],[\"new与delete不能再混用了\",{\"1\":{\"714\":1}}],[\"new与delete功能只剩下malloc与free功能\",{\"1\":{\"713\":1}}],[\"new与delete实现原理进行剖析\",{\"0\":{\"709\":1}}],[\"new与delete要成对出现\",{\"1\":{\"513\":1,\"515\":1}}],[\"new最后将开辟好内存用指针p返回\",{\"0\":{\"520\":1}}],[\"new和operator\",{\"1\":{\"519\":1}}],[\"new和deletea原理\",{\"0\":{\"516\":1}}],[\"new获得的内存实质上还是用malloc开辟出来的\",{\"1\":{\"518\":1}}],[\"new来获得的内存\",{\"1\":{\"518\":1}}],[\"new返回的地址\",{\"1\":{\"517\":1}}],[\"new就是简单的分配内存即可\",{\"1\":{\"516\":1}}],[\"new申请是已经初始化的堆空间\",{\"1\":{\"515\":1}}],[\"new开辟时对单个元素内存后面不需要\",{\"1\":{\"513\":1,\"708\":1}}],[\"new开辟内存时需要指定类型\",{\"1\":{\"513\":1,\"708\":1}}],[\"new抛出的是bad\",{\"1\":{\"513\":1,\"708\":1}}],[\"new相当于运算符重载函数\",{\"1\":{\"513\":1,\"708\":1}}],[\"new需要分配不同的内存地址\",{\"1\":{\"470\":1}}],[\"new或malloc后才会分配堆内存\",{\"1\":{\"267\":1}}],[\"newstack\",{\"1\":{\"224\":3}}],[\"new\",{\"0\":{\"509\":1,\"513\":1,\"517\":1,\"518\":2,\"521\":2},\"1\":{\"59\":1,\"101\":2,\"182\":2,\"185\":1,\"224\":2,\"240\":1,\"271\":1,\"355\":4,\"385\":4,\"388\":1,\"397\":2,\"405\":5,\"406\":4,\"412\":1,\"414\":1,\"426\":1,\"435\":1,\"439\":1,\"455\":2,\"459\":6,\"464\":2,\"509\":1,\"510\":1,\"511\":4,\"512\":1,\"515\":3,\"516\":2,\"517\":3,\"518\":7,\"519\":3,\"520\":2,\"521\":1,\"523\":3,\"524\":3,\"548\":4,\"604\":1,\"605\":1,\"616\":1,\"618\":1,\"662\":11,\"685\":1,\"695\":1,\"699\":5,\"704\":4,\"707\":2,\"709\":3,\"710\":6,\"713\":2,\"714\":5,\"717\":1,\"718\":1,\"736\":8,\"747\":1,\"750\":2,\"751\":4,\"759\":1,\"762\":5,\"774\":1,\"777\":1,\"782\":1,\"783\":1,\"784\":1,\"791\":5,\"792\":6,\"795\":3,\"798\":1,\"802\":1,\"810\":2,\"817\":3,\"819\":3,\"821\":3,\"826\":1,\"830\":4,\"831\":8,\"832\":3,\"848\":1,\"849\":1,\"851\":1,\"852\":1,\"854\":1,\"855\":1,\"856\":1,\"857\":1,\"862\":2,\"864\":6,\"866\":4,\"867\":6,\"871\":3,\"905\":2,\"906\":1,\"907\":2,\"908\":2,\"948\":3,\"949\":3,\"1019\":1,\"1021\":1,\"1031\":12,\"1032\":4,\"1040\":1,\"1041\":6,\"1043\":1,\"1045\":3,\"1047\":2,\"1050\":2,\"1055\":2,\"1056\":4,\"1057\":2,\"1060\":2,\"1076\":10,\"1080\":2,\"1086\":1,\"1087\":1,\"1114\":2,\"1120\":4,\"1122\":2,\"1123\":8,\"1127\":3,\"1151\":1,\"1299\":1,\"1622\":1,\"1839\":1,\"1849\":2,\"1859\":2,\"1875\":2},\"2\":{\"720\":1,\"753\":1}}],[\"nmap\",{\"1\":{\"1133\":1}}],[\"nm\",{\"0\":{\"572\":1},\"1\":{\"248\":1}}],[\"nvidia控制面板\",{\"1\":{\"66\":1}}],[\"nvidia处理器\",{\"0\":{\"66\":1},\"1\":{\"66\":1}}],[\"nat模式\",{\"1\":{\"1796\":1}}],[\"native\",{\"1\":{\"1407\":1,\"1447\":2,\"1888\":2,\"1891\":2}}],[\"nat\",{\"1\":{\"1276\":1}}],[\"navigation\",{\"1\":{\"59\":1}}],[\"name改成了\",{\"1\":{\"1681\":2}}],[\"nameidx\",{\"1\":{\"1600\":1,\"1603\":1,\"1614\":1}}],[\"name的多列索引\",{\"1\":{\"1566\":1}}],[\"name现在是索引\",{\"1\":{\"1566\":1}}],[\"named\",{\"0\":{\"1293\":1}}],[\"namespacestd\",{\"1\":{\"1020\":1}}],[\"namespace\",{\"1\":{\"163\":1,\"267\":1,\"405\":1,\"406\":1,\"476\":1,\"584\":2,\"585\":2,\"588\":2,\"589\":2,\"590\":2,\"591\":2,\"592\":4,\"594\":19,\"597\":1,\"599\":1,\"601\":4,\"605\":1,\"606\":1,\"731\":1,\"736\":1,\"751\":1,\"830\":1,\"831\":1,\"832\":1,\"871\":1,\"953\":1,\"1031\":1,\"1041\":1,\"1055\":1,\"1060\":1,\"1115\":1,\"1123\":1,\"1147\":1,\"1148\":1,\"1151\":2,\"1154\":1,\"1155\":1,\"1158\":1,\"1168\":1,\"1183\":1,\"1188\":1,\"1207\":1,\"1209\":1,\"1219\":1,\"1233\":1,\"1915\":1}}],[\"name=zhangsan的数据加上了行锁\",{\"1\":{\"1701\":1}}],[\"name=backbutton\",{\"1\":{\"59\":2}}],[\"name=\",{\"1\":{\"59\":5,\"1478\":1,\"1563\":1,\"1564\":3,\"1603\":1,\"1888\":9,\"1891\":10}}],[\"name\",{\"1\":{\"54\":2,\"59\":3,\"60\":1,\"449\":1,\"492\":2,\"494\":6,\"560\":1,\"563\":2,\"571\":1,\"621\":3,\"784\":1,\"862\":10,\"864\":6,\"866\":5,\"867\":16,\"886\":13,\"900\":11,\"905\":13,\"953\":2,\"1002\":12,\"1189\":9,\"1310\":1,\"1316\":2,\"1384\":2,\"1407\":4,\"1415\":2,\"1425\":1,\"1428\":4,\"1447\":11,\"1475\":2,\"1477\":1,\"1511\":10,\"1513\":4,\"1514\":3,\"1515\":3,\"1525\":4,\"1531\":1,\"1537\":5,\"1538\":1,\"1551\":1,\"1564\":2,\"1566\":1,\"1569\":3,\"1600\":1,\"1603\":2,\"1614\":8,\"1681\":1,\"1719\":1,\"1770\":2,\"1776\":1,\"1851\":2,\"1856\":1,\"1878\":1,\"1900\":1,\"1904\":1,\"1908\":1,\"1915\":4}}],[\"noon\",{\"1\":{\"1904\":2,\"1908\":1}}],[\"nonrepeatable\",{\"1\":{\"1639\":1}}],[\"nonf\",{\"1\":{\"1471\":1}}],[\"none即为默认值\",{\"1\":{\"50\":1}}],[\"none\",{\"1\":{\"48\":1,\"50\":1,\"51\":2}}],[\"nosql\",{\"1\":{\"1452\":1}}],[\"now\",{\"1\":{\"1427\":1,\"1443\":1,\"1508\":1}}],[\"nobjs的值\",{\"1\":{\"1102\":1}}],[\"nobjs会改变该值的大小\",{\"1\":{\"1102\":1}}],[\"nobjs大小的内存用于分配\",{\"1\":{\"1102\":1}}],[\"nobjs大小\",{\"1\":{\"1102\":1}}],[\"nobjs可能会在\",{\"1\":{\"1099\":1}}],[\"nobjs按引用传入\",{\"1\":{\"1099\":1}}],[\"nobjs个完整的\",{\"1\":{\"1102\":1}}],[\"nobjs个\",{\"1\":{\"1099\":1,\"1102\":3}}],[\"nobjs\",{\"1\":{\"1099\":7,\"1102\":10}}],[\"noexcept\",{\"1\":{\"607\":2}}],[\"notify\",{\"0\":{\"1229\":1},\"1\":{\"1219\":4,\"1221\":1,\"1229\":1,\"1849\":2,\"1859\":2,\"1869\":1,\"1872\":1,\"1875\":1}}],[\"notice\",{\"1\":{\"1018\":1,\"1025\":2}}],[\"nothreads\",{\"1\":{\"1093\":1,\"1096\":1}}],[\"nothrow\",{\"1\":{\"511\":1,\"848\":1,\"851\":1}}],[\"notset\",{\"1\":{\"1025\":1}}],[\"not\",{\"0\":{\"1016\":1,\"1296\":1,\"1407\":1,\"1592\":1},\"1\":{\"516\":1,\"572\":1,\"601\":5,\"1080\":1,\"1102\":1,\"1318\":1,\"1320\":1,\"1407\":1,\"1435\":1,\"1437\":2,\"1471\":1,\"1507\":1,\"1513\":1,\"1515\":1,\"1537\":10,\"1544\":3,\"1551\":3,\"1592\":1,\"1719\":1,\"1828\":1,\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":1}}],[\"noterootpath\",{\"1\":{\"60\":4}}],[\"no\",{\"0\":{\"1293\":1},\"1\":{\"51\":1,\"59\":1,\"234\":1,\"293\":3,\"312\":1,\"1151\":6,\"1773\":1}}],[\"normal模式循环切换文件\",{\"1\":{\"1133\":1}}],[\"normal\",{\"1\":{\"49\":2,\"366\":1}}],[\"node2\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"node1\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"nodename\",{\"1\":{\"53\":1,\"59\":7}}],[\"node\",{\"1\":{\"0\":1,\"810\":10,\"817\":21,\"819\":16,\"821\":17,\"1081\":3,\"1096\":2}}],[\"nu\",{\"1\":{\"1133\":1,\"1291\":1}}],[\"numeric\",{\"1\":{\"1237\":1}}],[\"numbytes\",{\"1\":{\"286\":8}}],[\"number2\",{\"1\":{\"480\":1,\"488\":2,\"497\":1,\"618\":6}}],[\"number1\",{\"1\":{\"480\":2,\"488\":5}}],[\"numbers\",{\"1\":{\"140\":4,\"141\":5,\"142\":5,\"143\":10,\"488\":1}}],[\"number++\",{\"1\":{\"11\":1}}],[\"number\",{\"1\":{\"11\":2,\"323\":1,\"359\":1,\"440\":1,\"459\":2,\"476\":4,\"480\":1,\"497\":2,\"515\":5,\"585\":1,\"589\":3,\"590\":4,\"592\":8,\"594\":22,\"616\":2,\"618\":14,\"630\":4,\"633\":9,\"653\":8,\"729\":3,\"1340\":1,\"1407\":2}}],[\"num+6\",{\"1\":{\"163\":6}}],[\"num\",{\"1\":{\"104\":5,\"107\":5,\"110\":8,\"118\":6,\"129\":3,\"148\":4,\"149\":4,\"163\":15,\"170\":5,\"171\":3,\"191\":12,\"214\":9,\"736\":1,\"771\":3,\"812\":2,\"1340\":1,\"1378\":1,\"1385\":5}}],[\"nums含有负数\",{\"1\":{\"191\":1}}],[\"nums2\",{\"1\":{\"104\":2,\"107\":2,\"110\":8,\"169\":3,\"170\":4,\"171\":2,\"191\":4}}],[\"nums1\",{\"1\":{\"104\":2,\"107\":2,\"110\":10,\"169\":3,\"170\":4,\"171\":3,\"191\":5}}],[\"nums元素组成可能为\",{\"1\":{\"87\":1}}],[\"nums\",{\"1\":{\"73\":6,\"77\":4,\"78\":6,\"84\":4,\"87\":12,\"93\":3,\"94\":3,\"96\":11,\"97\":8,\"110\":3,\"113\":1,\"114\":5,\"115\":5,\"118\":3,\"121\":6,\"124\":1,\"125\":7,\"126\":8,\"129\":5,\"132\":7,\"133\":18,\"135\":11,\"136\":22,\"137\":15,\"142\":5,\"153\":2,\"154\":4,\"155\":2,\"158\":9,\"161\":6,\"162\":30,\"177\":2,\"178\":2,\"179\":8,\"188\":16,\"191\":19,\"194\":17,\"199\":11,\"202\":14,\"205\":11,\"214\":20,\"217\":9,\"220\":12}}],[\"null约束\",{\"1\":{\"1434\":1}}],[\"nullpter\",{\"1\":{\"826\":1}}],[\"nullptr\",{\"0\":{\"525\":1},\"1\":{\"70\":1,\"101\":2,\"185\":1,\"188\":1,\"191\":2,\"224\":1,\"355\":1,\"385\":1,\"388\":1,\"405\":3,\"406\":1,\"426\":1,\"455\":1,\"459\":1,\"464\":1,\"492\":2,\"510\":1,\"512\":1,\"515\":3,\"516\":1,\"529\":2,\"530\":8,\"535\":1,\"547\":3,\"548\":4,\"571\":1,\"606\":2,\"631\":1,\"632\":1,\"633\":1,\"662\":9,\"699\":4,\"704\":2,\"710\":2,\"736\":6,\"747\":8,\"751\":6,\"755\":3,\"756\":5,\"759\":4,\"762\":10,\"768\":1,\"771\":1,\"774\":6,\"777\":6,\"782\":5,\"783\":6,\"784\":4,\"787\":5,\"791\":4,\"792\":4,\"795\":6,\"798\":3,\"802\":7,\"810\":1,\"817\":10,\"819\":3,\"821\":4,\"848\":4,\"849\":3,\"851\":1,\"852\":1,\"854\":4,\"855\":2,\"856\":3,\"857\":2,\"864\":1,\"949\":2,\"1041\":2,\"1050\":1,\"1055\":5,\"1057\":1,\"1082\":3,\"1120\":3,\"1121\":2,\"1123\":5,\"1127\":1,\"1147\":1,\"1148\":1,\"1194\":2,\"1299\":1,\"1839\":1,\"1847\":4,\"1849\":2,\"1856\":4,\"1859\":1,\"1869\":1,\"1871\":1,\"1872\":1,\"1875\":1,\"1878\":1}}],[\"null通常被定义为如下\",{\"1\":{\"526\":1}}],[\"null\",{\"0\":{\"525\":1},\"1\":{\"59\":2,\"271\":1,\"273\":2,\"274\":1,\"277\":2,\"286\":2,\"515\":1,\"526\":5,\"528\":1,\"768\":2,\"771\":2,\"1080\":1,\"1194\":1,\"1299\":1,\"1374\":1,\"1383\":1,\"1384\":3,\"1385\":5,\"1435\":1,\"1437\":2,\"1471\":2,\"1513\":2,\"1521\":2,\"1523\":1,\"1537\":10,\"1543\":1,\"1544\":2,\"1551\":3,\"1618\":1,\"1737\":1}}],[\"nullfile\",{\"1\":{\"44\":1}}],[\"n转换为\",{\"1\":{\"17\":1}}],[\"n作为换行符\",{\"1\":{\"17\":1}}],[\"n\",{\"0\":{\"774\":1},\"1\":{\"8\":2,\"11\":1,\"17\":2,\"76\":1,\"81\":14,\"100\":2,\"101\":3,\"113\":2,\"115\":1,\"125\":2,\"126\":5,\"129\":3,\"141\":2,\"143\":3,\"146\":2,\"148\":3,\"149\":6,\"174\":2,\"178\":2,\"194\":4,\"195\":1,\"199\":5,\"202\":1,\"214\":3,\"239\":1,\"277\":4,\"323\":2,\"338\":1,\"440\":2,\"468\":3,\"483\":1,\"484\":3,\"494\":2,\"535\":2,\"547\":7,\"557\":1,\"570\":1,\"594\":2,\"618\":5,\"633\":4,\"747\":2,\"755\":3,\"756\":1,\"774\":9,\"787\":2,\"802\":1,\"806\":2,\"810\":2,\"890\":4,\"894\":13,\"965\":2,\"969\":3,\"970\":1,\"973\":1,\"974\":3,\"1021\":2,\"1026\":2,\"1031\":4,\"1032\":2,\"1080\":9,\"1093\":5,\"1096\":7,\"1099\":7,\"1102\":5,\"1282\":1,\"1299\":1,\"1383\":3,\"1384\":5,\"1385\":10,\"1523\":1,\"1622\":2,\"1729\":1,\"1839\":3,\"1849\":3,\"1875\":3,\"1878\":4}}],[\"输出空行\",{\"1\":{\"1357\":1}}],[\"输出目标文件\",{\"1\":{\"1330\":1}}],[\"输出汇编代码\",{\"1\":{\"1330\":1}}],[\"输出xx\",{\"1\":{\"1321\":1}}],[\"输出priority\",{\"1\":{\"1021\":1}}],[\"输出换行\",{\"1\":{\"1021\":1}}],[\"输出消息\",{\"1\":{\"1021\":1}}],[\"输出日期\",{\"1\":{\"1021\":1}}],[\"输出categroy名称\",{\"1\":{\"1021\":1}}],[\"输出一个\",{\"1\":{\"1021\":1}}],[\"输出到标准输出\",{\"1\":{\"1330\":1}}],[\"输出到文件中并且能够设置文件最大超过多少时生成新文件\",{\"1\":{\"1019\":1}}],[\"输出到文件中\",{\"1\":{\"1019\":1}}],[\"输出到控制台上\",{\"1\":{\"1019\":1}}],[\"输出到输出流中\",{\"1\":{\"1019\":1}}],[\"输出对象内存布局信息\",{\"1\":{\"958\":1}}],[\"输出结果\",{\"1\":{\"907\":2,\"966\":1}}],[\"输出结果中的每个元素一定是\",{\"1\":{\"169\":1}}],[\"输出的结果被交换\",{\"1\":{\"905\":1}}],[\"输出人的出列顺序\",{\"1\":{\"810\":1}}],[\"输出了一个没有意义的字符\",{\"1\":{\"599\":1}}],[\"输出operator\",{\"1\":{\"517\":1}}],[\"输出流运算符\",{\"1\":{\"476\":1}}],[\"输出为8\",{\"1\":{\"470\":1}}],[\"输出\",{\"1\":{\"129\":2,\"169\":2,\"177\":1,\"306\":1,\"1357\":1,\"1903\":1}}],[\"输出该行单词个数\",{\"1\":{\"8\":1}}],[\"输入begin\",{\"1\":{\"1681\":1}}],[\"输入字符型就可以使用索引了\",{\"1\":{\"1593\":1}}],[\"输入字符串以字符数组\",{\"1\":{\"67\":1}}],[\"输入如下命令\",{\"0\":{\"1402\":1}}],[\"输入数字无效\",{\"1\":{\"1168\":1}}],[\"输入下面命令进行查看\",{\"0\":{\"1398\":1}}],[\"输入下面命令\",{\"1\":{\"958\":1}}],[\"输入消息id\",{\"1\":{\"871\":1}}],[\"输入的分母是0\",{\"1\":{\"605\":3}}],[\"输入的数据通常会被要输出的部分覆盖掉\",{\"1\":{\"67\":1}}],[\"输入流运算符\",{\"1\":{\"476\":1}}],[\"输入有序数组\",{\"0\":{\"140\":1},\"1\":{\"140\":1}}],[\"输入\",{\"1\":{\"129\":2,\"169\":2,\"177\":1,\"1855\":1}}],[\"输入g\",{\"1\":{\"60\":1}}],[\"输入法\",{\"1\":{\"33\":1}}],[\"输入shell\",{\"1\":{\"27\":1}}],[\"输入一行字符串\",{\"1\":{\"8\":1}}],[\"单库处理能力有限\",{\"1\":{\"1886\":1}}],[\"单库太大\",{\"1\":{\"1886\":1}}],[\"单线程\",{\"0\":{\"1851\":1}}],[\"单纯看内存上搜索都是o\",{\"1\":{\"1623\":1}}],[\"单纯给某个变量取个别名是毫无意义的\",{\"1\":{\"617\":1}}],[\"单列索引\",{\"1\":{\"1610\":1,\"1614\":1}}],[\"单位是秒\",{\"1\":{\"1754\":1}}],[\"单位\",{\"1\":{\"1574\":1,\"1776\":1}}],[\"单表太大\",{\"1\":{\"1886\":1}}],[\"单表查询\",{\"1\":{\"1537\":1}}],[\"单表select查询\",{\"0\":{\"1511\":1}}],[\"单重映射表\",{\"1\":{\"1000\":1,\"1002\":1}}],[\"单重集合\",{\"1\":{\"999\":1,\"1002\":1}}],[\"单例的经典实现方式是\",{\"1\":{\"845\":1}}],[\"单例类的特点\",{\"0\":{\"841\":1}}],[\"单例模式的自动释放\",{\"0\":{\"853\":1}}],[\"单例模式实现\",{\"0\":{\"845\":1}}],[\"单例模式可以分为\",{\"1\":{\"842\":1}}],[\"单例模式分类\",{\"0\":{\"842\":1}}],[\"单例模式是指在整个系统生命周期内\",{\"1\":{\"836\":1}}],[\"单例模式\",{\"0\":{\"835\":1,\"1032\":1},\"1\":{\"1863\":1}}],[\"单向循环链表的实现\",{\"0\":{\"819\":1}}],[\"单向循环链表\",{\"0\":{\"818\":1}}],[\"单向链表的实现\",{\"0\":{\"817\":1}}],[\"单向链表\",{\"0\":{\"816\":1},\"1\":{\"791\":1}}],[\"单链表\",{\"0\":{\"791\":1},\"1\":{\"792\":1}}],[\"单个库太大\",{\"1\":{\"1886\":1}}],[\"单个节点存储的key值比较多\",{\"1\":{\"1626\":1}}],[\"单个虚继承\",{\"1\":{\"940\":2}}],[\"单个\",{\"0\":{\"1312\":1},\"1\":{\"376\":1}}],[\"单独处理中心位置\",{\"1\":{\"81\":1}}],[\"单词和若干空格\",{\"1\":{\"8\":1}}],[\"单元测试\",{\"1\":{\"0\":1}}],[\"为结束符的\",{\"1\":{\"1878\":1}}],[\"为主机名\",{\"1\":{\"1770\":1}}],[\"为确保效率\",{\"1\":{\"1724\":1}}],[\"为0表示事\",{\"1\":{\"1652\":1}}],[\"为0的地方\",{\"1\":{\"555\":1}}],[\"为避免冲突所花费的性能也就越多\",{\"1\":{\"1631\":1,\"1677\":1}}],[\"为止\",{\"1\":{\"1348\":1}}],[\"为字符串\",{\"1\":{\"1299\":1}}],[\"为第一个不能转换的字符的指针\",{\"1\":{\"1299\":1}}],[\"为要转换的字符串\",{\"1\":{\"1299\":1}}],[\"为一个源文件创建一个快捷方式\",{\"1\":{\"1268\":1}}],[\"为空\",{\"1\":{\"1173\":1}}],[\"为o\",{\"1\":{\"969\":1,\"970\":1}}],[\"为2\",{\"1\":{\"968\":1}}],[\"为vector预留空间\",{\"1\":{\"965\":1}}],[\"为都提供了\",{\"1\":{\"830\":1}}],[\"为成员参与破冰游戏\",{\"1\":{\"812\":1}}],[\"为这么一个小的操作定义一个函数的好处有\",{\"1\":{\"500\":1}}],[\"为4\",{\"1\":{\"470\":1}}],[\"为3\",{\"1\":{\"338\":1}}],[\"为小端存储\",{\"1\":{\"307\":1}}],[\"为\",{\"1\":{\"302\":1,\"968\":1,\"1688\":1,\"1719\":3}}],[\"为单位的\",{\"1\":{\"1622\":1}}],[\"为单位\",{\"1\":{\"239\":1}}],[\"为何堆排序是不稳定排序\",{\"0\":{\"196\":1}}],[\"为什么插入id为9的数据也不行呢\",{\"1\":{\"1688\":1}}],[\"为什么mysql\",{\"0\":{\"1626\":1}}],[\"为什么innodb不加主键会自动生成一个主键\",{\"0\":{\"1558\":1}}],[\"为什么配置成静态ip\",{\"0\":{\"1277\":1}}],[\"为什么每次出错都是不一样的\",{\"1\":{\"1219\":1}}],[\"为什么其他申请的16b的内存可以在\",{\"1\":{\"1102\":1}}],[\"为什么定义抽象类\",{\"0\":{\"901\":1}}],[\"为什么用多态\",{\"0\":{\"882\":1}}],[\"为什么析构函数可以成为虚函数\",{\"0\":{\"877\":1}}],[\"为什么需要隔离性呢\",{\"1\":{\"1711\":1}}],[\"为什么需要连接查询\",{\"0\":{\"1535\":1}}],[\"为什么需要单例模式\",{\"0\":{\"837\":1}}],[\"为什么需要补码\",{\"0\":{\"344\":1}}],[\"为什么是n+1呢\",{\"1\":{\"774\":1}}],[\"为什么要分库分表\",{\"0\":{\"1885\":1}}],[\"为什么要在\",{\"0\":{\"1319\":1}}],[\"为什么要使用命名空间\",{\"0\":{\"582\":1}}],[\"为什么要内存对齐\",{\"0\":{\"553\":1}}],[\"为什么要定义模板\",{\"0\":{\"359\":1}}],[\"为什么在delete\",{\"1\":{\"520\":1}}],[\"为什么不用epoll而是选用select\",{\"0\":{\"1455\":1}}],[\"为什么不用pyqt做个好看点界面\",{\"1\":{\"6\":1}}],[\"为什么不依赖vector\",{\"0\":{\"993\":1}}],[\"为什么不把所有的函数都定义成内联函数\",{\"1\":{\"505\":1}}],[\"为什么会发生这个问题\",{\"1\":{\"459\":1}}],[\"为什么c和c++函数参数从右往左压栈\",{\"0\":{\"1063\":1}}],[\"为什么c++空类占用内存大小为1\",{\"0\":{\"1073\":1}}],[\"为什么c++的书都推荐使用0而不是null来表示空指针呢\",{\"0\":{\"528\":1}}],[\"为什么c++还保留malloc\",{\"0\":{\"514\":1}}],[\"为什么const成员无法调用普通成员方法\",{\"0\":{\"441\":1}}],[\"为什么c语言不能叫跨平台\",{\"0\":{\"303\":1}}],[\"为什么拷贝时候要使用\",{\"0\":{\"401\":1}}],[\"为什么显示效果为\",{\"1\":{\"307\":1}}],[\"为什么说c语言移植性强\",{\"0\":{\"302\":1}}],[\"为什么叫c语言\",{\"0\":{\"300\":1}}],[\"为什么进程间通信比较困难\",{\"1\":{\"267\":1}}],[\"为什么这么做呢\",{\"1\":{\"235\":1}}],[\"为什么该算法能够搜索左侧边界\",{\"1\":{\"96\":1}}],[\"为typora选择使用\",{\"0\":{\"66\":1}}],[\"为每一个标记都添加事件\",{\"1\":{\"59\":2}}],[\"为了权限最小化\",{\"1\":{\"1821\":1}}],[\"为了不用手动指定mycat的路径\",{\"1\":{\"1800\":1}}],[\"为了防止幻读\",{\"1\":{\"1693\":1}}],[\"为了可以更快速的\",{\"1\":{\"1673\":1}}],[\"为了保持高质量\",{\"1\":{\"1896\":1}}],[\"为了保持良好的编程习惯\",{\"1\":{\"509\":1}}],[\"为了保证输入内容的字符串格式\",{\"1\":{\"1878\":1}}],[\"为了保证数据的安全性\",{\"1\":{\"1644\":1}}],[\"为了兼容其他关系型数据库的分页语法\",{\"1\":{\"1516\":1}}],[\"为了方便\",{\"1\":{\"1315\":1}}],[\"为了方便日后查看又把结果自动存储到word内便于编辑\",{\"1\":{\"5\":1}}],[\"为了避免事务执行过程中花费过多磁盘io\",{\"1\":{\"1758\":1}}],[\"为了避免将build目录里临时生成的cpp也加进来\",{\"1\":{\"1312\":1}}],[\"为了避免这样的warning\",{\"1\":{\"276\":1}}],[\"为了cpu充分调度\",{\"1\":{\"1209\":1}}],[\"为了把返回值带出来\",{\"1\":{\"1115\":1}}],[\"为了\",{\"1\":{\"1079\":1}}],[\"为了增强现有类的功能\",{\"1\":{\"831\":3}}],[\"为了调用正确的析构函数\",{\"1\":{\"715\":1}}],[\"为了对数据成员进行初始化\",{\"1\":{\"665\":1}}],[\"为了解决这个问题\",{\"1\":{\"1251\":1}}],[\"为了解决\",{\"1\":{\"582\":1}}],[\"为了解决内存块的管理所以要设计一个管理内存块的\",{\"1\":{\"285\":1}}],[\"为了访问未对齐的内存\",{\"1\":{\"553\":1}}],[\"为了让程序链接或运行过程中能正确找到相应的库文件\",{\"1\":{\"1332\":1}}],[\"为了让其他方法不用判空\",{\"1\":{\"405\":1}}],[\"为了让一台空闲的电脑上能够运行\",{\"1\":{\"301\":1}}],[\"为了能早点儿玩上游戏\",{\"1\":{\"301\":1}}],[\"为了简单起见\",{\"1\":{\"283\":1}}],[\"为了代码\",{\"0\":{\"271\":1}}],[\"为了使排序具有稳定性\",{\"1\":{\"213\":1}}],[\"为了重传的效率更高二者分片也不同\",{\"1\":{\"22\":1}}],[\"为了提高c语言的移植性而设立的c语言标准\",{\"1\":{\"16\":1}}],[\"tted\",{\"0\":{\"1633\":1}}],[\"tx\",{\"1\":{\"1632\":1}}],[\"txt内容如下\",{\"1\":{\"1836\":1}}],[\"txt用于掌控全局\",{\"1\":{\"1316\":1}}],[\"txt添加相应配置\",{\"1\":{\"1309\":1}}],[\"txt\",{\"0\":{\"1315\":1},\"1\":{\"6\":1,\"1032\":1,\"1060\":2,\"1250\":2,\"1309\":4,\"1310\":1,\"1314\":1,\"1315\":4,\"1316\":2,\"1318\":5,\"1836\":2}}],[\"tsinghua\",{\"1\":{\"1284\":7}}],[\"t参数表示超时等待时间\",{\"1\":{\"1252\":1}}],[\"t参数表示重试次数\",{\"1\":{\"1252\":1}}],[\"twice\",{\"1\":{\"1240\":1}}],[\"two\",{\"1\":{\"535\":1,\"1362\":2}}],[\"twosum\",{\"1\":{\"125\":1,\"126\":1,\"141\":1,\"142\":1,\"143\":1}}],[\"tnn\",{\"1\":{\"1238\":1}}],[\"t或\",{\"1\":{\"1237\":1}}],[\"tlist\",{\"1\":{\"1208\":3,\"1233\":3}}],[\"t包含了所有的大的类型\",{\"1\":{\"1189\":1}}],[\"t5\",{\"1\":{\"1114\":2}}],[\"t4调用赋值重载函数\",{\"1\":{\"1112\":1}}],[\"t4原本已存在\",{\"1\":{\"1111\":1}}],[\"t4\",{\"1\":{\"1110\":2,\"1111\":6,\"1112\":5,\"1113\":5,\"1114\":2,\"1851\":2}}],[\"tp>\",{\"1\":{\"1080\":1,\"1086\":2}}],[\"tp\",{\"1\":{\"1079\":4,\"1080\":7,\"1086\":10}}],[\"t为实际的类型\",{\"1\":{\"968\":1}}],[\"tb\",{\"1\":{\"885\":1,\"1348\":1,\"1733\":4,\"1734\":3,\"1735\":8,\"1740\":4}}],[\"tv02\",{\"1\":{\"832\":2}}],[\"tv01\",{\"1\":{\"832\":2}}],[\"tv01表示支持vga接口的投影仪\",{\"1\":{\"832\":1}}],[\"tv\",{\"1\":{\"832\":2}}],[\"tuna\",{\"1\":{\"1284\":6}}],[\"tunlp\",{\"1\":{\"1238\":1}}],[\"ture\",{\"1\":{\"765\":1}}],[\"tuple是元组的意思\",{\"1\":{\"376\":1}}],[\"tuple\",{\"1\":{\"376\":1}}],[\"tmpstr\",{\"1\":{\"1120\":2,\"1122\":2,\"1123\":12}}],[\"tmp析构\",{\"1\":{\"1115\":1}}],[\"tmp拷贝构造main函数栈帧上的临时对象\",{\"1\":{\"1115\":1}}],[\"tmp对象作为局部对象就析构了\",{\"1\":{\"1115\":1}}],[\"tmp是不能直接给t2赋值的\",{\"1\":{\"1115\":1}}],[\"tmp\",{\"1\":{\"699\":5,\"736\":8,\"905\":4,\"1115\":4,\"1116\":2,\"1173\":3,\"1174\":2,\"1175\":1}}],[\"t与int区别\",{\"1\":{\"535\":1}}],[\"t3\",{\"1\":{\"385\":2,\"1110\":1,\"1111\":1,\"1112\":1,\"1113\":1,\"1114\":1,\"1851\":2}}],[\"t2析构\",{\"1\":{\"1115\":1}}],[\"t2>\",{\"1\":{\"1086\":2}}],[\"t2\",{\"1\":{\"385\":2,\"412\":4,\"414\":2,\"1086\":2,\"1110\":1,\"1111\":3,\"1112\":2,\"1113\":2,\"1114\":6,\"1115\":2,\"1116\":2,\"1173\":2,\"1207\":2,\"1219\":4,\"1851\":2}}],[\"t1析构\",{\"1\":{\"1115\":1}}],[\"t1是已经构造好的test对象\",{\"1\":{\"1115\":1}}],[\"t1\",{\"1\":{\"385\":2,\"411\":3,\"414\":2,\"1050\":4,\"1086\":5,\"1110\":3,\"1111\":3,\"1112\":3,\"1113\":3,\"1114\":1,\"1115\":2,\"1116\":3,\"1173\":2,\"1207\":3,\"1219\":4,\"1851\":2}}],[\"tfunc<t\",{\"1\":{\"370\":1}}],[\"tfunc\",{\"1\":{\"370\":1}}],[\"ty>\",{\"1\":{\"355\":1,\"984\":1,\"1127\":2,\"1188\":1}}],[\"ty\",{\"1\":{\"355\":2,\"984\":1,\"1127\":2,\"1148\":2,\"1197\":1}}],[\"type参数为1就可以了\",{\"1\":{\"1750\":1}}],[\"type都是\",{\"1\":{\"1618\":1}}],[\"type即为primary且只有一个\",{\"1\":{\"1618\":1}}],[\"type>\",{\"1\":{\"984\":1}}],[\"typec\",{\"1\":{\"832\":2}}],[\"typeinfo\",{\"1\":{\"614\":1}}],[\"typeid\",{\"0\":{\"956\":1},\"1\":{\"492\":2,\"563\":3,\"604\":2,\"621\":3,\"953\":2,\"1189\":5}}],[\"type\",{\"0\":{\"1320\":1},\"1\":{\"446\":1,\"520\":1,\"537\":2,\"538\":3,\"539\":4,\"540\":4,\"541\":1,\"542\":2,\"546\":18,\"628\":2,\"784\":1,\"957\":1,\"1080\":2,\"1082\":1,\"1194\":1,\"1310\":1,\"1320\":3,\"1521\":2,\"1618\":2,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1719\":3,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1,\"1902\":1,\"1903\":1,\"1907\":2}}],[\"typename告知编译器后面类型的作用域后面是类型\",{\"1\":{\"1147\":1}}],[\"typename\",{\"1\":{\"362\":1,\"378\":2,\"385\":1,\"704\":1,\"751\":2,\"981\":1,\"982\":1,\"989\":1,\"1082\":1,\"1087\":1,\"1127\":1,\"1147\":1,\"1148\":4,\"1158\":4,\"1188\":4,\"1189\":5,\"1194\":1}}],[\"typename是后来才添加了\",{\"1\":{\"360\":1}}],[\"types<\",{\"1\":{\"355\":1}}],[\"typedef\",{\"1\":{\"296\":1,\"494\":3,\"547\":1,\"894\":1,\"1025\":1,\"1080\":3,\"1081\":1,\"1188\":2}}],[\"typora使用了0号显卡\",{\"1\":{\"63\":1}}],[\"typoraclean\",{\"1\":{\"60\":2}}],[\"typora清理不用的图片\",{\"0\":{\"60\":1}}],[\"typora配置\",{\"0\":{\"43\":1},\"1\":{\"60\":1}}],[\"typora检测\",{\"1\":{\"29\":1}}],[\"typora中自动补全标签\",{\"1\":{\"29\":1}}],[\"typora\",{\"1\":{\"29\":3,\"44\":3,\"52\":1,\"59\":1,\"61\":1,\"63\":1,\"66\":1}}],[\"t>\",{\"1\":{\"355\":1,\"362\":1,\"365\":1,\"366\":1,\"368\":1,\"370\":2,\"377\":1,\"378\":1,\"385\":1,\"389\":1,\"530\":2,\"704\":1,\"751\":2,\"885\":1,\"980\":1,\"981\":2,\"982\":2,\"1041\":2,\"1047\":1,\"1055\":2,\"1060\":2,\"1080\":1,\"1087\":1,\"1127\":1,\"1148\":4,\"1186\":1,\"1188\":1,\"1189\":2}}],[\"trx\",{\"1\":{\"1656\":16,\"1681\":3,\"1682\":1}}],[\"transaction\",{\"1\":{\"1631\":4,\"1632\":1,\"1640\":2,\"1656\":2,\"1677\":2,\"1734\":1}}],[\"travel\",{\"1\":{\"301\":2}}],[\"tries=40\",{\"1\":{\"1256\":1}}],[\"tries增加重试次数\",{\"0\":{\"1256\":1},\"1\":{\"1256\":1}}],[\"triangle\",{\"1\":{\"898\":3}}],[\"tree\",{\"1\":{\"1244\":1,\"1245\":1,\"1280\":1}}],[\"tree常用命令\",{\"0\":{\"1243\":1,\"1245\":1}}],[\"tree插件\",{\"0\":{\"1138\":1}}],[\"try和catch必须成对出现\",{\"1\":{\"608\":1}}],[\"try和catch都是\",{\"1\":{\"599\":1}}],[\"try块中如果抛出异常\",{\"1\":{\"608\":1}}],[\"try\",{\"1\":{\"599\":17,\"600\":3,\"601\":10,\"602\":1,\"605\":2,\"606\":2,\"1102\":3}}],[\"tr\",{\"1\":{\"541\":1}}],[\"true为1\",{\"1\":{\"473\":1}}],[\"true和false是字面值\",{\"1\":{\"473\":1}}],[\"true\",{\"1\":{\"53\":1,\"54\":2,\"59\":15,\"146\":1,\"149\":1,\"152\":1,\"153\":1,\"154\":1,\"155\":1,\"158\":2,\"161\":1,\"162\":1,\"166\":1,\"174\":2,\"182\":1,\"188\":1,\"378\":2,\"473\":2,\"754\":1,\"755\":1,\"756\":2,\"817\":1,\"819\":1,\"821\":1,\"1081\":1,\"1233\":1,\"1839\":1,\"1847\":1,\"1849\":1,\"1856\":1,\"1875\":1,\"1878\":1,\"1891\":1}}],[\"tanp\",{\"1\":{\"1820\":1}}],[\"tanp|grep\",{\"1\":{\"1616\":1}}],[\"tap\",{\"1\":{\"1398\":1}}],[\"tab缩进等\",{\"1\":{\"1299\":1}}],[\"tabnew\",{\"1\":{\"1137\":1}}],[\"tab\",{\"0\":{\"1137\":1}}],[\"tabstop=4\",{\"1\":{\"1133\":1,\"1291\":1}}],[\"tables\",{\"1\":{\"1507\":1,\"1551\":1,\"1552\":1,\"1671\":1}}],[\"table\",{\"0\":{\"1600\":1},\"1\":{\"251\":1,\"572\":1,\"914\":1,\"1237\":1,\"1428\":2,\"1437\":1,\"1447\":3,\"1521\":1,\"1537\":3,\"1551\":3,\"1552\":19,\"1600\":1,\"1614\":5,\"1618\":1,\"1671\":2,\"1719\":1,\"1729\":1,\"1736\":1,\"1830\":2}}],[\"tar和\",{\"1\":{\"1263\":1}}],[\"tar的使用方法\",{\"0\":{\"1260\":1}}],[\"tar\",{\"1\":{\"1015\":2,\"1260\":11,\"1263\":2,\"1285\":2,\"1305\":3,\"1395\":1,\"1396\":2}}],[\"targets\",{\"1\":{\"1366\":6}}],[\"target\",{\"1\":{\"73\":2,\"84\":3,\"93\":3,\"94\":3,\"96\":7,\"97\":5,\"124\":1,\"125\":4,\"126\":5,\"140\":1,\"141\":3,\"142\":5,\"143\":5,\"812\":2,\"1315\":1,\"1316\":3,\"1322\":1,\"1365\":5}}],[\"tail\",{\"1\":{\"787\":3,\"819\":6,\"1253\":1}}],[\"tasks\",{\"1\":{\"1820\":1}}],[\"task\",{\"1\":{\"267\":1,\"1233\":2}}],[\"tag\",{\"1\":{\"45\":1}}],[\"t\",{\"0\":{\"1934\":1,\"1939\":1},\"1\":{\"61\":1,\"101\":5,\"166\":7,\"185\":1,\"191\":1,\"194\":6,\"214\":1,\"217\":2,\"239\":1,\"244\":1,\"248\":1,\"286\":1,\"355\":10,\"360\":2,\"362\":6,\"365\":2,\"366\":2,\"368\":2,\"370\":2,\"371\":5,\"372\":3,\"377\":1,\"378\":13,\"385\":23,\"388\":23,\"389\":4,\"422\":2,\"441\":2,\"470\":1,\"493\":2,\"501\":1,\"516\":12,\"518\":5,\"521\":1,\"526\":2,\"530\":9,\"535\":8,\"536\":2,\"547\":9,\"572\":8,\"704\":28,\"710\":2,\"747\":8,\"751\":7,\"782\":2,\"783\":3,\"791\":1,\"802\":1,\"857\":2,\"885\":1,\"980\":2,\"981\":7,\"982\":7,\"989\":3,\"1011\":2,\"1021\":2,\"1026\":2,\"1031\":1,\"1041\":6,\"1047\":1,\"1055\":6,\"1060\":2,\"1076\":5,\"1079\":4,\"1080\":11,\"1082\":3,\"1087\":11,\"1090\":25,\"1093\":2,\"1096\":2,\"1099\":1,\"1102\":11,\"1110\":4,\"1111\":1,\"1115\":6,\"1116\":2,\"1127\":29,\"1148\":5,\"1151\":4,\"1173\":3,\"1186\":3,\"1189\":8,\"1206\":2,\"1208\":2,\"1227\":2,\"1233\":2,\"1252\":3,\"1277\":1,\"1282\":1,\"1299\":1,\"1347\":1,\"1378\":1,\"1523\":4,\"1539\":6,\"1581\":2,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1738\":5,\"1740\":2,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1,\"1846\":2,\"1851\":6,\"1859\":2}}],[\"thus\",{\"1\":{\"1102\":1}}],[\"thunk\",{\"1\":{\"234\":2}}],[\"that\",{\"1\":{\"1102\":2}}],[\"thiscall\",{\"1\":{\"1189\":1}}],[\"this指针将正确的对象的地址传入析构函数中\",{\"1\":{\"715\":1}}],[\"this指针是不一样\",{\"1\":{\"440\":1}}],[\"this指针隐藏在\",{\"1\":{\"392\":1}}],[\"this指针指向本身\",{\"1\":{\"392\":1}}],[\"this指针\",{\"0\":{\"392\":1},\"1\":{\"1167\":1}}],[\"this\",{\"1\":{\"355\":3,\"385\":3,\"392\":4,\"405\":4,\"406\":3,\"440\":6,\"441\":2,\"459\":2,\"463\":1,\"464\":4,\"516\":1,\"548\":3,\"601\":5,\"662\":8,\"695\":4,\"699\":3,\"704\":3,\"731\":12,\"735\":1,\"736\":6,\"747\":5,\"848\":1,\"850\":1,\"851\":1,\"900\":1,\"908\":2,\"925\":1,\"1032\":16,\"1050\":3,\"1055\":3,\"1082\":1,\"1102\":1,\"1110\":1,\"1120\":3,\"1121\":3,\"1123\":6,\"1127\":1,\"1151\":1,\"1172\":1,\"1207\":4,\"1208\":1,\"1209\":3,\"1210\":1,\"1219\":4,\"1233\":2,\"1849\":3,\"1859\":3,\"1875\":1}}],[\"thing\",{\"1\":{\"277\":1}}],[\"thinkphp\",{\"1\":{\"0\":1}}],[\"thompson\",{\"1\":{\"301\":4}}],[\"three\",{\"1\":{\"1362\":2}}],[\"threesum\",{\"1\":{\"133\":1,\"137\":1}}],[\"thread>\",{\"1\":{\"1208\":1,\"1233\":1}}],[\"thread模拟车站三个窗口买票的程序\",{\"1\":{\"1208\":1}}],[\"thread2\",{\"1\":{\"1207\":1}}],[\"thread是namespace\",{\"1\":{\"1207\":1}}],[\"threadhandle2\",{\"1\":{\"1207\":2}}],[\"threadhandle1\",{\"1\":{\"1207\":2}}],[\"thread1\",{\"1\":{\"1207\":1}}],[\"thread1会永远运行在main\",{\"1\":{\"1206\":1}}],[\"thread之前的\",{\"1\":{\"1206\":1}}],[\"thread定义一个线程对象\",{\"1\":{\"1204\":1}}],[\"threadpool\",{\"1\":{\"1151\":4}}],[\"threads\",{\"1\":{\"1076\":1,\"1079\":1,\"1081\":4,\"1082\":11,\"1090\":1,\"1096\":1,\"1099\":2,\"1102\":2}}],[\"thread\",{\"1\":{\"493\":1,\"1050\":5,\"1151\":7,\"1202\":2,\"1207\":6,\"1208\":3,\"1209\":3,\"1210\":1,\"1219\":8,\"1233\":4,\"1848\":1,\"1849\":4,\"1851\":4,\"1859\":6,\"1875\":3}}],[\"throw后的语句不执行\",{\"1\":{\"608\":1}}],[\"throw+表达式\",{\"1\":{\"600\":1}}],[\"throw表达式\",{\"0\":{\"600\":1}}],[\"throw\",{\"1\":{\"101\":1,\"182\":1,\"224\":2,\"599\":1,\"600\":3,\"601\":4,\"602\":1,\"605\":2,\"606\":3,\"607\":5,\"704\":1,\"710\":2,\"736\":1,\"747\":4,\"1102\":2,\"1105\":1,\"1127\":1}}],[\"through\",{\"1\":{\"50\":2}}],[\"them\",{\"1\":{\"1143\":1}}],[\"the\",{\"0\":{\"1407\":1},\"1\":{\"51\":2,\"185\":2,\"388\":2,\"494\":2,\"600\":1,\"751\":1,\"1031\":15,\"1080\":1,\"1082\":4,\"1102\":3,\"1127\":1,\"1240\":1,\"1252\":1,\"1407\":1}}],[\"tim\",{\"1\":{\"1735\":1}}],[\"timeout退出wait\",{\"1\":{\"1871\":1}}],[\"timeout和no\",{\"1\":{\"1871\":1}}],[\"timeout是10\",{\"1\":{\"1754\":1}}],[\"timeout为1800\",{\"1\":{\"1754\":1}}],[\"timeout\",{\"1\":{\"1754\":3,\"1849\":1,\"1859\":1,\"1871\":2,\"1872\":1}}],[\"time只影响当前session\",{\"1\":{\"1578\":1}}],[\"time=0\",{\"1\":{\"1578\":1,\"1579\":1}}],[\"timers\",{\"1\":{\"1237\":1}}],[\"time\",{\"0\":{\"1578\":1},\"1\":{\"59\":2,\"70\":1,\"101\":3,\"188\":2,\"191\":2,\"239\":2,\"751\":1,\"817\":1,\"819\":1,\"957\":1,\"1147\":1,\"1148\":1,\"1207\":4,\"1238\":1,\"1240\":1,\"1537\":3,\"1574\":1,\"1577\":1,\"1776\":1}}],[\"timestamp\",{\"1\":{\"1427\":1,\"1443\":3,\"1845\":1,\"1856\":1}}],[\"times\",{\"1\":{\"49\":1}}],[\"tinyint\",{\"1\":{\"1422\":1,\"1437\":1,\"1537\":2,\"1551\":1}}],[\"tickecount\",{\"1\":{\"1208\":1}}],[\"ticketcount\",{\"1\":{\"1208\":4,\"1209\":16,\"1210\":5}}],[\"ticketmovie\",{\"1\":{\"830\":4}}],[\"title\",{\"1\":{\"45\":1}}],[\"total\",{\"1\":{\"1102\":8,\"1271\":3}}],[\"totalprice\",{\"1\":{\"435\":4,\"439\":4}}],[\"tool\",{\"0\":{\"1285\":1}}],[\"tools的扩展设置\",{\"1\":{\"1306\":1}}],[\"tools压缩文件\",{\"1\":{\"1285\":1}}],[\"tools选项\",{\"1\":{\"1285\":1}}],[\"tools\",{\"1\":{\"1280\":1,\"1285\":1,\"1306\":1}}],[\"tool=memcheck\",{\"1\":{\"1035\":1}}],[\"too\",{\"1\":{\"1082\":1}}],[\"tom\",{\"1\":{\"494\":1,\"1733\":2,\"1734\":1,\"1735\":2}}],[\"tolowercase\",{\"1\":{\"59\":8}}],[\"toc\",{\"1\":{\"51\":23}}],[\"topelement\",{\"1\":{\"59\":7}}],[\"top\",{\"1\":{\"51\":1,\"59\":8,\"182\":5,\"224\":17,\"388\":10,\"784\":1,\"984\":1,\"989\":1,\"990\":2,\"992\":2}}],[\"to\",{\"0\":{\"1295\":1},\"1\":{\"41\":1,\"49\":1,\"59\":3,\"182\":1,\"191\":2,\"485\":1,\"488\":1,\"497\":2,\"503\":1,\"600\":1,\"826\":1,\"1080\":1,\"1082\":2,\"1102\":13,\"1143\":1,\"1240\":1,\"1253\":1,\"1328\":2,\"1335\":1,\"1361\":1,\"1408\":1,\"1447\":4,\"1485\":1,\"1640\":1,\"1799\":2,\"1821\":1,\"1825\":1,\"1828\":1,\"1829\":1,\"1833\":1,\"1902\":1,\"1903\":1,\"1907\":2}}],[\"telnet\",{\"1\":{\"1828\":1}}],[\"tee\",{\"1\":{\"1410\":2}}],[\"tends\",{\"1\":{\"1102\":1}}],[\"test6\",{\"1\":{\"1909\":2}}],[\"testdb\",{\"1\":{\"1384\":1,\"1385\":1}}],[\"testlambda02<>\",{\"1\":{\"1173\":1}}],[\"testlambda02\",{\"1\":{\"1173\":2}}],[\"testlambda03\",{\"1\":{\"1173\":2}}],[\"testlambda01<>\",{\"1\":{\"1173\":1}}],[\"testlambda01\",{\"1\":{\"1173\":1}}],[\"testlambda\",{\"1\":{\"1173\":1}}],[\"testa\",{\"1\":{\"1057\":2}}],[\"test0\",{\"1\":{\"535\":1,\"612\":1,\"717\":1}}],[\"test5\",{\"1\":{\"440\":1,\"1908\":2}}],[\"test4\",{\"1\":{\"439\":1,\"618\":2,\"1907\":2}}],[\"test1\",{\"1\":{\"388\":1,\"522\":1,\"536\":1,\"718\":1,\"1026\":1,\"1902\":1,\"1903\":1}}],[\"test3\",{\"1\":{\"378\":2,\"459\":2,\"515\":1,\"524\":1,\"618\":1,\"633\":2,\"1031\":1,\"1905\":1}}],[\"test2\",{\"1\":{\"378\":2,\"459\":1,\"497\":2,\"515\":1,\"523\":1,\"547\":2,\"618\":1,\"633\":1,\"1026\":1,\"1031\":2,\"1271\":2,\"1904\":1}}],[\"test\",{\"1\":{\"240\":2,\"312\":1,\"371\":1,\"372\":1,\"378\":2,\"382\":3,\"385\":8,\"388\":1,\"389\":1,\"410\":4,\"411\":3,\"412\":4,\"413\":5,\"414\":5,\"415\":1,\"422\":3,\"459\":2,\"476\":6,\"497\":1,\"515\":1,\"517\":7,\"547\":1,\"567\":2,\"568\":5,\"569\":2,\"570\":2,\"575\":2,\"576\":2,\"577\":1,\"601\":2,\"602\":2,\"616\":1,\"618\":1,\"633\":1,\"652\":1,\"669\":1,\"670\":1,\"672\":1,\"678\":1,\"714\":11,\"890\":1,\"891\":1,\"900\":1,\"913\":3,\"943\":1,\"949\":1,\"1018\":6,\"1019\":1,\"1031\":2,\"1032\":4,\"1035\":1,\"1041\":2,\"1110\":15,\"1111\":9,\"1112\":8,\"1113\":11,\"1114\":47,\"1115\":18,\"1116\":6,\"1154\":3,\"1167\":7,\"1189\":4,\"1260\":1,\"1271\":6,\"1287\":1,\"1322\":1,\"1383\":1,\"1733\":4,\"1734\":3,\"1735\":8,\"1848\":2,\"1875\":2,\"1915\":1}}],[\"terminated\",{\"1\":{\"234\":1,\"1729\":2}}],[\"temporary\",{\"1\":{\"1736\":1}}],[\"tempalte<typename\",{\"1\":{\"1189\":1}}],[\"temp\",{\"1\":{\"73\":2,\"101\":4,\"107\":2,\"234\":6,\"238\":3,\"615\":4,\"616\":4,\"618\":9,\"620\":2,\"756\":3,\"759\":3,\"774\":7,\"777\":6,\"795\":2,\"802\":3,\"819\":3,\"848\":2,\"849\":2,\"1271\":3}}],[\"template后面的<>什么参数都没有\",{\"1\":{\"1187\":1}}],[\"template<\",{\"1\":{\"1081\":1,\"1082\":6,\"1099\":1,\"1102\":2}}],[\"template<0>\",{\"1\":{\"1080\":1}}],[\"template<threads\",{\"1\":{\"1076\":1}}],[\"template<typename\",{\"1\":{\"365\":1,\"366\":1,\"368\":1,\"376\":1,\"377\":1,\"751\":2,\"885\":1,\"980\":1,\"981\":3,\"982\":3,\"989\":1,\"1041\":2,\"1047\":1,\"1055\":2,\"1060\":2,\"1127\":3,\"1147\":1,\"1148\":4,\"1158\":4,\"1173\":3,\"1186\":1,\"1188\":4,\"1189\":2}}],[\"template<>中为空\",{\"1\":{\"368\":1}}],[\"template<>\",{\"1\":{\"366\":1,\"368\":1,\"1187\":1,\"1188\":1}}],[\"template<class\",{\"1\":{\"355\":1,\"389\":1,\"530\":2,\"984\":1,\"985\":1}}],[\"template\",{\"1\":{\"6\":1,\"45\":1,\"355\":1,\"360\":2,\"362\":3,\"365\":1,\"366\":1,\"368\":1,\"370\":2,\"371\":1,\"372\":1,\"378\":4,\"385\":2,\"388\":7,\"389\":1,\"704\":2,\"963\":1,\"1007\":1,\"1076\":1,\"1079\":5,\"1080\":4,\"1081\":2,\"1082\":6,\"1086\":6,\"1087\":2,\"1090\":2,\"1096\":2,\"1099\":1,\"1102\":3,\"1127\":1,\"1186\":1,\"1188\":1,\"1189\":1}}],[\"text=一般用法\",{\"1\":{\"1878\":1}}],[\"text类型评论发送不了全文\",{\"1\":{\"1423\":1}}],[\"text或\",{\"1\":{\"255\":2}}],[\"text段\",{\"0\":{\"253\":1},\"1\":{\"234\":1,\"267\":1}}],[\"textcontent=e\",{\"1\":{\"61\":1}}],[\"text\",{\"1\":{\"29\":5,\"48\":3,\"49\":1,\"50\":9,\"51\":1,\"60\":2,\"246\":2,\"251\":1,\"255\":2,\"257\":1,\"262\":1,\"263\":2,\"271\":1,\"392\":1,\"570\":1,\"572\":1,\"1082\":1,\"1361\":5,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1}}],[\"tcpdump\",{\"1\":{\"1238\":1}}],[\"tcp|awk\",{\"1\":{\"1238\":1}}],[\"tcp\",{\"1\":{\"22\":1,\"1237\":1,\"1238\":1,\"1239\":1,\"1818\":1,\"1820\":2}}],[\"tcp还有拥塞控制和流量控制\",{\"1\":{\"22\":1}}],[\"tcp的数据大小如果大于mss大小\",{\"1\":{\"22\":1}}],[\"tcp提供的控制首先就是可靠传输\",{\"1\":{\"22\":1}}],[\"tcp和udp的区别\",{\"0\":{\"22\":1}}],[\"2c\",{\"1\":{\"1878\":2}}],[\"2c5c6dfa9716\",{\"1\":{\"597\":1}}],[\"2内连接查询\",{\"0\":{\"1501\":1}}],[\"2nf\",{\"0\":{\"1461\":1}}],[\"250\",{\"1\":{\"1851\":2}}],[\"25\",{\"1\":{\"1511\":1}}],[\"255\",{\"1\":{\"1278\":3,\"1828\":1}}],[\"256\",{\"1\":{\"191\":1}}],[\"2月\",{\"1\":{\"1271\":11}}],[\"2把mtx互斥锁释放掉\",{\"1\":{\"1219\":1}}],[\"2单重映射表与多重映射表\",{\"0\":{\"1000\":1}}],[\"2倍的方式进行扩容\",{\"1\":{\"973\":1,\"974\":1}}],[\"2使用方式\",{\"0\":{\"969\":1}}],[\"2使用实例\",{\"0\":{\"966\":1}}],[\"2输出结果\",{\"1\":{\"908\":1}}],[\"2感兴趣\",{\"1\":{\"871\":1}}],[\"28h\",{\"1\":{\"638\":1}}],[\"28\",{\"1\":{\"557\":1,\"1271\":1}}],[\"24字节的内存块\",{\"1\":{\"1082\":1}}],[\"24\",{\"1\":{\"557\":2,\"1090\":1,\"1774\":1}}],[\"2447f7ce\",{\"1\":{\"500\":1}}],[\"242\",{\"0\":{\"166\":1},\"1\":{\"166\":1}}],[\"2+2\",{\"1\":{\"339\":1}}],[\"2+1\",{\"1\":{\"97\":1}}],[\"23\",{\"0\":{\"780\":1},\"1\":{\"780\":1,\"1032\":8,\"1384\":1,\"1395\":1,\"1688\":2}}],[\"234\",{\"0\":{\"754\":1},\"1\":{\"754\":1}}],[\"234567e10\",{\"1\":{\"340\":1}}],[\"23456788e10\",{\"1\":{\"340\":1}}],[\"234567892e10\",{\"1\":{\"340\":1}}],[\"23456789e10\",{\"1\":{\"340\":1}}],[\"23空出来\",{\"1\":{\"557\":1}}],[\"23位的小数部分\",{\"1\":{\"339\":1}}],[\"232\",{\"0\":{\"182\":1},\"1\":{\"182\":1}}],[\"29\",{\"1\":{\"214\":1,\"1305\":4,\"1322\":1}}],[\"2的⼦序列\",{\"1\":{\"202\":1}}],[\"26\",{\"1\":{\"166\":2,\"174\":1}}],[\"216\",{\"1\":{\"1818\":2}}],[\"21都被阻塞了\",{\"1\":{\"1693\":1}}],[\"21这又是什么鬼\",{\"1\":{\"1239\":1}}],[\"21存在\",{\"1\":{\"1007\":2}}],[\"21\",{\"0\":{\"762\":1},\"1\":{\"202\":2,\"214\":1,\"234\":1,\"557\":1,\"762\":1,\"817\":4,\"1007\":4,\"1008\":1,\"1271\":11,\"1415\":2,\"1475\":1,\"1511\":1,\"1515\":2,\"1537\":1}}],[\"219\",{\"0\":{\"158\":1},\"1\":{\"158\":1}}],[\"217\",{\"0\":{\"152\":1},\"1\":{\"152\":1}}],[\"211\",{\"1\":{\"0\":1}}],[\"2^31\",{\"1\":{\"147\":1}}],[\"222\",{\"1\":{\"459\":1,\"497\":1,\"547\":1}}],[\"220\",{\"0\":{\"161\":1},\"1\":{\"161\":1}}],[\"22\",{\"1\":{\"101\":4,\"214\":2,\"234\":1,\"1284\":1,\"1285\":1,\"1475\":3,\"1537\":1,\"1688\":2,\"1818\":1}}],[\"2713\",{\"1\":{\"1296\":2}}],[\"2708\",{\"1\":{\"1296\":2}}],[\"27为空\",{\"1\":{\"557\":1}}],[\"27\",{\"0\":{\"76\":1},\"1\":{\"76\":1,\"1796\":1}}],[\"204\",{\"1\":{\"1255\":1}}],[\"2061\",{\"1\":{\"1828\":2}}],[\"206\",{\"0\":{\"777\":1},\"1\":{\"777\":1}}],[\"203\",{\"0\":{\"759\":1},\"1\":{\"759\":1}}],[\"20=40是错误的\",{\"1\":{\"620\":1}}],[\"2013安装目录>\",{\"1\":{\"312\":1}}],[\"2001\",{\"1\":{\"1299\":2}}],[\"2000的事务2的id\",{\"1\":{\"1665\":1}}],[\"2000w数据\",{\"1\":{\"1622\":1}}],[\"2000\",{\"1\":{\"1000\":1,\"1415\":3}}],[\"2000010\",{\"1\":{\"1740\":1}}],[\"2000000\",{\"1\":{\"1523\":1,\"1740\":4}}],[\"20000\",{\"1\":{\"487\":1,\"497\":1}}],[\"200k\",{\"1\":{\"284\":1}}],[\"200\",{\"1\":{\"129\":1,\"497\":1,\"594\":1,\"618\":3,\"633\":2,\"747\":4,\"819\":3,\"894\":1,\"1025\":1,\"1155\":1,\"1166\":1}}],[\"20\",{\"1\":{\"104\":1,\"107\":2,\"110\":1,\"191\":1,\"234\":3,\"236\":1,\"239\":2,\"246\":2,\"365\":2,\"368\":3,\"406\":1,\"411\":1,\"449\":1,\"450\":2,\"480\":1,\"483\":2,\"484\":6,\"488\":1,\"489\":2,\"497\":2,\"511\":1,\"557\":1,\"563\":2,\"567\":1,\"568\":1,\"569\":1,\"570\":1,\"575\":1,\"592\":2,\"594\":2,\"614\":1,\"620\":1,\"621\":3,\"622\":1,\"638\":2,\"639\":2,\"667\":1,\"678\":1,\"731\":1,\"821\":2,\"884\":2,\"885\":2,\"894\":1,\"900\":4,\"906\":1,\"943\":1,\"953\":1,\"954\":1,\"966\":3,\"980\":1,\"981\":2,\"982\":2,\"999\":5,\"1001\":2,\"1002\":1,\"1041\":1,\"1045\":1,\"1050\":1,\"1082\":1,\"1099\":1,\"1102\":2,\"1110\":3,\"1111\":3,\"1112\":1,\"1113\":1,\"1114\":2,\"1115\":1,\"1147\":1,\"1148\":1,\"1154\":2,\"1158\":1,\"1165\":1,\"1173\":2,\"1174\":1,\"1175\":1,\"1177\":1,\"1183\":2,\"1186\":1,\"1188\":2,\"1238\":1,\"1271\":7,\"1415\":2,\"1428\":1,\"1515\":2,\"1537\":1,\"1592\":3,\"1614\":4,\"1660\":1,\"1663\":1,\"1665\":2,\"1673\":1,\"1681\":3,\"1682\":3,\"1758\":1,\"1759\":1,\"1767\":1,\"1772\":1,\"1773\":2,\"1774\":1,\"1776\":1,\"1901\":1}}],[\"209\",{\"0\":{\"73\":1},\"1\":{\"73\":1}}],[\"2022\",{\"1\":{\"1773\":2,\"1774\":1,\"1820\":1}}],[\"2021\",{\"1\":{\"1537\":12,\"1774\":1}}],[\"2024\",{\"1\":{\"1032\":8}}],[\"20240305235207200\",{\"1\":{\"1410\":1}}],[\"20240305232611466\",{\"1\":{\"1402\":1}}],[\"20240305232223229\",{\"1\":{\"1401\":1}}],[\"20240310234105841\",{\"1\":{\"1367\":1}}],[\"20240310142108995\",{\"1\":{\"1339\":1}}],[\"20240310141436371\",{\"1\":{\"1338\":1}}],[\"20240310141538480\",{\"1\":{\"1338\":1}}],[\"20240310173458700\",{\"1\":{\"1332\":1}}],[\"20240310154324639\",{\"1\":{\"1327\":1}}],[\"20240310133845350\",{\"1\":{\"261\":1}}],[\"20240311104103732\",{\"1\":{\"1260\":1}}],[\"20240315130939110\",{\"1\":{\"22\":1}}],[\"20240315130548521\",{\"1\":{\"22\":1}}],[\"20240312103817142\",{\"1\":{\"16\":1}}],[\"20240210160207328\",{\"1\":{\"1287\":1}}],[\"20240210155930348\",{\"1\":{\"1287\":1}}],[\"20240209194830447\",{\"1\":{\"1391\":1}}],[\"20240209211620696\",{\"1\":{\"1277\":1}}],[\"20240209211150556\",{\"1\":{\"1276\":1}}],[\"20240202162644415\",{\"1\":{\"621\":1}}],[\"20240202155647969\",{\"1\":{\"614\":1}}],[\"20240202222822996\",{\"1\":{\"516\":1}}],[\"20240201150931334\",{\"1\":{\"570\":1}}],[\"20240408210426812\",{\"1\":{\"1878\":1}}],[\"20240407114100091\",{\"1\":{\"1551\":1}}],[\"20240407162501541\",{\"1\":{\"1515\":1}}],[\"20240407131732168\",{\"1\":{\"1475\":1}}],[\"20240407090705269\",{\"1\":{\"1464\":1}}],[\"20240407090151306\",{\"1\":{\"1464\":1}}],[\"20240407090807653\",{\"1\":{\"1461\":1}}],[\"20240407085829027\",{\"1\":{\"1463\":1}}],[\"20240407084815669\",{\"1\":{\"1462\":1}}],[\"20240406210040984\",{\"1\":{\"1471\":1}}],[\"20240406210021446\",{\"1\":{\"1470\":1}}],[\"20240406210003709\",{\"1\":{\"1469\":1}}],[\"20240406214640176\",{\"1\":{\"1437\":1}}],[\"20240406204703570\",{\"1\":{\"1427\":1}}],[\"20240406204601492\",{\"1\":{\"1425\":1}}],[\"20240406204529908\",{\"1\":{\"1421\":1}}],[\"20240404110003096\",{\"1\":{\"1417\":1}}],[\"20240404103955415\",{\"1\":{\"1417\":1}}],[\"20240404103638709\",{\"1\":{\"1416\":1}}],[\"20240409142125992\",{\"1\":{\"40\":1}}],[\"20240409142046712\",{\"1\":{\"39\":1}}],[\"20240409142503015\",{\"1\":{\"35\":1}}],[\"20240409141923954\",{\"1\":{\"38\":1}}],[\"20240409140346944\",{\"1\":{\"38\":1}}],[\"20240409140210893\",{\"1\":{\"36\":1}}],[\"20240421225335827\",{\"1\":{\"1818\":1}}],[\"20240421115737534\",{\"1\":{\"1775\":1}}],[\"20240421114020759\",{\"1\":{\"1770\":1}}],[\"20240421114121369\",{\"1\":{\"1770\":1}}],[\"20240421015016270\",{\"1\":{\"1774\":1}}],[\"20240421014049849\",{\"1\":{\"1768\":1}}],[\"20240420132938427\",{\"1\":{\"1677\":1}}],[\"20240420193947369\",{\"1\":{\"1668\":2}}],[\"20240420160437173\",{\"1\":{\"1658\":1}}],[\"20240427160328925\",{\"1\":{\"1220\":1}}],[\"20240429164446966\",{\"1\":{\"1085\":1}}],[\"20240428143246759\",{\"1\":{\"868\":1}}],[\"20240419231953567\",{\"1\":{\"1689\":1}}],[\"20240419183553280\",{\"1\":{\"1712\":1}}],[\"20240419150312478\",{\"1\":{\"1677\":1}}],[\"20240419155523434\",{\"1\":{\"1633\":1}}],[\"20240419161539787\",{\"1\":{\"1635\":1}}],[\"20240418223534192\",{\"1\":{\"1592\":1}}],[\"20240418220258482\",{\"1\":{\"1589\":1}}],[\"20240418162100913\",{\"1\":{\"1563\":1}}],[\"20240417192441961\",{\"1\":{\"1559\":1}}],[\"20240416170741355\",{\"1\":{\"1529\":1}}],[\"20240416155709023\",{\"1\":{\"1525\":1}}],[\"20240416140713583\",{\"1\":{\"1521\":1}}],[\"20240416141102785\",{\"1\":{\"1521\":1}}],[\"20240413094600216\",{\"1\":{\"1477\":1}}],[\"20240413100255722\",{\"1\":{\"1896\":1}}],[\"20240413175814411\",{\"1\":{\"715\":1}}],[\"20240413153213559\",{\"1\":{\"657\":1}}],[\"20240412143331454\",{\"1\":{\"1306\":1}}],[\"20240412142839918\",{\"1\":{\"1305\":1}}],[\"20240412134918477\",{\"1\":{\"1306\":1}}],[\"20240415111605527\",{\"1\":{\"938\":1}}],[\"20240410192158623\",{\"1\":{\"751\":1}}],[\"20240410165523682\",{\"1\":{\"698\":1}}],[\"20240414114736980\",{\"1\":{\"678\":1}}],[\"20240411203054816\",{\"1\":{\"1016\":1}}],[\"20240411204413778\",{\"1\":{\"1015\":1}}],[\"20240411204317307\",{\"1\":{\"1015\":1}}],[\"20240411091801938\",{\"1\":{\"406\":1}}],[\"20240411151958707\",{\"1\":{\"369\":1}}],[\"20240411140728256\",{\"1\":{\"364\":1}}],[\"20240101150131801\",{\"1\":{\"581\":1}}],[\"20240131011722928\",{\"1\":{\"252\":1}}],[\"20240131004256680\",{\"1\":{\"251\":1}}],[\"20240130222426316\",{\"1\":{\"249\":1}}],[\"20240130204306887\",{\"1\":{\"239\":1}}],[\"20240130203609288\",{\"1\":{\"238\":1}}],[\"20240130153420171\",{\"1\":{\"267\":1}}],[\"20240130150034776\",{\"1\":{\"267\":1}}],[\"20240130155845449\",{\"1\":{\"233\":1}}],[\"20240130155633380\",{\"1\":{\"232\":1}}],[\"20240130183016130\",{\"1\":{\"238\":1}}],[\"20240130182849062\",{\"1\":{\"237\":1}}],[\"20240130182232318\",{\"1\":{\"236\":1}}],[\"20240130173737985\",{\"1\":{\"234\":1}}],[\"20240113171317370\",{\"1\":{\"774\":1}}],[\"20240115123654224\",{\"1\":{\"46\":1}}],[\"20240115124252212\",{\"1\":{\"5\":1}}],[\"20240115124235596\",{\"1\":{\"5\":1}}],[\"20240114222645084\",{\"1\":{\"45\":1}}],[\"20231230134403043\",{\"1\":{\"349\":1}}],[\"20231230130126412\",{\"1\":{\"323\":1}}],[\"20231230174224741\",{\"1\":{\"340\":1}}],[\"20231230175541124\",{\"1\":{\"340\":1}}],[\"20231230175233568\",{\"1\":{\"340\":1}}],[\"20231230175132311\",{\"1\":{\"340\":1}}],[\"20231230175915108\",{\"1\":{\"320\":1}}],[\"20231230164803584\",{\"1\":{\"339\":1}}],[\"20231230142228229\",{\"1\":{\"346\":1}}],[\"20231230145335308\",{\"1\":{\"334\":1}}],[\"20231230144954359\",{\"1\":{\"333\":1}}],[\"20231230144838893\",{\"1\":{\"331\":1}}],[\"20231230144015991\",{\"1\":{\"293\":1}}],[\"20231230140401166\",{\"1\":{\"329\":1}}],[\"20231230124538132\",{\"1\":{\"326\":1}}],[\"20231230120138838\",{\"1\":{\"308\":1}}],[\"20231230104904001\",{\"1\":{\"312\":1}}],[\"20231230103243664\",{\"1\":{\"243\":1,\"310\":1}}],[\"20231230111622514\",{\"1\":{\"311\":1}}],[\"20231230111457047\",{\"1\":{\"311\":1}}],[\"20231230115745742\",{\"1\":{\"308\":1}}],[\"20231217144250890\",{\"1\":{\"61\":1}}],[\"202\",{\"0\":{\"146\":1},\"1\":{\"146\":1,\"1278\":1}}],[\"2020\",{\"1\":{\"45\":1}}],[\"2rem\",{\"1\":{\"51\":1}}],[\"2px\",{\"1\":{\"48\":1,\"49\":1}}],[\"2\",{\"0\":{\"831\":1,\"863\":1,\"865\":1,\"866\":1,\"968\":1,\"969\":1,\"1042\":1,\"1043\":1,\"1046\":2,\"1047\":1,\"1115\":1,\"1182\":1,\"1195\":1,\"1203\":1,\"1205\":1,\"1218\":1,\"1219\":1,\"1226\":1,\"1373\":1,\"1486\":1,\"1491\":1,\"1495\":1,\"1578\":1,\"1659\":1,\"1663\":1,\"1680\":1,\"1693\":1,\"1730\":1,\"1734\":1,\"1774\":1,\"1798\":1,\"1803\":1,\"1806\":1,\"1809\":1,\"1812\":1,\"1821\":1,\"1825\":1,\"1829\":1,\"1889\":1,\"1892\":1,\"1898\":1,\"1899\":2,\"1900\":1,\"1904\":1,\"1908\":1},\"1\":{\"22\":1,\"29\":3,\"50\":2,\"51\":1,\"53\":2,\"54\":1,\"59\":3,\"67\":1,\"70\":1,\"78\":1,\"81\":4,\"84\":1,\"91\":1,\"93\":1,\"94\":1,\"95\":5,\"96\":2,\"97\":1,\"101\":6,\"104\":8,\"107\":7,\"110\":5,\"113\":1,\"114\":1,\"118\":2,\"121\":1,\"129\":4,\"133\":1,\"135\":3,\"140\":1,\"142\":1,\"161\":1,\"163\":1,\"169\":6,\"177\":6,\"178\":1,\"182\":2,\"185\":1,\"194\":4,\"199\":3,\"202\":2,\"205\":1,\"224\":1,\"240\":2,\"244\":1,\"283\":2,\"306\":1,\"323\":1,\"339\":1,\"345\":1,\"355\":2,\"372\":2,\"378\":17,\"385\":3,\"389\":1,\"395\":1,\"406\":2,\"433\":1,\"434\":1,\"454\":1,\"455\":1,\"458\":8,\"459\":11,\"463\":3,\"464\":1,\"487\":1,\"494\":1,\"497\":1,\"512\":1,\"515\":4,\"535\":2,\"547\":1,\"548\":1,\"553\":3,\"557\":1,\"578\":1,\"594\":1,\"599\":1,\"601\":2,\"618\":1,\"639\":1,\"658\":1,\"672\":1,\"695\":6,\"704\":3,\"721\":1,\"730\":1,\"731\":2,\"736\":1,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":6,\"755\":1,\"756\":1,\"783\":1,\"792\":1,\"795\":1,\"802\":2,\"810\":4,\"819\":2,\"830\":1,\"854\":2,\"856\":1,\"857\":1,\"871\":6,\"875\":1,\"889\":1,\"891\":2,\"894\":2,\"898\":1,\"900\":1,\"908\":1,\"965\":1,\"966\":3,\"968\":2,\"969\":1,\"970\":1,\"973\":2,\"974\":1,\"990\":1,\"991\":1,\"992\":1,\"1007\":1,\"1011\":1,\"1041\":1,\"1050\":2,\"1056\":2,\"1090\":1,\"1102\":3,\"1114\":4,\"1115\":1,\"1127\":2,\"1155\":2,\"1168\":3,\"1179\":1,\"1188\":1,\"1207\":1,\"1219\":1,\"1227\":1,\"1238\":1,\"1239\":1,\"1240\":2,\"1271\":6,\"1299\":2,\"1305\":4,\"1310\":1,\"1312\":3,\"1314\":1,\"1315\":2,\"1316\":1,\"1317\":1,\"1318\":2,\"1321\":1,\"1367\":1,\"1507\":1,\"1516\":2,\"1531\":1,\"1537\":6,\"1538\":1,\"1552\":1,\"1615\":1,\"1622\":2,\"1686\":1,\"1719\":2,\"1733\":2,\"1734\":1,\"1735\":2,\"1736\":5,\"1773\":1,\"1803\":2,\"1851\":1,\"1891\":1,\"1902\":1,\"1903\":1,\"1904\":2,\"1905\":2,\"1907\":1,\"1908\":1,\"1909\":2,\"1914\":1,\"1915\":3}}],[\"i=i+1\",{\"1\":{\"1523\":1}}],[\"i=0\",{\"1\":{\"355\":4,\"385\":3,\"704\":5,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":6,\"966\":8,\"984\":1,\"985\":1,\"990\":1,\"991\":1,\"992\":1,\"999\":3,\"1001\":2,\"1002\":1,\"1011\":2,\"1523\":1,\"1622\":1}}],[\"i+1\",{\"1\":{\"1523\":2}}],[\"i++\",{\"1\":{\"67\":1,\"70\":1,\"355\":1,\"494\":1,\"966\":5,\"1001\":2,\"1002\":1,\"1011\":2,\"1099\":1,\"1127\":4,\"1385\":1,\"1622\":1,\"1851\":2}}],[\"ignore\",{\"1\":{\"1340\":1}}],[\"i下载\",{\"1\":{\"1250\":1}}],[\"ip=127\",{\"1\":{\"1844\":1,\"1878\":1}}],[\"ip\",{\"1\":{\"1238\":2,\"1839\":4,\"1846\":1,\"1847\":2,\"1848\":1,\"1849\":4,\"1856\":3,\"1859\":3,\"1875\":5,\"1878\":1}}],[\"ip或\",{\"1\":{\"1237\":1}}],[\"i或\",{\"1\":{\"1237\":1}}],[\"i块出去\",{\"1\":{\"1102\":1}}],[\"i大小的chunk应该在\",{\"1\":{\"1102\":1}}],[\"i从\",{\"1\":{\"1102\":1}}],[\"i从1开始\",{\"1\":{\"1099\":1}}],[\"i为\",{\"1\":{\"1099\":1}}],[\"i都加1\",{\"1\":{\"1099\":1}}],[\"ic\",{\"1\":{\"891\":4,\"943\":6}}],[\"icon\",{\"1\":{\"45\":1}}],[\"it=set1\",{\"1\":{\"1002\":1}}],[\"it2\",{\"1\":{\"747\":4,\"966\":10,\"1008\":2}}],[\"it1++\",{\"1\":{\"1011\":1}}],[\"it1=set1\",{\"1\":{\"999\":1}}],[\"it1=vec\",{\"1\":{\"966\":1}}],[\"it1\",{\"1\":{\"747\":4,\"966\":17,\"999\":10,\"1000\":4,\"1011\":9,\"1148\":4}}],[\"itb\",{\"1\":{\"747\":2}}],[\"it迭代器指向容器的首元素\",{\"1\":{\"698\":1}}],[\"it\",{\"1\":{\"698\":3,\"699\":6,\"700\":2,\"704\":6,\"742\":6,\"743\":5,\"745\":7,\"746\":6,\"747\":45,\"871\":6,\"999\":1,\"1001\":8,\"1002\":7,\"1007\":2,\"1082\":1,\"1102\":2,\"1147\":3,\"1148\":3,\"1168\":3,\"1178\":3,\"1909\":3}}],[\"itempool\",{\"1\":{\"751\":11}}],[\"item\",{\"1\":{\"751\":7,\"1740\":4}}],[\"item>\",{\"1\":{\"51\":5}}],[\"iterator派生类\",{\"1\":{\"1011\":1}}],[\"iterator底层原理\",{\"1\":{\"1011\":1}}],[\"iterator自己搜索\",{\"1\":{\"999\":1}}],[\"iterator就失效了\",{\"1\":{\"743\":1}}],[\"iterator即容器的迭代器\",{\"1\":{\"698\":1,\"699\":1}}],[\"iterator\",{\"1\":{\"539\":8,\"543\":7,\"698\":5,\"699\":8,\"700\":1,\"704\":8,\"747\":23,\"1011\":16,\"1147\":1,\"1148\":5}}],[\"iter\",{\"1\":{\"125\":3}}],[\"id合法且<12\",{\"1\":{\"1689\":1}}],[\"id>11所获取的数据量\",{\"1\":{\"1688\":1}}],[\"id>11\",{\"1\":{\"1688\":1}}],[\"id>2500000\",{\"1\":{\"1539\":1}}],[\"id测试间隙锁\",{\"0\":{\"1688\":1}}],[\"id就写哪个事务id\",{\"1\":{\"1681\":1}}],[\"id放的就是该事务的id\",{\"1\":{\"1681\":1}}],[\"id后\",{\"1\":{\"1656\":1}}],[\"id可能会发生改变\",{\"1\":{\"1656\":1}}],[\"ids列表中\",{\"1\":{\"1656\":1}}],[\"ids就不会更新\",{\"1\":{\"1656\":1}}],[\"ids可能会有更新\",{\"1\":{\"1656\":1}}],[\"ids\",{\"1\":{\"1656\":6}}],[\"id字段\",{\"1\":{\"1552\":1}}],[\"id=8的数据\",{\"1\":{\"1701\":1}}],[\"id=4\",{\"1\":{\"1693\":1}}],[\"id=9\",{\"1\":{\"1693\":2}}],[\"id=5\",{\"1\":{\"1693\":1}}],[\"id=24\",{\"1\":{\"1689\":2}}],[\"id=7\",{\"1\":{\"1682\":1}}],[\"id=b\",{\"1\":{\"1539\":1}}],[\"id=10\",{\"1\":{\"1693\":1}}],[\"id=1080\",{\"1\":{\"1251\":1}}],[\"id=1080命令\",{\"1\":{\"1251\":1}}],[\"id=1080保存\",{\"1\":{\"1251\":1}}],[\"id=12\",{\"1\":{\"1689\":2}}],[\"id=1\",{\"1\":{\"1251\":1,\"1480\":1}}],[\"id也是继续增加\",{\"1\":{\"1480\":1}}],[\"identified\",{\"1\":{\"1408\":1,\"1447\":3,\"1799\":1,\"1821\":3,\"1828\":1}}],[\"identification\",{\"1\":{\"957\":1}}],[\"iderived\",{\"1\":{\"889\":2}}],[\"id\",{\"0\":{\"1824\":1},\"1\":{\"891\":5,\"1002\":14,\"1151\":3,\"1207\":1,\"1428\":2,\"1437\":1,\"1515\":2,\"1521\":1,\"1525\":3,\"1539\":4,\"1551\":1,\"1552\":1,\"1614\":8,\"1656\":21,\"1681\":4,\"1682\":1,\"1689\":1,\"1738\":6,\"1740\":5,\"1773\":1,\"1824\":1,\"1832\":1,\"1833\":1,\"1891\":1,\"1904\":1,\"1908\":2}}],[\"idndef\",{\"1\":{\"578\":1}}],[\"idx\",{\"1\":{\"185\":3,\"512\":4,\"536\":3,\"547\":3,\"618\":2,\"1031\":2,\"1839\":6,\"1849\":6,\"1875\":6,\"1878\":6}}],[\"iz\",{\"1\":{\"432\":3}}],[\"iy都是先执行默认初始化后\",{\"1\":{\"422\":1}}],[\"iy\",{\"1\":{\"392\":1,\"396\":2,\"421\":6,\"422\":3,\"432\":7,\"433\":7,\"434\":6,\"459\":5,\"463\":2,\"722\":9}}],[\"ix锁\",{\"1\":{\"1673\":1}}],[\"ix和\",{\"1\":{\"422\":1}}],[\"ix\",{\"1\":{\"392\":1,\"396\":2,\"421\":6,\"422\":3,\"432\":9,\"433\":8,\"434\":6,\"459\":5,\"463\":2,\"722\":9,\"1673\":1}}],[\"ibd\",{\"1\":{\"1623\":1}}],[\"ib2\",{\"1\":{\"891\":7}}],[\"ib1\",{\"1\":{\"891\":8}}],[\"ibase3\",{\"1\":{\"889\":2}}],[\"ibase2\",{\"1\":{\"889\":2}}],[\"ibase1\",{\"1\":{\"889\":2}}],[\"ib\",{\"1\":{\"364\":2,\"371\":9,\"594\":1,\"891\":12,\"943\":8,\"1758\":2}}],[\"ia\",{\"1\":{\"364\":2,\"368\":2,\"371\":9,\"547\":2,\"594\":2,\"943\":10}}],[\"i<\",{\"1\":{\"1622\":1}}],[\"i<n\",{\"1\":{\"1523\":1}}],[\"i<arr\",{\"1\":{\"1001\":2}}],[\"i<50\",{\"1\":{\"999\":3}}],[\"i<10\",{\"1\":{\"984\":1,\"985\":1}}],[\"i<20\",{\"1\":{\"355\":1,\"704\":1,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":6,\"966\":5,\"990\":1,\"991\":1,\"992\":1,\"1002\":1,\"1011\":2}}],[\"i<size\",{\"1\":{\"355\":1,\"385\":1,\"704\":2,\"966\":3}}],[\"i<len\",{\"1\":{\"355\":2,\"385\":2,\"704\":2}}],[\"i2\",{\"1\":{\"293\":1}}],[\"i的结束时是等于mid\",{\"1\":{\"202\":1}}],[\"i表示左半边的下标\",{\"1\":{\"202\":1}}],[\"iii\",{\"0\":{\"161\":1},\"1\":{\"161\":1}}],[\"ii\",{\"0\":{\"140\":1,\"158\":1,\"768\":1,\"801\":1},\"1\":{\"140\":1,\"158\":1,\"768\":1,\"801\":1}}],[\"i\",{\"0\":{\"1250\":1,\"1939\":1},\"1\":{\"67\":3,\"70\":7,\"81\":8,\"87\":5,\"101\":22,\"104\":5,\"107\":2,\"110\":2,\"115\":4,\"118\":2,\"125\":11,\"132\":4,\"133\":9,\"135\":12,\"136\":4,\"137\":8,\"141\":7,\"142\":6,\"153\":3,\"155\":3,\"158\":11,\"161\":5,\"162\":23,\"166\":9,\"170\":2,\"188\":7,\"191\":8,\"194\":4,\"199\":6,\"202\":6,\"205\":6,\"214\":10,\"217\":6,\"239\":1,\"307\":1,\"355\":6,\"385\":7,\"406\":19,\"494\":5,\"526\":1,\"528\":2,\"529\":1,\"572\":1,\"574\":2,\"575\":3,\"576\":5,\"605\":1,\"621\":2,\"704\":8,\"731\":2,\"751\":3,\"755\":3,\"782\":5,\"783\":3,\"792\":4,\"810\":7,\"817\":2,\"819\":2,\"906\":6,\"966\":3,\"1001\":2,\"1099\":3,\"1102\":6,\"1127\":11,\"1141\":1,\"1147\":2,\"1148\":2,\"1151\":9,\"1177\":2,\"1208\":3,\"1219\":10,\"1233\":4,\"1238\":4,\"1250\":1,\"1328\":2,\"1330\":1,\"1347\":1,\"1348\":2,\"1362\":2,\"1366\":1,\"1385\":2,\"1397\":9,\"1454\":1,\"1523\":2,\"1677\":1,\"1757\":1,\"1784\":2,\"1839\":2,\"1849\":2,\"1851\":8,\"1856\":1,\"1859\":2,\"1875\":2}}],[\"implementation\",{\"1\":{\"826\":2}}],[\"import\",{\"1\":{\"60\":1}}],[\"important\",{\"1\":{\"49\":4}}],[\"imaname\",{\"1\":{\"60\":3}}],[\"imagenames\",{\"1\":{\"60\":2}}],[\"image\",{\"1\":{\"5\":2,\"16\":1,\"22\":2,\"35\":1,\"36\":1,\"38\":2,\"39\":1,\"40\":1,\"45\":1,\"46\":1,\"61\":1,\"66\":3,\"232\":1,\"233\":1,\"234\":1,\"236\":1,\"237\":1,\"238\":2,\"239\":1,\"243\":1,\"249\":1,\"251\":1,\"252\":1,\"261\":1,\"267\":2,\"293\":1,\"308\":2,\"310\":1,\"311\":2,\"312\":1,\"320\":1,\"323\":1,\"326\":1,\"329\":1,\"331\":1,\"333\":1,\"334\":1,\"339\":1,\"340\":4,\"346\":1,\"349\":1,\"364\":1,\"369\":1,\"406\":1,\"516\":1,\"570\":1,\"581\":1,\"614\":1,\"621\":1,\"657\":1,\"678\":1,\"698\":1,\"715\":1,\"731\":2,\"751\":1,\"774\":1,\"783\":1,\"803\":1,\"868\":1,\"938\":1,\"1015\":2,\"1016\":1,\"1085\":1,\"1220\":1,\"1260\":1,\"1276\":1,\"1277\":1,\"1287\":2,\"1305\":1,\"1306\":2,\"1327\":1,\"1332\":1,\"1338\":2,\"1339\":1,\"1367\":1,\"1391\":1,\"1401\":1,\"1402\":1,\"1410\":1,\"1416\":1,\"1417\":2,\"1421\":1,\"1425\":1,\"1427\":1,\"1437\":1,\"1461\":1,\"1462\":1,\"1463\":1,\"1464\":2,\"1469\":1,\"1470\":1,\"1471\":1,\"1475\":1,\"1477\":1,\"1515\":1,\"1521\":2,\"1525\":1,\"1529\":1,\"1551\":1,\"1559\":1,\"1563\":1,\"1589\":1,\"1592\":1,\"1633\":1,\"1635\":1,\"1658\":1,\"1668\":2,\"1677\":2,\"1689\":1,\"1712\":1,\"1768\":1,\"1770\":2,\"1774\":1,\"1775\":1,\"1818\":1,\"1878\":1,\"1896\":1}}],[\"img\",{\"1\":{\"50\":1,\"81\":2,\"235\":2,\"238\":6,\"345\":1,\"395\":1,\"418\":1,\"438\":1,\"444\":1,\"462\":1,\"518\":2,\"520\":1,\"523\":1,\"539\":1,\"771\":1,\"783\":1,\"787\":1,\"791\":1,\"792\":1,\"1677\":1}}],[\"io线程出错一般是网络问题\",{\"1\":{\"1830\":1}}],[\"ioinit\",{\"1\":{\"572\":1}}],[\"iostream\",{\"1\":{\"234\":1}}],[\"io\",{\"1\":{\"110\":2,\"496\":2,\"673\":1,\"678\":2,\"692\":2,\"707\":2,\"750\":2,\"965\":2,\"1063\":2,\"1087\":2,\"1121\":2,\"1610\":2,\"1747\":2,\"1784\":1,\"1828\":2,\"1888\":1,\"1891\":1}}],[\"io设备到文件的映射\",{\"1\":{\"17\":1}}],[\"ionic\",{\"1\":{\"0\":1}}],[\"is指的是表锁\",{\"1\":{\"1673\":1}}],[\"is锁\",{\"1\":{\"1673\":1}}],[\"isspace\",{\"1\":{\"1299\":1}}],[\"isready\",{\"1\":{\"1233\":3}}],[\"ispalindrome\",{\"1\":{\"755\":1,\"756\":1}}],[\"istream\",{\"1\":{\"731\":4,\"736\":4}}],[\"isbn\",{\"1\":{\"600\":1}}],[\"is\",{\"1\":{\"182\":1,\"185\":2,\"224\":2,\"286\":2,\"355\":1,\"388\":2,\"600\":1,\"695\":4,\"751\":1,\"1031\":15,\"1032\":16,\"1080\":1,\"1127\":1,\"1240\":2,\"1318\":1,\"1471\":2,\"1513\":2,\"1543\":1,\"1544\":2,\"1618\":1,\"1820\":1,\"1828\":1,\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":1}}],[\"isanagram\",{\"1\":{\"166\":1}}],[\"isaddanchorevent\",{\"1\":{\"59\":2}}],[\"isadd\",{\"1\":{\"54\":3,\"59\":3}}],[\"ishappy\",{\"1\":{\"148\":1,\"149\":1}}],[\"isfile\",{\"1\":{\"60\":1}}],[\"isdirectory\",{\"1\":{\"60\":2}}],[\"iscurassetexist\",{\"1\":{\"60\":2}}],[\"isused\",{\"1\":{\"60\":2}}],[\"isolation=\",{\"1\":{\"1640\":1}}],[\"isolation\",{\"1\":{\"1632\":2,\"1640\":1,\"1644\":1}}],[\"iso\",{\"0\":{\"1016\":1},\"1\":{\"16\":3}}],[\"iszhwei\",{\"1\":{\"5\":2,\"110\":1,\"496\":1,\"673\":1,\"678\":1,\"692\":1,\"707\":1,\"750\":1,\"965\":1,\"1063\":1,\"1087\":2,\"1121\":1,\"1610\":1,\"1747\":1}}],[\"ifconfig\",{\"1\":{\"1280\":1}}],[\"if需要1元函数对象\",{\"1\":{\"1148\":1}}],[\"if函数需要传入一个\",{\"1\":{\"1148\":1}}],[\"if判断哪个还有剩\",{\"1\":{\"762\":1}}],[\"ifdef\",{\"1\":{\"244\":1,\"526\":1,\"570\":2,\"571\":2,\"577\":2,\"1079\":1,\"1080\":1,\"1321\":1,\"1848\":1,\"1849\":1,\"1875\":2}}],[\"ifndef\",{\"1\":{\"188\":1,\"194\":1,\"199\":1,\"205\":1,\"217\":1,\"220\":1,\"244\":1,\"439\":1,\"504\":1,\"506\":1,\"577\":1,\"817\":1,\"1079\":1,\"1093\":1,\"1096\":1,\"1102\":1,\"1839\":1,\"1845\":1,\"1846\":1,\"1848\":1,\"1856\":2,\"1859\":2,\"1875\":1,\"1878\":1}}],[\"iframediv\",{\"1\":{\"59\":5}}],[\"iframedivs\",{\"1\":{\"59\":2}}],[\"iframe\",{\"0\":{\"55\":1},\"1\":{\"59\":9}}],[\"ifwinactive\",{\"1\":{\"29\":1}}],[\"if\",{\"1\":{\"8\":3,\"11\":3,\"29\":1,\"53\":2,\"54\":1,\"59\":16,\"60\":13,\"70\":1,\"73\":1,\"77\":1,\"78\":1,\"81\":1,\"84\":2,\"87\":1,\"93\":2,\"94\":2,\"96\":4,\"97\":5,\"101\":7,\"104\":1,\"107\":1,\"110\":4,\"115\":2,\"118\":4,\"121\":1,\"125\":2,\"126\":3,\"129\":1,\"133\":4,\"135\":2,\"136\":4,\"137\":2,\"141\":1,\"142\":4,\"143\":2,\"149\":2,\"153\":1,\"154\":1,\"155\":1,\"158\":2,\"162\":2,\"166\":1,\"170\":1,\"171\":1,\"174\":1,\"178\":2,\"179\":1,\"182\":3,\"185\":3,\"188\":2,\"191\":3,\"194\":2,\"202\":2,\"205\":2,\"214\":4,\"217\":3,\"220\":3,\"224\":3,\"271\":2,\"273\":2,\"274\":1,\"277\":5,\"286\":4,\"296\":1,\"355\":3,\"385\":3,\"388\":3,\"405\":2,\"406\":3,\"464\":1,\"547\":1,\"548\":5,\"557\":1,\"594\":2,\"601\":1,\"602\":2,\"605\":1,\"606\":1,\"618\":2,\"631\":1,\"642\":2,\"662\":9,\"699\":2,\"704\":4,\"710\":2,\"736\":4,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":10,\"751\":3,\"755\":1,\"756\":2,\"759\":1,\"762\":3,\"765\":1,\"768\":1,\"771\":3,\"774\":1,\"777\":2,\"782\":6,\"783\":8,\"784\":3,\"787\":1,\"791\":3,\"792\":4,\"795\":1,\"798\":1,\"810\":1,\"817\":4,\"819\":4,\"821\":4,\"848\":4,\"849\":2,\"851\":1,\"854\":3,\"855\":2,\"856\":2,\"857\":1,\"871\":3,\"949\":2,\"966\":3,\"999\":2,\"1000\":1,\"1001\":2,\"1007\":4,\"1008\":2,\"1011\":1,\"1050\":1,\"1055\":5,\"1057\":1,\"1076\":2,\"1080\":1,\"1082\":1,\"1086\":1,\"1087\":2,\"1093\":1,\"1096\":2,\"1099\":2,\"1102\":9,\"1120\":2,\"1121\":1,\"1123\":3,\"1127\":6,\"1148\":5,\"1158\":1,\"1168\":1,\"1178\":2,\"1179\":1,\"1209\":1,\"1210\":1,\"1299\":2,\"1318\":2,\"1320\":1,\"1383\":1,\"1384\":3,\"1385\":6,\"1507\":2,\"1839\":12,\"1847\":3,\"1849\":17,\"1856\":4,\"1859\":6,\"1869\":2,\"1871\":2,\"1872\":3,\"1875\":13,\"1878\":3,\"1915\":2}}],[\"ini\",{\"1\":{\"1750\":1,\"1754\":1,\"1824\":1}}],[\"ini或my\",{\"1\":{\"1746\":1}}],[\"initsize个连接\",{\"1\":{\"1859\":1}}],[\"initsize=10\",{\"1\":{\"1844\":1,\"1878\":1}}],[\"initsize\",{\"1\":{\"1839\":4,\"1848\":1,\"1849\":4,\"1859\":3,\"1865\":1,\"1875\":4,\"1878\":1}}],[\"init方法初始化后返回的指针\",{\"1\":{\"1374\":1}}],[\"init\",{\"1\":{\"857\":3,\"1188\":5,\"1373\":1,\"1383\":1,\"1384\":1,\"1385\":1,\"1847\":1,\"1856\":1}}],[\"initwithimage\",{\"1\":{\"271\":1}}],[\"initialization\",{\"1\":{\"572\":1}}],[\"initialize\",{\"1\":{\"51\":1}}],[\"initial\",{\"1\":{\"49\":1,\"51\":2}}],[\"in优化成range范围搜索\",{\"0\":{\"1592\":1}}],[\"in是否能用到索引\",{\"0\":{\"1592\":1}}],[\"in和not\",{\"0\":{\"1592\":1}}],[\"in虽然会用到索引但是一般也会产生中间表\",{\"1\":{\"1544\":1}}],[\"in的效率其实不高\",{\"1\":{\"1471\":1}}],[\"innodb总是先把buffer\",{\"1\":{\"1758\":1}}],[\"innodb修改操作数据\",{\"1\":{\"1758\":1}}],[\"innodb行锁是通过给索引上的来实现的\",{\"1\":{\"1713\":1}}],[\"innodb存储引擎支持事务处理\",{\"1\":{\"1713\":1}}],[\"innodb存储引擎会做如下优化\",{\"1\":{\"1569\":1}}],[\"innodb将使用表锁\",{\"1\":{\"1700\":1}}],[\"innodb才使用行级锁\",{\"1\":{\"1700\":1}}],[\"innodb会使用redo\",{\"1\":{\"1758\":1}}],[\"innodb会给数据加上\",{\"1\":{\"1694\":1}}],[\"innodb会自动生成主键\",{\"1\":{\"1681\":1}}],[\"innodb会自动增加一个int字段当主键索引\",{\"1\":{\"1610\":1}}],[\"innodb串行化隔离级别使用间隙锁\",{\"1\":{\"1686\":1}}],[\"innodb提供了2种读取操作\",{\"1\":{\"1677\":1}}],[\"innodb的已提交读和可重复读的\",{\"1\":{\"1677\":1}}],[\"innodb的主键和二级索引树\",{\"0\":{\"1562\":1}}],[\"innodb是支持行锁\",{\"1\":{\"1669\":1}}],[\"innodb表级锁\",{\"0\":{\"1669\":1}}],[\"innodb如何判断某条记录是否对当前事务可见呢\",{\"1\":{\"1656\":1}}],[\"innodb支持事务\",{\"1\":{\"1649\":1}}],[\"innodb支持行锁和表索\",{\"1\":{\"1557\":1}}],[\"innodb数据和索引存放在同一文件\",{\"1\":{\"1624\":1}}],[\"innodb自适应哈希索引\",{\"0\":{\"1569\":1},\"1\":{\"1747\":2}}],[\"innodb\",{\"0\":{\"1645\":1},\"1\":{\"1453\":1,\"1569\":4,\"1610\":1,\"1623\":1,\"1686\":4,\"1706\":2,\"1717\":1,\"1747\":1,\"1748\":1,\"1752\":2,\"1758\":2,\"1881\":1}}],[\"inner也可以省略\",{\"1\":{\"1537\":1}}],[\"innertext\",{\"1\":{\"53\":3,\"54\":4,\"59\":10}}],[\"inner\",{\"1\":{\"51\":6,\"1501\":1,\"1537\":2}}],[\"inet\",{\"1\":{\"1237\":2}}],[\"infile\",{\"1\":{\"1729\":1}}],[\"infomation\",{\"1\":{\"1025\":1}}],[\"info\",{\"1\":{\"1018\":1,\"1025\":1,\"1032\":12,\"1340\":1,\"1415\":2}}],[\"inf=2\",{\"1\":{\"163\":1}}],[\"inumber\",{\"1\":{\"629\":5,\"633\":7}}],[\"inlines\",{\"1\":{\"503\":1}}],[\"inline只是对编译器建议把函数处理成内联函数\",{\"1\":{\"502\":1}}],[\"inline函数\",{\"1\":{\"504\":1,\"506\":1}}],[\"inline函数的定义才能将调用函数替换为函数代码\",{\"1\":{\"504\":1}}],[\"inline函数是一种\",{\"1\":{\"504\":1}}],[\"inline函数在编译过程中\",{\"1\":{\"502\":1}}],[\"inline函数不再生成相应的函数符号\",{\"1\":{\"501\":1,\"502\":1}}],[\"inline\",{\"1\":{\"500\":2,\"501\":2,\"504\":7,\"506\":2,\"530\":2,\"1086\":4}}],[\"inline内联函数和普通函数的区别🍗🍗🍗\",{\"0\":{\"502\":1}}],[\"inline内联函数\",{\"0\":{\"500\":1}}],[\"invalid\",{\"1\":{\"101\":1,\"485\":1,\"604\":1,\"747\":2}}],[\"inst>\",{\"1\":{\"1076\":2,\"1079\":2,\"1080\":1,\"1081\":1,\"1082\":11,\"1090\":1,\"1096\":1,\"1099\":2,\"1102\":4}}],[\"instance\",{\"1\":{\"1093\":1,\"1096\":1}}],[\"instantiated\",{\"1\":{\"182\":1,\"791\":1,\"792\":1}}],[\"installation\",{\"1\":{\"1401\":1}}],[\"install\",{\"1\":{\"234\":1,\"1015\":1,\"1016\":3,\"1035\":1,\"1131\":1,\"1132\":1,\"1280\":2,\"1285\":1,\"1287\":4,\"1289\":1,\"1290\":1,\"1293\":1,\"1305\":1,\"1371\":1,\"1393\":1,\"1397\":4,\"1399\":1,\"1818\":1}}],[\"inside<double>\",{\"1\":{\"389\":1}}],[\"inside<t>\",{\"1\":{\"389\":1}}],[\"inside\",{\"1\":{\"389\":3}}],[\"insight中的reference功能\",{\"1\":{\"41\":1}}],[\"insight使用\",{\"0\":{\"32\":1}}],[\"insert然后commit后\",{\"1\":{\"1665\":1}}],[\"insert之后\",{\"1\":{\"1665\":1}}],[\"insert进行小批量数据插入\",{\"1\":{\"1490\":1}}],[\"insert增加\",{\"0\":{\"1475\":1}}],[\"inserthead\",{\"1\":{\"819\":2,\"821\":4}}],[\"inserttail\",{\"1\":{\"819\":2,\"821\":3}}],[\"insert时加上break时候\",{\"1\":{\"743\":1}}],[\"insertsort\",{\"1\":{\"205\":4}}],[\"inserted\",{\"1\":{\"199\":3}}],[\"insert\",{\"1\":{\"101\":4,\"104\":1,\"107\":1,\"110\":2,\"125\":1,\"129\":1,\"137\":1,\"149\":1,\"153\":1,\"162\":1,\"170\":1,\"171\":1,\"205\":3,\"741\":1,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":5,\"871\":1,\"966\":1,\"985\":1,\"999\":4,\"1000\":16,\"1001\":2,\"1002\":6,\"1008\":1,\"1086\":1,\"1148\":1,\"1168\":6,\"1178\":1,\"1384\":1,\"1428\":2,\"1447\":1,\"1471\":1,\"1475\":3,\"1477\":1,\"1485\":1,\"1486\":1,\"1490\":3,\"1523\":1,\"1537\":3,\"1548\":1,\"1656\":1,\"1733\":4,\"1734\":3,\"1735\":8,\"1772\":1,\"1790\":1,\"1846\":1,\"1847\":1,\"1851\":2,\"1856\":3,\"1878\":1,\"1905\":3}}],[\"insertbefore\",{\"1\":{\"53\":1,\"59\":1}}],[\"independent\",{\"1\":{\"1333\":1}}],[\"index关闭自适应哈希索引\",{\"1\":{\"1747\":1}}],[\"indexes\",{\"1\":{\"1599\":1}}],[\"index正好pcur\",{\"1\":{\"792\":1}}],[\"index是从0开始的\",{\"1\":{\"790\":1}}],[\"index为1\",{\"1\":{\"214\":1}}],[\"indexdiff\",{\"1\":{\"161\":3,\"162\":5}}],[\"index2\",{\"1\":{\"140\":4}}],[\"index1\",{\"1\":{\"140\":4,\"1614\":4}}],[\"index++\",{\"1\":{\"59\":2,\"406\":1}}],[\"index\",{\"1\":{\"53\":1,\"54\":2,\"59\":10,\"191\":4,\"406\":2,\"699\":4,\"704\":4,\"736\":4,\"790\":9,\"791\":15,\"792\":17,\"1090\":2,\"1093\":2,\"1096\":1,\"1099\":2,\"1102\":2,\"1208\":2,\"1209\":6,\"1210\":2,\"1521\":2,\"1569\":2,\"1581\":1,\"1600\":1,\"1603\":1,\"1614\":9,\"1618\":2,\"1719\":1,\"1736\":3}}],[\"indent\",{\"1\":{\"50\":1}}],[\"in\",{\"0\":{\"1515\":1},\"1\":{\"51\":1,\"60\":4,\"67\":1,\"234\":1,\"504\":1,\"516\":1,\"731\":4,\"736\":6,\"890\":10,\"1020\":2,\"1099\":1,\"1102\":2,\"1238\":1,\"1240\":1,\"1253\":1,\"1318\":1,\"1362\":2,\"1366\":1,\"1407\":2,\"1471\":1,\"1515\":3,\"1523\":1,\"1544\":2,\"1592\":2,\"1618\":1,\"1656\":1,\"1665\":1,\"1698\":1,\"1701\":1,\"1738\":1}}],[\"inherit\",{\"1\":{\"51\":10,\"53\":1,\"54\":1,\"59\":2}}],[\"incomplete\",{\"1\":{\"1252\":1}}],[\"incompatable\",{\"1\":{\"747\":1}}],[\"incalid\",{\"1\":{\"747\":1}}],[\"incvxworksh\",{\"1\":{\"577\":3}}],[\"increment`自增\",{\"1\":{\"1481\":1}}],[\"increment\",{\"1\":{\"51\":15,\"1428\":2,\"1433\":1,\"1437\":1,\"1537\":2,\"1551\":1,\"1552\":1}}],[\"include预编译指令后\",{\"1\":{\"593\":1}}],[\"include进行包含实现文件\",{\"1\":{\"504\":1,\"506\":1}}],[\"include和\",{\"1\":{\"312\":1}}],[\"include目录下查找到stdio\",{\"1\":{\"312\":1}}],[\"include＜＞\",{\"0\":{\"312\":1}}],[\"include<log4cpp\",{\"1\":{\"1020\":5}}],[\"include<stdio\",{\"1\":{\"575\":1,\"576\":1}}],[\"include<string>\",{\"1\":{\"536\":1}}],[\"include<>\",{\"1\":{\"312\":1}}],[\"include<iostream>\",{\"1\":{\"267\":1,\"736\":1,\"1020\":1}}],[\"include<bits\",{\"1\":{\"163\":1,\"267\":1}}],[\"included\",{\"1\":{\"234\":1}}],[\"include\",{\"0\":{\"312\":1,\"1209\":1,\"1314\":1},\"1\":{\"8\":1,\"11\":1,\"60\":5,\"101\":4,\"104\":3,\"107\":3,\"110\":3,\"118\":3,\"185\":1,\"188\":7,\"191\":6,\"194\":3,\"199\":2,\"202\":3,\"205\":2,\"214\":4,\"217\":2,\"220\":2,\"224\":3,\"234\":3,\"244\":1,\"277\":4,\"293\":1,\"311\":1,\"312\":5,\"323\":1,\"338\":1,\"378\":2,\"405\":1,\"406\":1,\"433\":1,\"434\":1,\"459\":1,\"468\":1,\"476\":2,\"492\":1,\"493\":1,\"494\":1,\"497\":1,\"500\":1,\"504\":1,\"506\":5,\"515\":2,\"547\":3,\"548\":2,\"557\":1,\"563\":1,\"569\":1,\"570\":1,\"571\":3,\"576\":1,\"577\":1,\"578\":1,\"588\":2,\"590\":1,\"594\":7,\"597\":2,\"599\":3,\"601\":10,\"602\":1,\"605\":2,\"606\":3,\"614\":3,\"618\":1,\"621\":2,\"633\":1,\"642\":1,\"662\":4,\"731\":1,\"751\":2,\"810\":1,\"817\":6,\"819\":1,\"821\":1,\"826\":3,\"830\":2,\"831\":2,\"832\":2,\"849\":3,\"852\":3,\"864\":1,\"871\":4,\"889\":1,\"891\":1,\"894\":1,\"953\":2,\"965\":1,\"969\":1,\"970\":1,\"999\":1,\"1000\":1,\"1002\":2,\"1007\":1,\"1008\":1,\"1015\":1,\"1031\":9,\"1032\":9,\"1041\":1,\"1042\":1,\"1055\":2,\"1060\":5,\"1115\":1,\"1123\":1,\"1133\":1,\"1146\":2,\"1147\":5,\"1148\":5,\"1151\":7,\"1154\":7,\"1158\":4,\"1168\":7,\"1183\":3,\"1188\":2,\"1207\":2,\"1209\":4,\"1219\":5,\"1233\":5,\"1291\":1,\"1299\":8,\"1314\":1,\"1315\":1,\"1316\":4,\"1321\":2,\"1372\":2,\"1383\":2,\"1384\":4,\"1385\":4,\"1399\":2,\"1839\":8,\"1846\":3,\"1847\":3,\"1848\":9,\"1849\":3,\"1856\":9,\"1859\":15,\"1875\":12,\"1878\":11,\"1901\":1,\"1915\":3}}],[\"int32\",{\"1\":{\"1915\":1}}],[\"int用时间戳表示考试时间\",{\"1\":{\"1537\":1}}],[\"int底层内存存储的数据大小固定不变\",{\"1\":{\"1424\":1}}],[\"int类型下将其混用\",{\"0\":{\"713\":1}}],[\"int指针的指针\",{\"1\":{\"490\":2}}],[\"integer\",{\"0\":{\"329\":1}}],[\"intel\",{\"1\":{\"227\":3,\"234\":2,\"244\":1,\"260\":1,\"261\":1,\"516\":1,\"614\":1,\"621\":1}}],[\"interfaces\",{\"1\":{\"1237\":1}}],[\"interfaces的缩写\",{\"1\":{\"16\":1}}],[\"intersection\",{\"1\":{\"170\":1,\"171\":1}}],[\"interval\",{\"1\":{\"59\":2}}],[\"int>\",{\"1\":{\"125\":2,\"141\":1,\"158\":1,\"178\":1,\"372\":1,\"1001\":1,\"1173\":2}}],[\"into\",{\"1\":{\"51\":1,\"1384\":1,\"1428\":2,\"1475\":3,\"1477\":1,\"1490\":3,\"1523\":1,\"1537\":3,\"1729\":1,\"1733\":4,\"1734\":3,\"1735\":8,\"1851\":2,\"1856\":1,\"1878\":1}}],[\"int\",{\"0\":{\"1424\":1},\"1\":{\"8\":2,\"11\":4,\"60\":2,\"67\":3,\"70\":7,\"73\":7,\"77\":4,\"78\":4,\"81\":8,\"84\":5,\"87\":3,\"93\":4,\"94\":4,\"96\":8,\"97\":7,\"101\":19,\"104\":7,\"107\":6,\"110\":9,\"114\":1,\"115\":4,\"118\":10,\"121\":3,\"125\":2,\"126\":3,\"129\":6,\"133\":4,\"137\":3,\"141\":2,\"142\":8,\"143\":3,\"148\":7,\"149\":5,\"158\":2,\"162\":3,\"163\":12,\"166\":4,\"170\":1,\"174\":2,\"178\":2,\"179\":4,\"182\":8,\"185\":14,\"188\":6,\"191\":25,\"194\":2,\"199\":9,\"202\":14,\"205\":3,\"214\":10,\"217\":2,\"220\":7,\"224\":12,\"234\":16,\"236\":5,\"246\":13,\"267\":13,\"271\":3,\"277\":2,\"286\":2,\"296\":1,\"323\":1,\"330\":1,\"338\":1,\"355\":12,\"365\":3,\"368\":1,\"371\":2,\"378\":1,\"385\":11,\"388\":1,\"395\":2,\"405\":1,\"406\":18,\"410\":1,\"411\":2,\"412\":2,\"413\":5,\"421\":7,\"422\":16,\"423\":2,\"426\":1,\"432\":7,\"433\":11,\"434\":18,\"439\":1,\"440\":1,\"449\":2,\"459\":15,\"463\":1,\"468\":2,\"470\":2,\"473\":3,\"476\":3,\"480\":3,\"483\":7,\"484\":11,\"485\":6,\"487\":3,\"488\":6,\"489\":7,\"490\":32,\"491\":12,\"492\":59,\"493\":7,\"494\":2,\"497\":22,\"500\":9,\"501\":2,\"504\":8,\"506\":9,\"510\":2,\"511\":9,\"512\":3,\"515\":15,\"516\":1,\"517\":3,\"518\":2,\"520\":1,\"521\":2,\"524\":6,\"526\":1,\"528\":2,\"529\":1,\"535\":4,\"547\":3,\"548\":1,\"557\":13,\"560\":3,\"563\":23,\"567\":8,\"568\":8,\"569\":8,\"570\":11,\"571\":13,\"572\":2,\"574\":3,\"575\":3,\"576\":7,\"578\":3,\"584\":1,\"585\":2,\"588\":3,\"589\":2,\"590\":2,\"591\":1,\"592\":5,\"594\":27,\"597\":1,\"599\":2,\"601\":6,\"602\":4,\"605\":1,\"606\":1,\"612\":3,\"613\":1,\"614\":4,\"615\":6,\"616\":10,\"618\":35,\"620\":6,\"621\":9,\"624\":6,\"625\":17,\"629\":5,\"630\":8,\"631\":1,\"632\":1,\"633\":11,\"637\":6,\"638\":7,\"639\":12,\"640\":8,\"641\":10,\"642\":20,\"653\":1,\"662\":4,\"667\":7,\"684\":6,\"688\":18,\"692\":3,\"693\":4,\"695\":11,\"699\":4,\"704\":16,\"709\":2,\"713\":4,\"714\":3,\"722\":4,\"729\":1,\"731\":7,\"736\":2,\"742\":2,\"743\":2,\"745\":3,\"746\":3,\"747\":10,\"751\":3,\"755\":4,\"756\":3,\"759\":4,\"762\":3,\"768\":2,\"771\":5,\"774\":6,\"777\":1,\"782\":3,\"783\":5,\"784\":4,\"787\":6,\"791\":12,\"792\":14,\"795\":4,\"798\":3,\"802\":5,\"806\":1,\"810\":9,\"817\":14,\"819\":8,\"821\":7,\"826\":20,\"830\":1,\"831\":1,\"832\":1,\"862\":1,\"864\":2,\"866\":1,\"867\":1,\"871\":8,\"884\":4,\"886\":1,\"889\":5,\"891\":18,\"894\":2,\"900\":1,\"905\":11,\"906\":3,\"907\":1,\"908\":1,\"913\":1,\"919\":4,\"934\":2,\"939\":4,\"943\":15,\"948\":13,\"953\":7,\"954\":6,\"966\":11,\"980\":1,\"981\":1,\"982\":1,\"984\":2,\"985\":2,\"990\":1,\"991\":1,\"992\":1,\"999\":4,\"1001\":9,\"1002\":8,\"1007\":8,\"1008\":2,\"1011\":4,\"1020\":2,\"1031\":2,\"1032\":9,\"1040\":3,\"1041\":6,\"1043\":2,\"1045\":4,\"1047\":2,\"1050\":2,\"1055\":5,\"1056\":2,\"1057\":1,\"1060\":5,\"1066\":1,\"1076\":1,\"1079\":1,\"1081\":1,\"1082\":5,\"1090\":1,\"1096\":1,\"1099\":3,\"1102\":4,\"1110\":4,\"1111\":1,\"1112\":4,\"1113\":1,\"1114\":35,\"1115\":7,\"1116\":2,\"1120\":1,\"1123\":1,\"1124\":1,\"1127\":7,\"1147\":2,\"1148\":2,\"1151\":10,\"1154\":7,\"1155\":1,\"1158\":6,\"1165\":5,\"1166\":6,\"1168\":2,\"1173\":14,\"1174\":3,\"1175\":3,\"1177\":4,\"1178\":2,\"1179\":1,\"1183\":5,\"1186\":1,\"1188\":14,\"1189\":24,\"1207\":3,\"1208\":4,\"1209\":4,\"1210\":1,\"1219\":12,\"1225\":1,\"1226\":1,\"1232\":1,\"1233\":4,\"1299\":7,\"1321\":2,\"1344\":2,\"1374\":1,\"1376\":1,\"1380\":1,\"1382\":1,\"1383\":1,\"1384\":2,\"1385\":6,\"1422\":1,\"1424\":1,\"1428\":2,\"1437\":1,\"1523\":3,\"1537\":5,\"1551\":1,\"1552\":3,\"1614\":4,\"1622\":1,\"1839\":9,\"1848\":7,\"1849\":3,\"1851\":4,\"1856\":1,\"1859\":8,\"1875\":10,\"1878\":8,\"1907\":1,\"1908\":1,\"1909\":2,\"1915\":1}}],[\"inputit\",{\"1\":{\"537\":2,\"541\":2}}],[\"input\",{\"1\":{\"8\":1,\"60\":2,\"600\":1}}],[\"文字常量区\",{\"1\":{\"535\":1}}],[\"文档间跳转返回\",{\"0\":{\"55\":1,\"57\":1}}],[\"文档间锚点\",{\"0\":{\"55\":1,\"56\":1}}],[\"文档和自动化部署工具\",{\"1\":{\"0\":1}}],[\"文章大纲自动编号\",{\"1\":{\"51\":1}}],[\"文章主题自动编号\",{\"1\":{\"51\":1}}],[\"文章内容自动编号\",{\"1\":{\"51\":1}}],[\"文本缩进\",{\"1\":{\"50\":1}}],[\"文本修饰\",{\"1\":{\"50\":1}}],[\"文件操作\",{\"0\":{\"1945\":1}}],[\"文件不为空\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":1}}],[\"文件不存在等\",{\"1\":{\"597\":1}}],[\"文件可能包含敏感信息\",{\"1\":{\"1338\":1}}],[\"文件可以直接放在这个文件夹内\",{\"1\":{\"5\":1}}],[\"文件对于程序员和系统管理员来说是非常有价值的\",{\"1\":{\"1338\":1}}],[\"文件来实现这些函数\",{\"1\":{\"1333\":1}}],[\"文件并添加你的库目录\",{\"1\":{\"1332\":1}}],[\"文件并不能执行\",{\"1\":{\"310\":1}}],[\"文件的大小有限制\",{\"1\":{\"1338\":1}}],[\"文件的大小限制为无限制\",{\"1\":{\"1338\":1}}],[\"文件的源码目录即可\",{\"1\":{\"1316\":1}}],[\"文件的分类\",{\"0\":{\"17\":1}}],[\"文件放到\",{\"1\":{\"1316\":1}}],[\"文件所在的目录\",{\"1\":{\"1310\":1}}],[\"文件大小是其链接文件的路径名称的字符数\",{\"1\":{\"1268\":1}}],[\"文件a内容也会改变\",{\"1\":{\"1267\":1}}],[\"文件名为logtest\",{\"1\":{\"1026\":1}}],[\"文件中\",{\"1\":{\"310\":1}}],[\"文件中均为0101\",{\"1\":{\"310\":1}}],[\"文件中包含可执行指令的节区\",{\"1\":{\"228\":1}}],[\"文件即可\",{\"1\":{\"28\":1}}],[\"文件夹即可\",{\"1\":{\"27\":1}}],[\"文件缓冲区\",{\"1\":{\"16\":1}}],[\"文件\",{\"0\":{\"1315\":1},\"1\":{\"16\":1,\"27\":1,\"28\":1,\"48\":1,\"49\":1,\"51\":1,\"62\":1,\"63\":1,\"239\":1,\"310\":1,\"526\":1,\"675\":1,\"1317\":1,\"1318\":1,\"1332\":1,\"1333\":1,\"1338\":2}}],[\"和物理机\",{\"1\":{\"1821\":1}}],[\"和物理机的网络地位相同\",{\"1\":{\"1821\":1}}],[\"和slave区分开\",{\"1\":{\"1820\":1}}],[\"和slave\",{\"1\":{\"1818\":1}}],[\"和select\",{\"1\":{\"1548\":1}}],[\"和读服务器\",{\"1\":{\"1803\":1}}],[\"和逻辑表\",{\"1\":{\"1803\":1}}],[\"和上面的问题一样\",{\"0\":{\"1763\":1}}],[\"和多线程编程的死锁情况相似\",{\"1\":{\"1706\":1}}],[\"和指向undo\",{\"1\":{\"1682\":1}}],[\"和mvcc的关系不大\",{\"1\":{\"1681\":1}}],[\"和出现不可重复读现象的原因相同\",{\"1\":{\"1660\":1}}],[\"和都是可能发生的\",{\"1\":{\"1631\":1}}],[\"和avl树一样\",{\"1\":{\"1623\":1}}],[\"和学号无关\",{\"1\":{\"1461\":1}}],[\"和列\",{\"1\":{\"1451\":1}}],[\"和varchar\",{\"1\":{\"1426\":1}}],[\"和volatile\",{\"1\":{\"563\":1}}],[\"和静态库\",{\"0\":{\"1335\":1}}],[\"和网关\",{\"1\":{\"1278\":1}}],[\"和硬链接\",{\"0\":{\"1266\":1}}],[\"和ubuntu\",{\"1\":{\"1818\":1}}],[\"和unlock\",{\"1\":{\"1212\":1}}],[\"和unique\",{\"1\":{\"1211\":1}}],[\"和upper\",{\"0\":{\"163\":1},\"1\":{\"163\":2}}],[\"和拷贝构造过程一样\",{\"1\":{\"1127\":1}}],[\"和test\",{\"1\":{\"1110\":1,\"1111\":1}}],[\"和pop\",{\"0\":{\"1086\":1,\"1087\":1}}],[\"和pa\",{\"0\":{\"520\":1}}],[\"和普通函数一样\",{\"1\":{\"923\":1}}],[\"和普通的虚函数不同\",{\"1\":{\"900\":1}}],[\"和投影仪\",{\"1\":{\"832\":1}}],[\"和代理模式很像\",{\"1\":{\"831\":1}}],[\"和一个特定值\",{\"1\":{\"795\":1}}],[\"和一个整数\",{\"1\":{\"158\":1}}],[\"和一个整数目标值\",{\"1\":{\"124\":1}}],[\"和重载的区别在于\",{\"1\":{\"695\":1}}],[\"和重写的区别在于\",{\"1\":{\"695\":1}}],[\"和通过指针解引用修改指针指向的内存的值\",{\"1\":{\"619\":1}}],[\"和extern\",{\"0\":{\"573\":1}}],[\"和函数at\",{\"1\":{\"539\":1}}],[\"和foo\",{\"1\":{\"526\":1}}],[\"和free\",{\"1\":{\"285\":1}}],[\"和编译器实现new\",{\"1\":{\"523\":1}}],[\"和编译器有关\",{\"1\":{\"512\":1}}],[\"和delete\",{\"0\":{\"517\":1},\"1\":{\"517\":2}}],[\"和有没有a没有关系\",{\"1\":{\"492\":1}}],[\"和commit\",{\"1\":{\"1658\":1}}],[\"和const\",{\"1\":{\"490\":1}}],[\"和c++标准库中提供的allocator是一样的\",{\"1\":{\"1079\":1}}],[\"和c语言一样\",{\"1\":{\"484\":1}}],[\"和成员函数\",{\"1\":{\"449\":1}}],[\"和对数据的操作\",{\"1\":{\"449\":1}}],[\"和常量成员相同\",{\"1\":{\"433\":1}}],[\"和偏特化\",{\"1\":{\"389\":1}}],[\"和删除末尾数据pop\",{\"1\":{\"354\":1}}],[\"和我们关键字重名\",{\"1\":{\"296\":1}}],[\"和其派生的函数进行动态的申请内存\",{\"1\":{\"282\":1}}],[\"和谐数组是指一个数组里元素的最大值和最小值之间的差别\",{\"1\":{\"177\":1}}],[\"和两个整数\",{\"1\":{\"161\":1,\"801\":1}}],[\"和left\",{\"1\":{\"136\":1}}],[\"和为目标值target\",{\"1\":{\"124\":1}}],[\"和\",{\"0\":{\"228\":1,\"312\":1,\"1315\":1,\"1357\":1,\"1476\":1},\"1\":{\"5\":1,\"126\":1,\"136\":1,\"140\":2,\"158\":1,\"161\":1,\"166\":3,\"169\":1,\"174\":1,\"182\":1,\"301\":1,\"302\":1,\"340\":1,\"519\":1,\"575\":1,\"601\":1,\"604\":1,\"728\":1,\"730\":1,\"771\":3,\"791\":1,\"801\":1,\"802\":2,\"842\":1,\"1042\":1,\"1099\":1,\"1124\":1,\"1314\":1,\"1315\":4,\"1317\":1,\"1318\":2,\"1334\":1,\"1335\":1,\"1345\":1,\"1614\":1,\"1656\":1,\"1677\":1,\"1693\":1,\"1736\":1,\"1754\":1,\"1864\":1,\"1896\":1,\"1913\":1}}],[\"wsx\",{\"1\":{\"1825\":1,\"1828\":1,\"1829\":1}}],[\"wu\",{\"1\":{\"1475\":1}}],[\"wuhan\",{\"1\":{\"547\":1,\"662\":1,\"949\":1}}],[\"wget默认重试20次连接下载文件\",{\"1\":{\"1256\":1}}],[\"wget默认会以最后一个符合\",{\"1\":{\"1251\":1}}],[\"wget的断点续传是自动的\",{\"1\":{\"1252\":1}}],[\"wget\",{\"0\":{\"1249\":1,\"1250\":1,\"1251\":1,\"1252\":1,\"1253\":1},\"1\":{\"1248\":1,\"1249\":1,\"1250\":1,\"1251\":2,\"1252\":2,\"1253\":2,\"1254\":2,\"1255\":1,\"1256\":1,\"1395\":1}}],[\"wget使用方法\",{\"0\":{\"1248\":1}}],[\"w或\",{\"1\":{\"1237\":1}}],[\"where字段而不是select字段where\",{\"1\":{\"1610\":1}}],[\"where后面值判断是否为null\",{\"1\":{\"1544\":1}}],[\"where\",{\"1\":{\"1384\":2,\"1407\":1,\"1471\":2,\"1478\":1,\"1480\":2,\"1491\":1,\"1492\":1,\"1494\":1,\"1500\":6,\"1501\":2,\"1511\":6,\"1513\":2,\"1514\":3,\"1515\":4,\"1525\":3,\"1526\":1,\"1537\":4,\"1538\":7,\"1539\":1,\"1541\":2,\"1543\":1,\"1544\":3,\"1563\":3,\"1564\":3,\"1566\":1,\"1569\":3,\"1581\":1,\"1592\":2,\"1593\":1,\"1623\":1,\"1686\":1,\"1688\":2,\"1689\":2,\"1693\":1,\"1738\":2,\"1740\":2,\"1836\":2}}],[\"whereis\",{\"1\":{\"1306\":1}}],[\"what返回的内容由编译器决定\",{\"1\":{\"605\":1}}],[\"what\",{\"1\":{\"605\":3,\"606\":3,\"1102\":1}}],[\"wh命名空间中的number\",{\"1\":{\"592\":1}}],[\"wh\",{\"1\":{\"592\":4,\"594\":3}}],[\"while这些复杂的语句\",{\"1\":{\"504\":1,\"506\":1}}],[\"while\",{\"0\":{\"270\":1,\"275\":1},\"1\":{\"8\":1,\"11\":1,\"59\":2,\"67\":1,\"70\":3,\"73\":2,\"78\":3,\"81\":1,\"84\":1,\"93\":1,\"94\":1,\"96\":2,\"97\":2,\"110\":1,\"121\":1,\"126\":1,\"129\":1,\"133\":3,\"136\":8,\"137\":1,\"142\":1,\"143\":3,\"148\":2,\"149\":2,\"179\":1,\"182\":1,\"185\":1,\"194\":1,\"202\":3,\"205\":1,\"220\":3,\"224\":1,\"271\":1,\"275\":1,\"276\":2,\"277\":5,\"286\":1,\"296\":1,\"355\":1,\"406\":1,\"745\":1,\"747\":5,\"751\":1,\"756\":3,\"759\":1,\"762\":1,\"765\":1,\"768\":2,\"771\":6,\"774\":5,\"777\":2,\"782\":1,\"783\":1,\"784\":1,\"787\":3,\"791\":4,\"795\":1,\"798\":2,\"802\":3,\"806\":2,\"810\":1,\"817\":7,\"819\":4,\"821\":5,\"966\":2,\"984\":1,\"990\":1,\"991\":1,\"992\":1,\"1020\":1,\"1031\":1,\"1208\":1,\"1209\":3,\"1210\":1,\"1219\":2,\"1233\":1,\"1523\":2,\"1839\":1,\"1849\":7,\"1859\":5,\"1869\":1,\"1871\":1,\"1872\":1,\"1875\":3,\"1878\":1},\"2\":{\"279\":1}}],[\"wd命名空间中的number\",{\"1\":{\"592\":1}}],[\"wd\",{\"1\":{\"584\":2,\"585\":2,\"589\":6,\"590\":6,\"592\":6,\"594\":19,\"1031\":1}}],[\"www\",{\"1\":{\"1251\":2,\"1277\":1}}],[\"ww\",{\"1\":{\"557\":1}}],[\"wall\",{\"1\":{\"1317\":3,\"1327\":2}}],[\"walk\",{\"1\":{\"60\":1}}],[\"waiting\",{\"1\":{\"1240\":5}}],[\"wait|awk\",{\"1\":{\"1238\":1}}],[\"wait连接\",{\"1\":{\"1238\":1}}],[\"wait里面传的是unique\",{\"1\":{\"1227\":1}}],[\"wait\",{\"0\":{\"1871\":1},\"1\":{\"1219\":2,\"1227\":1,\"1240\":5,\"1754\":2,\"1849\":2,\"1859\":2,\"1869\":1,\"1871\":3,\"1872\":1,\"1875\":1}}],[\"watermark\",{\"1\":{\"1082\":1,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1}}],[\"watchmovice\",{\"1\":{\"830\":3}}],[\"wanning\",{\"1\":{\"1025\":1}}],[\"wang\",{\"1\":{\"886\":2,\"905\":2,\"1415\":2,\"1475\":1}}],[\"wangdao\",{\"1\":{\"548\":1}}],[\"warning\",{\"1\":{\"1318\":2,\"1799\":1}}],[\"warningmessage\",{\"1\":{\"1020\":1}}],[\"warnings\",{\"1\":{\"293\":3}}],[\"warn\",{\"1\":{\"1018\":1,\"1020\":1,\"1025\":1,\"1031\":6,\"1032\":12}}],[\"was\",{\"1\":{\"516\":1}}],[\"w\",{\"1\":{\"252\":1,\"535\":1,\"1060\":2,\"1139\":2,\"1141\":1,\"1282\":1,\"1347\":1,\"1410\":2,\"1537\":4}}],[\"written\",{\"1\":{\"1253\":1}}],[\"writetype=\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"writetype=0\",{\"1\":{\"1803\":1}}],[\"writehost\",{\"1\":{\"1803\":3}}],[\"writehost参与读操作的负载\",{\"1\":{\"1803\":1}}],[\"write>h6\",{\"1\":{\"51\":1}}],[\"write>h5\",{\"1\":{\"51\":1}}],[\"write>h4\",{\"1\":{\"51\":1}}],[\"write>h3\",{\"1\":{\"51\":1}}],[\"write\",{\"1\":{\"49\":2,\"51\":5,\"59\":5,\"1671\":1}}],[\"wrapper\",{\"1\":{\"1800\":1,\"1805\":1,\"1806\":1}}],[\"wrap\",{\"1\":{\"49\":1}}],[\"wed\",{\"1\":{\"1820\":1}}],[\"werror\",{\"1\":{\"1327\":1}}],[\"wextra\",{\"1\":{\"1327\":1}}],[\"we\",{\"1\":{\"1102\":3}}],[\"weak\",{\"0\":{\"1057\":1},\"1\":{\"1050\":2,\"1056\":2,\"1057\":4}}],[\"weight\",{\"1\":{\"49\":1,\"51\":1}}],[\"webkit\",{\"1\":{\"49\":1}}],[\"web框架\",{\"1\":{\"0\":1}}],[\"web开发\",{\"1\":{\"0\":1}}],[\"wildcard\",{\"1\":{\"1361\":1,\"1365\":1,\"1366\":2,\"1367\":2}}],[\"will\",{\"1\":{\"182\":1,\"601\":5,\"791\":1,\"792\":1,\"1102\":1,\"1253\":1}}],[\"with\",{\"1\":{\"49\":1,\"60\":1,\"1102\":1,\"1408\":1,\"1447\":2,\"1656\":1,\"1799\":1}}],[\"width\",{\"1\":{\"48\":1,\"59\":1,\"271\":1,\"898\":5}}],[\"win10\",{\"1\":{\"1796\":1,\"1818\":1}}],[\"win10上的mysql\",{\"1\":{\"1785\":1}}],[\"win10上typora卡顿的问题及其解决方案\",{\"0\":{\"63\":1}}],[\"window下是\",{\"1\":{\"267\":1}}],[\"window\",{\"1\":{\"52\":1,\"53\":1,\"54\":1,\"59\":10,\"61\":1}}],[\"windows主机\",{\"1\":{\"1892\":1}}],[\"windows是my\",{\"1\":{\"1750\":1}}],[\"windows下vs是不允许定义空struct结构体的\",{\"1\":{\"1071\":1}}],[\"windows环境下\",{\"0\":{\"1029\":1}}],[\"windows会将esp和ebp初始化为0xcccccccc\",{\"1\":{\"908\":1}}],[\"windows与\",{\"1\":{\"303\":1}}],[\"windows\",{\"0\":{\"1244\":1},\"1\":{\"27\":1,\"30\":1,\"44\":1,\"45\":1,\"234\":1,\"312\":1,\"1198\":1,\"1201\":1,\"1202\":1,\"1255\":2}}],[\"windows上r模式读取linux保存的文件\",{\"1\":{\"17\":1}}],[\"windows系统使用\",{\"1\":{\"17\":1}}],[\"win\",{\"1\":{\"27\":1,\"45\":1}}],[\"wor\",{\"1\":{\"536\":1}}],[\"wordpress\",{\"1\":{\"1249\":2,\"1251\":1,\"1252\":2,\"1253\":2}}],[\"word\",{\"1\":{\"8\":2,\"49\":1}}],[\"world2\",{\"1\":{\"1165\":2}}],[\"world\",{\"1\":{\"8\":1,\"277\":2,\"405\":1,\"476\":4,\"515\":1,\"535\":4,\"536\":2,\"547\":3,\"548\":1,\"588\":1,\"662\":2,\"698\":2,\"699\":1,\"849\":1,\"852\":1,\"1123\":1,\"1158\":2,\"1164\":2,\"1173\":2,\"1271\":3,\"1361\":2}}],[\"wt文件夹用于存放模板序列\",{\"1\":{\"5\":1}}],[\"wt\",{\"1\":{\"4\":1}}],[\"这张表不用进行拆分\",{\"1\":{\"1891\":1}}],[\"这表示mycat正常监听8066和9066端口\",{\"1\":{\"1804\":1}}],[\"这依然不算commit成功\",{\"1\":{\"1763\":1}}],[\"这相当于事务没有commit成功\",{\"1\":{\"1759\":1}}],[\"这相当于把整个表给锁住了\",{\"1\":{\"1719\":1}}],[\"这条语句\",{\"1\":{\"1719\":1,\"1720\":1}}],[\"这条查询会加什么锁呢\",{\"0\":{\"1719\":1,\"1720\":1}}],[\"这条age=22的数据自然就被查到了\",{\"1\":{\"1664\":1}}],[\"这在已提交读隔离级别是允许发生的\",{\"1\":{\"1634\":1}}],[\"这在处理\",{\"1\":{\"604\":1}}],[\"这主要看是什么存储引擎\",{\"1\":{\"1624\":1}}],[\"这实际上会执行以下步骤\",{\"1\":{\"1410\":1}}],[\"这可能导致变量的值在每次引用时都可能不同\",{\"1\":{\"1357\":1}}],[\"这对于监视变量或内存地址在程序执行过程中的变化非常有用\",{\"1\":{\"1341\":1}}],[\"这对于加速链接过程很有用\",{\"1\":{\"1334\":1}}],[\"这通常可以通过运行\",{\"1\":{\"1332\":1}}],[\"这通常意味着将库文件复制到某个标准库目录\",{\"1\":{\"1332\":1}}],[\"这3种模式都定义了ndebug宏\",{\"1\":{\"1320\":1}}],[\"这3个类中都有一个同名成员函数print\",{\"1\":{\"652\":1}}],[\"这么精确\",{\"1\":{\"1219\":1}}],[\"这么写就是当前使用\",{\"1\":{\"135\":1}}],[\"这几个例子指导我们在写函数模板\",{\"1\":{\"1190\":1}}],[\"这行代码中出现了new\",{\"1\":{\"1041\":1}}],[\"这与我们的预期是有差别的\",{\"1\":{\"943\":1}}],[\"这说明\",{\"1\":{\"900\":1}}],[\"这说明了构造函数是可以\",{\"1\":{\"421\":1}}],[\"这两个参数的值需要设置大一些\",{\"1\":{\"1754\":1}}],[\"这两个属于存储引擎层的日志\",{\"1\":{\"1679\":1}}],[\"这两个目标文件添加到库中\",{\"1\":{\"1334\":1}}],[\"这两个是\",{\"1\":{\"1317\":1}}],[\"这两次操作的\",{\"1\":{\"1120\":1}}],[\"这两者不可能统一\",{\"1\":{\"876\":1}}],[\"这两种分别就是sgi\",{\"1\":{\"1079\":1}}],[\"这两种转换之间的差别是巨大的\",{\"1\":{\"628\":1}}],[\"这两种方式的效果是一样的\",{\"1\":{\"1317\":1}}],[\"这两种方式分配的都是虚拟内存\",{\"1\":{\"281\":1}}],[\"这两种方法最大的就是会出现不一致问题\",{\"1\":{\"598\":1}}],[\"这两种类型并不兼容\",{\"1\":{\"490\":1}}],[\"这和执行构造函数时的顺序正好\",{\"1\":{\"675\":1}}],[\"这意味着这些页上的修改是持久的\",{\"1\":{\"1762\":1}}],[\"这意味着你在编写c++程序时\",{\"1\":{\"608\":1}}],[\"这意味着它们不是由类的的构造函数初始化的\",{\"1\":{\"435\":1}}],[\"这部分代码按c语言的格式进行编译\",{\"1\":{\"577\":1}}],[\"这会使编译速度变得很慢\",{\"1\":{\"826\":1}}],[\"这会使得书写难度很繁琐\",{\"1\":{\"576\":1}}],[\"这会在整个项目里生效\",{\"1\":{\"293\":1}}],[\"这组函数被称为重载函数\",{\"1\":{\"560\":1}}],[\"这组数据一样可以收录到\",{\"1\":{\"135\":1}}],[\"这组数据\",{\"1\":{\"135\":2}}],[\"这完全没有必要\",{\"1\":{\"560\":1}}],[\"这时需要用到分库分表\",{\"1\":{\"1885\":1}}],[\"这时我们再增加了1行新数据\",{\"1\":{\"1682\":1}}],[\"这时可以使用\",{\"1\":{\"1318\":1}}],[\"这时就能够正常使用了\",{\"1\":{\"1029\":1}}],[\"这时\",{\"1\":{\"662\":1,\"981\":1}}],[\"这时候就需要引入数据库中间件了\",{\"1\":{\"1791\":1}}],[\"这时候是要把\",{\"1\":{\"1096\":1}}],[\"这时候\",{\"1\":{\"529\":1}}],[\"这时经过链接\",{\"1\":{\"310\":1}}],[\"这便非法内存访问了\",{\"1\":{\"523\":1}}],[\"这便证实了前面所述的\",{\"1\":{\"518\":1}}],[\"这次new\",{\"1\":{\"523\":1}}],[\"这次调出以后\",{\"1\":{\"306\":1}}],[\"这也就造成上面程序的p1不能使用的情况\",{\"1\":{\"1044\":1}}],[\"这也就不难解释\",{\"1\":{\"520\":1}}],[\"这也是为什么不喜欢用带in子查询的原因所在\",{\"1\":{\"1544\":1}}],[\"这也是为什么它放在了只读数据段中\",{\"1\":{\"915\":1}}],[\"这也是工作当中的\",{\"1\":{\"1357\":1}}],[\"这也是的方式\",{\"1\":{\"439\":1}}],[\"这其实是因为编译器用相差的这4个字节用来保存一个东西\",{\"1\":{\"520\":1}}],[\"这块空间根本就没分配\",{\"1\":{\"517\":1}}],[\"这并不代表一个空的基类也需要加一个字节到子类中去\",{\"1\":{\"470\":1}}],[\"这要与\",{\"1\":{\"463\":1}}],[\"这就相当于把student表进行水平拆分了\",{\"1\":{\"1892\":1}}],[\"这就会写到binlog里面\",{\"1\":{\"1830\":1}}],[\"这就可以让我们接下来数据恢复的操作被记录在mysql\",{\"1\":{\"1774\":1}}],[\"这就太晚了\",{\"1\":{\"1758\":1}}],[\"这就把type字段从range优化为了const\",{\"1\":{\"1739\":1}}],[\"这就意味着\",{\"1\":{\"1713\":1}}],[\"这就意味着只有通过索引检索数据\",{\"1\":{\"1700\":1}}],[\"这就决定了在\",{\"1\":{\"1706\":1}}],[\"这就导致权限不够\",{\"1\":{\"1821\":1}}],[\"这就导致代码的稳定性不太好\",{\"1\":{\"1790\":1}}],[\"这就导致事务2不能给整张表加s锁了\",{\"1\":{\"1673\":1}}],[\"这就导致效率低下的问题\",{\"1\":{\"1672\":1}}],[\"这就发生了幻读\",{\"1\":{\"1665\":1}}],[\"这就证明update做的是当前读\",{\"1\":{\"1665\":1}}],[\"这就解决了脏读问题\",{\"1\":{\"1658\":1}}],[\"这就话就error\",{\"1\":{\"368\":1}}],[\"这就是删除一个不存在的表\",{\"1\":{\"1830\":1}}],[\"这就是原子类型\",{\"1\":{\"1233\":1}}],[\"这就是动态绑定\",{\"1\":{\"954\":1}}],[\"这就是是静态绑定\",{\"1\":{\"953\":1}}],[\"这就是纯虚函数的作用\",{\"1\":{\"898\":1}}],[\"这就是菱形继承问题<\",{\"1\":{\"688\":1}}],[\"这就是引用存在的意义\",{\"1\":{\"615\":1}}],[\"这就是函数重载\",{\"1\":{\"560\":1}}],[\"这就是为什么必须初始化\",{\"1\":{\"484\":1}}],[\"这就是一套方法能知道处理哪个对象的原因\",{\"1\":{\"392\":1}}],[\"这就是编译器的类库目录\",{\"1\":{\"312\":1}}],[\"这就是\",{\"1\":{\"301\":1}}],[\"这2个数值表示一个进程自启动以来所发生的缺页中断的次数\",{\"1\":{\"289\":1}}],[\"这些新增加的连接都没有被再次使用过\",{\"1\":{\"1865\":1}}],[\"这些日志都是需要有的\",{\"1\":{\"1767\":1}}],[\"这些redo\",{\"1\":{\"1762\":1}}],[\"这些节点都不在一个磁盘块上\",{\"1\":{\"1622\":1}}],[\"这些默认配置都在mysql的配置文件中可以修改\",{\"1\":{\"1555\":1}}],[\"这些语句定义了数据库\",{\"1\":{\"1548\":1}}],[\"这些语句定义了不同的数据库\",{\"1\":{\"1548\":1}}],[\"这些限制逻辑或者代码逻辑是由mysql本身控制的\",{\"1\":{\"1437\":1}}],[\"这些操作需要线程2把另外一部分事情做完\",{\"1\":{\"1218\":1}}],[\"这些函数对象\",{\"1\":{\"1161\":1}}],[\"这些函数在编译过程中会产生this指针来接收所传入函数的地址\",{\"1\":{\"392\":1}}],[\"这些都是通用的api接口\",{\"1\":{\"830\":1}}],[\"这些模式关注类和对象的组合\",{\"1\":{\"829\":1}}],[\"这些异常\",{\"1\":{\"600\":1}}],[\"这些程序设计语言可以归纳为以下几类\",{\"1\":{\"445\":1}}],[\"这些接口有差异\",{\"1\":{\"303\":1}}],[\"这些接口均为每一个操作系统独有的\",{\"1\":{\"303\":1}}],[\"这些接口使得应用程序能够更方便地访问和操作系统提供的各种功能\",{\"1\":{\"16\":1}}],[\"这些块怎么管理呢\",{\"1\":{\"285\":1}}],[\"这些空宏会给出警告\",{\"1\":{\"276\":1}}],[\"这段代码中大括号后多了一个分号\",{\"1\":{\"274\":1}}],[\"这展开存在两个问题\",{\"1\":{\"273\":1}}],[\"这将打开一个新的窗口\",{\"1\":{\"261\":1}}],[\"这一块是在连接池启动的时候做的\",{\"1\":{\"1839\":1,\"1849\":1,\"1859\":1,\"1875\":1}}],[\"这一步配置主要是给io线程读取binlog使用\",{\"1\":{\"1825\":1}}],[\"这一步是确保事务持久性的关键\",{\"1\":{\"1762\":1}}],[\"这一点不同于其他函数\",{\"1\":{\"504\":1}}],[\"这一过程被称为还原现场之后通过ret返回上一个函数\",{\"1\":{\"235\":1}}],[\"这一行代码\",{\"1\":{\"136\":1}}],[\"这个功能点肯定需要放在独立的线程中去做\",{\"1\":{\"1866\":1}}],[\"这个功能主要用在下面的情况\",{\"1\":{\"577\":1}}],[\"这个drop操作不需要在从库上同步\",{\"1\":{\"1830\":1}}],[\"这个日志记录了mysql\",{\"1\":{\"1810\":1}}],[\"这个逻辑库userdb对应的就是真实库mytest\",{\"1\":{\"1809\":1}}],[\"这个逻辑库看起来好像在mycat一台机器上\",{\"1\":{\"1802\":1}}],[\"这个节点对应具体的物理机器叫datahost\",{\"1\":{\"1803\":1}}],[\"这个库或者表的内容放在哪个节点\",{\"1\":{\"1803\":1}}],[\"这个库最终会映射到mysql\",{\"1\":{\"1802\":1}}],[\"这个库其实是不存在的\",{\"1\":{\"1802\":1}}],[\"这个端口也是可以改的\",{\"1\":{\"1792\":1}}],[\"这个过程是异步的\",{\"1\":{\"1762\":1}}],[\"这个过程也被称为解包\",{\"1\":{\"377\":1}}],[\"这个值是可以修改的\",{\"1\":{\"1776\":1}}],[\"这个值设的越高\",{\"1\":{\"1752\":1}}],[\"这个值都会被更新\",{\"1\":{\"1344\":1}}],[\"这个参数定义了innodb存储引擎的表数据和索引数据的最大内存缓冲区大小\",{\"1\":{\"1752\":1}}],[\"这个版本的数据放到了undo\",{\"1\":{\"1682\":1}}],[\"这个事务把book\",{\"1\":{\"1681\":2}}],[\"这个事务id都不会改变\",{\"1\":{\"1681\":1}}],[\"这个地址表示的是一个数据的内存的位置\",{\"1\":{\"1681\":1}}],[\"这个是我们创建表的时候\",{\"1\":{\"1681\":1}}],[\"这个是因为英特尔的\",{\"1\":{\"307\":1}}],[\"这个级别仍然允许不可重复读和幻读产生\",{\"1\":{\"1677\":1}}],[\"这个并不是\",{\"1\":{\"1656\":1}}],[\"这个标志表示已经成功进入mysql命令行界面\",{\"1\":{\"1407\":1}}],[\"这个在命令工具中使用不同\",{\"1\":{\"1376\":1}}],[\"这个表达式的值\",{\"1\":{\"1345\":1}}],[\"这个表示ipv6的21号端口的意思\",{\"1\":{\"1239\":1}}],[\"这个命令将显示内存地址\",{\"1\":{\"1344\":1}}],[\"这个保持和自动情况下一致即可\",{\"1\":{\"1278\":1}}],[\"这个子线程就从这个main分离出去了\",{\"1\":{\"1207\":1}}],[\"这个还没有实例化\",{\"1\":{\"1147\":1}}],[\"这个仓库有大量的vim配色文件\",{\"1\":{\"1143\":1}}],[\"这个临时对象才析构\",{\"1\":{\"1113\":1}}],[\"这个临时对象也是要生成的\",{\"1\":{\"1113\":1}}],[\"这个临时对象肯定是要生成的\",{\"1\":{\"1113\":1}}],[\"这个临时对象肯定要构造生成的\",{\"1\":{\"1111\":1}}],[\"这个临时变量是可以进行取地址操作的\",{\"1\":{\"620\":1}}],[\"这个备用可以给当前字节数使用\",{\"1\":{\"1105\":1}}],[\"这个可以看成节点的next域\",{\"1\":{\"1082\":1}}],[\"这个特性\",{\"1\":{\"1063\":1}}],[\"这个智能指针不能析构这个资源\",{\"1\":{\"1054\":1}}],[\"这个智能指针不使用这个资源了\",{\"1\":{\"1054\":1}}],[\"这个资源的引用计数就减1\",{\"1\":{\"1054\":1}}],[\"这个资源相应的引用计数就加1\",{\"1\":{\"1054\":1}}],[\"这个类型的整体描述\",{\"1\":{\"1239\":1}}],[\"这个类生成的对象就有vfptr\",{\"1\":{\"933\":1}}],[\"这个类的对象的成员变量有占用外部资源\",{\"1\":{\"404\":1}}],[\"这个原因很简单\",{\"1\":{\"876\":1}}],[\"这个叫添加适配器类\",{\"1\":{\"832\":1}}],[\"这个叫做重载\",{\"1\":{\"370\":1}}],[\"这个就叫代码重构\",{\"1\":{\"832\":1}}],[\"这个头文件里面涉及到的所有的头文件\",{\"1\":{\"826\":1}}],[\"这个头文件\",{\"1\":{\"826\":1}}],[\"这个操作在多数情况下只需要构造而没有分配内存的操作\",{\"1\":{\"751\":1}}],[\"这个另外的函数抛出了异常\",{\"1\":{\"601\":1}}],[\"这个另外的函数中发生了异常\",{\"1\":{\"600\":1}}],[\"这个异常可以由程序员处理\",{\"1\":{\"597\":1}}],[\"这个extern\",{\"1\":{\"570\":1}}],[\"这个重载函数啊\",{\"1\":{\"528\":1}}],[\"这个重载函数\",{\"1\":{\"528\":1}}],[\"这个时候c++\",{\"1\":{\"529\":1}}],[\"这个时候危险了\",{\"1\":{\"528\":1}}],[\"这个时候我们可以使用do\",{\"1\":{\"277\":1}}],[\"这个函数在a\",{\"1\":{\"528\":1}}],[\"这个细节虽然不会影响函数的功能\",{\"1\":{\"504\":1}}],[\"这个空间大小不会随编号的位数改变而改变\",{\"1\":{\"308\":1}}],[\"这个宏的本意是\",{\"1\":{\"273\":1}}],[\"这个设置仅对\",{\"1\":{\"239\":1}}],[\"这个选项用于混合显示源代码和反汇编代码\",{\"1\":{\"228\":1}}],[\"这个选项用于反汇编目标\",{\"1\":{\"228\":1}}],[\"这个软件尤其是对做基因编辑方向的同学简直就是福音感觉有用的同学请不吝fork\",{\"1\":{\"3\":1}}],[\"这种锁机制就是所谓的间隙锁\",{\"1\":{\"1686\":1}}],[\"这种通过\",{\"1\":{\"1656\":1}}],[\"这种修改只对当前会话session有效\",{\"1\":{\"1652\":1}}],[\"这种代码的特性在于没有绝对跳转\",{\"1\":{\"1333\":1}}],[\"这种方法有点麻烦\",{\"1\":{\"1318\":1}}],[\"这种方式本身就线程安全\",{\"1\":{\"844\":1}}],[\"这种方式\",{\"1\":{\"843\":1}}],[\"这种方式会显得比较冗余\",{\"1\":{\"589\":1}}],[\"这种写法\",{\"1\":{\"1315\":1}}],[\"这种能派生新类\",{\"1\":{\"900\":1}}],[\"这种数据结构\",{\"1\":{\"784\":1}}],[\"这种转换的安全性也要开发人员来保证\",{\"1\":{\"629\":1}}],[\"这种错误可以通过调试来解决\",{\"1\":{\"597\":1}}],[\"这种情况即为\",{\"1\":{\"1736\":1}}],[\"这种情况在菱形继承中非常明显\",{\"1\":{\"943\":1}}],[\"这种情况是线程不安全的\",{\"1\":{\"846\":1}}],[\"这种情况下的排序称为外排序\",{\"1\":{\"1525\":1}}],[\"这种情况下\",{\"1\":{\"470\":1,\"615\":1,\"1808\":1}}],[\"这种情况的处理\",{\"1\":{\"96\":1}}],[\"这种格式会或\",{\"1\":{\"457\":1}}],[\"这种就是类型参数\",{\"1\":{\"371\":1}}],[\"这种\",{\"1\":{\"353\":1}}],[\"这种三元组\",{\"1\":{\"136\":1}}],[\"这种去重其实对提升程序运行效率是没有帮助的\",{\"1\":{\"136\":1}}],[\"这样sql线程就不用和dump线程进行读写同步了\",{\"1\":{\"1783\":1}}],[\"这样对比每条记录的trx\",{\"1\":{\"1656\":1}}],[\"这样对于下面的test\",{\"1\":{\"1321\":1}}],[\"这样每一行记录搜索的\",{\"1\":{\"1626\":1}}],[\"这样一个b\",{\"1\":{\"1623\":1}}],[\"这样一来\",{\"1\":{\"861\":1}}],[\"这样数据就不一致了\",{\"1\":{\"1464\":1}}],[\"这样在mysql中就可以进行自动联想功能\",{\"1\":{\"1410\":1}}],[\"这样在程序中就会出现名字冲突\",{\"1\":{\"582\":1}}],[\"这样会对程序的目录结构造成污染\",{\"1\":{\"1319\":1}}],[\"这样会大大提高函数的时空效率\",{\"1\":{\"615\":1}}],[\"这样当执行\",{\"1\":{\"1315\":1}}],[\"这样方便查找\",{\"1\":{\"1313\":1}}],[\"这样多ip计算机就不用重复显示了\",{\"1\":{\"1239\":1}}],[\"这样写即使字段顺序不一致也无所谓\",{\"1\":{\"1475\":1}}],[\"这样写数据和字段\",{\"1\":{\"1475\":1}}],[\"这样写虽然解决了内存泄漏问题\",{\"1\":{\"1122\":1}}],[\"这样写会导致test\",{\"1\":{\"568\":1}}],[\"这样必然可以极大的提高效率\",{\"1\":{\"1121\":1}}],[\"这样可以避免对并发插入的影响\",{\"1\":{\"1724\":1}}],[\"这样可以避免其他事务执行增\",{\"1\":{\"1721\":1}}],[\"这样可以大大减少死锁的机会\",{\"1\":{\"1724\":1}}],[\"这样可以\",{\"1\":{\"1116\":1}}],[\"这样调用时\",{\"1\":{\"637\":1}}],[\"这样才是正确使用reinterpret\",{\"1\":{\"632\":1}}],[\"这样做减少了函数名的数量\",{\"1\":{\"560\":1}}],[\"这样最早的代码是这样的\",{\"1\":{\"529\":1}}],[\"这样用开起来别扭\",{\"1\":{\"528\":1}}],[\"这样就不用指定路径\",{\"1\":{\"1800\":1}}],[\"这样就不会出错了\",{\"1\":{\"795\":1}}],[\"这样就实现了从库内容和主库内容的同步\",{\"1\":{\"1783\":1}}],[\"这样就能防止幻读发生\",{\"1\":{\"1688\":1}}],[\"这样就可以编译出\",{\"1\":{\"1318\":1}}],[\"这样就没意义了\",{\"1\":{\"1041\":1}}],[\"这样就会造成\",{\"1\":{\"949\":1}}],[\"这样就会导致编译错误\",{\"1\":{\"423\":1}}],[\"这样就保证虚基类的唯一副本只被初始化一次\",{\"1\":{\"891\":1}}],[\"这样就有了类似上面的代码来定义null\",{\"1\":{\"527\":1}}],[\"这样的命令时\",{\"1\":{\"1334\":1}}],[\"这样的话\",{\"1\":{\"1586\":1}}],[\"这样的话各种配件\",{\"1\":{\"867\":1}}],[\"这样的话栈空间肯定会溢出的\",{\"1\":{\"399\":1}}],[\"这样的设计使得代码很难维护\",{\"1\":{\"861\":1}}],[\"这样的情况下也会有用到\",{\"1\":{\"577\":1}}],[\"这样的用法同样不会表现出什么问题\",{\"1\":{\"524\":1}}],[\"这样的成员在\",{\"1\":{\"435\":1}}],[\"这样编译器就存在可能去优化代码\",{\"1\":{\"378\":1}}],[\"这样模板才能够正常实例化\",{\"1\":{\"363\":1}}],[\"这样下次调用malloc\",{\"1\":{\"285\":1}}],[\"这样子做主要是因为\",{\"1\":{\"284\":1}}],[\"这样宏在预处理的时候会直接被展开\",{\"1\":{\"273\":1}}],[\"这样\",{\"1\":{\"135\":1,\"593\":1,\"1631\":1,\"1783\":1}}],[\"这不都一样吗\",{\"1\":{\"135\":1}}],[\"这里需要自定义shared\",{\"1\":{\"1849\":1,\"1859\":1,\"1872\":1}}],[\"这里需要注意\",{\"1\":{\"458\":1}}],[\"这里设置的用户\",{\"1\":{\"1802\":1}}],[\"这里加的是共享锁\",{\"1\":{\"1689\":1}}],[\"这里显示const\",{\"1\":{\"1618\":1}}],[\"这里显示null\",{\"1\":{\"1618\":1}}],[\"这里以5\",{\"0\":{\"1395\":1}}],[\"这里使用lambda表达式\",{\"1\":{\"1870\":1}}],[\"这里使用了\",{\"1\":{\"1318\":1}}],[\"这里使用了两个\",{\"1\":{\"848\":1}}],[\"这里使用互斥锁存在的问题\",{\"1\":{\"1232\":1}}],[\"这里模拟生产者生产10个物品\",{\"1\":{\"1219\":2}}],[\"这里会做\",{\"1\":{\"1120\":1}}],[\"这里\",{\"1\":{\"1115\":1,\"1345\":1}}],[\"这里剩余的内存必然为8的整数倍\",{\"1\":{\"1102\":1}}],[\"这里是在服务器应用线程中调用的\",{\"1\":{\"1849\":1,\"1859\":1,\"1870\":1,\"1872\":1}}],[\"这里是\",{\"1\":{\"1030\":1}}],[\"这里已经安装成功\",{\"1\":{\"1015\":1}}],[\"这里就体现出虚函数的作用了\",{\"1\":{\"913\":1}}],[\"这里就要识别\",{\"1\":{\"631\":1}}],[\"这里的user和student都是实际存在的物理表名\",{\"1\":{\"1891\":1}}],[\"这里的覆盖指的是中相应被覆盖\",{\"1\":{\"913\":1}}],[\"这里的迭代器在第一次insert之后\",{\"1\":{\"743\":1}}],[\"这里必须是非成员函数才可以\",{\"1\":{\"784\":1}}],[\"这里要判断是否遍历完成\",{\"1\":{\"784\":1}}],[\"这里不要写成\",{\"1\":{\"774\":1}}],[\"这里我把休眠时间挪到解锁之后\",{\"1\":{\"1209\":1}}],[\"这里我们重点关注\",{\"1\":{\"1719\":1}}],[\"这里我们只讲述vector中的push\",{\"1\":{\"1127\":1}}],[\"这里我们的对象a占4个字节\",{\"1\":{\"934\":1}}],[\"这里我们就要用到\",{\"1\":{\"784\":1}}],[\"这里我们未考虑扩容\",{\"1\":{\"747\":1}}],[\"这里我会使用百度脑图作为演示\",{\"1\":{\"58\":1}}],[\"这里直接push省去mov\",{\"1\":{\"638\":1}}],[\"这里为整型常量的地址\",{\"1\":{\"630\":1}}],[\"这里仅仅调用一次析构函数就好了\",{\"1\":{\"523\":1}}],[\"这里主要讨论如何为对象和对象数组动态分配内存\",{\"1\":{\"459\":1}}],[\"这里只是简单实现以下vector容器\",{\"1\":{\"355\":1}}],[\"这里列出避免大家后面命名变量名时\",{\"1\":{\"296\":1}}],[\"这里也是delete\",{\"1\":{\"224\":1}}],[\"这里无法停止\",{\"1\":{\"101\":1}}],[\"这功能可能不太大众\",{\"1\":{\"59\":1}}],[\"这是mysqld路径\",{\"1\":{\"1820\":1}}],[\"这是高并发场景下常用的一种优化手段\",{\"1\":{\"1745\":1}}],[\"这是为什么\",{\"1\":{\"1700\":1}}],[\"这是不能允许的\",{\"1\":{\"1693\":1}}],[\"这是不同的\",{\"1\":{\"463\":1}}],[\"这是因为\",{\"1\":{\"1693\":1,\"1706\":1}}],[\"这是因为我们插入的数据id是自增的\",{\"1\":{\"1689\":1}}],[\"这是因为在串行化隔离级别中\",{\"1\":{\"1688\":1}}],[\"这是因为c++的链接规范与c的规范在很多方面是相似的\",{\"1\":{\"578\":1}}],[\"这是因为c++编译器通常能够正确处理c语言的函数声明\",{\"1\":{\"578\":1}}],[\"这是因为c风格字符串不仅使用起来不太方便\",{\"1\":{\"536\":1}}],[\"这是存储引擎来保证的\",{\"1\":{\"1650\":1}}],[\"这是由各种锁机制以及事务并发的mvcc版本控制实现的\",{\"1\":{\"1634\":1}}],[\"这是由于字符串是以\",{\"1\":{\"1878\":1}}],[\"这是由于vector<auto\",{\"1\":{\"1045\":1}}],[\"这是由于\",{\"1\":{\"470\":2}}],[\"这是怎么做到的呢\",{\"1\":{\"913\":1}}],[\"这是定义\",{\"1\":{\"574\":1}}],[\"这是赋值语句\",{\"1\":{\"432\":1}}],[\"这是\",{\"1\":{\"251\":1}}],[\"这是会还原上面保存的寄存器值\",{\"1\":{\"235\":1}}],[\"这是侧边栏的顺序\",{\"1\":{\"45\":1}}],[\"这是页面的图标\",{\"1\":{\"45\":1}}],[\"这是文章的标题\",{\"1\":{\"45\":1}}],[\"这是一辆奔驰汽车\",{\"1\":{\"831\":1}}],[\"这是一辆奥迪汽车\",{\"1\":{\"831\":1}}],[\"这是一辆宝马汽车\",{\"1\":{\"831\":1}}],[\"这是一个公共的头文件\",{\"1\":{\"1845\":1,\"1856\":1}}],[\"这是一个内存缓存\",{\"1\":{\"1762\":1}}],[\"这是一个空容器\",{\"1\":{\"382\":1}}],[\"这是一个非常细节的思考过程\",{\"1\":{\"135\":1}}],[\"这是一个基因序列比对工具\",{\"1\":{\"3\":1}}],[\"这是一组由ieee制定的标准簇\",{\"1\":{\"16\":1}}],[\"虽然可以继续使用root账号\",{\"1\":{\"1821\":1}}],[\"虽然数据的安全性提高了\",{\"1\":{\"1712\":1}}],[\"虽然我们在linux上查看的ip地址是192\",{\"1\":{\"1821\":1}}],[\"虽然我们where后面的字段现在使用的id而不是name\",{\"1\":{\"1701\":1}}],[\"虽然我觉得qq邮箱无所谓\",{\"1\":{\"0\":1}}],[\"虽然不影响上述sql执行结果\",{\"1\":{\"1693\":1}}],[\"虽然不需要恢复也能通过测试用例\",{\"1\":{\"756\":1}}],[\"虽然看不到\",{\"1\":{\"1635\":1}}],[\"虽然索引大大提高了查询的速度\",{\"1\":{\"1609\":1}}],[\"虽然链式哈希表的桶看起来有顺序\",{\"1\":{\"1603\":1}}],[\"虽然explain查看执行计划显示全文扫描\",{\"1\":{\"1522\":1}}],[\"虽然group\",{\"1\":{\"1512\":1}}],[\"虽然构造函数不能被定义成虚函数\",{\"1\":{\"946\":1}}],[\"虽然总的时间复杂度为\",{\"1\":{\"802\":1}}],[\"虽然没问题\",{\"1\":{\"618\":1}}],[\"虽然未加\",{\"1\":{\"578\":1}}],[\"虽然都是指向int类型的指针\",{\"1\":{\"563\":1}}],[\"虽然第二个函数的参数中包含了const修饰符\",{\"1\":{\"563\":1}}],[\"虽然上面我们说明了0比null可以让我们更加警觉\",{\"1\":{\"529\":1}}],[\"虽然c语言为我们提供了calloc来开辟一段初始化好\",{\"1\":{\"509\":1}}],[\"虽然有逻辑错误\",{\"1\":{\"597\":1}}],[\"虽然有这么多好处\",{\"1\":{\"500\":1}}],[\"虽然有很多优秀的软件能做双序列比对\",{\"1\":{\"3\":1}}],[\"虽然灵活\",{\"1\":{\"359\":1}}],[\"虽然也有类型\",{\"1\":{\"359\":1}}],[\"虽然\",{\"1\":{\"312\":1}}],[\"mvcc是已提交读和可重复读的原理\",{\"1\":{\"1712\":1}}],[\"mvcc是多版本并发控制\",{\"1\":{\"1656\":1}}],[\"mvcc机制会对这张表增加2列\",{\"1\":{\"1682\":1}}],[\"mvcc机制会生成一个数据请求时间点的一致性数据快照\",{\"1\":{\"1656\":1}}],[\"mvcc会给我们创建的表增加2个列\",{\"1\":{\"1681\":1}}],[\"mvcc提供了一种并发的读取方式\",{\"1\":{\"1677\":1}}],[\"mvcc应用于可重复读隔离级别\",{\"0\":{\"1661\":1}}],[\"mvcc应用于已提交读隔离级别\",{\"0\":{\"1657\":1}}],[\"mvcc概念\",{\"0\":{\"1656\":1}}],[\"mvcc多版本并发控制中\",{\"1\":{\"1656\":1}}],[\"mvcc多版本并发控制\",{\"0\":{\"1655\":1},\"1\":{\"1656\":1,\"1658\":2,\"1660\":1,\"1663\":2,\"1664\":2,\"1665\":5}}],[\"mvcc\",{\"1\":{\"1645\":1,\"1656\":2,\"1665\":2,\"1677\":1,\"1679\":1,\"1717\":1},\"2\":{\"1667\":1,\"1684\":1}}],[\"mv\",{\"1\":{\"1332\":1}}],[\"m=3\",{\"1\":{\"1321\":1}}],[\"mkdir\",{\"1\":{\"1299\":4}}],[\"m或\",{\"1\":{\"1237\":1}}],[\"mtx\",{\"1\":{\"1209\":7,\"1210\":2,\"1219\":7,\"1225\":3,\"1226\":4,\"1227\":2,\"1232\":2}}],[\"m2是我们配置的备用的第二套写库\",{\"1\":{\"1808\":1}}],[\"m2叫做stand\",{\"1\":{\"1803\":1}}],[\"m2位置是main函数上临时对象给str2拷贝赋值\",{\"1\":{\"1120\":1}}],[\"m2\",{\"1\":{\"1120\":1}}],[\"m1挂了\",{\"1\":{\"1814\":1}}],[\"m1叫做writehost\",{\"1\":{\"1803\":1}}],[\"m1位置处\",{\"1\":{\"1120\":1}}],[\"m1\",{\"1\":{\"1120\":1}}],[\"mp\",{\"1\":{\"1909\":2}}],[\"mprefcnt\",{\"1\":{\"1055\":11}}],[\"mptr\",{\"1\":{\"1041\":3,\"1055\":3,\"1120\":17,\"1121\":7,\"1122\":6,\"1123\":43}}],[\"m+n\",{\"1\":{\"771\":1}}],[\"mslave\",{\"1\":{\"1821\":3,\"1825\":1,\"1828\":1,\"1829\":1}}],[\"msl\",{\"1\":{\"1240\":1}}],[\"msg\",{\"1\":{\"871\":8,\"1032\":40,\"1902\":2,\"1903\":2,\"1904\":3,\"1907\":4,\"1908\":2}}],[\"msgid\",{\"1\":{\"871\":18}}],[\"ms\",{\"1\":{\"751\":1,\"1851\":2}}],[\"mf\",{\"1\":{\"684\":1}}],[\"mcount++\",{\"1\":{\"1055\":1}}],[\"mcount\",{\"1\":{\"1055\":5}}],[\"mc\",{\"1\":{\"684\":1,\"688\":4}}],[\"mcb\",{\"1\":{\"286\":9,\"287\":3}}],[\"mb再初始化即10\",{\"1\":{\"422\":1}}],[\"mb\",{\"1\":{\"413\":3,\"422\":5,\"667\":4,\"684\":1,\"688\":4,\"919\":2,\"934\":1,\"948\":4,\"953\":2,\"954\":2,\"1114\":6,\"1173\":4,\"1183\":4}}],[\"mreal++\",{\"1\":{\"731\":2}}],[\"mreal\",{\"1\":{\"731\":14}}],[\"mr\",{\"1\":{\"234\":1}}],[\"m32指定编译为32位程序\",{\"1\":{\"234\":1,\"1327\":1}}],[\"m32\",{\"1\":{\"234\":2,\"1327\":1}}],[\"mytest2中的两张表\",{\"1\":{\"1892\":1}}],[\"mytest2\",{\"1\":{\"1888\":1,\"1891\":1}}],[\"mytest1和mytest2分成了不同机器上的不同的库\",{\"1\":{\"1888\":1}}],[\"mytest1\",{\"1\":{\"1888\":1,\"1891\":1}}],[\"mytest\",{\"1\":{\"1830\":2}}],[\"myi\",{\"1\":{\"1623\":1}}],[\"myi文件中\",{\"1\":{\"1558\":1}}],[\"myisam和innodb\",{\"0\":{\"1626\":1}}],[\"myisam数据和索引分开存储\",{\"1\":{\"1624\":1}}],[\"myisam\",{\"1\":{\"1610\":1,\"1623\":1,\"1706\":2,\"1881\":1}}],[\"myisam支持表级锁和全文索引\",{\"1\":{\"1557\":1}}],[\"myisam的一张表分为了\",{\"1\":{\"1557\":1}}],[\"myi三个文件\",{\"1\":{\"1557\":1}}],[\"myd\",{\"1\":{\"1557\":1,\"1623\":1}}],[\"mydebug\",{\"1\":{\"1318\":2}}],[\"mydeletor<int>>\",{\"1\":{\"1060\":1}}],[\"mydeletor\",{\"1\":{\"1060\":2}}],[\"myadd\",{\"1\":{\"1315\":3,\"1316\":7}}],[\"mybind1st<compare\",{\"1\":{\"1148\":2}}],[\"mybind1st就是将函数对象封装了一下\",{\"1\":{\"1148\":1}}],[\"mybind1st\",{\"1\":{\"1148\":5}}],[\"myfiledeletor<file>>\",{\"1\":{\"1060\":1}}],[\"myfiledeletor\",{\"1\":{\"1060\":2}}],[\"myfunction<int\",{\"1\":{\"1158\":1}}],[\"myfunction<r\",{\"1\":{\"1158\":3}}],[\"myfunction\",{\"1\":{\"607\":8,\"1158\":4}}],[\"mylib\",{\"1\":{\"1331\":4,\"1332\":1}}],[\"mylinkedlist\",{\"1\":{\"791\":5,\"792\":5}}],[\"mylog\",{\"1\":{\"1032\":1}}],[\"myless<int>\",{\"1\":{\"981\":1,\"982\":1}}],[\"myless\",{\"1\":{\"981\":1,\"982\":1}}],[\"mygreater<int>\",{\"1\":{\"981\":1,\"982\":1}}],[\"mygreater\",{\"1\":{\"981\":1,\"982\":1}}],[\"mycount++\",{\"1\":{\"1233\":1}}],[\"mycount\",{\"1\":{\"1233\":3}}],[\"mycat会根据配置在两个库上查询并进行数据合并\",{\"1\":{\"1892\":1}}],[\"mycat操作的逻辑表user会影响linux主机上的物理表\",{\"1\":{\"1892\":1}}],[\"mycat=\",{\"1\":{\"1888\":1,\"1891\":1}}],[\"mycat提供的分表算法都在rule\",{\"1\":{\"1886\":1}}],[\"mycat就是云db\",{\"1\":{\"1809\":1}}],[\"mycat就是反向代理服务器\",{\"1\":{\"1791\":1}}],[\"mycat需要进行容灾切换\",{\"1\":{\"1803\":1}}],[\"mycat定时发送指定语句给mysql\",{\"1\":{\"1803\":1}}],[\"mycat内置连接池的最大\",{\"1\":{\"1803\":1}}],[\"mycat还有一个管理端口9066\",{\"1\":{\"1792\":1}}],[\"mycat还可以马上把一个从库\",{\"1\":{\"1791\":1}}],[\"mycat服务端口是8066\",{\"1\":{\"1792\":1}}],[\"mycat服务端口和管理端口\",{\"0\":{\"1792\":1}}],[\"mycat服务器挂了两套环境\",{\"1\":{\"1791\":1}}],[\"mycategory\",{\"1\":{\"1032\":14}}],[\"mycat\",{\"0\":{\"1807\":1},\"1\":{\"1031\":1,\"1791\":1,\"1800\":4,\"1805\":1,\"1806\":1,\"1886\":1,\"1888\":3,\"1891\":3}}],[\"mycmp>\",{\"1\":{\"784\":1}}],[\"mycmp\",{\"1\":{\"784\":1}}],[\"myclass\",{\"1\":{\"423\":2}}],[\"myexp\",{\"1\":{\"606\":4}}],[\"myexception\",{\"1\":{\"606\":9}}],[\"mysub\",{\"1\":{\"1315\":3}}],[\"mystrq\",{\"1\":{\"1020\":3}}],[\"mystruct\",{\"1\":{\"594\":1,\"1346\":3}}],[\"mystruct1\",{\"1\":{\"557\":2}}],[\"mystructss\",{\"1\":{\"557\":3}}],[\"mystructgg\",{\"1\":{\"557\":3}}],[\"mystructa\",{\"1\":{\"557\":1}}],[\"mystructdd\",{\"1\":{\"557\":3}}],[\"mystructee\",{\"1\":{\"557\":3}}],[\"mystructff\",{\"1\":{\"557\":3}}],[\"mystruct2\",{\"1\":{\"557\":3}}],[\"mystructxx\",{\"1\":{\"557\":3}}],[\"mysql拓展\",{\"2\":{\"1883\":1,\"1894\":1}}],[\"mysql数据库编程\",{\"1\":{\"1863\":1}}],[\"mysql数据恢复分为两部分\",{\"1\":{\"1775\":1}}],[\"mysql数据恢复小结\",{\"0\":{\"1775\":1}}],[\"mysql连接池\",{\"2\":{\"1841\":1,\"1853\":1,\"1858\":1,\"1861\":1,\"1868\":1,\"1874\":1,\"1877\":1,\"1880\":1}}],[\"mysql连接对象\",{\"1\":{\"1383\":1}}],[\"mysql登录密码\",{\"1\":{\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"mysql登录用户名\",{\"1\":{\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"mysql主从同步配置字符集问题解决\",{\"1\":{\"1828\":1}}],[\"mysql集群\",{\"2\":{\"1788\":1,\"1794\":1,\"1816\":1,\"1835\":1}}],[\"mysqlbinlog\",{\"1\":{\"1773\":1,\"1774\":2,\"1828\":1}}],[\"mysql原生自带\",{\"1\":{\"1772\":1}}],[\"mysql下\",{\"1\":{\"1758\":1}}],[\"mysql重做日志redo\",{\"0\":{\"1757\":1},\"1\":{\"1758\":4,\"1759\":1}}],[\"mysql线程缓存\",{\"0\":{\"1753\":1}}],[\"mysql查询缓存\",{\"0\":{\"1749\":1}}],[\"mysql优化\",{\"2\":{\"1742\":1,\"1756\":1}}],[\"mysql优化之慢日志查询\",{\"0\":{\"1572\":1}}],[\"mysql4\",{\"1\":{\"1736\":1}}],[\"mysql中有两种排序方式\",{\"1\":{\"1736\":1}}],[\"mysql就不会去使用索引\",{\"1\":{\"1713\":1}}],[\"mysql间隙锁\",{\"0\":{\"1685\":1}}],[\"mysql回滚日志undo\",{\"0\":{\"1676\":1},\"1\":{\"1677\":2,\"1681\":4,\"1682\":4}}],[\"mysql锁机制\",{\"2\":{\"1675\":1,\"1696\":1,\"1704\":1,\"1710\":1,\"1715\":1,\"1723\":1,\"1726\":1}}],[\"mysql意向共享锁\",{\"0\":{\"1668\":1}}],[\"mysql默认工作级别\",{\"1\":{\"1677\":1}}],[\"mysql默认\",{\"1\":{\"1631\":1}}],[\"mysql支持的四种隔离级别是\",{\"1\":{\"1631\":1}}],[\"mysql支持两种索引\",{\"1\":{\"1623\":1}}],[\"mysql事务的隔离级别\",{\"0\":{\"1630\":1}}],[\"mysql端口号的查看\",{\"0\":{\"1616\":1}}],[\"mysql函数调用\",{\"1\":{\"1615\":1}}],[\"mysql做了如下优化\",{\"1\":{\"1592\":1}}],[\"mysql日志是在mysql\",{\"1\":{\"1767\":1}}],[\"mysql日志\",{\"2\":{\"1584\":1,\"1667\":1,\"1684\":1,\"1765\":1,\"1778\":1}}],[\"mysql一般只显示小数点后两位的时间\",{\"1\":{\"1582\":1}}],[\"mysql定义的很多的全局的开关\",{\"1\":{\"1574\":1}}],[\"mysql可以设置慢查询日志\",{\"1\":{\"1573\":1,\"1776\":1}}],[\"mysql索引常见问题\",{\"0\":{\"1585\":1}}],[\"mysql索引\",{\"1\":{\"1747\":1},\"2\":{\"1568\":1,\"1571\":1,\"1597\":1,\"1606\":1,\"1612\":1,\"1620\":1,\"1629\":1}}],[\"mysql存储引擎\",{\"0\":{\"1555\":1},\"2\":{\"1561\":1}}],[\"mysql8\",{\"0\":{\"1527\":1,\"1529\":1,\"1751\":1},\"1\":{\"1592\":1,\"1594\":1}}],[\"mysql核心sql\",{\"2\":{\"1483\":1,\"1488\":1,\"1504\":1,\"1510\":1,\"1533\":1,\"1546\":1,\"1550\":1,\"1554\":1}}],[\"mysql运算符\",{\"0\":{\"1468\":1}}],[\"mysql区别于其他关系型数据库的特点\",{\"0\":{\"1453\":1}}],[\"mysql是查找名字为\",{\"1\":{\"1518\":1}}],[\"mysql是如何查询的\",{\"0\":{\"1518\":1}}],[\"mysql是基于c\",{\"1\":{\"1452\":1}}],[\"mysql是上一步mysql\",{\"1\":{\"1374\":1}}],[\"mysql作者担心mysql收购后收费写的\",{\"1\":{\"1452\":1}}],[\"mysql基础\",{\"1\":{\"1610\":1},\"2\":{\"1419\":1,\"1430\":1,\"1439\":1,\"1446\":1,\"1449\":1,\"1457\":1,\"1467\":1,\"1473\":1}}],[\"mysql的端口号\",{\"1\":{\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"mysql的ip地址\",{\"1\":{\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"mysql的root账户有远程访问权限\",{\"1\":{\"1796\":1}}],[\"mysql的服务端口是3306\",{\"1\":{\"1792\":1}}],[\"mysql的服务模型是\",{\"0\":{\"1454\":1}}],[\"mysql的查询缓存是把上一次select的查询结果记录下来放在缓存当中\",{\"1\":{\"1749\":1}}],[\"mysql的一大优点就是插件式存储引擎\",{\"1\":{\"1555\":1}}],[\"mysql的表操作\",{\"0\":{\"1551\":1}}],[\"mysql的库操作\",{\"0\":{\"1505\":1}}],[\"mysql的停止\",{\"1\":{\"1409\":1}}],[\"mysql的启动\",{\"1\":{\"1409\":1}}],[\"mysql常用命令\",{\"0\":{\"1409\":1}}],[\"mysqldump\",{\"1\":{\"1836\":4}}],[\"mysqldump数据备份\",{\"0\":{\"1836\":1}}],[\"mysqld将记录了数据修改的log\",{\"1\":{\"1763\":1}}],[\"mysqld将拒绝您\",{\"1\":{\"1754\":1}}],[\"mysqld会单独的跑在一个机器上\",{\"1\":{\"1758\":1}}],[\"mysqld服务器在响应错误握手之前等待连接数据包的秒数\",{\"1\":{\"1754\":1}}],[\"mysqld\",{\"1\":{\"1408\":1,\"1410\":1,\"1555\":1,\"1616\":1,\"1769\":2,\"1770\":1,\"1799\":2,\"1820\":6}}],[\"mysql>\",{\"1\":{\"1407\":14,\"1408\":3,\"1768\":1,\"1774\":1,\"1799\":3,\"1821\":4,\"1825\":1,\"1826\":2,\"1828\":1,\"1829\":1,\"1830\":3,\"1836\":1}}],[\"mysql头文件在\",{\"1\":{\"1399\":1}}],[\"mysql5\",{\"0\":{\"1388\":1,\"1527\":1,\"1528\":1,\"1690\":1,\"1737\":1,\"1750\":1},\"1\":{\"1528\":1,\"1600\":1,\"1632\":1,\"1690\":1}}],[\"mysql\",{\"0\":{\"20\":1,\"1474\":1,\"1655\":1,\"1717\":1,\"1746\":1,\"1767\":1,\"1844\":1},\"1\":{\"0\":1,\"1372\":1,\"1373\":4,\"1374\":4,\"1375\":3,\"1376\":4,\"1377\":9,\"1378\":3,\"1379\":3,\"1380\":3,\"1381\":2,\"1382\":6,\"1383\":6,\"1384\":9,\"1385\":25,\"1390\":1,\"1393\":2,\"1395\":4,\"1396\":1,\"1397\":8,\"1398\":2,\"1399\":2,\"1401\":1,\"1402\":2,\"1403\":1,\"1405\":6,\"1407\":3,\"1408\":4,\"1409\":3,\"1410\":3,\"1411\":1,\"1447\":3,\"1452\":1,\"1464\":2,\"1555\":2,\"1556\":1,\"1569\":1,\"1574\":1,\"1580\":1,\"1594\":1,\"1610\":1,\"1622\":1,\"1636\":1,\"1656\":1,\"1658\":2,\"1660\":1,\"1663\":2,\"1664\":2,\"1665\":5,\"1668\":1,\"1673\":1,\"1690\":1,\"1700\":1,\"1701\":1,\"1708\":1,\"1717\":1,\"1721\":1,\"1736\":2,\"1747\":1,\"1753\":1,\"1754\":2,\"1758\":1,\"1763\":1,\"1769\":2,\"1770\":1,\"1772\":1,\"1773\":2,\"1774\":3,\"1776\":1,\"1790\":1,\"1799\":1,\"1803\":1,\"1820\":18,\"1825\":1,\"1828\":4,\"1829\":1,\"1836\":2,\"1839\":2,\"1846\":3,\"1847\":8,\"1849\":2,\"1856\":11,\"1859\":2,\"1875\":2,\"1878\":2,\"1881\":4,\"1888\":2,\"1891\":2},\"2\":{\"1386\":1,\"1412\":1,\"1418\":1,\"1429\":1,\"1438\":1,\"1445\":1,\"1448\":1,\"1456\":1,\"1466\":1,\"1472\":1,\"1482\":1,\"1487\":1,\"1503\":1,\"1509\":1,\"1532\":1,\"1545\":1,\"1549\":1,\"1553\":1,\"1560\":1,\"1567\":1,\"1570\":1,\"1583\":1,\"1596\":1,\"1605\":1,\"1611\":1,\"1619\":1,\"1628\":1,\"1637\":1,\"1641\":1,\"1646\":1,\"1653\":1,\"1666\":1,\"1667\":1,\"1674\":1,\"1683\":1,\"1684\":1,\"1695\":1,\"1703\":1,\"1709\":1,\"1714\":1,\"1722\":1,\"1725\":1,\"1741\":1,\"1755\":1,\"1764\":1,\"1777\":1,\"1787\":1,\"1793\":1,\"1815\":1,\"1834\":1,\"1837\":1,\"1840\":1,\"1852\":1,\"1857\":1,\"1860\":1,\"1867\":1,\"1873\":1,\"1876\":1,\"1879\":1,\"1882\":1,\"1893\":1}}],[\"my\",{\"0\":{\"1947\":1,\"1948\":1,\"1949\":1,\"1951\":1,\"1952\":1,\"1953\":1,\"1954\":1,\"1955\":1},\"1\":{\"202\":3,\"1093\":4,\"1096\":6,\"1099\":5,\"1102\":12,\"1133\":2,\"1148\":4,\"1291\":2,\"1299\":1,\"1365\":1,\"1746\":1,\"1748\":1,\"1754\":1,\"1769\":1,\"1772\":1,\"1776\":1}}],[\"myqueue\",{\"1\":{\"182\":7}}],[\"m\",{\"0\":{\"1950\":1},\"1\":{\"104\":2,\"107\":2,\"110\":2,\"227\":2,\"234\":4,\"239\":1,\"260\":1,\"301\":2,\"405\":15,\"422\":13,\"516\":1,\"614\":1,\"621\":1,\"810\":2,\"848\":13,\"1021\":6,\"1026\":6,\"1031\":4,\"1032\":2,\"1082\":2,\"1086\":7,\"1093\":1,\"1096\":1,\"1099\":3,\"1102\":2,\"1321\":1,\"1415\":4,\"1443\":1,\"1525\":3,\"1537\":3,\"1610\":1,\"1618\":1,\"1656\":6,\"1851\":5,\"1905\":5,\"1909\":2}}],[\"medium\",{\"1\":{\"1407\":1}}],[\"methods\",{\"1\":{\"1428\":2}}],[\"method工厂方法是标准的oop设计模式之一\",{\"1\":{\"866\":1}}],[\"method\",{\"0\":{\"865\":1}}],[\"me\",{\"1\":{\"684\":1}}],[\"meows\",{\"1\":{\"494\":1}}],[\"message为用户打印显示一条消息\",{\"1\":{\"1318\":1}}],[\"message\",{\"1\":{\"239\":1,\"1020\":2,\"1318\":1,\"1915\":2}}],[\"member\",{\"1\":{\"1102\":1,\"1346\":3}}],[\"memset\",{\"1\":{\"515\":3,\"547\":1,\"571\":1,\"572\":1,\"908\":1}}],[\"mem\",{\"1\":{\"286\":6,\"287\":2}}],[\"memoryqueue\",{\"1\":{\"1020\":1}}],[\"memory\",{\"1\":{\"239\":3,\"286\":12,\"531\":2,\"1453\":1,\"1820\":1,\"1864\":1}}],[\"memcpy\",{\"1\":{\"101\":2,\"224\":1,\"406\":1,\"1076\":1}}],[\"mergelist\",{\"1\":{\"783\":3}}],[\"mergeklists\",{\"1\":{\"782\":1,\"783\":1,\"784\":1}}],[\"mergetwolists\",{\"1\":{\"762\":1,\"782\":2,\"783\":3}}],[\"merge\",{\"1\":{\"202\":7,\"1521\":1}}],[\"mergesort\",{\"1\":{\"202\":3}}],[\"menu\",{\"1\":{\"27\":1}}],[\"mixed\",{\"1\":{\"1407\":2}}],[\"missing\",{\"0\":{\"1368\":1}}],[\"mirrors\",{\"1\":{\"1284\":6}}],[\"mirror\",{\"1\":{\"1284\":1}}],[\"milliseconds\",{\"1\":{\"1208\":1,\"1209\":3,\"1210\":1,\"1219\":4,\"1849\":1,\"1859\":1,\"1869\":1,\"1871\":1,\"1872\":1}}],[\"miles\",{\"1\":{\"900\":1}}],[\"miao\",{\"1\":{\"886\":2,\"905\":2}}],[\"mian\",{\"1\":{\"568\":1}}],[\"mimage++\",{\"1\":{\"731\":2}}],[\"mimage\",{\"1\":{\"731\":14}}],[\"mid\",{\"1\":{\"93\":4,\"94\":4,\"96\":12,\"97\":9,\"202\":9}}],[\"middlenode\",{\"1\":{\"798\":2}}],[\"middle\",{\"1\":{\"84\":6,\"142\":6,\"783\":3}}],[\"mincon=\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"mincon\",{\"1\":{\"1803\":1}}],[\"minsizerel\",{\"1\":{\"1320\":1}}],[\"minsubarraylen\",{\"1\":{\"73\":1}}],[\"minimum\",{\"1\":{\"1312\":4,\"1314\":1,\"1315\":1,\"1316\":1,\"1317\":1,\"1318\":1,\"1322\":1}}],[\"minheap\",{\"1\":{\"984\":1}}],[\"minnode\",{\"1\":{\"784\":4}}],[\"minnum\",{\"1\":{\"214\":8}}],[\"minflt代表minor\",{\"1\":{\"289\":1}}],[\"minflt\",{\"1\":{\"289\":1}}],[\"minpos\",{\"1\":{\"217\":5}}],[\"min\",{\"1\":{\"73\":1,\"118\":4,\"191\":2,\"214\":2,\"1444\":1,\"1656\":4}}],[\"microsoft\",{\"1\":{\"27\":1,\"49\":2}}],[\"morning\",{\"1\":{\"1902\":1,\"1903\":1,\"1907\":1}}],[\"more\",{\"1\":{\"45\":1,\"1238\":1,\"1773\":1}}],[\"mobile=\",{\"1\":{\"1593\":1}}],[\"monitor表示状态监控\",{\"1\":{\"1808\":1}}],[\"mone\",{\"1\":{\"1531\":1}}],[\"money\",{\"1\":{\"1531\":1}}],[\"mono\",{\"1\":{\"49\":2}}],[\"mozilla\",{\"1\":{\"1255\":1}}],[\"move移动语义函数和forward类型完美转发函数\",{\"1\":{\"1194\":1}}],[\"move移动语义和forward完美转发\",{\"0\":{\"1127\":1}}],[\"move\",{\"1\":{\"267\":2,\"1047\":1,\"1127\":5}}],[\"mov\",{\"1\":{\"234\":14,\"235\":1,\"236\":3,\"238\":2,\"638\":3,\"906\":2,\"908\":1,\"954\":2}}],[\"modify\",{\"1\":{\"1552\":2}}],[\"modern\",{\"1\":{\"1896\":1,\"1906\":1}}],[\"mode\",{\"1\":{\"1299\":3,\"1318\":2,\"1656\":1,\"1665\":1,\"1698\":1,\"1701\":1,\"1719\":3}}],[\"moduleb\",{\"1\":{\"578\":1}}],[\"module\",{\"0\":{\"1293\":1},\"1\":{\"578\":2}}],[\"modulea\",{\"1\":{\"578\":2}}],[\"mod\",{\"1\":{\"191\":6,\"1891\":2}}],[\"mouseover\",{\"1\":{\"53\":1,\"59\":5}}],[\"mmap内存映射文件是在堆和栈的中间\",{\"1\":{\"283\":1}}],[\"mmap是在进程的虚拟地址空间中\",{\"1\":{\"281\":1}}],[\"mm\",{\"1\":{\"46\":1}}],[\"master和slave通过主从复制实现数据同步更新\",{\"1\":{\"1885\":1}}],[\"master配置\",{\"0\":{\"1819\":1,\"1832\":1}}],[\"master的ip为192\",{\"1\":{\"1818\":1}}],[\"master的更改\",{\"1\":{\"1785\":1}}],[\"master做写操作\",{\"1\":{\"1803\":1}}],[\"master是正常\",{\"1\":{\"1803\":1}}],[\"master库只做写操作\",{\"1\":{\"1803\":1}}],[\"master创建user表\",{\"1\":{\"1785\":1}}],[\"master创建mytest数据库\",{\"1\":{\"1785\":1}}],[\"master服务器创建一个binlog转储线程\",{\"1\":{\"1784\":1}}],[\"master\",{\"1\":{\"1772\":1,\"1783\":1,\"1784\":2,\"1785\":1,\"1791\":2,\"1796\":1,\"1803\":1,\"1821\":1,\"1822\":1,\"1825\":10,\"1828\":2,\"1829\":8,\"1833\":1,\"1885\":1}}],[\"masquerade\",{\"1\":{\"1237\":1}}],[\"male\",{\"1\":{\"1428\":2,\"1437\":1,\"1475\":4,\"1511\":1,\"1514\":2,\"1551\":1,\"1614\":4,\"1856\":1,\"1878\":1}}],[\"malloc来\",{\"1\":{\"518\":1}}],[\"malloc申请的是未初始化的堆空间\",{\"1\":{\"515\":1}}],[\"malloc与new\",{\"0\":{\"708\":1}}],[\"malloc与new的区别\",{\"1\":{\"513\":1,\"708\":1}}],[\"malloc与free\",{\"1\":{\"513\":1,\"515\":1}}],[\"malloc函数分配内存\",{\"1\":{\"284\":1}}],[\"malloc函数会\",{\"1\":{\"283\":1}}],[\"malloc大于128k的内存\",{\"1\":{\"284\":1}}],[\"malloc概述\",{\"0\":{\"282\":1}}],[\"malloc\",{\"0\":{\"280\":1,\"286\":1,\"521\":1,\"522\":1},\"1\":{\"277\":4,\"282\":3,\"285\":4,\"286\":2,\"385\":1,\"515\":4,\"516\":1,\"519\":1,\"522\":2,\"535\":1,\"547\":1,\"571\":1,\"572\":1,\"629\":1,\"633\":1,\"704\":1,\"710\":2,\"1079\":1,\"1080\":7,\"1087\":1,\"1093\":1,\"1096\":1,\"1102\":18,\"1105\":1,\"1127\":1,\"1622\":1}}],[\"matching\",{\"1\":{\"1240\":1}}],[\"matebook14\",{\"1\":{\"397\":1,\"439\":1,\"449\":1,\"464\":1}}],[\"mac\",{\"1\":{\"1201\":1}}],[\"machines\",{\"1\":{\"1102\":1}}],[\"make伪目标\",{\"1\":{\"1355\":1}}],[\"make就可以只编译出\",{\"1\":{\"1318\":1}}],[\"makefile的命令行\",{\"1\":{\"1368\":1}}],[\"makefile目录下的指定源文件生成一个可执行程序\",{\"1\":{\"1365\":1}}],[\"makefile使用方法\",{\"0\":{\"1351\":1}}],[\"makefile\",{\"0\":{\"1368\":1},\"1\":{\"1315\":1,\"1361\":2,\"1367\":1}}],[\"make命令的\",{\"0\":{\"1363\":1}}],[\"make命令\",{\"1\":{\"1308\":1,\"1317\":1}}],[\"make出现报错\",{\"0\":{\"1016\":1}}],[\"make\",{\"1\":{\"1000\":16,\"1001\":1,\"1002\":3,\"1015\":3,\"1082\":1,\"1102\":3,\"1168\":1,\"1280\":1,\"1318\":1,\"1355\":3,\"1363\":1}}],[\"ma跑到派生类最后面去了\",{\"1\":{\"937\":1}}],[\"ma的初始化在b与c的构造函数中进行\",{\"1\":{\"688\":1}}],[\"manipulation\",{\"1\":{\"1548\":1}}],[\"mangling\",{\"1\":{\"560\":1,\"571\":1}}],[\"managed\",{\"1\":{\"286\":3}}],[\"ma先初始化\",{\"1\":{\"422\":1}}],[\"ma类型编译器认为是加了类的作用域\",{\"1\":{\"410\":1}}],[\"ma\",{\"1\":{\"410\":1,\"411\":1,\"412\":1,\"413\":1,\"422\":4,\"517\":1,\"667\":3,\"684\":1,\"688\":4,\"919\":2,\"934\":1,\"948\":4,\"953\":2,\"954\":2,\"1110\":6,\"1114\":6,\"1115\":7,\"1173\":4,\"1183\":2}}],[\"majflt代表majorfault\",{\"1\":{\"289\":1}}],[\"majflt\",{\"1\":{\"289\":1}}],[\"majorityelement\",{\"1\":{\"114\":1,\"115\":1}}],[\"magazine\",{\"1\":{\"174\":5}}],[\"maxidletime=60\",{\"1\":{\"1844\":1,\"1878\":1}}],[\"maxidletime\",{\"1\":{\"1839\":3,\"1848\":1,\"1849\":5,\"1859\":4,\"1865\":1,\"1875\":3,\"1878\":1}}],[\"maximum\",{\"1\":{\"1240\":1}}],[\"maxsize=1024\",{\"1\":{\"1844\":1,\"1878\":1}}],[\"maxsize\",{\"1\":{\"1839\":3,\"1848\":1,\"1849\":3,\"1859\":2,\"1865\":1,\"1875\":4,\"1878\":1}}],[\"maxcon=\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"maxcon\",{\"1\":{\"1803\":1}}],[\"maxheap\",{\"1\":{\"1183\":4}}],[\"maxbackupindex=2\",{\"1\":{\"1026\":1}}],[\"maxfilesize=1024\",{\"1\":{\"1026\":1}}],[\"maxnunlen\",{\"1\":{\"191\":4}}],[\"maxnum\",{\"1\":{\"191\":8,\"214\":5}}],[\"maxn=100000+10\",{\"1\":{\"163\":1}}],[\"max\",{\"1\":{\"129\":1,\"178\":2,\"179\":1,\"214\":2,\"239\":3,\"497\":1,\"500\":2,\"501\":1,\"540\":1,\"1076\":2,\"1082\":2,\"1093\":1,\"1096\":2,\"1102\":2,\"1444\":1,\"1656\":4,\"1736\":1,\"1754\":1}}],[\"map实例\",{\"1\":{\"1002\":1}}],[\"map提供\",{\"1\":{\"1000\":1}}],[\"map使用2\",{\"1\":{\"1000\":1}}],[\"map使用1\",{\"1\":{\"1000\":1}}],[\"map不允许重复\",{\"1\":{\"1000\":1}}],[\"map1\",{\"1\":{\"1000\":31,\"1001\":6}}],[\"map添加数据的方法2\",{\"1\":{\"871\":1}}],[\"map添加数据的方法1\",{\"1\":{\"871\":1}}],[\"map>\",{\"1\":{\"871\":1,\"1000\":1}}],[\"map<int\",{\"1\":{\"125\":1,\"141\":1,\"158\":1,\"178\":1,\"871\":1,\"1000\":3,\"1001\":1,\"1002\":1,\"1168\":1,\"1905\":1,\"1909\":2}}],[\"map\",{\"0\":{\"155\":1},\"1\":{\"59\":1,\"968\":1,\"1000\":4,\"1002\":1,\"1168\":1}}],[\"mariadb\",{\"1\":{\"1452\":1}}],[\"mark\",{\"1\":{\"717\":1,\"718\":1}}],[\"markdown\",{\"1\":{\"44\":3}}],[\"margin\",{\"1\":{\"49\":1,\"51\":11}}],[\"main2\",{\"1\":{\"1318\":6}}],[\"main1\",{\"1\":{\"1318\":5}}],[\"main函数结束\",{\"1\":{\"1115\":1}}],[\"main函数内\",{\"0\":{\"236\":1}}],[\"main\",{\"1\":{\"8\":1,\"11\":1,\"60\":2,\"70\":1,\"101\":2,\"104\":1,\"107\":1,\"110\":1,\"118\":1,\"163\":1,\"185\":1,\"188\":2,\"191\":1,\"214\":1,\"224\":1,\"234\":14,\"238\":1,\"246\":3,\"247\":1,\"248\":3,\"251\":1,\"252\":2,\"253\":2,\"255\":4,\"260\":3,\"261\":3,\"267\":1,\"277\":2,\"310\":2,\"323\":1,\"338\":1,\"355\":1,\"365\":1,\"368\":1,\"378\":1,\"385\":1,\"405\":1,\"406\":1,\"411\":1,\"412\":1,\"413\":1,\"421\":1,\"422\":2,\"426\":1,\"433\":1,\"434\":1,\"439\":1,\"449\":1,\"459\":1,\"468\":1,\"476\":1,\"483\":2,\"484\":2,\"485\":1,\"490\":3,\"494\":1,\"497\":1,\"500\":1,\"501\":3,\"506\":1,\"515\":1,\"516\":2,\"517\":1,\"547\":1,\"548\":1,\"557\":1,\"563\":2,\"567\":4,\"568\":6,\"569\":4,\"570\":4,\"571\":1,\"572\":1,\"575\":4,\"576\":1,\"588\":2,\"589\":1,\"590\":1,\"592\":1,\"594\":6,\"597\":1,\"599\":1,\"601\":4,\"602\":1,\"605\":1,\"606\":1,\"614\":2,\"618\":1,\"621\":2,\"631\":1,\"633\":1,\"638\":1,\"642\":1,\"653\":1,\"662\":2,\"667\":1,\"688\":2,\"695\":3,\"699\":1,\"704\":1,\"731\":1,\"742\":1,\"743\":1,\"751\":1,\"810\":2,\"817\":3,\"819\":2,\"821\":1,\"830\":1,\"831\":1,\"832\":1,\"862\":1,\"864\":2,\"866\":1,\"867\":1,\"871\":1,\"886\":1,\"889\":1,\"894\":1,\"900\":1,\"905\":1,\"906\":1,\"907\":1,\"908\":1,\"913\":1,\"948\":1,\"953\":1,\"980\":1,\"981\":1,\"982\":1,\"984\":1,\"1002\":2,\"1011\":1,\"1014\":1,\"1020\":1,\"1031\":1,\"1032\":5,\"1040\":1,\"1041\":2,\"1043\":1,\"1045\":1,\"1047\":1,\"1050\":2,\"1055\":1,\"1056\":2,\"1057\":1,\"1060\":1,\"1066\":1,\"1110\":1,\"1111\":1,\"1112\":1,\"1113\":1,\"1114\":1,\"1115\":1,\"1116\":1,\"1120\":1,\"1123\":1,\"1124\":1,\"1127\":1,\"1147\":1,\"1148\":1,\"1151\":1,\"1154\":1,\"1155\":1,\"1158\":1,\"1168\":1,\"1173\":1,\"1183\":1,\"1186\":1,\"1188\":1,\"1189\":2,\"1207\":3,\"1208\":1,\"1219\":2,\"1225\":1,\"1226\":1,\"1233\":1,\"1261\":5,\"1284\":8,\"1299\":2,\"1312\":6,\"1313\":1,\"1314\":1,\"1315\":1,\"1316\":1,\"1321\":1,\"1327\":2,\"1360\":3,\"1361\":1,\"1365\":1,\"1367\":1,\"1383\":1,\"1384\":1,\"1385\":1,\"1820\":1,\"1851\":1,\"1856\":4,\"1878\":1,\"1907\":1,\"1908\":1,\"1909\":1,\"1915\":2}}],[\"mdfile\",{\"1\":{\"60\":6}}],[\"mdfiles\",{\"1\":{\"60\":6}}],[\"mdfilecontent\",{\"1\":{\"60\":3}}],[\"mdima\",{\"1\":{\"60\":2}}],[\"mdcancelima\",{\"1\":{\"60\":2}}],[\"md文件的默认名字\",{\"1\":{\"44\":1}}],[\"md文件的运行程序\",{\"1\":{\"44\":1}}],[\"md\",{\"0\":{\"44\":1,\"787\":1},\"1\":{\"44\":2,\"45\":2,\"49\":2,\"51\":38,\"60\":8,\"684\":1,\"688\":4}}],[\"must\",{\"1\":{\"600\":1,\"1096\":1}}],[\"multiverse\",{\"1\":{\"1284\":8}}],[\"multi\",{\"1\":{\"1102\":1,\"1656\":1}}],[\"multimap允许重复值\",{\"1\":{\"1000\":1}}],[\"multimap<int\",{\"1\":{\"1000\":1}}],[\"multimap使用\",{\"1\":{\"1000\":1}}],[\"multimap\",{\"1\":{\"1000\":1,\"1002\":1}}],[\"multiply<double\",{\"1\":{\"371\":1}}],[\"multiply<int\",{\"1\":{\"371\":1}}],[\"multiply\",{\"1\":{\"371\":8,\"497\":1,\"500\":6}}],[\"multilib\",{\"1\":{\"234\":1}}],[\"multiset<int>\",{\"1\":{\"999\":1}}],[\"multiset<long\",{\"1\":{\"162\":1}}],[\"multiset使用\",{\"1\":{\"999\":1}}],[\"multiset常用方法\",{\"1\":{\"999\":1}}],[\"multiset\",{\"1\":{\"999\":1,\"1002\":1}}],[\"multiset是有序的\",{\"1\":{\"162\":1}}],[\"multiset指定元素删除\",{\"1\":{\"162\":1}}],[\"multalin\",{\"1\":{\"4\":1}}],[\"mutable\",{\"1\":{\"1174\":1}}],[\"mutalin\",{\"1\":{\"5\":2}}],[\"mutex互斥锁\",{\"1\":{\"1217\":1}}],[\"mutex互斥锁和lock\",{\"0\":{\"1208\":1}}],[\"mutex>\",{\"1\":{\"848\":2,\"849\":1,\"1210\":1,\"1219\":5,\"1226\":1,\"1227\":1,\"1232\":2}}],[\"mutex\",{\"0\":{\"1209\":1,\"1225\":1},\"1\":{\"848\":6,\"849\":1,\"1202\":1,\"1209\":1,\"1219\":2,\"1225\":1,\"1226\":1,\"1227\":2,\"1839\":2,\"1848\":2,\"1859\":2,\"1875\":2,\"1878\":2}}],[\"mutialin\",{\"0\":{\"3\":1}}],[\"621\",{\"1\":{\"1773\":1}}],[\"62a2ec5eff0f4c45b1c3cb131751db46\",{\"1\":{\"1663\":1}}],[\"6340800\",{\"1\":{\"1299\":1}}],[\"65\",{\"1\":{\"1178\":2}}],[\"65536\",{\"1\":{\"239\":1}}],[\"6670d39aad9e4af19b284a2666571e28\",{\"1\":{\"1665\":1}}],[\"66\",{\"1\":{\"817\":8}}],[\"666\",{\"1\":{\"101\":4}}],[\"69\",{\"1\":{\"817\":4}}],[\"693e6eec33134fa488aff85e9a3c7500\",{\"1\":{\"262\":1}}],[\"61\",{\"0\":{\"787\":1},\"1\":{\"787\":1}}],[\"6f70a6649d2192cf32af68500915d84b476aa34ec899f98766c038fc9cc54662\",{\"1\":{\"783\":1}}],[\"6的代码\",{\"1\":{\"774\":1}}],[\"646465\",{\"1\":{\"1415\":2}}],[\"64位\",{\"1\":{\"1347\":1}}],[\"648\",{\"1\":{\"1255\":1}}],[\"64\",{\"1\":{\"572\":2,\"1305\":4,\"1395\":1}}],[\"64bit\",{\"1\":{\"285\":1}}],[\"6会出错\",{\"1\":{\"500\":1}}],[\"60c0c0\",{\"1\":{\"1299\":1}}],[\"600\",{\"1\":{\"1025\":1,\"1754\":1}}],[\"6000\",{\"1\":{\"439\":1,\"440\":1}}],[\"60\",{\"1\":{\"300\":1,\"1114\":1}}],[\"6章\",{\"1\":{\"264\":1}}],[\"6rem\",{\"1\":{\"51\":1}}],[\"6\",{\"0\":{\"1377\":1,\"1499\":1,\"1500\":1,\"1501\":1},\"1\":{\"0\":1,\"22\":1,\"29\":1,\"50\":1,\"104\":6,\"107\":2,\"110\":1,\"129\":1,\"163\":1,\"234\":1,\"378\":3,\"500\":2,\"747\":1,\"810\":2,\"817\":4,\"819\":2,\"968\":1,\"991\":1,\"1032\":1,\"1114\":1,\"1115\":1,\"1255\":1,\"1310\":1,\"1719\":2,\"1818\":1,\"1888\":2,\"1891\":2,\"1914\":1}}],[\"q指向要归还的\",{\"1\":{\"1093\":1}}],[\"q指向第m人\",{\"1\":{\"810\":1}}],[\"qt工程则添加到includepath中去\",{\"1\":{\"1029\":1}}],[\"q<=>p\",{\"1\":{\"492\":1}}],[\"q2\",{\"1\":{\"492\":2}}],[\"q1netibaqnvntwfrzxitc2hlbg==\",{\"1\":{\"1082\":1,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1}}],[\"q1\",{\"1\":{\"492\":2}}],[\"q类型是const\",{\"1\":{\"490\":1}}],[\"q是常量\",{\"1\":{\"490\":1}}],[\"q是的类型是const\",{\"1\":{\"490\":1}}],[\"q时\",{\"1\":{\"490\":1}}],[\"q可被赋值\",{\"1\":{\"490\":1}}],[\"q和p相同\",{\"1\":{\"490\":1}}],[\"q和\",{\"1\":{\"490\":1}}],[\"q和q可以被赋值\",{\"1\":{\"490\":1}}],[\"q不能被赋值\",{\"1\":{\"490\":2}}],[\"q表示\",{\"1\":{\"490\":1}}],[\"q都指向0x100\",{\"1\":{\"490\":1}}],[\"q\",{\"0\":{\"399\":1,\"400\":1,\"401\":1,\"465\":1,\"466\":1,\"467\":1,\"1557\":1,\"1558\":1,\"1947\":1,\"1948\":2,\"1949\":1,\"1950\":1,\"1951\":1,\"1952\":1,\"1953\":1,\"1954\":1,\"1955\":1},\"1\":{\"239\":1,\"490\":12,\"492\":9,\"625\":4,\"713\":2,\"810\":13,\"1041\":2,\"1050\":2,\"1055\":1,\"1093\":3,\"1137\":1,\"1139\":1,\"1141\":1,\"1376\":2,\"1566\":1}}],[\"quit\",{\"1\":{\"1340\":1,\"1407\":1,\"1799\":1}}],[\"quiet\",{\"1\":{\"1240\":1}}],[\"quick\",{\"1\":{\"220\":3}}],[\"quicksortcore\",{\"1\":{\"220\":2}}],[\"quicksort\",{\"1\":{\"220\":5}}],[\"qu\",{\"1\":{\"1142\":1}}],[\"query\",{\"0\":{\"1548\":1,\"1576\":1,\"1577\":1,\"1578\":1},\"1\":{\"1376\":2,\"1377\":1,\"1384\":1,\"1385\":1,\"1407\":2,\"1573\":1,\"1574\":2,\"1577\":4,\"1578\":3,\"1579\":1,\"1776\":1,\"1799\":2,\"1846\":1,\"1847\":3,\"1856\":4}}],[\"queryselector\",{\"1\":{\"59\":1}}],[\"queryselectorall\",{\"1\":{\"59\":5}}],[\"que不为空\",{\"1\":{\"1219\":1}}],[\"que7\",{\"1\":{\"784\":1}}],[\"que6\",{\"1\":{\"784\":1}}],[\"que5\",{\"1\":{\"784\":1}}],[\"que4\",{\"1\":{\"784\":1}}],[\"que2\",{\"1\":{\"784\":1}}],[\"que1\",{\"1\":{\"784\":1}}],[\"que\",{\"1\":{\"185\":14,\"751\":3,\"968\":1,\"984\":5,\"991\":5,\"1219\":24}}],[\"queue队列容器\",{\"1\":{\"1863\":1}}],[\"queuemutex\",{\"1\":{\"1839\":1,\"1848\":1,\"1849\":4,\"1859\":4,\"1869\":1,\"1870\":1,\"1872\":2,\"1875\":2,\"1878\":1}}],[\"queue本身就有3个模板参数\",{\"1\":{\"1183\":1}}],[\"queue变量是stringqueueappender类中用于具体存储日志的内存队列\",{\"1\":{\"1020\":1}}],[\"queue的模板实参\",{\"1\":{\"784\":1}}],[\"queue<connection\",{\"1\":{\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"queue<data\",{\"1\":{\"1183\":1}}],[\"queue<data>\",{\"1\":{\"1183\":1}}],[\"queue<string>\",{\"1\":{\"1020\":1}}],[\"queue<std\",{\"1\":{\"1020\":1}}],[\"queue<student\",{\"1\":{\"784\":5}}],[\"queue<student>\",{\"1\":{\"784\":1}}],[\"queue<int\",{\"1\":{\"984\":1}}],[\"queue<int>\",{\"1\":{\"751\":1,\"984\":1,\"991\":1,\"992\":1,\"1219\":2}}],[\"queue<listnode\",{\"1\":{\"784\":1}}],[\"queue<t>\",{\"1\":{\"751\":4}}],[\"queueitem是类型而不是成员变量\",{\"1\":{\"751\":1}}],[\"queueitem是告知编译器\",{\"1\":{\"751\":1}}],[\"queueitem会陷入递归调用\",{\"1\":{\"751\":1}}],[\"queueitem\",{\"1\":{\"751\":20}}],[\"queue1\",{\"1\":{\"406\":2}}],[\"queues\",{\"1\":{\"239\":1}}],[\"queue\",{\"1\":{\"182\":6,\"185\":6,\"406\":19,\"751\":2,\"784\":1,\"1020\":2,\"1183\":1,\"1219\":8,\"1839\":1,\"1848\":1,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"qunit\",{\"1\":{\"0\":1}}],[\"qq\",{\"1\":{\"0\":1}}],[\"不真正释放连接\",{\"1\":{\"1866\":1}}],[\"不自动切换\",{\"1\":{\"1803\":1}}],[\"不开启读写分离\",{\"1\":{\"1803\":1}}],[\"不支持远程连接\",{\"1\":{\"1799\":1}}],[\"不支持查询缓存\",{\"0\":{\"1751\":1}}],[\"不支持事务\",{\"1\":{\"1557\":1,\"1706\":1}}],[\"不影响相同的select\",{\"1\":{\"1688\":1}}],[\"不在间隙锁范围内\",{\"1\":{\"1693\":1}}],[\"不在\",{\"1\":{\"1656\":1}}],[\"不重新生成数据快照m\",{\"1\":{\"1656\":1}}],[\"不被其它正在执行的事务所看到\",{\"1\":{\"1644\":1}}],[\"不一定非要杜绝\",{\"1\":{\"1639\":3}}],[\"不一样\",{\"1\":{\"774\":1}}],[\"不存数据地址\",{\"1\":{\"1627\":1}}],[\"不存储data\",{\"1\":{\"1626\":1}}],[\"不存在返回容器末尾迭代器\",{\"1\":{\"999\":1}}],[\"不存在多份实例\",{\"1\":{\"837\":1}}],[\"不存在连等赋值\",{\"1\":{\"736\":1}}],[\"不存在\",{\"1\":{\"267\":2}}],[\"不存在则返回end\",{\"1\":{\"163\":4}}],[\"不行\",{\"1\":{\"1566\":1}}],[\"不匹配不显示\",{\"0\":{\"1501\":1}}],[\"不加asc\",{\"1\":{\"1496\":1}}],[\"不建议采用\",{\"1\":{\"1890\":1}}],[\"不建议使用\",{\"1\":{\"1494\":1}}],[\"不建议手动析构\",{\"1\":{\"426\":1}}],[\"不等于\",{\"1\":{\"1471\":1}}],[\"不满足的范式的表怎么办\",{\"0\":{\"1465\":1}}],[\"不符合第二范式\",{\"1\":{\"1461\":1}}],[\"不符合我们软件设计的思想\",{\"1\":{\"861\":1}}],[\"不写static\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":2}}],[\"不写则查看所有的更改\",{\"1\":{\"1773\":1}}],[\"不写默认也是升序\",{\"1\":{\"1525\":1}}],[\"不写就是默认\",{\"1\":{\"1318\":1}}],[\"不写\",{\"1\":{\"1315\":1}}],[\"不进入while循环\",{\"1\":{\"1221\":1}}],[\"不进行构造\",{\"1\":{\"1127\":1}}],[\"不为空\",{\"1\":{\"1173\":1}}],[\"不好\",{\"1\":{\"1168\":1}}],[\"不好操作\",{\"1\":{\"615\":1}}],[\"不区分大小写\",{\"1\":{\"1141\":1}}],[\"不通过内存池管理\",{\"1\":{\"1082\":1}}],[\"不知道\",{\"1\":{\"1155\":1}}],[\"不知道传入参数个数\",{\"1\":{\"1063\":1}}],[\"不知道运行时传入了几个参数\",{\"1\":{\"1063\":1}}],[\"不知道变量具体类型\",{\"1\":{\"359\":1}}],[\"不再使用这个资源的时候\",{\"1\":{\"1054\":1}}],[\"不带去重效果\",{\"1\":{\"1502\":1}}],[\"不带形参的函数\",{\"1\":{\"1162\":1}}],[\"不带引用技术的智能指针\",{\"1\":{\"1047\":1}}],[\"不带引用计数\",{\"1\":{\"1044\":1}}],[\"不带引用计数的智能指针怎么解决浅拷贝问题\",{\"1\":{\"1042\":1}}],[\"不带引用计数的智能指针\",{\"0\":{\"1038\":1,\"1042\":1},\"1\":{\"1042\":1}}],[\"不带虚函数\",{\"1\":{\"940\":1}}],[\"不带的是取地址\",{\"1\":{\"613\":1}}],[\"不属于标准的oop设计模式中的一项\",{\"1\":{\"861\":1}}],[\"不安全\",{\"0\":{\"921\":1},\"1\":{\"856\":1}}],[\"不安全的向下转型\",{\"1\":{\"678\":1}}],[\"不作详细介绍\",{\"1\":{\"846\":1}}],[\"不止变动的代码需要重新编译\",{\"1\":{\"826\":1}}],[\"不包含记录本身\",{\"1\":{\"1686\":1}}],[\"不包含环\",{\"1\":{\"765\":1,\"768\":1}}],[\"不包括记录本身\",{\"1\":{\"1686\":1}}],[\"不包括子查询和union查询\",{\"1\":{\"1521\":1}}],[\"不包括null结束符\",{\"1\":{\"535\":1}}],[\"不构造\",{\"1\":{\"751\":1}}],[\"不然容易引起内存泄漏\",{\"1\":{\"736\":1}}],[\"不然每次操作的时候都需要判断是否为空\",{\"1\":{\"736\":1}}],[\"不然没效果\",{\"1\":{\"565\":1}}],[\"不必用户重载\",{\"1\":{\"728\":1}}],[\"不必为其他应用程序重写代码\",{\"1\":{\"500\":1}}],[\"不论何种继承方式\",{\"1\":{\"685\":1}}],[\"不论是系统头文件\",{\"1\":{\"312\":1}}],[\"不难看出\",{\"1\":{\"653\":1}}],[\"不调用func\",{\"1\":{\"631\":1}}],[\"不允许读取未commit的数据\",{\"1\":{\"1677\":1}}],[\"不允许存储key值重复的元素\",{\"1\":{\"999\":2}}],[\"不允许key重复\",{\"1\":{\"999\":1}}],[\"不允许我们派生类这样对从基类继承的ma进行初始化\",{\"1\":{\"667\":1}}],[\"不允许标准算术转换和类类型的转换\",{\"1\":{\"608\":1}}],[\"不允许一个对象\",{\"1\":{\"470\":1}}],[\"不到\",{\"1\":{\"599\":1}}],[\"不管更改哪个存储引擎\",{\"1\":{\"1767\":1}}],[\"不管事务是否提交都会记录下来\",{\"1\":{\"1758\":1}}],[\"不管发生什么异常事件\",{\"1\":{\"1757\":1}}],[\"不管是表锁还是行锁\",{\"1\":{\"1702\":1}}],[\"不管是已提交读还是可重复读\",{\"1\":{\"1658\":1}}],[\"不管是\",{\"1\":{\"1622\":1}}],[\"不管是链接的是文件还是目录\",{\"1\":{\"1272\":1}}],[\"不管是c++中的thread还是linux中的pthread\",{\"1\":{\"1151\":1}}],[\"不管是变量地址给p还是常量地址给p\",{\"1\":{\"492\":1}}],[\"不管初始化列表中次序如何\",{\"1\":{\"943\":1}}],[\"不管以什么继承方式\",{\"1\":{\"658\":3}}],[\"不管下标是多少都会照常访问\",{\"1\":{\"597\":1}}],[\"不做检查\",{\"1\":{\"597\":1}}],[\"不做任何类型检查\",{\"1\":{\"481\":1}}],[\"不定义名字的命名空间称为匿名命名空间\",{\"1\":{\"591\":1}}],[\"不报错\",{\"1\":{\"523\":1}}],[\"不用再创建和mysql\",{\"1\":{\"1865\":1}}],[\"不用再进行一遍真正的sql查询\",{\"1\":{\"1749\":1}}],[\"不用考虑线程安全\",{\"1\":{\"1839\":1,\"1849\":1,\"1859\":1,\"1875\":1}}],[\"不用担心这条新插入的数据和查询条件是一样的\",{\"1\":{\"1692\":1}}],[\"不用加锁\",{\"1\":{\"1656\":1}}],[\"不用修饰distinct\",{\"1\":{\"1514\":1}}],[\"不用直接使用互斥锁的lock和unlock方法\",{\"1\":{\"1219\":1}}],[\"不用扩容或缩容\",{\"1\":{\"1076\":1}}],[\"不用每个产品类建一个工厂\",{\"1\":{\"867\":1}}],[\"不用去共享进程中的资源\",{\"1\":{\"840\":1}}],[\"不用写了\",{\"1\":{\"576\":3}}],[\"不用传给它对象个数\",{\"1\":{\"520\":1}}],[\"不用空间配置器会怎么样\",{\"0\":{\"382\":1}}],[\"不妨从这样一个类aa开始\",{\"1\":{\"518\":1}}],[\"不合法\",{\"1\":{\"517\":1}}],[\"不需要和mysql的账号密码一样\",{\"1\":{\"1802\":1}}],[\"不需要额外排序\",{\"1\":{\"1736\":1}}],[\"不需要用户手动加锁\",{\"1\":{\"1701\":1}}],[\"不需要再加间隙锁\",{\"1\":{\"1694\":1}}],[\"不需要再检查哪些行被加上了x或s锁\",{\"1\":{\"1673\":1}}],[\"不需要访问内核空间\",{\"1\":{\"1622\":1}}],[\"不需要进入for循环再填写next域\",{\"1\":{\"1099\":1}}],[\"不需要扩容了\",{\"1\":{\"966\":1}}],[\"不需要重新编译就可以替换库文件\",{\"1\":{\"826\":1}}],[\"不需要专门进行扩容操作\",{\"1\":{\"815\":1}}],[\"不需要大块连续内存\",{\"1\":{\"815\":1}}],[\"不需要while遍历后面的所有的结点\",{\"1\":{\"762\":1}}],[\"不需要加mutable\",{\"1\":{\"1175\":1}}],[\"不需要加匿名空间作用域限定符\",{\"1\":{\"594\":1}}],[\"不需要加中括号\",{\"1\":{\"513\":1,\"708\":1}}],[\"不需要写\",{\"1\":{\"584\":2}}],[\"不需要table\",{\"1\":{\"584\":1}}],[\"不需要else\",{\"1\":{\"214\":1}}],[\"不同事务之间对于数据的锁\",{\"1\":{\"1699\":1}}],[\"不同于binlog是mysql\",{\"1\":{\"1679\":1}}],[\"不同元素\",{\"1\":{\"1603\":1}}],[\"不同存储引擎主要是存储方式不一样\",{\"1\":{\"1557\":1}}],[\"不同存储引擎主要是影响表的结构\",{\"1\":{\"1555\":1}}],[\"不同存储引擎有什么区别\",{\"0\":{\"1557\":1}}],[\"不同进程访问不同的sqlist\",{\"1\":{\"1452\":1}}],[\"不同汽车1l油跑的公里不一样\",{\"1\":{\"900\":1}}],[\"不同容器之间不能相互比较\",{\"1\":{\"747\":1}}],[\"不同容器的迭代器\",{\"1\":{\"741\":1}}],[\"不同容器底层数据结构不一样\",{\"1\":{\"698\":1}}],[\"不同差异都封装在迭代器++运算符重载函数中\",{\"1\":{\"698\":1}}],[\"不同数据结构\",{\"1\":{\"698\":1}}],[\"不同的程序访问一组表时\",{\"1\":{\"1724\":1}}],[\"不同的代码段\",{\"1\":{\"1706\":1}}],[\"不同的线程栈不同\",{\"1\":{\"1233\":1}}],[\"不同的是\",{\"1\":{\"922\":1}}],[\"不同的人分别完成不同的部分\",{\"1\":{\"582\":1}}],[\"不同的索引i\",{\"1\":{\"158\":1}}],[\"不同系统不同模型值不同\",{\"1\":{\"547\":1}}],[\"不同点\",{\"1\":{\"515\":1}}],[\"不同\",{\"1\":{\"513\":1,\"597\":1}}],[\"不抛出异常\",{\"1\":{\"511\":1}}],[\"不应该出现在函数的声明中\",{\"1\":{\"504\":1}}],[\"不初始化怎么发生替换\",{\"1\":{\"484\":1}}],[\"不叫常量\",{\"1\":{\"483\":1}}],[\"不会配置好主从复制后\",{\"1\":{\"1830\":1}}],[\"不会因为临时创建和销毁线程\",{\"1\":{\"1753\":1}}],[\"不会出现死锁\",{\"1\":{\"1713\":1}}],[\"不会出现数据污染等意外情况\",{\"1\":{\"839\":1}}],[\"不会产生冲突\",{\"1\":{\"1673\":1}}],[\"不会使用索引\",{\"1\":{\"1593\":1}}],[\"不会让多个智能指针管理资源\",{\"1\":{\"1047\":1}}],[\"不会调用派生类derived的析构函数\",{\"1\":{\"949\":1}}],[\"不会调用对象构造函数\",{\"1\":{\"519\":1}}],[\"不会发生动态绑定\",{\"1\":{\"927\":1}}],[\"不会改变引用的指向\",{\"1\":{\"618\":1}}],[\"不会改变原有数据的非const性质\",{\"1\":{\"490\":1}}],[\"不会对temp进行复制\",{\"1\":{\"616\":1}}],[\"不会自动回收动态分配的内存\",{\"1\":{\"608\":1}}],[\"不会抛出任何异常\",{\"1\":{\"607\":2}}],[\"不会抛出异常\",{\"1\":{\"599\":1}}],[\"不会检查下标越界\",{\"1\":{\"597\":1,\"599\":1}}],[\"不会在符号表生成符号\",{\"1\":{\"502\":1}}],[\"不会占用整型之外的资源\",{\"1\":{\"401\":1}}],[\"不会影响内存的最小单元大小\",{\"1\":{\"308\":1}}],[\"不仅仅是获取了满足条件的这3行的行锁\",{\"1\":{\"1688\":1}}],[\"不仅仅这种内置类型如此\",{\"1\":{\"524\":1}}],[\"不仅会对符合条件的\",{\"1\":{\"1686\":1}}],[\"不仅这个事务执行效率低\",{\"1\":{\"1670\":1}}],[\"不仅要存储\",{\"1\":{\"1626\":1}}],[\"不仅要把\",{\"1\":{\"385\":1,\"704\":1,\"747\":1,\"1087\":1}}],[\"不仅给容器底层开辟指定大小空间\",{\"1\":{\"965\":1,\"966\":1,\"969\":1,\"970\":1}}],[\"不仅如此\",{\"1\":{\"582\":1}}],[\"不仅显示符号表\",{\"1\":{\"248\":1}}],[\"不考虑const或valatile后\",{\"1\":{\"630\":1}}],[\"不考虑const或valatile\",{\"1\":{\"630\":1}}],[\"不考虑共享内存\",{\"1\":{\"281\":1}}],[\"不考虑输出结果的顺序\",{\"1\":{\"169\":1}}],[\"不使用连接池的测试\",{\"1\":{\"1851\":2}}],[\"不使用循环\",{\"1\":{\"1366\":1}}],[\"不使用重载\",{\"1\":{\"528\":1}}],[\"不使用\",{\"0\":{\"273\":1}}],[\"不可重复读举例\",{\"1\":{\"1639\":1}}],[\"不可重复读\",{\"1\":{\"1639\":1,\"1665\":2,\"1712\":1}}],[\"不可重复读和幻读一定程度上是可以允许的\",{\"1\":{\"1639\":1}}],[\"不可重复读和幻读\",{\"0\":{\"1639\":1},\"1\":{\"1631\":1}}],[\"不可能说我输入的索引值的字典序小\",{\"1\":{\"1603\":1}}],[\"不可能说又来一个宝马灯工厂\",{\"1\":{\"867\":1}}],[\"不可能两个人用同一个email\",{\"1\":{\"1463\":1}}],[\"不可能将一个成员方法的函数指针扔给c的函数指针\",{\"1\":{\"1151\":1}}],[\"不可能出现\",{\"1\":{\"876\":1}}],[\"不可能在alpha\",{\"1\":{\"302\":1}}],[\"不可访问\",{\"1\":{\"267\":1}}],[\"不可以修改指针所指变量的值\",{\"1\":{\"497\":1}}],[\"不可以改变指针本身\",{\"1\":{\"497\":2}}],[\"不可以改变指针的指向\",{\"1\":{\"488\":1}}],[\"不可以改变p1指针的指向\",{\"1\":{\"488\":1}}],[\"不可以\",{\"1\":{\"140\":1,\"630\":1}}],[\"不适用与浮点型排序\",{\"1\":{\"212\":1}}],[\"不是明文\",{\"1\":{\"1772\":1}}],[\"不是把数据全部刷到磁盘\",{\"1\":{\"1762\":1}}],[\"不是直接修改磁盘上的数据\",{\"1\":{\"1758\":1}}],[\"不是针对行记录加的锁\",{\"1\":{\"1713\":1}}],[\"不是行锁\",{\"1\":{\"1673\":1}}],[\"不是读取全部的索引加载到内存\",{\"1\":{\"1623\":1}}],[\"不是从1开始\",{\"1\":{\"1480\":1}}],[\"不是线程安全的操作\",{\"1\":{\"1208\":1}}],[\"不是线程安全的\",{\"1\":{\"1096\":1}}],[\"不是之前的8个字节\",{\"1\":{\"937\":1}}],[\"不是重写\",{\"1\":{\"890\":1}}],[\"不是用新的链表\",{\"1\":{\"762\":1}}],[\"不是struct里面最大的4的整数倍\",{\"1\":{\"557\":1}}],[\"不是所有的客户都能访问到老板\",{\"1\":{\"830\":1}}],[\"不是所有的硬件平台都能访问任意地址上的任意数据的\",{\"1\":{\"553\":1}}],[\"不是所有inline都会被编译器处理成内联函数\",{\"1\":{\"502\":1}}],[\"不是一个函数\",{\"1\":{\"515\":1}}],[\"不是编译器提供的\",{\"1\":{\"367\":1}}],[\"不是unorder\",{\"1\":{\"170\":1}}],[\"不是\",{\"1\":{\"146\":1,\"251\":1,\"972\":1}}],[\"不是脚本\",{\"1\":{\"30\":1}}],[\"不去重版本\",{\"1\":{\"110\":1}}],[\"不能无限制的创建连接\",{\"1\":{\"1865\":1}}],[\"不能配置成一样的\",{\"1\":{\"1820\":1}}],[\"不能写入\",{\"1\":{\"1790\":1}}],[\"不能并发进行\",{\"1\":{\"1700\":1,\"1713\":1}}],[\"不能出现部分成功\",{\"1\":{\"1649\":1}}],[\"不能重复\",{\"1\":{\"1610\":2}}],[\"不能进行\",{\"1\":{\"1603\":1,\"1604\":1}}],[\"不能进行写操作\",{\"1\":{\"440\":1}}],[\"不能存储中文\",{\"1\":{\"1552\":1}}],[\"不能再分割\",{\"1\":{\"1460\":1}}],[\"不能用于字符串\",{\"1\":{\"1433\":1}}],[\"不能用一个右值引用变量来引用左值\",{\"1\":{\"622\":1}}],[\"不能为空\",{\"1\":{\"1432\":1,\"1610\":1}}],[\"不能直接查看\",{\"1\":{\"1772\":1}}],[\"不能直接运行\",{\"1\":{\"1229\":1}}],[\"不能直接写第2级标题\",{\"1\":{\"51\":1}}],[\"不能串行执行\",{\"1\":{\"1208\":1}}],[\"不能及时看到其他线程对共享数据的修改\",{\"1\":{\"1082\":1}}],[\"不能将弱智能指针当成裸指针看待\",{\"1\":{\"1057\":1}}],[\"不能将声明与实现分开\",{\"1\":{\"504\":1,\"506\":1}}],[\"不能拷贝构造\",{\"1\":{\"1047\":1}}],[\"不能使用资源\",{\"1\":{\"1057\":1}}],[\"不能使用\",{\"1\":{\"994\":1}}],[\"不能使用迭代器遍历\",{\"1\":{\"989\":1}}],[\"不能内联调用\",{\"1\":{\"982\":1}}],[\"不能加载一些运行时的资源\",{\"1\":{\"844\":1}}],[\"不能定义为类的成员函数\",{\"1\":{\"730\":1}}],[\"不能被继承\",{\"1\":{\"724\":1}}],[\"不能创建栈对象\",{\"1\":{\"718\":1}}],[\"不能从基类继承下来的\",{\"0\":{\"685\":1}}],[\"不能初始化空对象\",{\"1\":{\"619\":1}}],[\"不能返回局部的或临时的对象的指针或引用\",{\"1\":{\"1115\":1}}],[\"不能返回局部变量的引用\",{\"1\":{\"616\":1}}],[\"不能返回指针的引用\",{\"1\":{\"848\":1}}],[\"不能返回一个局部变量的引用\",{\"1\":{\"618\":1}}],[\"不能在函数内部返回new分配的堆空间变量的引用\",{\"1\":{\"616\":1}}],[\"不能省略\",{\"1\":{\"599\":1}}],[\"不能够达到最终的目标\",{\"1\":{\"597\":1}}],[\"不能修改指针指向\",{\"1\":{\"535\":1}}],[\"不能修改指针所指变量的值\",{\"1\":{\"497\":2}}],[\"不能修改指针所指内容的值\",{\"1\":{\"488\":1}}],[\"不能混用\",{\"1\":{\"517\":1,\"715\":1}}],[\"不能把常量地址泄漏给一个普通指针或者普通引用变量\",{\"1\":{\"485\":1}}],[\"不能取地址的\",{\"1\":{\"621\":1}}],[\"不能取地址\",{\"1\":{\"476\":1}}],[\"不能分配内存大小为0的空间\",{\"1\":{\"470\":1}}],[\"不能访问非const版本的成员函数\",{\"1\":{\"440\":1}}],[\"不能调用非const版本的函数\",{\"1\":{\"440\":1}}],[\"不能入队了\",{\"1\":{\"406\":1}}],[\"不能去掉\",{\"1\":{\"399\":1,\"400\":1}}],[\"不能与关键字重名\",{\"1\":{\"316\":1}}],[\"不能有重复的三元组\",{\"1\":{\"135\":1}}],[\"不能像数组一样\",{\"1\":{\"91\":1}}],[\"不要边写边删\",{\"1\":{\"1866\":1}}],[\"不要申请超过实际需要的锁级别\",{\"1\":{\"1724\":1}}],[\"不要背课文1\",{\"1\":{\"1615\":1}}],[\"不要直接复制\",{\"1\":{\"1408\":1}}],[\"不要和其他windows\",{\"1\":{\"1278\":1}}],[\"不要一行行的阅读\",{\"1\":{\"1105\":1}}],[\"不要按赋值方式接收\",{\"1\":{\"1067\":1}}],[\"不要先定义在返回\",{\"1\":{\"1067\":1}}],[\"不要出现野指针\",{\"1\":{\"736\":1}}],[\"不要这样写\",{\"1\":{\"633\":1,\"1067\":1,\"1475\":1}}],[\"不要被表象迷住了\",{\"1\":{\"625\":1}}],[\"不要去返回堆空间的引用\",{\"1\":{\"618\":1}}],[\"不要去写for\",{\"1\":{\"504\":1,\"506\":1}}],[\"不要在头文件中使用using编译指令\",{\"1\":{\"593\":1}}],[\"不要分成头文件与实现文件的形式\",{\"1\":{\"504\":1,\"506\":1}}],[\"不要用delete\",{\"1\":{\"224\":1}}],[\"不要用数字邮箱名\",{\"1\":{\"0\":1}}],[\"不要写成age\",{\"1\":{\"1422\":1}}],[\"不要写成赋值\",{\"1\":{\"142\":1}}],[\"不要写数组的大小\",{\"1\":{\"512\":1}}],[\"不要写size\",{\"1\":{\"101\":1}}],[\"不要求序列元素在原数组中连续\",{\"1\":{\"129\":1}}],[\"不要给另外的数组分配额外的空间\",{\"1\":{\"67\":1}}],[\"不保证可靠交付数据\",{\"1\":{\"22\":1}}],[\"不过你可以通过\",{\"1\":{\"1255\":1}}],[\"不过\",{\"1\":{\"282\":1,\"285\":1}}],[\"不过得按回车后才能被渲染\",{\"1\":{\"61\":1}}],[\"不过有些技术人员比较反感\",{\"1\":{\"0\":1}}],[\"不过很难完整\",{\"1\":{\"0\":1}}],[\"如school\",{\"1\":{\"1821\":1}}],[\"如备份在~\",{\"1\":{\"1775\":1}}],[\"如数据持久化过程中掉电\",{\"1\":{\"1758\":1}}],[\"如m=500搜2000w的数据\",{\"1\":{\"1623\":1}}],[\"如varchar\",{\"1\":{\"1425\":1}}],[\"如字节\",{\"1\":{\"1347\":1}}],[\"如有需要可自行取消注释\",{\"1\":{\"1284\":1}}],[\"如printf\",{\"1\":{\"1063\":1}}],[\"如若提示缺少log4cpp库文件\",{\"1\":{\"1030\":1}}],[\"如g++\",{\"1\":{\"1016\":1}}],[\"如log4cpp\",{\"1\":{\"1015\":1}}],[\"如图为子cmakelist\",{\"1\":{\"1309\":1}}],[\"如图5\",{\"1\":{\"968\":1}}],[\"如图2\",{\"1\":{\"968\":2}}],[\"如此循环进行直到仅余15个人为止\",{\"1\":{\"811\":1}}],[\"如把int转成char\",{\"1\":{\"629\":1}}],[\"如把int转换为float\",{\"1\":{\"629\":1}}],[\"如交换两个变量的值\",{\"1\":{\"560\":1}}],[\"如递归\",{\"1\":{\"502\":1}}],[\"如在\",{\"1\":{\"422\":1}}],[\"如为指针成员等\",{\"1\":{\"420\":1}}],[\"如int\",{\"1\":{\"359\":1}}],[\"如下示例\",{\"1\":{\"1030\":1}}],[\"如下面的例子\",{\"1\":{\"652\":1}}],[\"如下所示\",{\"1\":{\"604\":1}}],[\"如下图所示\",{\"1\":{\"653\":1,\"1682\":2}}],[\"如下图\",{\"1\":{\"283\":1,\"284\":1,\"914\":1}}],[\"如下\",{\"1\":{\"273\":1,\"439\":1,\"1079\":1,\"1318\":1,\"1574\":1,\"1649\":1,\"1719\":1,\"1750\":2,\"1773\":1,\"1776\":1}}],[\"如下划线\",{\"1\":{\"50\":1}}],[\"如访问空指针时程序会崩溃\",{\"1\":{\"267\":1}}],[\"如\",{\"1\":{\"257\":1,\"395\":2,\"425\":1,\"432\":1,\"434\":1,\"459\":1,\"600\":1,\"640\":1,\"840\":1,\"1317\":1,\"1332\":2,\"1335\":1,\"1405\":1,\"1577\":1,\"1656\":2}}],[\"如何提高查询效率\",{\"0\":{\"1519\":1}}],[\"如何更新动态库🍗🍗🍗\",{\"0\":{\"1332\":1}}],[\"如何判断ip冲突没有\",{\"1\":{\"1278\":1}}],[\"如何判别\",{\"1\":{\"890\":1}}],[\"如何将这些函数对象的类型留下来\",{\"1\":{\"1161\":1}}],[\"如何将绑定器的类型留下来\",{\"1\":{\"1154\":1}}],[\"如何打开一个工程\",{\"0\":{\"1140\":1}}],[\"如何保证线程安全\",{\"0\":{\"840\":1}}],[\"如何快速得到\",{\"1\":{\"784\":1}}],[\"如何解决迭代器失效问题\",{\"0\":{\"744\":1}}],[\"如何从当前元素遍历到下一个元素\",{\"1\":{\"698\":1}}],[\"如何初始化基类的成员变量\",{\"0\":{\"667\":1}}],[\"如何定义和使用自己的异常类\",{\"0\":{\"606\":1}}],[\"如何抛出异常\",{\"1\":{\"599\":1}}],[\"如何测试系统是32位还是64位\",{\"1\":{\"535\":1}}],[\"如何知道从哪一行开始\",{\"1\":{\"234\":1}}],[\"如何知道回到main函数\",{\"1\":{\"234\":1}}],[\"如何设置高亮快捷键\",{\"0\":{\"62\":1}}],[\"如需取消开机自启\",{\"1\":{\"27\":1}}],[\"如果因为单张表的数据量太大\",{\"1\":{\"1886\":1}}],[\"如果因为表多而造成数据过多\",{\"1\":{\"1886\":1}}],[\"如果单纯的一次通信\",{\"1\":{\"1881\":1}}],[\"如果走完所有的mysql\",{\"1\":{\"1881\":1}}],[\"如果走到\",{\"1\":{\"771\":2}}],[\"如果文件结束\",{\"1\":{\"1878\":1}}],[\"如果文件已存在于库中\",{\"1\":{\"1334\":1}}],[\"如果connection队列为空\",{\"1\":{\"1866\":2}}],[\"如果c代码明确表示用c方式编译\",{\"0\":{\"567\":1}}],[\"如果真的出现这样的问题\",{\"1\":{\"1830\":1}}],[\"如果虚拟机是nat模式\",{\"1\":{\"1828\":1}}],[\"如果虚基类中没有定义的缺省构造函数\",{\"1\":{\"943\":1}}],[\"如果给slave配置的不是网关192\",{\"1\":{\"1821\":1}}],[\"如果mysql报错\",{\"1\":{\"1820\":1}}],[\"如果master有问题\",{\"1\":{\"1803\":1}}],[\"如果max\",{\"1\":{\"1736\":1}}],[\"如果物理机可以ping通虚拟机\",{\"1\":{\"1818\":1}}],[\"如果能正常返回数据\",{\"1\":{\"1803\":1}}],[\"如果能ping通\",{\"1\":{\"1278\":1}}],[\"如果缩小权限\",{\"1\":{\"1799\":1}}],[\"如果dump线程已经跟上master\",{\"1\":{\"1784\":1}}],[\"如果主从都正常\",{\"1\":{\"1803\":1}}],[\"如果主库挂了\",{\"1\":{\"1780\":1}}],[\"如果主键一样\",{\"1\":{\"1692\":1}}],[\"如果写redo\",{\"1\":{\"1763\":1}}],[\"如果出现掉电\",{\"1\":{\"1760\":1}}],[\"如果buffer比较大\",{\"1\":{\"1758\":1}}],[\"如果base有虚函数\",{\"1\":{\"956\":1}}],[\"如果base没有虚函数\",{\"1\":{\"956\":1}}],[\"如果base\",{\"1\":{\"631\":1}}],[\"如果事务比较大\",{\"1\":{\"1758\":1}}],[\"如果连接空闲\",{\"1\":{\"1754\":1}}],[\"如果某个表的查询多而更改少\",{\"1\":{\"1750\":1}}],[\"如果某个数据成员是指针\",{\"1\":{\"426\":1}}],[\"如果redis上直接查到就不经过mysql数据库\",{\"1\":{\"1745\":1}}],[\"如果客户端的请求来了\",{\"1\":{\"1745\":1}}],[\"如果slave有问题\",{\"1\":{\"1803\":1}}],[\"如果sort\",{\"1\":{\"1736\":1}}],[\"如果sql语句中有二进制数据\",{\"1\":{\"1376\":1}}],[\"如果应用使用自动提交的方式\",{\"1\":{\"1731\":1}}],[\"如果对mysql数据库的读和写都在一台数据库服务器中操作\",{\"1\":{\"1779\":1}}],[\"如果对\",{\"0\":{\"1719\":1,\"1720\":1}}],[\"如果对一个命名空间中的实体并不熟悉时\",{\"1\":{\"588\":1}}],[\"如果认为全表扫描比使用索引效率高\",{\"1\":{\"1713\":1}}],[\"如果做整表扫描\",{\"1\":{\"1700\":1}}],[\"如果都是物理机通信\",{\"1\":{\"1828\":1}}],[\"如果都正确\",{\"1\":{\"1828\":1}}],[\"如果都用行锁\",{\"1\":{\"1670\":1}}],[\"如果都不满足\",{\"1\":{\"1148\":1}}],[\"如果记录的\",{\"1\":{\"1656\":5}}],[\"如果业务中间出现失败\",{\"1\":{\"1652\":1}}],[\"如果其中1套的主库宕机了\",{\"1\":{\"1791\":1}}],[\"如果其中任意一条sql由于停电\",{\"1\":{\"1650\":1}}],[\"如果其他事务插入了\",{\"1\":{\"1686\":1}}],[\"如果其他线程执行notify了\",{\"1\":{\"1219\":1}}],[\"如果这2句sql都成功了\",{\"1\":{\"1650\":1}}],[\"如果这个文件使用的是memory基于内存的存储引擎\",{\"1\":{\"1603\":1}}],[\"如果这个头文件被多次引用的话\",{\"1\":{\"574\":1}}],[\"如果这个函数在短时间内大量调用并且这个函数十分简单\",{\"1\":{\"502\":1}}],[\"如果这个过程\",{\"1\":{\"146\":1}}],[\"如果要进行索引树的搜素或者整表搜索\",{\"1\":{\"1626\":1}}],[\"如果要达到正确\",{\"1\":{\"340\":1}}],[\"如果显示为尖括号就表示这是个临时表\",{\"1\":{\"1618\":1}}],[\"如果使用\",{\"1\":{\"1747\":1}}],[\"如果使用默认的行锁\",{\"1\":{\"1670\":1}}],[\"如果使用常数等值查询\",{\"1\":{\"1618\":1}}],[\"如果使用索引得到的数据量和扫表得到的数据量接近\",{\"1\":{\"1617\":1}}],[\"如果使用索引最后得到的数据占总数据的70\",{\"1\":{\"1617\":1}}],[\"如果使用at\",{\"1\":{\"539\":1}}],[\"如果大表相关联的字段有索引\",{\"1\":{\"1590\":1}}],[\"如果大于128字节就相当于是大块内存\",{\"1\":{\"1082\":1}}],[\"如果自适应哈希索引可以提高效率\",{\"1\":{\"1569\":1}}],[\"如果自定义类型没有迭代器的实现\",{\"1\":{\"701\":1}}],[\"如果检测到某个二级索引不断被使用\",{\"1\":{\"1569\":1}}],[\"如果切换root失败\",{\"1\":{\"1556\":1}}],[\"如果数据库的性能到瓶颈了\",{\"1\":{\"1790\":1}}],[\"如果数据库连接统计数量比较大\",{\"1\":{\"1754\":1}}],[\"如果数据取不完还要去数据表去取数据\",{\"1\":{\"1617\":1}}],[\"如果数据量太大\",{\"1\":{\"1525\":1}}],[\"如果数组中每个元素都不相同\",{\"1\":{\"152\":1}}],[\"如果数组数值范围可控可以使用数组做hash\",{\"1\":{\"104\":1,\"107\":1,\"110\":1}}],[\"如果可能的话\",{\"1\":{\"1521\":1}}],[\"如果可以\",{\"1\":{\"174\":1}}],[\"如果字段类型是unique\",{\"1\":{\"1521\":1}}],[\"如果为null\",{\"1\":{\"1521\":1}}],[\"如果冗余太多\",{\"1\":{\"1459\":1}}],[\"如果存进去的是\",{\"1\":{\"1426\":1}}],[\"如果存在\",{\"1\":{\"158\":1,\"161\":1}}],[\"如果加减商品或者价格变动\",{\"1\":{\"1417\":1}}],[\"如果看到有\",{\"1\":{\"1398\":1}}],[\"如果执行以上命令\",{\"0\":{\"1391\":1}}],[\"如果执行后什么都没有返回\",{\"0\":{\"1390\":1}}],[\"如果执行delref后\",{\"1\":{\"1055\":1}}],[\"如果失败返回null\",{\"1\":{\"1377\":1}}],[\"如果传递一个已\",{\"1\":{\"1373\":1}}],[\"如果参数为空\",{\"1\":{\"1373\":1}}],[\"如果它们已经存在于库中\",{\"1\":{\"1334\":1}}],[\"如果它不存在的话\",{\"1\":{\"1334\":1}}],[\"如果库已经存在\",{\"1\":{\"1334\":1}}],[\"如果更新\",{\"1\":{\"1332\":1}}],[\"如果服务端\",{\"1\":{\"1332\":1}}],[\"如果vim\",{\"1\":{\"1287\":1}}],[\"如果a文件和b文件的关系是硬链接的关系\",{\"1\":{\"1267\":1}}],[\"如果需要\",{\"1\":{\"1256\":1}}],[\"如果需要做任何修改\",{\"1\":{\"500\":1}}],[\"如果网络有问题或下载一个大文件也有可能失败\",{\"1\":{\"1256\":1}}],[\"如果设置日志过期时间为7天\",{\"1\":{\"1775\":1}}],[\"如果设成\",{\"1\":{\"1252\":1}}],[\"如果设这两个数分别是\",{\"1\":{\"140\":1}}],[\"如果直接使用queue\",{\"1\":{\"1219\":1}}],[\"如果想编译出\",{\"1\":{\"1318\":1}}],[\"如果想跨语句使用之前定义好的lambda表达式\",{\"1\":{\"1180\":1}}],[\"如果想要得到预期的结果\",{\"1\":{\"943\":1}}],[\"如果lambda表达式的返回值不需要\",{\"1\":{\"1172\":1}}],[\"如果每个都写出来太麻烦\",{\"1\":{\"1158\":1}}],[\"如果满足函数对象的运算\",{\"1\":{\"1148\":1}}],[\"如果上面这样写会导致\",{\"1\":{\"1122\":1}}],[\"如果上面操作失败\",{\"1\":{\"1105\":1}}],[\"如果哪个字节数有空闲的chunk块\",{\"1\":{\"1105\":1}}],[\"如果当前位置存在挂载的chunk的情况\",{\"1\":{\"1102\":1}}],[\"如果备用内存不够了\",{\"1\":{\"1102\":1}}],[\"如果备用内存足够\",{\"1\":{\"1102\":1}}],[\"如果还有剩余的很小的内存块\",{\"1\":{\"1105\":1}}],[\"如果还有空闲的chunk块\",{\"1\":{\"1096\":1}}],[\"如果还希望通过默认构造函数创建对象\",{\"1\":{\"421\":1}}],[\"如果从左往右压栈\",{\"1\":{\"1063\":1}}],[\"如果将大根堆结构所有元素放入数组中\",{\"1\":{\"994\":1}}],[\"如果将func1函数参数中的x定义成默认值0\",{\"1\":{\"637\":1}}],[\"如果增加删除使用多\",{\"1\":{\"974\":1}}],[\"如果基类的析构函数声明为虚的\",{\"1\":{\"949\":1}}],[\"如果基类base的析构函数没有设置为虚函数\",{\"1\":{\"949\":1}}],[\"如果基类没有提供无参构造函数\",{\"1\":{\"423\":1}}],[\"如果继承链上存在虚继承的基类\",{\"1\":{\"943\":1}}],[\"如果只是在辅助索引树上查找\",{\"1\":{\"1689\":1}}],[\"如果只给age添加索引行不行\",{\"1\":{\"1566\":1}}],[\"如果只定义了protected型的构造函数而没有提供public构造函数\",{\"1\":{\"900\":1}}],[\"如果只有一个结点的情况\",{\"1\":{\"819\":1}}],[\"如果该派生类没有对所有的纯虚函数进行重定义\",{\"1\":{\"900\":1}}],[\"如果项目耦合度很高的情况下\",{\"1\":{\"882\":1}}],[\"如果index小于0\",{\"1\":{\"790\":1}}],[\"如果索引创建过多\",{\"1\":{\"1609\":1}}],[\"如果索引\",{\"1\":{\"790\":1}}],[\"如果索引无效\",{\"1\":{\"790\":1}}],[\"如果索引超出范围\",{\"1\":{\"539\":1}}],[\"如果后面相交则p1\",{\"1\":{\"771\":1}}],[\"如果两个链表不存在相交节点\",{\"1\":{\"771\":1}}],[\"如果链表无环\",{\"1\":{\"768\":1}}],[\"如果容器\",{\"1\":{\"741\":1}}],[\"如果派生类拥有自己的虚函数\",{\"1\":{\"940\":1}}],[\"如果派生类没有自己的虚函数\",{\"1\":{\"940\":1}}],[\"如果派生类没有显式定义构造函数而基类有显示定义构造函数\",{\"1\":{\"670\":1}}],[\"如果派生类没有显式定义构造函数\",{\"0\":{\"670\":1}}],[\"如果派生类中的方法和基类继承来的某个方法\",{\"1\":{\"915\":1}}],[\"如果派生类的初始化列表中没有显示调用则会出错\",{\"1\":{\"672\":1}}],[\"如果派生类和基类都有构造函数\",{\"1\":{\"672\":1}}],[\"如果派生类有构造函数\",{\"1\":{\"671\":1}}],[\"如果派生类有显式定义构造函数\",{\"1\":{\"669\":1}}],[\"如果派生类需要调用基类的无参构造函数\",{\"1\":{\"423\":1}}],[\"如果派生类需要调用基类的有参构造函数\",{\"1\":{\"423\":1}}],[\"如果派生类需要调用基类的构造函数\",{\"1\":{\"423\":1}}],[\"如果一直分配不成功\",{\"1\":{\"1102\":1}}],[\"如果一组重载函数\",{\"1\":{\"641\":1}}],[\"如果一个事务包含多个sql\",{\"1\":{\"1640\":1}}],[\"如果一个线程中间出现问题\",{\"1\":{\"1209\":1}}],[\"如果一个基类的成员函数定义为虚函数\",{\"1\":{\"913\":1}}],[\"如果一个函数中有多个默认参数\",{\"1\":{\"640\":1}}],[\"如果一个名称空间中有多个实体\",{\"1\":{\"588\":1}}],[\"如果一个结构里有某些结构体成员\",{\"1\":{\"557\":1}}],[\"如果实参是立即数\",{\"1\":{\"638\":1}}],[\"如果通过c中类型转换可以将int\",{\"1\":{\"630\":1}}],[\"如果函数传递的是类对象\",{\"1\":{\"615\":1}}],[\"如果遇到异常就需要考虑是否正确的回收了内存\",{\"1\":{\"608\":1}}],[\"如果try语句块有嵌套\",{\"1\":{\"603\":1}}],[\"如果越界就抛出一个异常\",{\"1\":{\"597\":1}}],[\"如果非要使用using编译指令\",{\"1\":{\"593\":1}}],[\"如果开发了一个或者\",{\"1\":{\"593\":1}}],[\"如果不自定义log\",{\"1\":{\"1769\":1}}],[\"如果不使用索引的\",{\"1\":{\"1669\":1}}],[\"如果不使用作用域限定符和using机制\",{\"1\":{\"586\":1}}],[\"如果不涉及对数据库操作\",{\"1\":{\"1618\":1}}],[\"如果不加索引就会变成字符串匹配\",{\"1\":{\"1610\":1}}],[\"如果不扫描完整张表\",{\"1\":{\"1591\":1}}],[\"如果不修改语句结束符这里分号\",{\"1\":{\"1523\":1}}],[\"如果不更新协议\",{\"1\":{\"1332\":1}}],[\"如果不这样做\",{\"1\":{\"1319\":1}}],[\"如果不够\",{\"1\":{\"1102\":1}}],[\"如果不为空\",{\"1\":{\"1096\":1}}],[\"如果不显式调用\",{\"1\":{\"943\":1}}],[\"如果不是通过指针或者引用来调用虚函数\",{\"1\":{\"927\":1}}],[\"如果不管测试的结果\",{\"1\":{\"913\":1}}],[\"如果不抛出来\",{\"1\":{\"599\":1}}],[\"如果不把定义放在extern\",{\"1\":{\"570\":1}}],[\"如果我们在客户端上直接用代码写死\",{\"1\":{\"1790\":1}}],[\"如果我们直接cat日志查看\",{\"1\":{\"1773\":1}}],[\"如果我们引入redis的话\",{\"1\":{\"1750\":1}}],[\"如果我们串行化\",{\"1\":{\"1712\":1}}],[\"如果我们指定age=20\",{\"1\":{\"1689\":1}}],[\"如果我们这时要修改刚刚insert的数据\",{\"1\":{\"1682\":1}}],[\"如果我们没有设置主键\",{\"1\":{\"1681\":1}}],[\"如果我们不想要这些文件就可以直接清空\",{\"1\":{\"1319\":1}}],[\"如果我们不写继承方式的话\",{\"0\":{\"659\":1}}],[\"如果我们最终得到的绑定器\",{\"1\":{\"1161\":1}}],[\"如果我们频繁对内存进行申请和释放\",{\"1\":{\"1079\":1}}],[\"如果我们\",{\"1\":{\"1040\":1,\"1672\":1,\"1712\":1}}],[\"如果我们如何做呢\",{\"1\":{\"984\":1}}],[\"如果我们需要把原链表的节点接到新链表上\",{\"1\":{\"795\":1}}],[\"如果我们想通过形参改变实参的值\",{\"1\":{\"615\":1}}],[\"如果我们一开始就有bar的这两个重载函数的话\",{\"1\":{\"528\":1}}],[\"如果我们的写法是\",{\"1\":{\"135\":1}}],[\"如果用链式哈希表构建索引\",{\"1\":{\"1603\":1}}],[\"如果用智能指针管理的是文件资源\",{\"1\":{\"1060\":1}}],[\"如果用户代码需要使用这个类\",{\"1\":{\"826\":1}}],[\"如果用户定义了派生类的拷贝构造函数或者重载了派生类的对象赋值运算符=\",{\"1\":{\"662\":1}}],[\"如果用户定义了基类的拷贝构造函数\",{\"1\":{\"662\":1}}],[\"如果用new\",{\"1\":{\"751\":1}}],[\"如果用变量给const初始化的叫常变量\",{\"1\":{\"484\":1}}],[\"如果用给const初始化的叫\",{\"1\":{\"484\":1}}],[\"如果右操作数是右值的时候\",{\"1\":{\"466\":1}}],[\"如果去掉\",{\"1\":{\"465\":1}}],[\"如果去掉引用符号\",{\"1\":{\"399\":1}}],[\"如果类给外部的接口\",{\"1\":{\"449\":1}}],[\"如果类中定义了虚函数\",{\"1\":{\"946\":1}}],[\"如果类中没有显式定义赋值运算符函数时\",{\"1\":{\"463\":1}}],[\"如果类中没有显式定义拷贝构造函数时\",{\"1\":{\"395\":1}}],[\"如果类中有其他类类型的成员对象\",{\"1\":{\"423\":1}}],[\"如果程序员没有显式的定义它\",{\"1\":{\"425\":1}}],[\"如果程序员没有显式定义它\",{\"1\":{\"420\":1}}],[\"如果没有写成功或者写完\",{\"1\":{\"1759\":1}}],[\"如果没有查到就去访问mysql数据库\",{\"1\":{\"1745\":1}}],[\"如果没有加primary\",{\"1\":{\"1681\":1}}],[\"如果没有返回行\",{\"1\":{\"1378\":1}}],[\"如果没有显式指定\",{\"1\":{\"1335\":1}}],[\"如果没有设置\",{\"1\":{\"1102\":1}}],[\"如果没有发生异常\",{\"1\":{\"599\":1}}],[\"如果没有在构造函数的初始化列表中显式地初始化成员\",{\"1\":{\"422\":1}}],[\"如果没有普通函数形式\",{\"1\":{\"368\":1}}],[\"如果是连接查询\",{\"1\":{\"1618\":1}}],[\"如果是尖括号括起来<union\",{\"1\":{\"1618\":1}}],[\"如果是普通int\",{\"1\":{\"1233\":1}}],[\"如果是在若干类层次中\",{\"1\":{\"891\":1}}],[\"如果是\",{\"1\":{\"754\":1}}],[\"如果是dynamic\",{\"1\":{\"631\":2}}],[\"如果是用顺序表实现队列\",{\"1\":{\"406\":1}}],[\"如果是整型\",{\"1\":{\"401\":1}}],[\"如果是外地手机\",{\"1\":{\"0\":1}}],[\"如果成员比较简单\",{\"1\":{\"396\":1}}],[\"如果在指定的maxidletime里面\",{\"1\":{\"1865\":1}}],[\"如果在commit的时候才写redo\",{\"1\":{\"1758\":1}}],[\"如果在安装mysql过程中安装多次都失败了\",{\"1\":{\"1405\":1}}],[\"如果在\",{\"1\":{\"1102\":1}}],[\"如果在自己的类中实现该函数\",{\"1\":{\"925\":1}}],[\"如果在多条继承路径上\",{\"1\":{\"653\":1}}],[\"如果在函数中抛出了没有在异常抛出列表中声明的异常\",{\"1\":{\"608\":1}}],[\"如果在修改内容编译器会报错提示\",{\"1\":{\"535\":1}}],[\"如果在项目当前目录下查找失败\",{\"1\":{\"312\":1}}],[\"如果在宏中使用\",{\"1\":{\"274\":1}}],[\"如果第3步\",{\"1\":{\"290\":1}}],[\"如果第一次使用的话\",{\"1\":{\"28\":1}}],[\"如果请求内存大于128k\",{\"1\":{\"284\":1}}],[\"如果有其他事务在\",{\"1\":{\"1717\":1}}],[\"如果有部分事务处理失败\",{\"1\":{\"1649\":1}}],[\"如果有索引\",{\"1\":{\"1626\":1}}],[\"如果有两个中间结点\",{\"1\":{\"798\":2}}],[\"如果有bug在编译时候就会出现\",{\"1\":{\"497\":1}}],[\"如果有错\",{\"1\":{\"359\":1}}],[\"如果有问题就可以在编译时发现错误\",{\"1\":{\"359\":1}}],[\"如果有什么条件满足\",{\"1\":{\"277\":1}}],[\"如果有else\",{\"1\":{\"274\":1}}],[\"如果有判断\",{\"1\":{\"273\":1}}],[\"如果发现访问的地址还没有做映射\",{\"1\":{\"263\":1}}],[\"如果发现这个数比目标数字大\",{\"1\":{\"93\":1}}],[\"如果发现这个数比目标数字小\",{\"1\":{\"93\":1,\"94\":1}}],[\"如果你的库安装在一个非标准目录\",{\"1\":{\"1332\":1}}],[\"如果你不断开原链表中的每个节点的\",{\"1\":{\"795\":2}}],[\"如果你正处于do\",{\"1\":{\"277\":1}}],[\"如果你想要链接到静态库\",{\"1\":{\"1335\":1}}],[\"如果你想要控制链接的优先级\",{\"1\":{\"1335\":1}}],[\"如果你想要查看特定函数或地址的汇编代码\",{\"1\":{\"261\":1}}],[\"如果你想调用基类的有参构造函数\",{\"1\":{\"671\":1}}],[\"如果你想在每一步执行时都看到对应的汇编指令\",{\"1\":{\"261\":1}}],[\"如果你没有指定任何参数\",{\"1\":{\"261\":1}}],[\"如果你希望更改\",{\"1\":{\"239\":1}}],[\"如果此类编译器如果允许访问未初始化的值\",{\"1\":{\"234\":1}}],[\"如果输入为空\",{\"1\":{\"214\":1}}],[\"如果父结点最大\",{\"1\":{\"194\":1}}],[\"如果前面的元素比后面的大\",{\"1\":{\"188\":1}}],[\"如果前面不是连续的\",{\"1\":{\"129\":1}}],[\"如果任意一值在数组中出现至少两次\",{\"1\":{\"152\":1}}],[\"如果\",{\"1\":{\"146\":1,\"599\":1,\"765\":2,\"790\":2,\"802\":1,\"1082\":1,\"1090\":1,\"1096\":1,\"1099\":1,\"1341\":1,\"1588\":1,\"1719\":3,\"1774\":1}}],[\"如果重复了怎么办\",{\"1\":{\"135\":1}}],[\"如果本身为大根堆\",{\"1\":{\"121\":1}}],[\"如果返回了2个页面\",{\"1\":{\"1622\":1}}],[\"如果返回最后一个\",{\"1\":{\"95\":1}}],[\"如果返回第一个出现的地方\",{\"1\":{\"95\":1}}],[\"如果找到了\",{\"1\":{\"93\":1,\"94\":1}}],[\"如果以上方法都不行的话\",{\"1\":{\"66\":1}}],[\"如果中途丢失了一个分片\",{\"1\":{\"22\":1}}],[\"如鼠标\",{\"1\":{\"17\":1}}],[\"如经常关机\",{\"1\":{\"0\":1}}],[\"微软拼音输入法设置\",{\"1\":{\"65\":1}}],[\"微软雅黑\",{\"1\":{\"49\":2}}],[\"微软输入法自定义快捷键快速修改日期\",{\"0\":{\"46\":1}}],[\"微信号\",{\"1\":{\"0\":1}}],[\"微信应用开发\",{\"1\":{\"0\":1}}],[\"微博开放平台\",{\"1\":{\"0\":1}}],[\"a=1\",{\"1\":{\"1610\":1}}],[\"a=7\",{\"1\":{\"267\":1}}],[\"avl平衡二叉树索引\",{\"0\":{\"1622\":1}}],[\"avg\",{\"1\":{\"1444\":1,\"1538\":2}}],[\"available\",{\"1\":{\"286\":5,\"287\":1}}],[\"affected\",{\"1\":{\"1407\":2,\"1799\":2}}],[\"after\",{\"1\":{\"1240\":3,\"1552\":2}}],[\"amount\",{\"1\":{\"1531\":3}}],[\"amd64\",{\"1\":{\"1395\":1,\"1396\":1,\"1397\":10}}],[\"amylib\",{\"1\":{\"1331\":2}}],[\"amix\",{\"0\":{\"1130\":1,\"1132\":1,\"1290\":1},\"1\":{\"1132\":1,\"1141\":2,\"1290\":1}}],[\"a<网络类型>或\",{\"1\":{\"1237\":1}}],[\"a或\",{\"1\":{\"1237\":1}}],[\"a以值传递捕获\",{\"1\":{\"1172\":1}}],[\"a>\",{\"1\":{\"1158\":1}}],[\"a>b\",{\"1\":{\"163\":1}}],[\"a2\",{\"1\":{\"1158\":3,\"1188\":4,\"1189\":4}}],[\"a2>\",{\"1\":{\"1158\":1,\"1188\":2,\"1189\":2}}],[\"awaiting\",{\"1\":{\"1240\":1}}],[\"awk\",{\"1\":{\"1238\":4}}],[\"awesome\",{\"1\":{\"1132\":1,\"1290\":1}}],[\"awesome版本包括很多很棒的插件\",{\"1\":{\"1132\":1,\"1290\":1}}],[\"aws\",{\"1\":{\"0\":1}}],[\"a对像已被析构\",{\"1\":{\"1050\":1}}],[\"a8\",{\"1\":{\"866\":1,\"867\":1}}],[\"a6\",{\"1\":{\"862\":1,\"864\":2}}],[\"auther\",{\"1\":{\"1681\":1}}],[\"authentication\",{\"1\":{\"1407\":1}}],[\"author\",{\"1\":{\"1318\":1}}],[\"autoincrement=\",{\"1\":{\"1891\":1}}],[\"autocommit=1\",{\"1\":{\"1731\":1}}],[\"autocommit=0\",{\"1\":{\"1652\":2,\"1731\":1}}],[\"autocommit为1表示\",{\"1\":{\"1652\":1}}],[\"autocommit\",{\"1\":{\"1652\":1}}],[\"autoremove\",{\"1\":{\"1405\":2}}],[\"autorelease\",{\"1\":{\"854\":5,\"855\":4}}],[\"auto不是一个类型的\",{\"1\":{\"700\":1}}],[\"auto\",{\"0\":{\"700\":1,\"1043\":1,\"1044\":1},\"1\":{\"70\":2,\"97\":1,\"125\":1,\"153\":1,\"155\":1,\"162\":2,\"170\":2,\"171\":1,\"178\":3,\"188\":1,\"191\":2,\"296\":1,\"699\":1,\"700\":1,\"704\":1,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":8,\"784\":3,\"848\":1,\"849\":1,\"855\":1,\"871\":2,\"966\":5,\"999\":1,\"1000\":1,\"1001\":2,\"1002\":2,\"1007\":1,\"1008\":1,\"1011\":2,\"1042\":1,\"1043\":3,\"1045\":3,\"1148\":2,\"1168\":1,\"1173\":3,\"1174\":1,\"1175\":1,\"1178\":1,\"1194\":1,\"1428\":2,\"1433\":1,\"1437\":1,\"1537\":2,\"1551\":1,\"1552\":1,\"1908\":1,\"1909\":1}}],[\"autohotkey\",{\"1\":{\"29\":1}}],[\"autohotkeyu64\",{\"1\":{\"28\":1}}],[\"autohotkey笔记\",{\"0\":{\"26\":1},\"1\":{\"47\":1}}],[\"aux\",{\"0\":{\"1314\":1},\"1\":{\"1086\":1,\"1312\":3,\"1314\":3,\"1315\":3,\"1316\":3,\"1317\":1}}],[\"auditfy\",{\"1\":{\"867\":1}}],[\"audicarlight\",{\"1\":{\"867\":1}}],[\"audilight\",{\"1\":{\"867\":1}}],[\"audifactroy\",{\"1\":{\"866\":1}}],[\"audifactory\",{\"1\":{\"866\":1,\"867\":2}}],[\"audifty\",{\"1\":{\"866\":2,\"867\":2}}],[\"audi\",{\"1\":{\"831\":2,\"862\":3,\"864\":8,\"866\":1,\"867\":4,\"900\":3}}],[\"ago\",{\"1\":{\"1820\":1}}],[\"age相同再按name排序\",{\"1\":{\"1566\":1}}],[\"age=17\",{\"1\":{\"1693\":1}}],[\"age=18查询结果的地方都加上了间隙锁\",{\"1\":{\"1693\":1}}],[\"age=15\",{\"1\":{\"1682\":1}}],[\"age=22\",{\"1\":{\"1693\":3}}],[\"age=21\",{\"1\":{\"1693\":2}}],[\"age=20\",{\"1\":{\"1566\":1,\"1689\":4}}],[\"age=age+1\",{\"1\":{\"1478\":1}}],[\"age字段名改为student\",{\"1\":{\"1552\":1}}],[\"age数据类型为int\",{\"1\":{\"1552\":1}}],[\"age<=25\",{\"1\":{\"1511\":1,\"1525\":3}}],[\"age>10\",{\"1\":{\"1836\":2}}],[\"age>14后\",{\"1\":{\"1689\":1}}],[\"age>=20\",{\"1\":{\"1525\":3}}],[\"age>=21\",{\"1\":{\"1511\":1}}],[\"age>20用到了\",{\"1\":{\"1690\":1}}],[\"age>20\",{\"1\":{\"1526\":2,\"1689\":1}}],[\"age>22\",{\"1\":{\"1514\":2}}],[\"age>21\",{\"1\":{\"1511\":1,\"1515\":1}}],[\"agent=\",{\"1\":{\"1255\":1}}],[\"agent参数伪装\",{\"1\":{\"1255\":1}}],[\"age\",{\"0\":{\"1719\":1,\"1720\":1},\"1\":{\"784\":9,\"1384\":1,\"1415\":2,\"1437\":1,\"1469\":2,\"1475\":2,\"1480\":1,\"1511\":7,\"1512\":1,\"1513\":2,\"1514\":3,\"1515\":5,\"1525\":6,\"1526\":9,\"1537\":5,\"1551\":1,\"1552\":6,\"1592\":5,\"1720\":1,\"1851\":2,\"1856\":1,\"1878\":1}}],[\"agrs\",{\"1\":{\"378\":10}}],[\"a中的fun函数\",{\"1\":{\"695\":3}}],[\"a就为虚基类\",{\"1\":{\"688\":1}}],[\"a到b为单继承\",{\"1\":{\"688\":1}}],[\"a称为d的间接基类\",{\"1\":{\"688\":1}}],[\"a为b\",{\"1\":{\"688\":1}}],[\"acd特性用事务日志实现\",{\"1\":{\"1677\":1}}],[\"acid特性\",{\"0\":{\"1644\":1}}],[\"active\",{\"1\":{\"1240\":1,\"1820\":2}}],[\"actionmap\",{\"1\":{\"1168\":8}}],[\"action1\",{\"1\":{\"273\":3,\"274\":2,\"275\":1}}],[\"action2\",{\"0\":{\"273\":1,\"274\":1},\"1\":{\"273\":3,\"274\":2,\"275\":1}}],[\"acknowledged\",{\"1\":{\"1240\":1}}],[\"acknowledgment\",{\"1\":{\"1240\":1}}],[\"ack插件\",{\"0\":{\"1141\":1}}],[\"ack\",{\"1\":{\"1131\":1,\"1240\":2,\"1289\":1}}],[\"accno\",{\"1\":{\"1531\":1}}],[\"acc\",{\"1\":{\"1082\":1}}],[\"ac86\",{\"1\":{\"597\":1}}],[\"a会被重复定义\",{\"1\":{\"574\":1}}],[\"a1>\",{\"1\":{\"1158\":1}}],[\"a1=rollingfileappender\",{\"1\":{\"1026\":1}}],[\"a1\",{\"1\":{\"557\":4,\"1026\":6,\"1158\":7,\"1188\":6,\"1189\":6}}],[\"a1cb\",{\"1\":{\"479\":1}}],[\"aa的时候并未多开4字节保存对象个数\",{\"1\":{\"523\":1}}],[\"aa\",{\"1\":{\"518\":6,\"520\":1,\"521\":3,\"522\":6,\"523\":6}}],[\"aaa的年龄成功了\",{\"1\":{\"1635\":1}}],[\"aaa已经存在\",{\"1\":{\"1635\":1}}],[\"aaaaa\",{\"1\":{\"1415\":2}}],[\"aaaaaaaaaaaaaaaaaaaa\",{\"1\":{\"1120\":2,\"1121\":1}}],[\"aaa\",{\"1\":{\"368\":1,\"563\":1,\"1060\":2,\"1124\":1,\"1127\":1,\"1186\":1,\"1189\":1}}],[\"a571\",{\"1\":{\"509\":1}}],[\"a4679599e78c\",{\"1\":{\"500\":1}}],[\"a是变量值可以修改\",{\"1\":{\"492\":1}}],[\"a是nums里遍历的元素\",{\"1\":{\"135\":1}}],[\"a的值改成了30\",{\"1\":{\"484\":1}}],[\"a的去重\",{\"0\":{\"135\":1}}],[\"adaptive\",{\"1\":{\"1569\":2,\"1747\":1}}],[\"adt\",{\"1\":{\"446\":1}}],[\"addtime有索引\",{\"1\":{\"1586\":1}}],[\"addtime就已经是有序的了\",{\"1\":{\"1586\":1}}],[\"addons\",{\"1\":{\"1287\":3}}],[\"addobserver\",{\"1\":{\"871\":6}}],[\"addappender\",{\"1\":{\"1019\":1,\"1020\":1,\"1031\":5,\"1032\":2}}],[\"addatindex\",{\"1\":{\"790\":1,\"791\":4,\"792\":2}}],[\"addattail\",{\"1\":{\"790\":1,\"791\":3,\"792\":2}}],[\"addathead\",{\"1\":{\"790\":1,\"791\":3,\"792\":1}}],[\"addrinfo\",{\"1\":{\"1415\":2}}],[\"addref\",{\"1\":{\"1055\":1}}],[\"addressid\",{\"1\":{\"1471\":2}}],[\"address\",{\"1\":{\"251\":1,\"286\":6,\"633\":4,\"1408\":1}}],[\"addr\",{\"1\":{\"517\":1,\"710\":2,\"711\":2}}],[\"add<double>\",{\"1\":{\"364\":1}}],[\"add\",{\"0\":{\"1315\":1},\"1\":{\"233\":1,\"234\":4,\"236\":1,\"362\":2,\"364\":3,\"368\":2,\"500\":3,\"504\":5,\"506\":10,\"571\":5,\"572\":9,\"642\":14,\"695\":7,\"1310\":1,\"1312\":5,\"1313\":3,\"1314\":3,\"1315\":11,\"1316\":10,\"1317\":3,\"1318\":3,\"1321\":1,\"1322\":1,\"1360\":7,\"1523\":3,\"1552\":6,\"1818\":1}}],[\"addeventlistener\",{\"1\":{\"53\":1,\"54\":1,\"59\":9}}],[\"addfontcolor\",{\"1\":{\"29\":13}}],[\"ax>\",{\"1\":{\"234\":2}}],[\"ap\",{\"1\":{\"1238\":1}}],[\"api接口不用修改\",{\"1\":{\"886\":1}}],[\"apt\",{\"0\":{\"1296\":2},\"1\":{\"234\":1,\"1016\":2,\"1035\":1,\"1131\":1,\"1280\":2,\"1284\":6,\"1287\":2,\"1289\":1,\"1293\":1,\"1295\":1,\"1296\":4,\"1305\":1,\"1371\":1,\"1393\":2,\"1397\":6,\"1399\":1,\"1405\":4,\"1818\":1}}],[\"applewebkit\",{\"1\":{\"1255\":1}}],[\"apply\",{\"1\":{\"49\":1}}],[\"appears\",{\"1\":{\"1082\":1}}],[\"appender为a1\",{\"1\":{\"1026\":1}}],[\"appender为rootappender\",{\"1\":{\"1026\":1}}],[\"appender和layout三者的关系\",{\"0\":{\"1022\":1}}],[\"appender\",{\"0\":{\"1019\":1},\"1\":{\"1019\":4,\"1021\":1,\"1025\":1,\"1026\":10}}],[\"appendchild\",{\"1\":{\"59\":1}}],[\"append\",{\"1\":{\"54\":2,\"59\":4,\"60\":1,\"536\":1,\"541\":4,\"547\":1}}],[\"app\",{\"1\":{\"59\":1,\"1305\":1}}],[\"appsrc\",{\"1\":{\"52\":1,\"61\":1}}],[\"atoi\",{\"1\":{\"1839\":5,\"1849\":5,\"1875\":5}}],[\"atoi这个只能字符串转十进制\",{\"1\":{\"1299\":1}}],[\"atomic\",{\"1\":{\"1055\":1,\"1202\":1,\"1233\":2,\"1644\":1,\"1839\":2,\"1848\":3,\"1859\":3,\"1875\":3}}],[\"atexit方式进行\",{\"0\":{\"856\":1}}],[\"atexit\",{\"1\":{\"572\":1,\"856\":1,\"857\":1,\"1032\":1}}],[\"attr\",{\"1\":{\"493\":2}}],[\"att\",{\"1\":{\"244\":1}}],[\"at\",{\"1\":{\"142\":1,\"354\":1,\"539\":2,\"597\":5,\"599\":2,\"605\":2,\"1773\":2}}],[\"atcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatcgatc\",{\"1\":{\"6\":1}}],[\"ant\",{\"1\":{\"1238\":1}}],[\"anlp|grep\",{\"1\":{\"1238\":1}}],[\"an\",{\"1\":{\"1102\":1,\"1238\":3}}],[\"anonymous\",{\"1\":{\"591\":1}}],[\"another\",{\"1\":{\"277\":1}}],[\"animals\",{\"1\":{\"494\":2}}],[\"animal\",{\"1\":{\"494\":6,\"886\":9,\"905\":10}}],[\"any\",{\"1\":{\"388\":1,\"1102\":1}}],[\"and\",{\"1\":{\"182\":1,\"202\":1,\"503\":1,\"572\":1,\"791\":1,\"792\":1,\"1240\":3,\"1407\":1,\"1480\":1,\"1511\":3,\"1525\":6,\"1537\":3,\"1538\":1,\"1541\":1,\"1610\":1}}],[\"ans\",{\"1\":{\"87\":4}}],[\"angularjs\",{\"1\":{\"0\":1}}],[\"ajustarray\",{\"1\":{\"70\":2}}],[\"asc\",{\"1\":{\"1496\":1,\"1525\":2,\"1614\":1}}],[\"ascii\",{\"1\":{\"1426\":1}}],[\"asflags\",{\"1\":{\"1356\":1}}],[\"assume\",{\"1\":{\"1102\":1}}],[\"assert\",{\"1\":{\"1321\":1}}],[\"assert不起作用\",{\"1\":{\"1321\":1}}],[\"assembler\",{\"1\":{\"234\":4}}],[\"assets\",{\"1\":{\"60\":3,\"81\":1,\"783\":1,\"1082\":1,\"1085\":1,\"1656\":1,\"1658\":2,\"1660\":1,\"1663\":2,\"1664\":2,\"1665\":5,\"1668\":1,\"1673\":1,\"1677\":2,\"1681\":4,\"1682\":4,\"1758\":4,\"1759\":1,\"1767\":1,\"1768\":1,\"1769\":2,\"1770\":2,\"1771\":2,\"1772\":2,\"1773\":8,\"1774\":10,\"1775\":1,\"1776\":5}}],[\"assetpath\",{\"1\":{\"60\":1}}],[\"asm\",{\"1\":{\"261\":1}}],[\"as\",{\"1\":{\"60\":1,\"182\":1,\"791\":1,\"792\":1,\"1356\":2,\"1526\":3,\"1531\":1,\"1537\":2}}],[\"abcd\",{\"1\":{\"1426\":2}}],[\"ab对象的引用计数均为1\",{\"1\":{\"1056\":1}}],[\"abstractfactory\",{\"1\":{\"867\":3}}],[\"abstract\",{\"0\":{\"867\":1},\"1\":{\"446\":1}}],[\"abs\",{\"1\":{\"158\":2,\"161\":2,\"162\":2,\"191\":2,\"771\":1}}],[\"absolutepath\",{\"1\":{\"60\":3}}],[\"ab1\",{\"1\":{\"5\":1}}],[\"article\",{\"1\":{\"1878\":1}}],[\"archives\",{\"1\":{\"1395\":1}}],[\"archived\",{\"1\":{\"1395\":1}}],[\"arflags\",{\"1\":{\"1356\":1}}],[\"ar\",{\"0\":{\"1334\":1},\"1\":{\"1334\":3,\"1356\":2}}],[\"arm\",{\"1\":{\"302\":1}}],[\"arr+sizeof\",{\"1\":{\"1007\":2}}],[\"arrary\",{\"1\":{\"101\":3}}],[\"array底层\",{\"1\":{\"1197\":1}}],[\"array\",{\"1\":{\"59\":4,\"483\":1,\"484\":2,\"531\":1,\"1082\":1}}],[\"arr\",{\"1\":{\"70\":10,\"101\":27,\"104\":5,\"459\":1,\"618\":4,\"1001\":10,\"1007\":8}}],[\"arg2\",{\"1\":{\"1158\":2}}],[\"arg1\",{\"1\":{\"1158\":2}}],[\"arguments\",{\"1\":{\"1361\":1}}],[\"argument\",{\"1\":{\"604\":1}}],[\"arg\",{\"1\":{\"493\":1,\"1158\":7}}],[\"args就是函数参数包\",{\"1\":{\"377\":1}}],[\"args\",{\"1\":{\"377\":2,\"378\":10,\"1299\":1,\"1340\":2}}],[\"args标识符的左侧使用了省略号\",{\"1\":{\"376\":1}}],[\"args>\",{\"1\":{\"376\":1,\"378\":3}}],[\"argv\",{\"1\":{\"60\":2,\"185\":1,\"433\":1,\"434\":1,\"449\":1,\"459\":1,\"468\":1,\"476\":1,\"497\":1,\"500\":1,\"506\":1,\"515\":1,\"547\":1,\"557\":1,\"571\":1,\"588\":1,\"594\":6,\"602\":1,\"618\":1,\"633\":1,\"642\":1,\"662\":2,\"894\":1,\"1020\":1,\"1031\":1,\"1299\":3}}],[\"argc\",{\"1\":{\"60\":2,\"185\":1,\"433\":1,\"434\":1,\"449\":1,\"459\":1,\"468\":1,\"476\":1,\"497\":1,\"500\":1,\"506\":1,\"515\":1,\"547\":1,\"557\":1,\"571\":1,\"588\":1,\"594\":6,\"602\":1,\"618\":1,\"633\":1,\"642\":1,\"662\":2,\"894\":1,\"1020\":1,\"1031\":1,\"1299\":2}}],[\"area\",{\"1\":{\"898\":4}}],[\"are\",{\"1\":{\"8\":1,\"1082\":1}}],[\"alivetime\",{\"1\":{\"1846\":3,\"1859\":3}}],[\"align转为4字节\",{\"1\":{\"1090\":1}}],[\"align\",{\"1\":{\"51\":1,\"1082\":2,\"1090\":18,\"1102\":1}}],[\"alert日志都可以记录下来\",{\"1\":{\"1025\":1}}],[\"alert\",{\"1\":{\"1025\":2,\"1031\":3}}],[\"alt\",{\"1\":{\"1277\":1}}],[\"alter等\",{\"1\":{\"1548\":1}}],[\"alter\",{\"1\":{\"1031\":3,\"1447\":1,\"1552\":16,\"1772\":1}}],[\"alternatives\",{\"1\":{\"1016\":1}}],[\"alt+7\",{\"1\":{\"29\":1}}],[\"alt+6\",{\"1\":{\"29\":1}}],[\"alt+5\",{\"1\":{\"29\":1}}],[\"alt+4\",{\"1\":{\"29\":1}}],[\"alt+3\",{\"1\":{\"29\":1}}],[\"alt+2\",{\"1\":{\"29\":1}}],[\"alt+1\",{\"1\":{\"29\":1}}],[\"alt+0\",{\"1\":{\"29\":1}}],[\"algo\",{\"1\":{\"110\":1}}],[\"algorithm\",{\"1\":{\"67\":1}}],[\"all替换\",{\"1\":{\"1739\":1}}],[\"all语句中\",{\"1\":{\"1618\":1}}],[\"all联合查询\",{\"1\":{\"1594\":1}}],[\"all通知其他线程\",{\"1\":{\"1221\":1}}],[\"alloc希望能够分配20个chunk块的内存\",{\"1\":{\"1102\":1}}],[\"alloc重新在备用内存中拿\",{\"1\":{\"1102\":1}}],[\"alloc源码\",{\"0\":{\"1102\":1}}],[\"alloc里被修改\",{\"1\":{\"1099\":1}}],[\"alloc异常类实例\",{\"1\":{\"605\":1}}],[\"alloc类型的异常\",{\"1\":{\"513\":1,\"708\":1}}],[\"allocation\",{\"1\":{\"1082\":1}}],[\"allocate源码\",{\"1\":{\"1102\":1}}],[\"allocate\",{\"1\":{\"385\":5,\"704\":5,\"964\":1,\"1076\":1,\"1080\":4,\"1082\":1,\"1087\":1,\"1096\":2,\"1102\":2,\"1127\":6}}],[\"allocator通过宏控制有两种实现\",{\"1\":{\"1079\":1}}],[\"allocators\",{\"1\":{\"1079\":1,\"1080\":1}}],[\"allocator\",{\"1\":{\"385\":17,\"704\":17,\"747\":7,\"1079\":5,\"1080\":3,\"1081\":3,\"1086\":2,\"1087\":3,\"1096\":2,\"1127\":16}}],[\"allocator实现\",{\"0\":{\"385\":1}}],[\"allocator<t>>\",{\"1\":{\"385\":1,\"704\":1,\"1087\":1,\"1127\":1}}],[\"allocator<\",{\"1\":{\"355\":1,\"985\":1,\"1079\":1}}],[\"alloc>\",{\"1\":{\"355\":2,\"747\":2,\"1079\":1,\"1086\":2}}],[\"alloc<\",{\"1\":{\"355\":1}}],[\"alloc\",{\"1\":{\"355\":1,\"385\":2,\"604\":1,\"605\":1,\"607\":2,\"704\":2,\"710\":2,\"985\":1,\"1076\":1,\"1079\":4,\"1080\":10,\"1081\":4,\"1082\":7,\"1086\":2,\"1087\":1,\"1090\":1,\"1093\":1,\"1096\":2,\"1099\":3,\"1102\":12,\"1105\":1,\"1127\":2}}],[\"allow\",{\"0\":{\"1016\":1},\"1\":{\"59\":6}}],[\"allfiles\",{\"1\":{\"60\":2}}],[\"allpicfiles\",{\"1\":{\"60\":6}}],[\"all\",{\"0\":{\"1229\":1},\"1\":{\"54\":2,\"59\":2,\"1143\":1,\"1219\":3,\"1229\":1,\"1237\":1,\"1357\":2,\"1362\":2,\"1365\":2,\"1366\":2,\"1367\":2,\"1408\":1,\"1447\":2,\"1485\":1,\"1486\":1,\"1502\":1,\"1514\":2,\"1521\":1,\"1618\":1,\"1799\":1,\"1836\":2,\"1849\":2,\"1859\":2,\"1869\":1,\"1872\":1,\"1875\":1}}],[\"ahk脚本所使用的文件名后缀\",{\"1\":{\"28\":1}}],[\"ahk脚本\",{\"1\":{\"27\":1}}],[\"ahk\",{\"1\":{\"27\":1,\"28\":1,\"29\":3}}],[\"a\",{\"0\":{\"257\":1,\"259\":1,\"1719\":1,\"1720\":1},\"1\":{\"8\":2,\"11\":2,\"59\":2,\"61\":1,\"135\":2,\"147\":1,\"163\":1,\"166\":2,\"174\":2,\"214\":2,\"224\":1,\"234\":7,\"236\":4,\"238\":1,\"239\":1,\"246\":4,\"252\":1,\"262\":2,\"263\":2,\"267\":1,\"277\":1,\"300\":1,\"340\":2,\"359\":1,\"365\":6,\"366\":6,\"368\":4,\"370\":2,\"371\":1,\"378\":4,\"422\":9,\"433\":1,\"468\":1,\"470\":1,\"483\":6,\"484\":10,\"485\":3,\"489\":5,\"490\":6,\"492\":18,\"500\":9,\"506\":3,\"516\":1,\"518\":3,\"521\":3,\"528\":14,\"529\":9,\"536\":1,\"547\":5,\"557\":6,\"563\":13,\"567\":3,\"568\":3,\"569\":3,\"570\":4,\"574\":1,\"578\":2,\"594\":2,\"605\":1,\"606\":1,\"612\":2,\"613\":1,\"614\":4,\"616\":2,\"618\":11,\"620\":1,\"621\":4,\"625\":4,\"628\":1,\"630\":5,\"638\":5,\"639\":4,\"640\":2,\"642\":7,\"647\":2,\"649\":1,\"650\":2,\"652\":4,\"653\":7,\"659\":1,\"682\":2,\"684\":3,\"688\":16,\"692\":1,\"693\":4,\"695\":26,\"724\":1,\"731\":3,\"771\":2,\"777\":2,\"784\":9,\"885\":1,\"890\":12,\"898\":6,\"900\":2,\"934\":4,\"939\":3,\"943\":8,\"980\":2,\"981\":6,\"982\":7,\"1008\":4,\"1020\":2,\"1032\":1,\"1050\":4,\"1056\":8,\"1057\":7,\"1080\":1,\"1110\":2,\"1114\":2,\"1148\":2,\"1154\":4,\"1158\":5,\"1165\":2,\"1166\":4,\"1172\":3,\"1173\":10,\"1174\":4,\"1175\":4,\"1177\":2,\"1178\":2,\"1179\":3,\"1186\":2,\"1187\":2,\"1188\":2,\"1189\":8,\"1194\":1,\"1202\":1,\"1217\":1,\"1237\":2,\"1238\":2,\"1240\":4,\"1245\":1,\"1331\":1,\"1334\":3,\"1335\":2,\"1338\":1,\"1345\":3,\"1357\":4,\"1537\":17,\"1538\":4,\"1539\":5,\"1540\":3,\"1541\":6,\"1543\":4,\"1544\":6,\"1557\":1,\"1566\":1,\"1718\":1,\"1719\":1,\"1736\":1,\"1740\":2,\"1757\":1,\"1828\":1,\"1878\":2}}],[\"b升序排列\",{\"1\":{\"1736\":1}}],[\"b+树所有叶子节点被连接成了有序链表结构\",{\"1\":{\"1627\":1}}],[\"b+树所有的数据都存在叶子节点上\",{\"1\":{\"1627\":1}}],[\"b+树的高度要小于b\",{\"1\":{\"1627\":1}}],[\"b+树的叶子节点存放关键字和数据\",{\"1\":{\"1627\":1}}],[\"b+树\",{\"0\":{\"1625\":1}}],[\"b+输入读取一个块\",{\"1\":{\"1603\":1}}],[\"b树不方便做看起来也不方便\",{\"1\":{\"1626\":1}}],[\"b树的\",{\"1\":{\"1626\":1}}],[\"b树的好处是减少磁盘io加速搜索\",{\"1\":{\"1623\":1}}],[\"b树\",{\"1\":{\"1626\":1}}],[\"b树索引\",{\"0\":{\"1623\":1}}],[\"b就只剩3条数据\",{\"1\":{\"1540\":1}}],[\"b为大表\",{\"1\":{\"1537\":1}}],[\"b不变\",{\"1\":{\"1537\":1}}],[\"bcnf\",{\"0\":{\"1463\":1}}],[\"bc范式\",{\"0\":{\"1463\":1}}],[\"bcpl\",{\"1\":{\"300\":1,\"301\":2}}],[\"bye\",{\"1\":{\"1799\":1}}],[\"by字段\",{\"1\":{\"1737\":1}}],[\"by语句中\",{\"1\":{\"1618\":1}}],[\"by性能都和索引相关\",{\"1\":{\"1530\":1}}],[\"by和group\",{\"1\":{\"1530\":1,\"1618\":1}}],[\"by会自动排序\",{\"0\":{\"1527\":1}}],[\"by结果进行过滤\",{\"1\":{\"1526\":1}}],[\"by后以索引进行排序\",{\"1\":{\"1525\":1}}],[\"by可能会出现比较耗时情况\",{\"1\":{\"1525\":1}}],[\"by功能强大也耗时\",{\"1\":{\"1512\":1}}],[\"by也能去重\",{\"1\":{\"1512\":1}}],[\"by\",{\"0\":{\"1525\":1,\"1526\":1,\"1736\":1,\"1737\":1},\"1\":{\"1408\":1,\"1447\":3,\"1496\":3,\"1497\":1,\"1525\":3,\"1526\":3,\"1531\":2,\"1538\":9,\"1566\":1,\"1729\":2,\"1737\":5,\"1740\":1,\"1799\":1,\"1803\":2,\"1821\":3,\"1828\":1}}],[\"byte\",{\"1\":{\"330\":1}}],[\"bytes空间出去\",{\"1\":{\"1102\":1}}],[\"bytes\",{\"1\":{\"239\":2,\"1076\":2,\"1082\":2,\"1090\":16,\"1093\":1,\"1096\":2,\"1102\":25}}],[\"bt\",{\"1\":{\"1338\":1,\"1340\":1}}],[\"b文件的内容也会被改变\",{\"1\":{\"1267\":1}}],[\"b进行后台下载\",{\"1\":{\"1253\":1}}],[\"bz2\",{\"1\":{\"1261\":2,\"1263\":1}}],[\"bz2的压缩文件解压\",{\"1\":{\"1261\":1}}],[\"bz2的压缩文件\",{\"1\":{\"1261\":1}}],[\"bzip2\",{\"1\":{\"1261\":3,\"1263\":1}}],[\"bzip2用来将文件压缩成后缀名为\",{\"1\":{\"1261\":1}}],[\"bz\",{\"1\":{\"1251\":2}}],[\"b改掉\",{\"1\":{\"1174\":1}}],[\"b以传引用的方式捕获\",{\"1\":{\"1172\":1}}],[\"bn<cr>\",{\"1\":{\"1133\":1}}],[\"bnze\",{\"1\":{\"900\":3}}],[\"b有10行\",{\"1\":{\"1537\":1}}],[\"b有默认值\",{\"1\":{\"1114\":1}}],[\"b有自己的mb\",{\"1\":{\"688\":1}}],[\"b派生出c\",{\"1\":{\"943\":1}}],[\"b派生类\",{\"1\":{\"684\":1}}],[\"b类有两个虚函数表\",{\"1\":{\"938\":1}}],[\"bf2\",{\"1\":{\"891\":2}}],[\"bf1\",{\"1\":{\"891\":2}}],[\"bf\",{\"1\":{\"891\":2}}],[\"bf35\",{\"1\":{\"636\":1}}],[\"bmdfty\",{\"1\":{\"867\":1}}],[\"bmwlight\",{\"1\":{\"867\":2}}],[\"bmw或者audi汽车制造工厂除了生产汽车\",{\"1\":{\"866\":1}}],[\"bmwfactroy\",{\"1\":{\"866\":1}}],[\"bmwfactory\",{\"1\":{\"866\":1,\"867\":2}}],[\"bmwfty\",{\"1\":{\"866\":2,\"867\":2}}],[\"bmw和audi两种汽车都有自己的工厂在生产\",{\"1\":{\"866\":1}}],[\"bmw\",{\"1\":{\"831\":2,\"862\":3,\"864\":8,\"866\":1,\"867\":4,\"900\":3}}],[\"b中的fun函数\",{\"1\":{\"695\":1}}],[\"b从a继承而来\",{\"1\":{\"688\":1}}],[\"b从a继承来并且有自己的mb\",{\"1\":{\"688\":1}}],[\"b从a单一继承而来\",{\"1\":{\"688\":1}}],[\"b从a单继承而来\",{\"1\":{\"688\":1}}],[\"b本身\",{\"1\":{\"618\":1}}],[\"b=\",{\"1\":{\"614\":1,\"1610\":1}}],[\"b=0\",{\"1\":{\"267\":1}}],[\"bd17\",{\"1\":{\"601\":1}}],[\"bdb7d4b4\",{\"1\":{\"601\":1}}],[\"bbbbb\",{\"1\":{\"1415\":2}}],[\"bbb\",{\"1\":{\"563\":1,\"1186\":1}}],[\"b6\",{\"1\":{\"473\":1}}],[\"b5\",{\"1\":{\"473\":1,\"489\":1}}],[\"b4不可变\",{\"1\":{\"489\":1}}],[\"b4\",{\"1\":{\"473\":1,\"489\":1}}],[\"b3是所修饰的变量\",{\"1\":{\"489\":1}}],[\"b3是常量不可变\",{\"1\":{\"489\":1}}],[\"b3\",{\"1\":{\"473\":1,\"489\":2}}],[\"b2本身可变\",{\"1\":{\"489\":1}}],[\"b2\",{\"1\":{\"473\":1,\"489\":1,\"891\":10,\"900\":2}}],[\"b18c\",{\"1\":{\"601\":1}}],[\"b1本身是⼀个常量\",{\"1\":{\"489\":1}}],[\"b1\",{\"1\":{\"473\":1,\"489\":1,\"557\":4,\"891\":10,\"900\":2}}],[\"b语言\",{\"1\":{\"301\":1}}],[\"b语言编写的\",{\"1\":{\"300\":1}}],[\"brno\",{\"1\":{\"1531\":4}}],[\"brand\",{\"1\":{\"397\":8,\"426\":6,\"435\":6,\"439\":7,\"440\":8,\"449\":7,\"450\":8,\"464\":12}}],[\"brk是将数据段\",{\"1\":{\"281\":1}}],[\"brk和mmap\",{\"1\":{\"281\":1}}],[\"bret\",{\"1\":{\"271\":3}}],[\"breakpoint\",{\"1\":{\"1340\":1}}],[\"break\",{\"1\":{\"121\":1,\"188\":1,\"194\":1,\"261\":1,\"271\":2,\"277\":4,\"286\":1,\"296\":1,\"742\":1,\"743\":1,\"747\":2,\"864\":1,\"871\":9,\"1099\":1,\"1168\":6,\"1340\":5,\"1849\":1,\"1859\":1}}],[\"bss段\",{\"1\":{\"267\":1}}],[\"bss映射到cpu虚拟地址\",{\"1\":{\"263\":1}}],[\"bss<=>\",{\"1\":{\"255\":1}}],[\"bss\",{\"1\":{\"251\":1,\"255\":1,\"267\":2}}],[\"b的值之前入栈\",{\"1\":{\"238\":1}}],[\"b的值\",{\"1\":{\"234\":1}}],[\"bundle\",{\"1\":{\"1395\":2,\"1396\":1}}],[\"bug\",{\"1\":{\"1102\":1}}],[\"build\",{\"0\":{\"1319\":1,\"1320\":1},\"1\":{\"1099\":1,\"1306\":1,\"1308\":1,\"1310\":2,\"1316\":2,\"1317\":1,\"1318\":3,\"1319\":3,\"1320\":3}}],[\"buffer写入磁盘上的redo\",{\"1\":{\"1763\":1}}],[\"buffer写入磁盘\",{\"1\":{\"1762\":1}}],[\"buffer不够\",{\"1\":{\"1736\":1}}],[\"buffer\",{\"0\":{\"1760\":1},\"1\":{\"202\":7,\"1736\":2,\"1748\":1,\"1752\":3,\"1758\":4,\"1762\":1,\"1763\":2,\"1913\":1}}],[\"bucket\",{\"1\":{\"191\":10}}],[\"bubble\",{\"1\":{\"188\":3}}],[\"bubblesort\",{\"1\":{\"188\":7,\"1367\":2}}],[\"buttons\",{\"1\":{\"54\":4,\"59\":12}}],[\"button\",{\"1\":{\"53\":10,\"54\":12,\"59\":32}}],[\"b与c的去重\",{\"0\":{\"136\":1}}],[\"birthdate\",{\"1\":{\"1552\":1}}],[\"bill\",{\"1\":{\"1531\":2}}],[\"bill是某银行代缴话费的主流水表结构\",{\"1\":{\"1531\":1}}],[\"bin和\",{\"1\":{\"1820\":1}}],[\"bin下建立软连接\",{\"1\":{\"1800\":1}}],[\"binlog位置等告诉slave\",{\"1\":{\"1833\":1}}],[\"binlog的position问题\",{\"0\":{\"1829\":1}}],[\"binlog的position\",{\"1\":{\"1825\":1}}],[\"binlog文件名\",{\"1\":{\"1825\":1}}],[\"binlog解码方式\",{\"1\":{\"1773\":1}}],[\"binlog默认在mysql的配置文件\",{\"1\":{\"1772\":1}}],[\"binlog\",{\"1\":{\"1772\":1,\"1774\":2,\"1784\":1,\"1785\":1}}],[\"bin\",{\"1\":{\"1016\":4,\"1305\":3,\"1306\":1,\"1316\":3,\"1317\":2,\"1318\":3,\"1773\":2,\"1774\":5,\"1799\":1,\"1800\":1,\"1820\":4,\"1825\":1,\"1829\":1}}],[\"bind绑定了一个\",{\"1\":{\"1154\":1}}],[\"bind绑定器和function函数对象\",{\"0\":{\"1942\":1}}],[\"bind绑定器绑定的结果依然还是一个函数对象\",{\"1\":{\"1180\":1}}],[\"bind绑定器可以给函数绑定固定的参数\",{\"1\":{\"1154\":1}}],[\"bind绑定器\",{\"1\":{\"1154\":2},\"2\":{\"1150\":1,\"1153\":1}}],[\"bind是函数模板\",{\"1\":{\"1154\":2}}],[\"bind\",{\"1\":{\"1151\":1,\"1154\":5,\"1155\":4,\"1195\":1,\"1848\":2,\"1849\":2,\"1859\":4,\"1875\":3}}],[\"bind和function实现muduo中的线程池\",{\"0\":{\"1151\":1}}],[\"bind2nd\",{\"1\":{\"1008\":2,\"1148\":2}}],[\"bind1st和bind2d作用\",{\"1\":{\"1146\":1}}],[\"bind1st和bind2d是stl中的\",{\"1\":{\"1146\":1}}],[\"bind1st和bind2d使用\",{\"0\":{\"1146\":1}}],[\"bind1st\",{\"1\":{\"1008\":2,\"1146\":1,\"1148\":1}}],[\"binding\",{\"1\":{\"883\":3}}],[\"binary\",{\"1\":{\"93\":1,\"94\":1,\"96\":1,\"97\":1,\"227\":1,\"1007\":2,\"1310\":2,\"1772\":1}}],[\"binarysearch\",{\"1\":{\"84\":1,\"142\":2}}],[\"biancheng\",{\"1\":{\"597\":1,\"599\":1}}],[\"bit\",{\"1\":{\"572\":1,\"1395\":1}}],[\"bitset<>\",{\"1\":{\"604\":1}}],[\"bits\",{\"1\":{\"234\":1}}],[\"big2\",{\"1\":{\"118\":9}}],[\"big1\",{\"1\":{\"118\":9}}],[\"between\",{\"1\":{\"1471\":1,\"1480\":1,\"1511\":1,\"1618\":1}}],[\"benz\",{\"1\":{\"831\":2}}],[\"been\",{\"1\":{\"606\":2}}],[\"be\",{\"1\":{\"182\":1,\"601\":5,\"791\":1,\"792\":1,\"1080\":1,\"1096\":1,\"1253\":1}}],[\"begin\",{\"1\":{\"60\":1,\"104\":1,\"107\":1,\"110\":3,\"114\":1,\"126\":1,\"133\":1,\"137\":1,\"154\":1,\"163\":4,\"170\":1,\"171\":2,\"179\":5,\"214\":2,\"220\":5,\"539\":2,\"698\":2,\"699\":3,\"700\":2,\"704\":3,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":4,\"966\":7,\"999\":2,\"1001\":1,\"1002\":2,\"1007\":8,\"1008\":1,\"1011\":4,\"1147\":3,\"1148\":5,\"1177\":1,\"1178\":1,\"1179\":1,\"1523\":1,\"1640\":1,\"1656\":1,\"1851\":6}}],[\"before\",{\"1\":{\"51\":27}}],[\"balance=\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"balance\",{\"1\":{\"1803\":1}}],[\"bank\",{\"1\":{\"1531\":2}}],[\"bak\",{\"1\":{\"1284\":1}}],[\"bahsrc\",{\"0\":{\"1281\":1}}],[\"baidu\",{\"1\":{\"1277\":1}}],[\"bad\",{\"1\":{\"604\":4,\"605\":2,\"607\":2,\"710\":2,\"1102\":1,\"1105\":1}}],[\"bashrc生效\",{\"1\":{\"1282\":1}}],[\"bashrc\",{\"1\":{\"1282\":1}}],[\"bask\",{\"1\":{\"1127\":1}}],[\"bas\",{\"1\":{\"662\":1}}],[\"basicconfigurator\",{\"1\":{\"1026\":1}}],[\"basiclayout\",{\"1\":{\"1020\":2,\"1031\":3}}],[\"basic\",{\"1\":{\"541\":1,\"546\":2,\"605\":1}}],[\"baseengine\",{\"1\":{\"1881\":3}}],[\"base64\",{\"1\":{\"1773\":2}}],[\"base<\",{\"1\":{\"1079\":1,\"1086\":2}}],[\"baseclass\",{\"1\":{\"933\":2}}],[\"base大小赋为0\",{\"1\":{\"908\":1}}],[\"base3\",{\"1\":{\"889\":7}}],[\"base1\",{\"1\":{\"889\":6}}],[\"base链表中\",{\"1\":{\"747\":1}}],[\"base节点的地址\",{\"1\":{\"747\":1}}],[\"base2\",{\"1\":{\"678\":2,\"889\":7}}],[\"base4initd1ev\",{\"1\":{\"572\":1}}],[\"base4initc1ev\",{\"1\":{\"572\":1}}],[\"base\",{\"1\":{\"48\":1,\"49\":1,\"51\":1,\"355\":1,\"422\":6,\"494\":4,\"631\":6,\"662\":38,\"667\":6,\"669\":4,\"670\":6,\"672\":9,\"678\":19,\"747\":9,\"894\":15,\"898\":2,\"900\":15,\"906\":4,\"907\":7,\"908\":9,\"913\":8,\"919\":5,\"920\":4,\"922\":2,\"923\":2,\"948\":14,\"949\":6,\"953\":14,\"954\":8,\"956\":3,\"1299\":3}}],[\"bark\",{\"1\":{\"886\":22,\"905\":7}}],[\"barks\",{\"1\":{\"494\":1}}],[\"bar\",{\"1\":{\"504\":1,\"528\":11,\"529\":7}}],[\"backports\",{\"1\":{\"1284\":2}}],[\"back的重载函数\",{\"1\":{\"1127\":1}}],[\"back函数\",{\"1\":{\"1127\":1}}],[\"back方法\",{\"1\":{\"1127\":1}}],[\"back代理了\",{\"1\":{\"989\":2}}],[\"back从当前末尾删除\",{\"1\":{\"747\":1}}],[\"back中加入了verfiy\",{\"1\":{\"747\":1}}],[\"back\",{\"1\":{\"59\":1,\"101\":9,\"110\":1,\"133\":1,\"137\":1,\"185\":2,\"188\":1,\"191\":4,\"354\":2,\"355\":6,\"385\":7,\"704\":4,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":9,\"755\":1,\"817\":9,\"871\":3,\"965\":2,\"966\":5,\"969\":2,\"970\":2,\"989\":3,\"991\":1,\"1011\":2,\"1045\":3,\"1086\":2,\"1087\":2,\"1124\":2,\"1127\":6,\"1147\":1,\"1148\":1,\"1151\":2,\"1177\":1,\"1208\":1,\"1233\":1}}],[\"backbutton\",{\"1\":{\"59\":2}}],[\"background\",{\"1\":{\"50\":1,\"1253\":1}}],[\"bae\",{\"1\":{\"0\":1}}],[\"blog\",{\"1\":{\"1878\":1}}],[\"block\",{\"1\":{\"286\":6,\"287\":2}}],[\"blocks\",{\"1\":{\"239\":2}}],[\"blue\",{\"1\":{\"29\":1}}],[\"black\",{\"1\":{\"29\":1,\"51\":5}}],[\"b\",{\"0\":{\"1253\":1},\"1\":{\"29\":1,\"135\":1,\"147\":1,\"163\":1,\"234\":9,\"236\":4,\"238\":1,\"246\":4,\"261\":1,\"267\":1,\"277\":1,\"300\":2,\"301\":4,\"340\":1,\"365\":6,\"366\":6,\"368\":4,\"370\":2,\"378\":3,\"422\":3,\"484\":2,\"490\":2,\"500\":9,\"506\":3,\"528\":9,\"529\":6,\"557\":5,\"563\":9,\"567\":3,\"568\":3,\"569\":3,\"570\":4,\"572\":1,\"605\":2,\"613\":1,\"614\":1,\"616\":2,\"618\":11,\"620\":1,\"621\":2,\"630\":1,\"632\":1,\"638\":4,\"639\":4,\"640\":2,\"642\":5,\"647\":2,\"649\":1,\"650\":2,\"652\":6,\"653\":5,\"659\":1,\"684\":1,\"688\":11,\"693\":1,\"695\":17,\"731\":3,\"771\":2,\"777\":1,\"784\":9,\"890\":12,\"891\":13,\"898\":6,\"920\":3,\"922\":1,\"923\":2,\"934\":3,\"939\":2,\"943\":7,\"980\":3,\"981\":6,\"982\":7,\"1008\":4,\"1056\":10,\"1057\":9,\"1114\":2,\"1148\":2,\"1154\":4,\"1158\":2,\"1165\":2,\"1166\":4,\"1172\":2,\"1173\":10,\"1174\":4,\"1175\":4,\"1177\":1,\"1186\":2,\"1187\":2,\"1188\":2,\"1189\":4,\"1253\":1,\"1340\":1,\"1345\":3,\"1347\":1,\"1357\":4,\"1537\":4,\"1538\":27,\"1539\":1,\"1540\":2,\"1541\":6,\"1543\":1,\"1544\":4,\"1623\":3,\"1627\":2,\"1736\":2}}],[\"boblim\",{\"1\":{\"1914\":1}}],[\"both\",{\"1\":{\"1240\":1}}],[\"bormal\",{\"1\":{\"267\":1}}],[\"border\",{\"1\":{\"48\":3,\"49\":3,\"51\":2}}],[\"bounds\",{\"1\":{\"531\":1}}],[\"bound\",{\"0\":{\"163\":2},\"1\":{\"162\":2,\"163\":12,\"599\":2}}],[\"book\",{\"1\":{\"1428\":1,\"1681\":1}}],[\"bool\",{\"0\":{\"473\":1},\"1\":{\"8\":1,\"60\":5,\"148\":1,\"149\":1,\"153\":1,\"154\":1,\"155\":1,\"158\":1,\"162\":1,\"166\":1,\"174\":1,\"182\":2,\"185\":2,\"188\":1,\"224\":1,\"355\":2,\"365\":3,\"366\":3,\"368\":2,\"385\":2,\"388\":4,\"406\":2,\"473\":7,\"540\":1,\"545\":6,\"563\":4,\"699\":4,\"704\":3,\"736\":3,\"747\":1,\"751\":1,\"755\":1,\"756\":1,\"765\":1,\"784\":4,\"817\":2,\"819\":1,\"821\":1,\"884\":2,\"885\":1,\"980\":1,\"981\":3,\"982\":3,\"1002\":1,\"1127\":2,\"1148\":3,\"1186\":1,\"1187\":1,\"1233\":1,\"1839\":2,\"1846\":2,\"1847\":2,\"1848\":1,\"1849\":1,\"1856\":5,\"1875\":2,\"1878\":3,\"1915\":1}}],[\"bootstrap\",{\"1\":{\"0\":1}}],[\"bower\",{\"1\":{\"0\":1}}],[\"s设计\",{\"1\":{\"1864\":1}}],[\"skip\",{\"1\":{\"1830\":1}}],[\"sx\",{\"1\":{\"1699\":1}}],[\"snapshot\",{\"1\":{\"1656\":2}}],[\"smallint\",{\"1\":{\"1552\":1}}],[\"smaller\",{\"1\":{\"1102\":1}}],[\"smoothing\",{\"1\":{\"49\":1}}],[\"sgi\",{\"0\":{\"1079\":1,\"1085\":1,\"1086\":1},\"1\":{\"1079\":1,\"1082\":1,\"1085\":1,\"1105\":1},\"2\":{\"1078\":1,\"1084\":1,\"1089\":1,\"1092\":1,\"1095\":1,\"1098\":1,\"1101\":1,\"1104\":1,\"1107\":1}}],[\"slice\",{\"1\":{\"1820\":1}}],[\"sleep\",{\"1\":{\"1050\":3,\"1202\":1,\"1207\":4,\"1208\":1,\"1209\":3,\"1210\":1,\"1219\":4,\"1233\":1,\"1849\":1,\"1859\":1}}],[\"sln解决方案文件\",{\"1\":{\"1029\":1}}],[\"slave从数据开始增量进行同步\",{\"1\":{\"1830\":1}}],[\"slave总是连接不上master\",{\"1\":{\"1826\":1}}],[\"slave配置\",{\"0\":{\"1823\":1,\"1833\":1}}],[\"slave做读操作\",{\"1\":{\"1803\":1}}],[\"slave是正常\",{\"1\":{\"1803\":1}}],[\"slave也将无法和master配合工作\",{\"1\":{\"1803\":1}}],[\"slave也同步了user表\",{\"1\":{\"1785\":1}}],[\"slave的mytest库中没有user表\",{\"1\":{\"1830\":1}}],[\"slave的sql线程处理该过程的最后一步\",{\"1\":{\"1784\":1}}],[\"slave的ip为192\",{\"1\":{\"1818\":1}}],[\"slave的i\",{\"1\":{\"1784\":1}}],[\"slave命令会在从服务器创建一个io线程\",{\"1\":{\"1784\":1}}],[\"slave执行start\",{\"1\":{\"1784\":1}}],[\"slave\",{\"1\":{\"1016\":1,\"1783\":1,\"1784\":3,\"1791\":1,\"1796\":1,\"1803\":2,\"1821\":3,\"1826\":3,\"1828\":4,\"1829\":2,\"1830\":7,\"1833\":1,\"1885\":2}}],[\"slow刚好指在目标元素上\",{\"1\":{\"774\":1,\"806\":1}}],[\"slow++\",{\"1\":{\"77\":1}}],[\"slow表示新数组下标\",{\"1\":{\"77\":1}}],[\"slow\",{\"1\":{\"73\":3,\"77\":2,\"148\":5,\"756\":4,\"765\":7,\"768\":9,\"774\":10,\"787\":4,\"798\":10,\"806\":4,\"1574\":1,\"1577\":2,\"1776\":1}}],[\"sqlmaxlimit=\",{\"1\":{\"1888\":2,\"1891\":1}}],[\"sql的完整处理流程\",{\"0\":{\"1881\":1}}],[\"sql的脚本\",{\"1\":{\"1836\":1}}],[\"sql的校验过程\",{\"1\":{\"1535\":1}}],[\"sql脚本重新执行一遍\",{\"1\":{\"1836\":1}}],[\"sql是root的文件\",{\"1\":{\"1836\":1}}],[\"sql文件内容如下\",{\"1\":{\"1836\":1}}],[\"sql文件中\",{\"1\":{\"1836\":1}}],[\"sql线程出错一般是sql在slave库执行出现了问题\",{\"1\":{\"1830\":1}}],[\"sql线程出错\",{\"0\":{\"1830\":1}}],[\"sql线程从relay\",{\"1\":{\"1784\":1}}],[\"sql中\",{\"1\":{\"1775\":1}}],[\"sql和索引优化总结\",{\"0\":{\"1743\":1}}],[\"sql优化\",{\"0\":{\"1727\":1}}],[\"sql语句和索引的优化\",{\"0\":{\"1744\":1}}],[\"sql语句和索引\",{\"1\":{\"1743\":1}}],[\"sql语句执行失败\",{\"1\":{\"1692\":1}}],[\"sql语句的日志\",{\"1\":{\"1574\":1,\"1776\":1}}],[\"sql查询所花费的时间会很长\",{\"1\":{\"1609\":1}}],[\"sql主要可以划分为以下\",{\"1\":{\"1548\":1}}],[\"sql概述\",{\"0\":{\"1547\":1}}],[\"sql执行成功\",{\"1\":{\"1384\":1,\"1385\":1}}],[\"sql\",{\"1\":{\"1384\":5,\"1385\":3,\"1656\":1,\"1686\":1,\"1706\":1,\"1719\":1,\"1720\":1,\"1774\":2,\"1775\":1,\"1784\":1,\"1830\":1,\"1836\":5,\"1846\":2,\"1847\":6,\"1851\":8,\"1856\":11,\"1878\":3}}],[\"sqlite\",{\"1\":{\"0\":1}}],[\"sqrt\",{\"1\":{\"898\":1}}],[\"s修改为std\",{\"1\":{\"605\":1}}],[\"ss共存\",{\"1\":{\"1701\":1}}],[\"sshd查看是否安装成功\",{\"1\":{\"1280\":1}}],[\"ssh客户端\",{\"1\":{\"1280\":1}}],[\"ssh\",{\"1\":{\"1238\":1,\"1280\":1}}],[\"ss\",{\"1\":{\"557\":1}}],[\"s5\",{\"1\":{\"536\":3,\"547\":6}}],[\"s4\",{\"1\":{\"536\":3,\"547\":4,\"1803\":1}}],[\"s3\",{\"1\":{\"536\":3,\"547\":9,\"1803\":1}}],[\"s2\",{\"1\":{\"536\":3,\"547\":4,\"1066\":3,\"1067\":1,\"1803\":1}}],[\"sprintf\",{\"1\":{\"1384\":3,\"1385\":1,\"1851\":2,\"1856\":1,\"1878\":1}}],[\"split\",{\"1\":{\"1238\":1}}],[\"spf\",{\"1\":{\"1141\":1}}],[\"sp\",{\"1\":{\"1050\":3,\"1139\":1,\"1849\":2,\"1859\":2,\"1869\":1,\"1870\":1,\"1872\":1}}],[\"special\",{\"1\":{\"1407\":2}}],[\"specialization\",{\"1\":{\"389\":2}}],[\"specifications\",{\"0\":{\"1016\":1}}],[\"specification\",{\"1\":{\"607\":2}}],[\"speak\",{\"1\":{\"494\":3}}],[\"sparc\",{\"1\":{\"302\":1}}],[\"span>\",{\"1\":{\"61\":1}}],[\"space++\",{\"1\":{\"11\":1}}],[\"space\",{\"1\":{\"11\":2,\"301\":2,\"1082\":1}}],[\"s1\",{\"1\":{\"378\":4,\"536\":12,\"547\":5,\"717\":1,\"718\":1,\"990\":5,\"1066\":3,\"1067\":1,\"1803\":1}}],[\"switchtype\",{\"1\":{\"1803\":1}}],[\"switch\",{\"1\":{\"296\":1,\"864\":1,\"871\":3,\"1168\":1}}],[\"swap3\",{\"1\":{\"560\":1}}],[\"swap2\",{\"1\":{\"560\":1}}],[\"swap1\",{\"1\":{\"560\":1}}],[\"swap\",{\"1\":{\"67\":2,\"70\":1,\"188\":2,\"194\":4,\"199\":1,\"205\":1,\"217\":2,\"220\":1,\"615\":2,\"618\":4}}],[\"sbin\",{\"1\":{\"1820\":1}}],[\"sbrk\",{\"1\":{\"286\":1}}],[\"sb\",{\"1\":{\"267\":1}}],[\"sb=0\",{\"1\":{\"267\":1}}],[\"sf\",{\"1\":{\"267\":1}}],[\"sd=10\",{\"1\":{\"267\":1}}],[\"s查看汇编\",{\"0\":{\"260\":1}}],[\"syn\",{\"1\":{\"1238\":1,\"1240\":4}}],[\"syntax\",{\"1\":{\"1133\":1,\"1291\":1,\"1915\":1}}],[\"symbolic\",{\"1\":{\"1237\":1}}],[\"symbal\",{\"1\":{\"251\":1,\"255\":1}}],[\"syslog\",{\"1\":{\"1411\":1}}],[\"sysconfig\",{\"0\":{\"1293\":1}}],[\"sysv\",{\"1\":{\"572\":1}}],[\"systemctl\",{\"1\":{\"1402\":1,\"1408\":1,\"1799\":1,\"1818\":5,\"1820\":6}}],[\"systemd\",{\"1\":{\"1296\":2,\"1820\":4}}],[\"system\",{\"1\":{\"16\":1,\"285\":2,\"1508\":1,\"1521\":1,\"1820\":2,\"1888\":1,\"1891\":1}}],[\"scanner\",{\"1\":{\"1849\":2,\"1859\":2}}],[\"scannerconnectiontask\",{\"1\":{\"1848\":1,\"1849\":2,\"1859\":3}}],[\"scanf等不安全的函数\",{\"1\":{\"293\":1}}],[\"scanf\",{\"0\":{\"293\":1},\"1\":{\"293\":1}}],[\"school\",{\"1\":{\"1836\":6,\"1856\":1,\"1878\":1}}],[\"schema>\",{\"1\":{\"1888\":1,\"1891\":2}}],[\"schemas\",{\"1\":{\"1888\":1,\"1891\":1}}],[\"schema\",{\"0\":{\"1803\":1},\"1\":{\"1719\":1,\"1720\":1,\"1803\":3,\"1804\":1,\"1805\":1,\"1806\":1,\"1814\":1,\"1888\":4,\"1891\":4}}],[\"scheduling\",{\"1\":{\"239\":1}}],[\"score>90\",{\"1\":{\"1538\":5}}],[\"score\",{\"1\":{\"1537\":5,\"1538\":4}}],[\"scoped\",{\"0\":{\"1046\":1},\"1\":{\"1042\":1}}],[\"scope\",{\"1\":{\"516\":1}}],[\"sc在\",{\"1\":{\"267\":1}}],[\"sc\",{\"1\":{\"267\":1}}],[\"scrolltop\",{\"1\":{\"59\":3}}],[\"scrolltop=top\",{\"1\":{\"59\":1}}],[\"scrolling\",{\"1\":{\"59\":1}}],[\"scripts\",{\"1\":{\"59\":1}}],[\"s或x\",{\"1\":{\"1677\":1}}],[\"s或\",{\"1\":{\"228\":1,\"1237\":1}}],[\"s的区别\",{\"0\":{\"228\":1}}],[\"sz+文件路径\",{\"1\":{\"1800\":1}}],[\"sznumbers\",{\"1\":{\"1299\":2}}],[\"sz字节\",{\"1\":{\"1076\":1}}],[\"sz处于同一数量区间\",{\"1\":{\"1076\":1}}],[\"sz都大于128字节\",{\"1\":{\"1076\":1}}],[\"sz和\",{\"1\":{\"1076\":2}}],[\"sz\",{\"1\":{\"185\":2,\"516\":1,\"1076\":18}}],[\"srand\",{\"1\":{\"70\":1,\"101\":3,\"188\":2,\"191\":2,\"817\":1,\"819\":1,\"1147\":1,\"1148\":1}}],[\"srcfiles\",{\"1\":{\"1361\":1}}],[\"srcs2\",{\"1\":{\"1314\":2,\"1316\":2}}],[\"srcs1\",{\"1\":{\"1314\":2,\"1316\":2}}],[\"srcs\",{\"1\":{\"1312\":4,\"1314\":2,\"1315\":6,\"1316\":3,\"1317\":2,\"1360\":2,\"1361\":2,\"1365\":3,\"1366\":4,\"1367\":2}}],[\"src\",{\"1\":{\"59\":1,\"406\":11,\"535\":4,\"731\":8,\"736\":13,\"1055\":7,\"1114\":6,\"1127\":13,\"1284\":4,\"1316\":4,\"1318\":3,\"1322\":2,\"1361\":1}}],[\"s\",{\"0\":{\"1099\":1,\"1102\":1,\"1934\":1,\"1939\":2,\"1947\":1,\"1948\":2,\"1949\":1,\"1950\":1,\"1951\":1,\"1952\":1,\"1953\":1,\"1954\":1,\"1955\":1},\"1\":{\"67\":10,\"166\":7,\"224\":16,\"228\":1,\"234\":1,\"239\":3,\"248\":1,\"252\":2,\"253\":1,\"260\":1,\"494\":1,\"516\":1,\"535\":1,\"541\":2,\"546\":4,\"547\":2,\"605\":3,\"614\":1,\"621\":1,\"633\":4,\"1021\":2,\"1026\":2,\"1032\":16,\"1066\":1,\"1067\":2,\"1076\":2,\"1080\":1,\"1082\":11,\"1090\":4,\"1093\":6,\"1096\":9,\"1099\":13,\"1102\":70,\"1105\":3,\"1271\":4,\"1305\":1,\"1330\":1,\"1332\":1,\"1334\":1,\"1347\":1,\"1348\":1,\"1383\":1,\"1384\":6,\"1385\":5,\"1452\":1,\"1673\":1,\"1697\":1,\"1851\":4,\"1856\":2,\"1878\":2}}],[\"su\",{\"1\":{\"1556\":1}}],[\"sunpro\",{\"1\":{\"1082\":2}}],[\"succeeded\",{\"1\":{\"1102\":1}}],[\"success\",{\"1\":{\"277\":2,\"1820\":1,\"1915\":2}}],[\"such\",{\"1\":{\"182\":1,\"234\":1,\"312\":1,\"791\":1,\"792\":1}}],[\"sudo\",{\"1\":{\"234\":1,\"1015\":1,\"1016\":3,\"1030\":2,\"1035\":1,\"1131\":1,\"1280\":2,\"1284\":4,\"1285\":1,\"1287\":2,\"1289\":1,\"1295\":1,\"1296\":3,\"1305\":2,\"1332\":4,\"1393\":2,\"1397\":16,\"1399\":1,\"1401\":1,\"1402\":1,\"1405\":3,\"1408\":1,\"1409\":2,\"1410\":4,\"1555\":1,\"1556\":1,\"1616\":1,\"1769\":1,\"1818\":4,\"1820\":1}}],[\"subdirectory来添加要生成\",{\"1\":{\"1316\":1}}],[\"subdirectory\",{\"1\":{\"1310\":1,\"1315\":2,\"1316\":2,\"1318\":1}}],[\"sub1=debug\",{\"1\":{\"1026\":1}}],[\"sub1的priority为debug\",{\"1\":{\"1026\":1}}],[\"sub1\",{\"1\":{\"1018\":9}}],[\"subclass\",{\"1\":{\"933\":1}}],[\"submap\",{\"1\":{\"871\":7}}],[\"subject\",{\"1\":{\"871\":10}}],[\"subst\",{\"1\":{\"1361\":2}}],[\"substr\",{\"1\":{\"60\":1,\"535\":1,\"536\":4,\"542\":1,\"1839\":2,\"1849\":2,\"1875\":2,\"1878\":6}}],[\"substring\",{\"1\":{\"59\":1}}],[\"subscribe\",{\"1\":{\"871\":1}}],[\"sub\",{\"0\":{\"1315\":1},\"1\":{\"233\":1,\"234\":2,\"235\":2,\"572\":1,\"908\":2,\"1313\":3,\"1314\":2,\"1315\":5,\"1316\":4,\"1360\":2}}],[\"sum函数后ebp回到esp位置\",{\"1\":{\"234\":1}}],[\"sum函数调用完\",{\"1\":{\"234\":1}}],[\"sum\",{\"0\":{\"238\":1,\"1497\":1},\"1\":{\"73\":4,\"126\":5,\"133\":3,\"148\":3,\"149\":3,\"234\":6,\"236\":2,\"238\":1,\"246\":4,\"247\":1,\"378\":6,\"567\":3,\"568\":3,\"569\":3,\"570\":5,\"638\":8,\"639\":4,\"1154\":4,\"1155\":1,\"1158\":2,\"1165\":2,\"1188\":3,\"1189\":5,\"1444\":1,\"1531\":2}}],[\"suffix\",{\"1\":{\"60\":5}}],[\"si\",{\"1\":{\"1475\":1,\"1511\":1}}],[\"situation\",{\"1\":{\"1102\":1}}],[\"since\",{\"1\":{\"1102\":1,\"1820\":1}}],[\"single\",{\"1\":{\"850\":18}}],[\"singletonflag\",{\"1\":{\"852\":2}}],[\"singletonmutex\",{\"1\":{\"849\":2}}],[\"singleton\",{\"1\":{\"849\":9,\"851\":18,\"852\":7,\"854\":11,\"855\":6,\"856\":10,\"857\":11}}],[\"singleinstance\",{\"1\":{\"848\":28}}],[\"singly\",{\"1\":{\"755\":1,\"756\":1,\"759\":1,\"762\":1,\"768\":1,\"771\":1,\"774\":1,\"782\":1,\"783\":1,\"784\":1,\"787\":1,\"795\":1,\"798\":1,\"802\":1}}],[\"signal\",{\"1\":{\"848\":2,\"851\":2}}],[\"signals\",{\"1\":{\"239\":1}}],[\"signed\",{\"1\":{\"296\":1}}],[\"size默认是16m\",{\"1\":{\"1758\":1}}],[\"size是同时为数据块和索引块做缓存\",{\"1\":{\"1752\":1}}],[\"size配置项\",{\"1\":{\"1752\":1,\"1753\":1}}],[\"size开始到128\",{\"1\":{\"1102\":1}}],[\"size记录了已经向os申请的所有空间\",{\"1\":{\"1102\":1}}],[\"size初始值为0\",{\"1\":{\"1102\":1}}],[\"size的空间\",{\"1\":{\"1102\":1}}],[\"size的空间都不够\",{\"1\":{\"1102\":1}}],[\"size的\",{\"1\":{\"1102\":1}}],[\"size的大小\",{\"1\":{\"968\":1}}],[\"size在对应的内存池分配\",{\"1\":{\"1102\":1}}],[\"size大的空闲chunk\",{\"1\":{\"1102\":1}}],[\"size大的空闲chunk分配出去\",{\"1\":{\"1102\":1}}],[\"size专门用来分配20个size字节的chunk\",{\"1\":{\"1102\":1}}],[\"size个字节\",{\"1\":{\"1102\":2}}],[\"size个对象的空间\",{\"1\":{\"751\":1}}],[\"size字节的chunk块分配\",{\"1\":{\"1102\":2}}],[\"sizeof变化的原因\",{\"0\":{\"955\":1}}],[\"sizeof是一个运算符\",{\"1\":{\"515\":1}}],[\"sizeof\",{\"1\":{\"101\":1,\"224\":1,\"286\":2,\"287\":1,\"296\":1,\"378\":12,\"385\":1,\"433\":3,\"439\":2,\"468\":3,\"470\":3,\"473\":1,\"515\":8,\"516\":1,\"522\":2,\"535\":2,\"547\":5,\"557\":16,\"571\":2,\"629\":1,\"633\":1,\"704\":1,\"728\":1,\"729\":2,\"751\":1,\"889\":2,\"891\":1,\"908\":1,\"953\":2,\"1007\":2,\"1080\":3,\"1087\":1,\"1127\":1,\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":1}}],[\"size\",{\"1\":{\"49\":2,\"50\":2,\"51\":7,\"60\":5,\"67\":3,\"73\":3,\"77\":1,\"78\":1,\"84\":1,\"87\":3,\"93\":1,\"94\":1,\"96\":4,\"97\":2,\"101\":26,\"104\":1,\"110\":2,\"114\":1,\"115\":1,\"118\":1,\"125\":1,\"126\":1,\"133\":2,\"137\":3,\"141\":1,\"142\":3,\"143\":1,\"154\":2,\"158\":1,\"162\":1,\"166\":2,\"179\":1,\"182\":1,\"185\":9,\"188\":1,\"191\":5,\"194\":7,\"199\":1,\"202\":3,\"205\":2,\"214\":4,\"217\":3,\"224\":3,\"239\":6,\"286\":3,\"355\":14,\"385\":20,\"388\":7,\"406\":19,\"516\":1,\"518\":9,\"521\":1,\"535\":9,\"536\":4,\"537\":2,\"538\":3,\"539\":4,\"540\":6,\"541\":1,\"542\":2,\"546\":18,\"547\":10,\"704\":23,\"710\":6,\"751\":5,\"755\":1,\"782\":3,\"783\":4,\"791\":11,\"792\":13,\"802\":1,\"966\":10,\"968\":3,\"990\":2,\"991\":2,\"992\":2,\"999\":3,\"1000\":4,\"1031\":1,\"1076\":5,\"1080\":7,\"1082\":5,\"1087\":3,\"1090\":25,\"1093\":2,\"1096\":2,\"1099\":1,\"1102\":26,\"1105\":1,\"1127\":22,\"1151\":4,\"1197\":1,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1748\":1,\"1752\":1,\"1753\":1,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1,\"1851\":2,\"1878\":1}}],[\"simpleconfigurator\",{\"1\":{\"1026\":1}}],[\"simplelayout主要是提供的成型的简单日志风格\",{\"1\":{\"1021\":1}}],[\"simplelayout\",{\"1\":{\"1021\":1,\"1031\":3}}],[\"simplefactory\",{\"1\":{\"864\":4}}],[\"simple\",{\"0\":{\"861\":1},\"1\":{\"861\":2,\"1521\":1,\"1618\":1}}],[\"simpletest\",{\"1\":{\"0\":1}}],[\"simsun\",{\"1\":{\"49\":1}}],[\"sh\",{\"1\":{\"1132\":2,\"1287\":1,\"1290\":2}}],[\"sharding\",{\"1\":{\"1885\":1}}],[\"share\",{\"1\":{\"1656\":1,\"1665\":1,\"1698\":1,\"1701\":1,\"1820\":1}}],[\"shared\",{\"0\":{\"1056\":1},\"1\":{\"849\":4,\"852\":4,\"1050\":2,\"1053\":1,\"1055\":1,\"1056\":6,\"1057\":3,\"1060\":1,\"1196\":1,\"1310\":2,\"1315\":2,\"1316\":3,\"1331\":1,\"1332\":1,\"1335\":1,\"1697\":1,\"1848\":3,\"1849\":3,\"1851\":2,\"1859\":6,\"1869\":2,\"1870\":1,\"1872\":3,\"1875\":4}}],[\"shadow\",{\"1\":{\"1082\":1,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1}}],[\"shutdown\",{\"1\":{\"1020\":1,\"1031\":3,\"1032\":1}}],[\"should\",{\"1\":{\"1102\":1}}],[\"short\",{\"1\":{\"296\":1,\"330\":1,\"371\":1,\"497\":1,\"557\":9,\"560\":3,\"1839\":1,\"1846\":1,\"1847\":1,\"1848\":1,\"1856\":2,\"1859\":1,\"1875\":1,\"1878\":1}}],[\"showcontainer\",{\"1\":{\"1147\":4,\"1148\":5}}],[\"showcarleftmiles\",{\"1\":{\"900\":4}}],[\"showfunc\",{\"1\":{\"631\":4}}],[\"show\",{\"0\":{\"1582\":1,\"1600\":1},\"1\":{\"101\":5,\"422\":2,\"594\":3,\"631\":1,\"731\":7,\"817\":6,\"819\":3,\"821\":3,\"831\":7,\"862\":3,\"864\":2,\"867\":6,\"906\":4,\"907\":8,\"908\":4,\"919\":4,\"920\":1,\"922\":2,\"923\":4,\"943\":2,\"948\":4,\"953\":10,\"954\":9,\"1041\":1,\"1055\":1,\"1340\":1,\"1407\":2,\"1409\":1,\"1506\":1,\"1507\":3,\"1551\":2,\"1552\":2,\"1555\":1,\"1569\":3,\"1574\":1,\"1577\":1,\"1578\":1,\"1582\":1,\"1599\":1,\"1600\":2,\"1614\":1,\"1651\":1,\"1747\":1,\"1768\":3,\"1771\":1,\"1772\":2,\"1776\":1,\"1786\":1,\"1790\":1,\"1808\":2,\"1822\":1,\"1826\":1,\"1830\":1}}],[\"shell下执行以下命令\",{\"1\":{\"1836\":1}}],[\"shell下登录mycat的8066端口\",{\"1\":{\"1809\":1}}],[\"shell下登录mycat的9066端口\",{\"1\":{\"1808\":1}}],[\"shell命令恢复备份数据\",{\"1\":{\"1774\":1}}],[\"shell上执行\",{\"1\":{\"1774\":1}}],[\"shell终端查找cmake位置\",{\"1\":{\"1306\":1}}],[\"shellsort\",{\"1\":{\"199\":4}}],[\"shellsortcore\",{\"1\":{\"199\":3}}],[\"shell\",{\"1\":{\"199\":2,\"1808\":1}}],[\"shellnew下\",{\"1\":{\"45\":1}}],[\"shellnew\",{\"1\":{\"44\":1}}],[\"shiftwidth=4\",{\"1\":{\"1133\":1,\"1291\":1}}],[\"shift\",{\"1\":{\"30\":1}}],[\"so库\",{\"1\":{\"1855\":1}}],[\"so库的malloc实现ptmalloc\",{\"1\":{\"1622\":1}}],[\"so或libc++\",{\"1\":{\"1622\":1}}],[\"so的软链接\",{\"1\":{\"1332\":1}}],[\"sots\",{\"1\":{\"908\":1}}],[\"sotr\",{\"1\":{\"217\":1}}],[\"sometype2\",{\"1\":{\"528\":4,\"529\":2}}],[\"sometype1\",{\"1\":{\"528\":6,\"529\":3}}],[\"something\",{\"1\":{\"277\":1}}],[\"so\",{\"1\":{\"267\":1,\"283\":1,\"1030\":1,\"1331\":2,\"1332\":9,\"1333\":1}}],[\"son为右孩子\",{\"1\":{\"194\":1}}],[\"son\",{\"1\":{\"194\":9}}],[\"sort\",{\"1\":{\"114\":1,\"126\":1,\"133\":1,\"137\":1,\"163\":2,\"179\":1,\"188\":3,\"194\":3,\"199\":2,\"202\":4,\"205\":3,\"217\":2,\"220\":3,\"1007\":5,\"1147\":2,\"1148\":2,\"1177\":1,\"1238\":4,\"1736\":4}}],[\"sortedsquares\",{\"1\":{\"87\":1}}],[\"solution\",{\"1\":{\"67\":1,\"73\":1,\"77\":1,\"78\":1,\"81\":1,\"87\":1,\"96\":1,\"114\":1,\"115\":1,\"125\":1,\"129\":1,\"133\":1,\"137\":1,\"141\":1,\"142\":1,\"143\":1,\"148\":1,\"149\":1,\"153\":1,\"154\":1,\"155\":1,\"158\":1,\"162\":1,\"166\":1,\"170\":1,\"171\":1,\"174\":1,\"178\":1,\"179\":1,\"755\":1,\"756\":1,\"759\":1,\"762\":1,\"768\":1,\"771\":2,\"774\":2,\"777\":2,\"782\":1,\"783\":1,\"784\":1,\"787\":1,\"795\":1,\"798\":2,\"802\":1}}],[\"solid和double和dotted和dashed等等\",{\"1\":{\"50\":1}}],[\"solid\",{\"1\":{\"48\":1,\"49\":2}}],[\"sources\",{\"1\":{\"1284\":3,\"1312\":3}}],[\"sourceforge\",{\"1\":{\"1014\":1,\"1015\":1}}],[\"sourcemappingurl=http\",{\"1\":{\"59\":1}}],[\"source\",{\"0\":{\"32\":1,\"1314\":1},\"1\":{\"49\":3,\"228\":1,\"572\":1,\"1282\":1,\"1284\":1,\"1310\":2,\"1312\":4,\"1314\":3,\"1315\":3,\"1316\":8,\"1317\":2,\"1318\":1,\"1774\":1,\"1775\":1,\"1836\":1}}],[\"socket\",{\"1\":{\"17\":1,\"1374\":2}}],[\"sex=\",{\"1\":{\"1511\":1,\"1514\":2,\"1525\":3}}],[\"sex\",{\"1\":{\"1415\":2,\"1437\":1,\"1475\":2,\"1511\":6,\"1513\":2,\"1514\":3,\"1515\":3,\"1525\":3,\"1537\":5,\"1551\":1,\"1614\":5,\"1851\":2,\"1856\":1,\"1878\":1}}],[\"serializetostring\",{\"1\":{\"1915\":1}}],[\"serializable隔离级别\",{\"0\":{\"1636\":1}}],[\"serializable\",{\"1\":{\"1631\":1}}],[\"serifcn\",{\"1\":{\"49\":1}}],[\"serno\",{\"1\":{\"1531\":2}}],[\"service\",{\"1\":{\"1402\":2,\"1409\":3,\"1410\":1,\"1769\":1,\"1799\":2,\"1818\":5,\"1820\":3}}],[\"server上\",{\"1\":{\"1885\":1}}],[\"server上生成的\",{\"1\":{\"1767\":1}}],[\"server这边由负责关闭这个连接\",{\"1\":{\"1881\":1}}],[\"server相当于可以划分成3个模块\",{\"1\":{\"1881\":1}}],[\"server模块\",{\"1\":{\"1881\":1}}],[\"server进行通信的时候\",{\"1\":{\"1881\":1}}],[\"server新的连接\",{\"1\":{\"1865\":1}}],[\"server创建initsize个数的connection连接\",{\"1\":{\"1865\":1}}],[\"server挂了\",{\"1\":{\"1814\":1}}],[\"server中也打开一下查询日志\",{\"1\":{\"1811\":1}}],[\"server真实的mysql库表上\",{\"1\":{\"1802\":1}}],[\"server和代理中间件是不在一台机器上的\",{\"1\":{\"1799\":1}}],[\"server的请求增多时\",{\"1\":{\"1865\":1}}],[\"server的访问效率\",{\"1\":{\"1864\":1}}],[\"server的general\",{\"1\":{\"1814\":1}}],[\"server的3306端口一样\",{\"1\":{\"1792\":1}}],[\"server的客户端\",{\"1\":{\"1577\":1}}],[\"server数据库\",{\"1\":{\"1790\":1}}],[\"server通信\",{\"1\":{\"1790\":1}}],[\"server作为从库\",{\"1\":{\"1785\":1}}],[\"server作为一个服务器\",{\"1\":{\"1754\":1}}],[\"server收到的所有sql语句\",{\"1\":{\"1810\":1}}],[\"server收到的\",{\"1\":{\"1767\":1}}],[\"server层日志简介\",{\"0\":{\"1767\":1}}],[\"server层四个日志\",{\"0\":{\"1766\":1}}],[\"server层的日志\",{\"1\":{\"1679\":1}}],[\"server需要保持commit状态的数据的持久性\",{\"1\":{\"1763\":1}}],[\"server对于长时间未通信的连接\",{\"1\":{\"1754\":1}}],[\"server对client\",{\"1\":{\"1535\":1}}],[\"server网络模块采用经典的\",{\"1\":{\"1753\":1}}],[\"server就可以使用了\",{\"1\":{\"1750\":1}}],[\"server启动时加载的配置文件\",{\"1\":{\"1746\":1}}],[\"server端的优化\",{\"1\":{\"1746\":1}}],[\"server优化\",{\"0\":{\"1746\":1}}],[\"server会选择一个事务释放锁并进行rollback\",{\"1\":{\"1708\":1}}],[\"server会根据情况\",{\"1\":{\"1700\":1,\"1701\":1}}],[\"server没使用索引\",{\"1\":{\"1690\":1}}],[\"server不会让自己执行事务的线程永远阻塞\",{\"1\":{\"1636\":1}}],[\"server查询数据时需要花费磁盘io按块读取数据\",{\"1\":{\"1622\":1}}],[\"server有自己的优化\",{\"1\":{\"1617\":1}}],[\"server为避免频繁回表\",{\"1\":{\"1569\":1}}],[\"server都会做优化\",{\"1\":{\"1544\":1}}],[\"server\",{\"0\":{\"1802\":1},\"1\":{\"1393\":1,\"1395\":2,\"1396\":1,\"1397\":4,\"1405\":1,\"1767\":1,\"1768\":1,\"1769\":2,\"1770\":2,\"1771\":2,\"1772\":2,\"1773\":9,\"1774\":10,\"1775\":1,\"1776\":5,\"1802\":1,\"1803\":2,\"1808\":1,\"1809\":1,\"1814\":2,\"1820\":4,\"1864\":1,\"1888\":1,\"1891\":1}}],[\"separator\",{\"0\":{\"1368\":1}}],[\"sent\",{\"1\":{\"1240\":6}}],[\"sendbuf\",{\"1\":{\"1903\":2,\"1907\":2}}],[\"send\",{\"1\":{\"29\":1,\"1318\":1,\"1915\":4}}],[\"sendinput\",{\"1\":{\"29\":6}}],[\"sellticket\",{\"1\":{\"1208\":2,\"1209\":3,\"1210\":1}}],[\"select等读操作在b\",{\"1\":{\"1790\":1}}],[\"select的指定的条件分为2类\",{\"1\":{\"1686\":1}}],[\"select的字段会导致回表\",{\"0\":{\"1588\":1}}],[\"select时都是直接用老的数据快照\",{\"1\":{\"1662\":1}}],[\"select做的都是快照读\",{\"1\":{\"1656\":1}}],[\"select后字段的多少也会影响想查询效率\",{\"1\":{\"1539\":1}}],[\"select后面选择的具体的列需要具体考虑\",{\"1\":{\"1511\":1}}],[\"select查询的序列号\",{\"1\":{\"1521\":1}}],[\"select性能足够\",{\"1\":{\"1455\":1}}],[\"selectsort\",{\"1\":{\"217\":5}}],[\"select\",{\"1\":{\"61\":1,\"217\":3,\"1385\":1,\"1427\":1,\"1447\":2,\"1471\":2,\"1485\":1,\"1486\":1,\"1494\":3,\"1495\":1,\"1496\":3,\"1497\":1,\"1500\":9,\"1501\":3,\"1502\":4,\"1508\":2,\"1511\":8,\"1512\":1,\"1513\":2,\"1514\":3,\"1515\":4,\"1516\":3,\"1521\":1,\"1525\":3,\"1526\":3,\"1531\":2,\"1537\":4,\"1538\":9,\"1539\":6,\"1540\":1,\"1541\":2,\"1543\":1,\"1544\":5,\"1563\":4,\"1564\":3,\"1566\":1,\"1569\":3,\"1581\":1,\"1592\":2,\"1593\":1,\"1603\":2,\"1618\":1,\"1623\":1,\"1632\":2,\"1652\":1,\"1656\":1,\"1663\":1,\"1665\":1,\"1686\":1,\"1688\":1,\"1689\":2,\"1692\":1,\"1698\":2,\"1717\":3,\"1718\":1,\"1719\":1,\"1720\":1,\"1738\":4,\"1740\":4,\"1836\":2}}],[\"selector\",{\"1\":{\"59\":2}}],[\"sees\",{\"1\":{\"1082\":1}}],[\"seen\",{\"1\":{\"137\":3}}],[\"se\",{\"1\":{\"1082\":1,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1}}],[\"se=0\",{\"1\":{\"267\":1}}],[\"segment\",{\"1\":{\"1240\":1}}],[\"seg\",{\"1\":{\"239\":1}}],[\"sec\",{\"1\":{\"751\":1,\"1407\":4,\"1799\":2}}],[\"secure\",{\"1\":{\"293\":3,\"1401\":1}}],[\"security\",{\"1\":{\"239\":1,\"1284\":4}}],[\"second\",{\"1\":{\"1148\":2,\"1168\":1,\"1909\":1}}],[\"secondhalfstart\",{\"1\":{\"756\":3}}],[\"seconds\",{\"1\":{\"239\":1,\"1050\":3,\"1207\":2,\"1233\":1,\"1849\":1,\"1859\":1}}],[\"second+visited\",{\"1\":{\"178\":1}}],[\"section\",{\"1\":{\"228\":1,\"251\":1}}],[\"search\",{\"1\":{\"93\":1,\"94\":1,\"96\":2,\"97\":2,\"1007\":2}}],[\"setpriority\",{\"1\":{\"1020\":1,\"1025\":1,\"1031\":3,\"1032\":1}}],[\"setprice\",{\"1\":{\"439\":1,\"449\":3,\"450\":2}}],[\"set<student>\",{\"1\":{\"1002\":1}}],[\"set<int\",{\"1\":{\"985\":1}}],[\"set<int>\",{\"1\":{\"104\":1,\"107\":1,\"110\":3,\"129\":1,\"137\":1,\"149\":1,\"153\":1,\"154\":1,\"170\":1,\"171\":2,\"999\":2,\"1001\":1,\"1002\":1}}],[\"set存放自定义类型\",{\"1\":{\"1002\":1}}],[\"set实例\",{\"1\":{\"1002\":1}}],[\"set使用2\",{\"1\":{\"999\":1}}],[\"set使用1\",{\"1\":{\"999\":1}}],[\"set不存储key值重复元素\",{\"1\":{\"999\":1}}],[\"set与unordered\",{\"1\":{\"999\":1}}],[\"set底层为红黑树\",{\"1\":{\"985\":1}}],[\"setnumber\",{\"1\":{\"653\":3}}],[\"setbrand\",{\"1\":{\"439\":1,\"449\":3,\"450\":2}}],[\"set1\",{\"1\":{\"171\":3,\"999\":17,\"1002\":6}}],[\"set做哈希表\",{\"0\":{\"171\":1}}],[\"set而不是vector是因为可能有多个相同的值出现\",{\"1\":{\"170\":1}}],[\"set\",{\"0\":{\"985\":1},\"1\":{\"104\":5,\"107\":5,\"110\":12,\"129\":5,\"149\":3,\"153\":4,\"154\":2,\"162\":7,\"170\":2,\"234\":1,\"244\":1,\"985\":3,\"999\":2,\"1001\":3,\"1002\":1,\"1133\":8,\"1291\":8,\"1312\":1,\"1316\":4,\"1317\":2,\"1318\":1,\"1320\":2,\"1322\":1,\"1340\":3,\"1384\":1,\"1407\":6,\"1428\":1,\"1469\":1,\"1478\":1,\"1492\":2,\"1523\":2,\"1574\":1,\"1577\":1,\"1578\":1,\"1582\":1,\"1652\":2,\"1730\":1,\"1731\":2,\"1776\":1,\"1828\":1,\"1830\":1,\"1915\":2}}],[\"set>\",{\"1\":{\"104\":1,\"107\":1,\"110\":1,\"999\":1}}],[\"setinterval\",{\"1\":{\"59\":1}}],[\"setitem\",{\"1\":{\"59\":1}}],[\"setattribute\",{\"1\":{\"59\":1}}],[\"settimeout\",{\"1\":{\"53\":1,\"54\":1,\"59\":7}}],[\"seqstack\",{\"1\":{\"224\":3}}],[\"seq\",{\"1\":{\"5\":1}}],[\"sequence文件夹用于存放测序后的结果\",{\"1\":{\"5\":1}}],[\"sequence\",{\"1\":{\"4\":1}}],[\"step\",{\"1\":{\"1340\":1}}],[\"stepi\",{\"1\":{\"261\":1}}],[\"stu1\",{\"1\":{\"1447\":1}}],[\"stumap\",{\"1\":{\"1002\":8}}],[\"stu\",{\"1\":{\"1002\":10,\"1384\":3,\"1385\":1,\"1447\":1,\"1688\":1,\"1689\":1,\"1836\":2}}],[\"student表的primarykey是id\",{\"1\":{\"1891\":1}}],[\"student表按照id取模拆分\",{\"1\":{\"1891\":1}}],[\"students\",{\"1\":{\"1428\":2}}],[\"student>\",{\"1\":{\"1002\":1}}],[\"student\",{\"1\":{\"717\":3,\"718\":3,\"784\":19,\"1002\":14,\"1537\":5,\"1538\":1,\"1540\":1,\"1541\":2,\"1544\":2,\"1552\":10,\"1563\":1,\"1564\":3,\"1566\":1,\"1569\":3,\"1592\":2,\"1599\":1,\"1600\":2,\"1603\":3,\"1614\":1,\"1623\":1,\"1891\":1}}],[\"studio\",{\"0\":{\"306\":1},\"1\":{\"312\":1}}],[\"studio要写这个\",{\"1\":{\"293\":1}}],[\"store\",{\"1\":{\"1377\":1,\"1378\":1,\"1385\":1}}],[\"storage\",{\"1\":{\"1086\":1}}],[\"stop\",{\"0\":{\"1368\":1},\"1\":{\"1409\":1,\"1773\":2,\"1774\":4,\"1818\":1,\"1820\":1,\"1826\":1,\"1830\":1}}],[\"stos\",{\"1\":{\"908\":1}}],[\"stout\",{\"1\":{\"182\":7}}],[\"st\",{\"1\":{\"388\":2,\"1238\":1}}],[\"stl所有的容器都不是线程安全\",{\"1\":{\"1219\":1}}],[\"stl二级空间配置器内存池的实现优点\",{\"1\":{\"1105\":1}}],[\"stl二级空间配置器重要成员解读\",{\"0\":{\"1079\":1},\"1\":{\"1082\":1}}],[\"stlpush\",{\"0\":{\"1087\":1}}],[\"stl空间配置器\",{\"1\":{\"1080\":1}}],[\"stl的bind只能用于二元的绑定器\",{\"1\":{\"1154\":1}}],[\"stl的verctor是怎么管理对象的\",{\"0\":{\"1085\":1},\"1\":{\"1085\":1}}],[\"stl的空间配置器\",{\"1\":{\"1080\":1}}],[\"stl的一级空间配置器和二级空间配置器的实现\",{\"1\":{\"1079\":1}}],[\"stl一级空间配置器也和stl标准模板库的实现是一样的\",{\"1\":{\"1079\":1}}],[\"stl提供了一级空间配置器和二级空间配置器\",{\"1\":{\"1079\":1}}],[\"stl源码\",{\"2\":{\"1078\":1,\"1084\":1,\"1089\":1,\"1092\":1,\"1095\":1,\"1098\":1,\"1101\":1,\"1104\":1,\"1107\":1}}],[\"stl顺序容器\",{\"0\":{\"962\":1}}],[\"stl\",{\"0\":{\"1086\":1},\"1\":{\"963\":1,\"1079\":7,\"1080\":2,\"1081\":1,\"1082\":2,\"1086\":6,\"1093\":1,\"1096\":1,\"1099\":1,\"1102\":3,\"1896\":2},\"2\":{\"357\":1,\"976\":1,\"987\":1,\"996\":1,\"1010\":1,\"1013\":1}}],[\"stl中的容器提供了多种数据结构\",{\"1\":{\"353\":1}}],[\"stl向量容器vector简单实现\",{\"0\":{\"352\":1}}],[\"stin\",{\"1\":{\"182\":8}}],[\"stream\",{\"1\":{\"1878\":1}}],[\"strerror\",{\"1\":{\"1299\":1}}],[\"strtol\",{\"1\":{\"1299\":8}}],[\"strace\",{\"1\":{\"1202\":1}}],[\"str引用的是临时对象\",{\"1\":{\"1123\":1}}],[\"str引用的就是一个临时对象\",{\"1\":{\"1123\":1}}],[\"str传入的就是右值亦称为将亡值\",{\"1\":{\"1121\":1}}],[\"strqappender\",{\"1\":{\"1020\":4}}],[\"str在第二次调用析构函数后\",{\"1\":{\"735\":1}}],[\"stripped\",{\"1\":{\"572\":1}}],[\"string=password\",{\"1\":{\"1407\":1}}],[\"string和队列容器std\",{\"1\":{\"1020\":1}}],[\"stringqueueappender的使用方法与ostreamappender类似\",{\"1\":{\"1020\":1}}],[\"stringqueueappender的功能是将日志记录到一个字符串队列中\",{\"1\":{\"1020\":1}}],[\"stringqueueappender\",{\"0\":{\"1020\":1},\"1\":{\"1019\":1,\"1020\":3}}],[\"string迭代器的实现\",{\"0\":{\"698\":1}}],[\"string对象可以使用下标操作符\",{\"1\":{\"539\":1}}],[\"string对象的构造\",{\"0\":{\"537\":1}}],[\"string字符串向c风格字符串的转化是通过3个成员函数完成的\",{\"1\":{\"538\":1}}],[\"string与c风格字符串的转换\",{\"0\":{\"538\":1}}],[\"string提供了很多方便字符串操作的方法\",{\"1\":{\"536\":1}}],[\"string类模板关于char型的实例化\",{\"1\":{\"536\":1}}],[\"string类本质上其实是basic\",{\"1\":{\"536\":1}}],[\"string类定义在c++头文件中\",{\"1\":{\"536\":1}}],[\"string作为一个类出现\",{\"1\":{\"536\":1}}],[\"string不必担心内存是否足够\",{\"1\":{\"536\":1}}],[\"strings\",{\"1\":{\"535\":1}}],[\"string\",{\"0\":{\"534\":1},\"1\":{\"60\":31,\"166\":2,\"174\":2,\"182\":1,\"191\":2,\"378\":3,\"405\":11,\"536\":8,\"537\":7,\"541\":20,\"542\":1,\"545\":12,\"546\":2,\"547\":6,\"548\":16,\"597\":2,\"599\":1,\"604\":1,\"605\":2,\"698\":3,\"699\":20,\"700\":1,\"735\":1,\"736\":24,\"784\":1,\"862\":4,\"864\":2,\"866\":3,\"867\":7,\"886\":5,\"900\":6,\"905\":5,\"1002\":4,\"1032\":3,\"1066\":4,\"1067\":1,\"1122\":2,\"1154\":1,\"1155\":1,\"1158\":2,\"1165\":4,\"1167\":3,\"1839\":9,\"1846\":7,\"1847\":6,\"1848\":5,\"1849\":4,\"1856\":13,\"1859\":6,\"1875\":9,\"1878\":13,\"1903\":1,\"1907\":3,\"1908\":2,\"1909\":2,\"1915\":4}}],[\"string>\",{\"1\":{\"60\":13,\"1000\":4,\"1020\":1,\"1905\":1,\"1909\":2}}],[\"strncat\",{\"1\":{\"535\":1}}],[\"strncpy\",{\"1\":{\"535\":1}}],[\"strncmp\",{\"1\":{\"535\":1}}],[\"strstr\",{\"1\":{\"535\":2}}],[\"str5\",{\"1\":{\"405\":1}}],[\"str4\",{\"1\":{\"405\":1,\"548\":4}}],[\"str3\",{\"1\":{\"405\":5,\"535\":5,\"548\":3,\"1123\":2}}],[\"str2\",{\"1\":{\"405\":5,\"535\":3,\"547\":3,\"548\":4,\"1120\":3,\"1123\":2}}],[\"str1对象中存入了各种各样的字符\",{\"1\":{\"698\":1}}],[\"str1叫容器吗\",{\"1\":{\"698\":2,\"699\":1}}],[\"str1\",{\"1\":{\"405\":8,\"535\":3,\"547\":8,\"548\":3,\"698\":3,\"699\":3,\"700\":2,\"701\":1,\"735\":1,\"1120\":2,\"1123\":2,\"1124\":2,\"1127\":2}}],[\"strcat\",{\"1\":{\"535\":2,\"547\":1,\"699\":1,\"736\":1,\"1122\":2,\"1123\":2}}],[\"strchr\",{\"1\":{\"535\":1}}],[\"strcpy\",{\"1\":{\"405\":3,\"449\":2,\"450\":2,\"464\":1,\"535\":2,\"547\":1,\"548\":3,\"662\":11,\"699\":4,\"736\":5,\"949\":2,\"1120\":3,\"1122\":2,\"1123\":5}}],[\"strcmp\",{\"1\":{\"366\":2,\"368\":1,\"535\":1,\"563\":1,\"699\":3,\"736\":3,\"1187\":1}}],[\"strlen\",{\"1\":{\"397\":2,\"405\":3,\"426\":1,\"435\":1,\"439\":1,\"464\":2,\"535\":5,\"547\":1,\"548\":3,\"662\":11,\"699\":6,\"736\":7,\"949\":2,\"1120\":3,\"1122\":4,\"1123\":11}}],[\"structure\",{\"0\":{\"1548\":1}}],[\"struct定义派生类\",{\"1\":{\"659\":1}}],[\"structaa\",{\"1\":{\"547\":2}}],[\"struct的默认访问权限是public\",{\"1\":{\"450\":1}}],[\"struct的功能已经进行了扩展\",{\"1\":{\"450\":1}}],[\"struct一样能做\",{\"1\":{\"450\":1}}],[\"struct\",{\"1\":{\"267\":1,\"286\":6,\"287\":2,\"296\":1,\"385\":1,\"450\":1,\"470\":1,\"494\":3,\"547\":1,\"555\":1,\"557\":10,\"585\":1,\"594\":3,\"704\":1,\"747\":1,\"751\":1,\"755\":1,\"756\":1,\"759\":1,\"762\":1,\"768\":1,\"771\":1,\"774\":1,\"782\":1,\"783\":1,\"784\":2,\"787\":1,\"791\":1,\"792\":1,\"795\":1,\"798\":1,\"802\":1,\"810\":1,\"817\":1,\"819\":1,\"821\":1,\"1080\":1,\"1087\":1,\"1127\":1}}],[\"str\",{\"1\":{\"60\":4,\"277\":6,\"405\":4,\"535\":7,\"538\":2,\"541\":1,\"546\":2,\"547\":1,\"597\":4,\"599\":3,\"699\":16,\"735\":2,\"736\":22,\"1120\":16,\"1121\":11,\"1123\":25,\"1124\":1,\"1154\":2,\"1158\":2,\"1165\":4,\"1167\":2,\"1299\":4,\"1839\":10,\"1845\":2,\"1847\":6,\"1849\":10,\"1856\":8,\"1875\":10,\"1878\":6,\"1903\":1,\"1915\":5}}],[\"strong\",{\"1\":{\"50\":1}}],[\"status查看以下标识\",{\"1\":{\"1830\":1}}],[\"status一下binlog日志文件名以及position\",{\"1\":{\"1829\":1}}],[\"status=0\",{\"1\":{\"1820\":1}}],[\"status给mysql\",{\"1\":{\"1803\":1}}],[\"status命令查看主从复制状态\",{\"1\":{\"1826\":1,\"1828\":1}}],[\"status命令\",{\"1\":{\"1750\":1}}],[\"status\",{\"1\":{\"1318\":2,\"1402\":2,\"1409\":1,\"1569\":2,\"1747\":1,\"1768\":1,\"1818\":1,\"1820\":3,\"1822\":1,\"1830\":1,\"1849\":1,\"1859\":1,\"1871\":1,\"1872\":1}}],[\"statistice\",{\"1\":{\"1237\":1}}],[\"static不能修饰class\",{\"1\":{\"591\":1}}],[\"static\",{\"0\":{\"629\":1},\"1\":{\"60\":15,\"267\":6,\"296\":1,\"410\":3,\"413\":4,\"415\":1,\"435\":1,\"439\":4,\"528\":1,\"547\":1,\"571\":1,\"572\":1,\"607\":1,\"629\":4,\"633\":2,\"678\":3,\"692\":1,\"751\":2,\"848\":4,\"849\":3,\"850\":2,\"851\":3,\"852\":3,\"854\":3,\"855\":3,\"856\":3,\"857\":5,\"876\":2,\"1032\":3,\"1080\":3,\"1082\":4,\"1090\":4,\"1093\":1,\"1096\":1,\"1102\":4,\"1114\":2,\"1310\":2,\"1315\":2,\"1316\":3,\"1335\":4,\"1839\":2,\"1848\":1,\"1849\":1,\"1859\":1,\"1875\":2,\"1878\":4}}],[\"state\",{\"0\":{\"1240\":1},\"1\":{\"1082\":1}}],[\"statement\",{\"1\":{\"601\":5}}],[\"stack与queue第二个模板类型参数依赖deque\",{\"0\":{\"993\":1}}],[\"stack常用方法\",{\"1\":{\"990\":1,\"991\":1,\"992\":1}}],[\"stack<string>\",{\"1\":{\"388\":1}}],[\"stack<int\",{\"1\":{\"388\":1}}],[\"stack<int>\",{\"1\":{\"182\":2,\"990\":1}}],[\"stack<t\",{\"1\":{\"388\":6}}],[\"stack窗口\",{\"1\":{\"240\":1}}],[\"stack\",{\"1\":{\"224\":2,\"239\":1,\"240\":2,\"267\":1,\"388\":4,\"989\":1}}],[\"started\",{\"1\":{\"1820\":1}}],[\"starting\",{\"1\":{\"1820\":1}}],[\"startpool\",{\"1\":{\"1151\":2}}],[\"starttime\",{\"1\":{\"751\":3}}],[\"start=mid+1\",{\"1\":{\"93\":1,\"94\":1}}],[\"start=0\",{\"1\":{\"93\":1,\"94\":1}}],[\"start+\",{\"1\":{\"93\":1,\"94\":1}}],[\"starty\",{\"1\":{\"81\":9}}],[\"startx\",{\"1\":{\"81\":8}}],[\"startup回车后自动打开开机自启目录\",{\"1\":{\"27\":1}}],[\"startup\",{\"1\":{\"27\":1}}],[\"start\",{\"1\":{\"27\":1,\"93\":2,\"94\":2,\"234\":1,\"286\":3,\"493\":2,\"1082\":3,\"1099\":1,\"1102\":24,\"1151\":1,\"1409\":1,\"1410\":1,\"1656\":2,\"1734\":1,\"1773\":2,\"1774\":5,\"1818\":1,\"1820\":3,\"1826\":1,\"1830\":2,\"1833\":1}}],[\"star一下哦\",{\"1\":{\"3\":1}}],[\"style\",{\"1\":{\"48\":1,\"50\":2,\"51\":2,\"53\":3,\"54\":2,\"59\":6}}],[\"stdin\",{\"1\":{\"1878\":1}}],[\"stdchrono时间库全面解析\",{\"1\":{\"1869\":1}}],[\"stdc++\",{\"1\":{\"163\":1,\"267\":1}}],[\"stduent\",{\"1\":{\"1563\":3}}],[\"std=c++11\",{\"1\":{\"516\":2,\"1317\":3,\"1367\":1}}],[\"std\",{\"0\":{\"852\":1},\"1\":{\"8\":2,\"11\":2,\"60\":47,\"70\":1,\"101\":4,\"104\":5,\"107\":5,\"110\":5,\"118\":3,\"163\":1,\"185\":2,\"188\":7,\"191\":5,\"194\":4,\"199\":2,\"202\":1,\"205\":2,\"214\":3,\"217\":2,\"220\":2,\"224\":2,\"267\":1,\"378\":3,\"405\":1,\"406\":1,\"422\":13,\"433\":2,\"434\":2,\"459\":2,\"468\":2,\"476\":1,\"497\":2,\"500\":2,\"506\":2,\"515\":2,\"536\":8,\"547\":3,\"548\":2,\"557\":2,\"569\":2,\"571\":2,\"588\":2,\"589\":4,\"590\":2,\"594\":17,\"597\":1,\"599\":1,\"601\":4,\"602\":3,\"604\":17,\"605\":1,\"606\":1,\"607\":2,\"618\":2,\"621\":7,\"633\":2,\"642\":2,\"662\":20,\"731\":1,\"736\":1,\"751\":1,\"810\":2,\"817\":4,\"819\":2,\"821\":2,\"830\":1,\"831\":1,\"832\":1,\"848\":11,\"849\":12,\"850\":6,\"851\":7,\"852\":12,\"871\":1,\"889\":2,\"891\":2,\"894\":2,\"953\":1,\"1020\":1,\"1031\":2,\"1032\":3,\"1041\":1,\"1047\":1,\"1050\":6,\"1055\":1,\"1060\":1,\"1079\":1,\"1080\":1,\"1115\":1,\"1123\":1,\"1127\":5,\"1147\":1,\"1148\":1,\"1151\":1,\"1154\":1,\"1158\":1,\"1168\":1,\"1183\":1,\"1188\":1,\"1204\":1,\"1207\":8,\"1208\":4,\"1209\":8,\"1210\":2,\"1219\":16,\"1225\":1,\"1226\":1,\"1227\":2,\"1233\":8,\"1299\":4,\"1321\":2,\"1839\":6,\"1846\":1,\"1847\":2,\"1848\":9,\"1849\":7,\"1856\":5,\"1859\":16,\"1869\":1,\"1871\":2,\"1872\":2,\"1875\":11,\"1878\":7,\"1915\":7}}],[\"savepoint\",{\"1\":{\"1640\":1}}],[\"satisfy\",{\"0\":{\"1407\":1},\"1\":{\"1407\":1}}],[\"safari\",{\"1\":{\"1255\":1}}],[\"safe\",{\"1\":{\"271\":1}}],[\"sa在\",{\"1\":{\"267\":1}}],[\"sa=8\",{\"1\":{\"267\":1}}],[\"same\",{\"1\":{\"59\":1}}],[\"san\",{\"1\":{\"1475\":3,\"1478\":1,\"1915\":1}}],[\"sandbox\",{\"1\":{\"59\":1}}],[\"sans\",{\"1\":{\"49\":2}}],[\"sae\",{\"1\":{\"0\":1}}],[\"sass\",{\"1\":{\"0\":1}}],[\"svn\",{\"1\":{\"0\":1}}],[\"plugin\",{\"1\":{\"1447\":1}}],[\"plugin=\",{\"1\":{\"1407\":1}}],[\"pl\",{\"1\":{\"1285\":1}}],[\"playvideo\",{\"1\":{\"832\":3}}],[\"play\",{\"1\":{\"832\":5}}],[\"placeholders\",{\"1\":{\"1151\":1,\"1155\":1}}],[\"placement版\",{\"1\":{\"518\":1}}],[\"place\",{\"1\":{\"67\":1}}],[\"plan\",{\"1\":{\"49\":1}}],[\"p或\",{\"1\":{\"1237\":1}}],[\"p相当于野指针了\",{\"1\":{\"1113\":1}}],[\"p拷贝到\",{\"1\":{\"1076\":1}}],[\"pwd\",{\"1\":{\"1915\":4}}],[\"pw\",{\"1\":{\"1050\":2}}],[\"ppfa\",{\"1\":{\"1031\":3}}],[\"ppl2\",{\"1\":{\"1031\":6}}],[\"ppl1\",{\"1\":{\"1031\":6}}],[\"ppointer\",{\"1\":{\"273\":2,\"274\":1}}],[\"p是基类指针调用的show\",{\"1\":{\"906\":1}}],[\"p指向的\",{\"1\":{\"1093\":2}}],[\"p指向尾结点\",{\"1\":{\"810\":1}}],[\"p指向了其他的派生类对象\",{\"1\":{\"631\":1}}],[\"pq\",{\"1\":{\"784\":6}}],[\"pque\",{\"1\":{\"406\":16,\"992\":5}}],[\"p++\",{\"1\":{\"747\":1}}],[\"p+1\",{\"1\":{\"747\":1}}],[\"pvga\",{\"1\":{\"832\":2}}],[\"pvideo\",{\"1\":{\"830\":5}}],[\"pvec\",{\"1\":{\"747\":13}}],[\"pvoid\",{\"1\":{\"629\":2}}],[\"pd1\",{\"1\":{\"920\":2}}],[\"pderived3\",{\"1\":{\"678\":2}}],[\"pderived2\",{\"1\":{\"678\":2}}],[\"pderived\",{\"1\":{\"662\":30,\"678\":1,\"889\":1,\"949\":9}}],[\"pd2\",{\"1\":{\"631\":3}}],[\"pdo\",{\"1\":{\"0\":1}}],[\"p的类型\",{\"1\":{\"631\":1}}],[\"pki\",{\"1\":{\"621\":1}}],[\"python\",{\"1\":{\"1913\":1}}],[\"python3\",{\"1\":{\"1293\":2}}],[\"python等\",{\"1\":{\"359\":1}}],[\"py\",{\"1\":{\"618\":4}}],[\"px\",{\"1\":{\"618\":4}}],[\"p更方便\",{\"1\":{\"618\":1}}],[\"pb先析构\",{\"1\":{\"1056\":1}}],[\"pbl\",{\"1\":{\"1031\":2}}],[\"pb识别的就是运行时期的类型\",{\"1\":{\"956\":1}}],[\"pb识别的就是编译时期的类型\",{\"1\":{\"956\":1}}],[\"pb就是class\",{\"1\":{\"956\":1}}],[\"pb是\",{\"1\":{\"956\":2}}],[\"pb是基类类型\",{\"1\":{\"953\":1}}],[\"pb的类型是base类型\",{\"1\":{\"948\":2}}],[\"pb2\",{\"1\":{\"891\":2,\"908\":3,\"920\":2}}],[\"pb1\",{\"1\":{\"891\":2,\"908\":3,\"920\":2}}],[\"pbase2\",{\"1\":{\"889\":4}}],[\"pbase3\",{\"1\":{\"678\":2,\"889\":3}}],[\"pbase\",{\"1\":{\"662\":48,\"678\":1,\"913\":2,\"949\":15}}],[\"pb\",{\"0\":{\"956\":1},\"1\":{\"615\":3,\"890\":7,\"948\":4,\"953\":7,\"954\":4,\"1056\":9,\"1915\":1}}],[\"p8\",{\"1\":{\"524\":2}}],[\"p7\",{\"1\":{\"524\":2}}],[\"p6\",{\"1\":{\"524\":2}}],[\"p5\",{\"1\":{\"497\":3,\"523\":3}}],[\"pfl\",{\"1\":{\"1031\":3}}],[\"pfloat\",{\"1\":{\"629\":1}}],[\"pf\",{\"1\":{\"493\":2,\"497\":2,\"894\":10,\"1839\":4,\"1849\":4,\"1875\":4,\"1878\":4}}],[\"pfunc2是函数类型\",{\"1\":{\"1188\":1}}],[\"pfunc2\",{\"1\":{\"1188\":4}}],[\"pfunc1是函数指针类型\",{\"1\":{\"1188\":1}}],[\"pfunc1\",{\"1\":{\"1188\":4}}],[\"pfunc\",{\"1\":{\"414\":3,\"1158\":24,\"1165\":1,\"1167\":1}}],[\"p又赋值给q\",{\"1\":{\"492\":1}}],[\"p存放的是a的地址\",{\"1\":{\"492\":1}}],[\"p存放的是const\",{\"1\":{\"490\":1}}],[\"p本身\",{\"1\":{\"490\":1}}],[\"p赋值给const\",{\"1\":{\"490\":1}}],[\"p和\",{\"1\":{\"490\":1}}],[\"p此时确实把\",{\"1\":{\"484\":1}}],[\"p4错误在于释放位置不对\",{\"1\":{\"523\":1}}],[\"p4\",{\"1\":{\"455\":1,\"488\":1,\"492\":1,\"497\":3,\"511\":1,\"523\":2,\"1114\":1}}],[\"p3的构造函数开辟的空间没有被释放\",{\"1\":{\"523\":1}}],[\"p3\",{\"1\":{\"455\":3,\"488\":3,\"492\":2,\"497\":3,\"511\":1,\"523\":2,\"831\":2,\"864\":1,\"871\":3,\"1047\":1,\"1114\":1}}],[\"p=\",{\"1\":{\"385\":3,\"704\":3}}],[\"ps1=\",{\"1\":{\"1282\":1}}],[\"psl\",{\"1\":{\"1031\":2}}],[\"psingleton\",{\"1\":{\"851\":6}}],[\"pstu\",{\"1\":{\"717\":1,\"718\":1}}],[\"pstr2\",{\"1\":{\"547\":8}}],[\"pstr\",{\"1\":{\"535\":3,\"547\":8,\"548\":25,\"699\":36,\"1120\":2,\"1123\":2}}],[\"pstack\",{\"1\":{\"224\":9}}],[\"ps\",{\"1\":{\"289\":1,\"1057\":3,\"1280\":1,\"1296\":1}}],[\"pi4jwca2\",{\"1\":{\"1677\":1}}],[\"pic\",{\"1\":{\"1333\":1}}],[\"pip\",{\"1\":{\"1293\":1}}],[\"pipe\",{\"1\":{\"239\":1}}],[\"pid\",{\"1\":{\"1253\":1,\"1820\":1}}],[\"piece\",{\"1\":{\"1102\":2}}],[\"pig是从animla继承而来\",{\"1\":{\"886\":1}}],[\"pig\",{\"1\":{\"886\":10,\"905\":2}}],[\"ping一下\",{\"1\":{\"1828\":1}}],[\"pinstance\",{\"1\":{\"854\":11,\"855\":7,\"856\":9,\"857\":8}}],[\"pint2\",{\"1\":{\"630\":1}}],[\"pint1\",{\"1\":{\"630\":1}}],[\"pint\",{\"1\":{\"459\":3,\"515\":11,\"571\":4,\"616\":2,\"618\":2,\"629\":4,\"630\":1,\"633\":3}}],[\"pimpl设计模式有如下优点\",{\"1\":{\"826\":1}}],[\"pimpl又称作\",{\"1\":{\"826\":1}}],[\"pimpl\",{\"0\":{\"826\":1},\"1\":{\"826\":6}}],[\"pimage\",{\"1\":{\"271\":5}}],[\"pi\",{\"1\":{\"323\":6,\"338\":7,\"492\":2}}],[\"p在栈上\",{\"1\":{\"267\":1}}],[\"pend\",{\"1\":{\"1299\":7}}],[\"pending\",{\"1\":{\"239\":1}}],[\"permanent\",{\"1\":{\"1818\":1}}],[\"permitted\",{\"1\":{\"1080\":1}}],[\"performance\",{\"1\":{\"1719\":1,\"1720\":1}}],[\"person\",{\"1\":{\"1477\":1}}],[\"perror\",{\"1\":{\"1299\":1}}],[\"per\",{\"1\":{\"751\":1}}],[\"peek\",{\"1\":{\"182\":6}}],[\"pconn\",{\"1\":{\"1849\":3,\"1859\":3,\"1870\":2,\"1872\":2}}],[\"pcar\",{\"1\":{\"831\":9}}],[\"pcur++\",{\"1\":{\"1127\":1}}],[\"pcur\",{\"1\":{\"791\":20,\"792\":20,\"795\":8,\"1127\":1}}],[\"pc2\",{\"1\":{\"397\":1,\"464\":1}}],[\"pc1\",{\"1\":{\"397\":2,\"439\":2,\"464\":2}}],[\"pcb块\",{\"1\":{\"267\":1}}],[\"pc\",{\"1\":{\"234\":2,\"449\":3,\"459\":1,\"890\":7,\"1348\":1}}],[\"ptnlayout2\",{\"1\":{\"1032\":4}}],[\"ptnlayout1\",{\"1\":{\"1032\":4}}],[\"ptail\",{\"1\":{\"792\":10}}],[\"pthread\",{\"0\":{\"857\":1},\"1\":{\"493\":3,\"857\":5,\"1151\":1,\"1198\":1,\"1202\":1,\"1322\":1,\"1849\":1,\"1859\":1,\"1875\":1}}],[\"pthread线程相关接口等\",{\"1\":{\"16\":1}}],[\"pt4\",{\"1\":{\"463\":2}}],[\"ptemp\",{\"1\":{\"459\":3,\"791\":9}}],[\"pts\",{\"1\":{\"458\":6}}],[\"pt2对象\",{\"1\":{\"434\":1}}],[\"pt2时\",{\"1\":{\"434\":1}}],[\"pt2\",{\"1\":{\"395\":1,\"434\":3,\"459\":4,\"463\":7,\"826\":3}}],[\"pt1与pt2都存在\",{\"1\":{\"463\":1}}],[\"pt1和\",{\"1\":{\"434\":2}}],[\"pt1对象已经存在\",{\"1\":{\"395\":1}}],[\"pt1\",{\"1\":{\"395\":2,\"434\":3,\"459\":4,\"463\":7,\"826\":3}}],[\"pt\",{\"1\":{\"372\":7,\"421\":2,\"433\":1,\"454\":2,\"455\":2,\"459\":4}}],[\"ptmp+i\",{\"1\":{\"385\":1,\"704\":1}}],[\"ptmp\",{\"1\":{\"355\":3,\"385\":4,\"406\":3,\"535\":6,\"704\":4,\"1122\":10,\"1123\":6,\"1127\":6}}],[\"ptr智能指针来管理\",{\"1\":{\"1866\":1}}],[\"ptr智能指针析构时\",{\"1\":{\"1849\":1,\"1859\":1,\"1872\":1}}],[\"ptr可以访问到旧数据\",{\"1\":{\"1681\":1}}],[\"ptr指针把当前数据和旧数据串成1个链表\",{\"1\":{\"1681\":1}}],[\"ptr指针合法性\",{\"1\":{\"747\":1}}],[\"ptr之间的关系\",{\"1\":{\"1220\":1,\"1228\":1}}],[\"ptr和scope\",{\"1\":{\"1220\":1,\"1228\":1}}],[\"ptr和weak\",{\"1\":{\"1050\":1,\"1053\":1,\"1055\":1,\"1196\":1}}],[\"ptr类似\",{\"1\":{\"1211\":1}}],[\"ptr4\",{\"1\":{\"1060\":1}}],[\"ptr3\",{\"1\":{\"1060\":1}}],[\"ptr都可以提供自定义删除器\",{\"1\":{\"1060\":1}}],[\"ptr都是线程安全的\",{\"1\":{\"1055\":1}}],[\"ptrb\",{\"1\":{\"1057\":4}}],[\"ptra\",{\"1\":{\"1057\":6}}],[\"ptr怎么使用资源\",{\"0\":{\"1057\":1}}],[\"ptr怎么解决浅拷贝问题\",{\"0\":{\"1044\":1}}],[\"ptr1\",{\"1\":{\"1056\":2,\"1057\":3,\"1060\":1}}],[\"ptr2\",{\"1\":{\"1056\":2,\"1057\":1,\"1060\":1}}],[\"ptr的释放资源的方式\",{\"1\":{\"1849\":1,\"1859\":1,\"1872\":1}}],[\"ptr的交叉引用问题\",{\"0\":{\"1056\":1}}],[\"ptr的区别是\",{\"1\":{\"1055\":1}}],[\"ptr将m\",{\"1\":{\"1055\":1}}],[\"ptr临时对象是右值\",{\"1\":{\"1047\":1}}],[\"ptr还暴力\",{\"1\":{\"1046\":1}}],[\"ptr运用在容器中\",{\"1\":{\"1045\":1}}],[\"ptr<connection>\",{\"1\":{\"1848\":1,\"1849\":2,\"1851\":2,\"1859\":3,\"1869\":2,\"1870\":1,\"1872\":2,\"1875\":2}}],[\"ptr<car>\",{\"1\":{\"864\":2,\"866\":2,\"867\":2}}],[\"ptr<file\",{\"1\":{\"1060\":2}}],[\"ptr<facory>\",{\"1\":{\"866\":2}}],[\"ptr<int\",{\"1\":{\"1060\":2}}],[\"ptr<int>>\",{\"1\":{\"1045\":3}}],[\"ptr<int>\",{\"1\":{\"1043\":2,\"1045\":3,\"1047\":4}}],[\"ptr<b>ptrb\",{\"1\":{\"1057\":1}}],[\"ptr<b>ptr2\",{\"1\":{\"1057\":1}}],[\"ptr<b>\",{\"1\":{\"1056\":4,\"1057\":1}}],[\"ptr<a>ptra\",{\"1\":{\"1057\":1}}],[\"ptr<a>ptr1\",{\"1\":{\"1057\":1}}],[\"ptr<a>ps\",{\"1\":{\"1057\":1}}],[\"ptr<a>\",{\"1\":{\"1050\":4,\"1056\":4,\"1057\":1}}],[\"ptr<abstractfactory>\",{\"1\":{\"867\":2}}],[\"ptr<t>\",{\"1\":{\"1047\":1}}],[\"ptr<light>\",{\"1\":{\"867\":2}}],[\"ptr<simplefactory>\",{\"1\":{\"864\":1}}],[\"ptr<singleton>\",{\"1\":{\"849\":4,\"852\":4}}],[\"ptr<videosite>\",{\"1\":{\"830\":3}}],[\"ptr不为空指针\",{\"1\":{\"736\":1}}],[\"ptr=nullptr\",{\"1\":{\"736\":1}}],[\"ptr++\",{\"1\":{\"704\":1,\"747\":1}}],[\"ptr\",{\"0\":{\"1043\":1,\"1045\":1,\"1046\":1,\"1047\":1},\"1\":{\"234\":12,\"236\":5,\"238\":1,\"267\":2,\"459\":1,\"638\":3,\"704\":8,\"711\":6,\"714\":3,\"736\":53,\"747\":14,\"751\":2,\"830\":4,\"906\":2,\"948\":6,\"954\":2,\"1011\":2,\"1041\":9,\"1042\":3,\"1043\":2,\"1047\":4,\"1050\":2,\"1053\":1,\"1055\":15,\"1060\":5,\"1122\":2,\"1196\":1,\"1210\":1,\"1219\":5,\"1343\":1,\"1656\":1,\"1681\":1,\"1682\":1,\"1848\":2,\"1859\":2,\"1863\":1,\"1875\":2}}],[\"p\",{\"1\":{\"178\":4,\"239\":1,\"267\":1,\"385\":12,\"411\":3,\"412\":3,\"440\":2,\"468\":3,\"483\":3,\"484\":7,\"485\":4,\"490\":7,\"492\":14,\"510\":4,\"512\":4,\"516\":2,\"520\":1,\"605\":1,\"614\":2,\"618\":5,\"624\":4,\"625\":6,\"631\":7,\"632\":2,\"633\":4,\"695\":6,\"699\":12,\"704\":12,\"709\":2,\"710\":8,\"711\":1,\"713\":2,\"747\":13,\"751\":10,\"755\":5,\"810\":10,\"817\":13,\"819\":23,\"821\":32,\"831\":6,\"832\":2,\"886\":5,\"890\":4,\"894\":13,\"898\":5,\"906\":4,\"907\":7,\"1021\":2,\"1026\":2,\"1031\":4,\"1032\":2,\"1040\":3,\"1041\":5,\"1050\":5,\"1055\":6,\"1060\":4,\"1076\":5,\"1080\":15,\"1086\":4,\"1087\":6,\"1093\":3,\"1102\":5,\"1113\":1,\"1127\":10,\"1271\":1,\"1395\":1,\"1397\":1,\"1403\":1,\"1405\":1,\"1408\":1,\"1774\":3,\"1836\":1,\"1847\":2,\"1849\":3,\"1856\":2,\"1859\":3}}],[\"p22\",{\"1\":{\"905\":7}}],[\"p2走m+n\",{\"1\":{\"771\":1}}],[\"p2链\",{\"1\":{\"756\":2}}],[\"p2认为p2只是指向了一个对象\",{\"1\":{\"715\":1}}],[\"p2\",{\"1\":{\"110\":4,\"455\":1,\"488\":1,\"492\":1,\"497\":3,\"511\":1,\"522\":2,\"630\":1,\"714\":4,\"715\":1,\"756\":5,\"762\":10,\"771\":19,\"777\":4,\"795\":4,\"802\":3,\"830\":2,\"831\":2,\"862\":1,\"864\":6,\"866\":2,\"867\":2,\"871\":2,\"905\":5,\"1043\":1,\"1047\":2,\"1114\":2}}],[\"p1指向了堆上开辟的一块内存\",{\"1\":{\"1043\":1}}],[\"p111111\",{\"1\":{\"1836\":5}}],[\"p11\",{\"1\":{\"905\":7}}],[\"p1只是单个元素\",{\"1\":{\"715\":1}}],[\"p1也只是析构p1\",{\"1\":{\"517\":1}}],[\"p1\",{\"1\":{\"110\":5,\"413\":3,\"455\":1,\"487\":3,\"488\":3,\"492\":1,\"497\":3,\"511\":1,\"517\":8,\"522\":2,\"535\":1,\"547\":1,\"630\":1,\"633\":11,\"714\":4,\"715\":1,\"756\":4,\"762\":10,\"771\":19,\"777\":16,\"787\":5,\"795\":5,\"802\":17,\"830\":2,\"831\":6,\"862\":1,\"864\":6,\"866\":2,\"867\":2,\"871\":3,\"905\":5,\"1043\":3,\"1047\":3,\"1114\":3}}],[\"png\",{\"1\":{\"66\":3,\"81\":1,\"783\":1,\"803\":1,\"1082\":1,\"1085\":1,\"1656\":1,\"1658\":2,\"1660\":1,\"1663\":2,\"1664\":2,\"1665\":5,\"1668\":1,\"1673\":1,\"1677\":2,\"1681\":4,\"1682\":4,\"1758\":4,\"1759\":1,\"1767\":1,\"1768\":1,\"1769\":2,\"1770\":2,\"1771\":2,\"1772\":2,\"1773\":8,\"1774\":10,\"1775\":1,\"1776\":5}}],[\"pr\",{\"1\":{\"984\":1,\"985\":1}}],[\"preset\",{\"1\":{\"1820\":1}}],[\"prepare\",{\"1\":{\"1658\":1}}],[\"prepare状态的数据不会出现在快照中\",{\"1\":{\"1658\":1}}],[\"preconfigure\",{\"1\":{\"1397\":1}}],[\"pre指针域指向前一个节点\",{\"1\":{\"820\":1,\"823\":1}}],[\"preleftnode\",{\"1\":{\"802\":4}}],[\"pre\",{\"1\":{\"747\":4,\"756\":4,\"787\":3,\"792\":4,\"802\":1,\"817\":10,\"821\":10,\"1820\":1}}],[\"pretty\",{\"1\":{\"849\":2,\"852\":2}}],[\"pret\",{\"1\":{\"633\":2}}],[\"prefer\",{\"1\":{\"503\":1}}],[\"pragma\",{\"1\":{\"244\":2,\"555\":1,\"556\":1,\"557\":3}}],[\"primarykey=\",{\"1\":{\"1891\":1}}],[\"primary\",{\"1\":{\"1428\":2,\"1432\":1,\"1437\":1,\"1537\":3,\"1551\":1,\"1552\":1,\"1614\":1,\"1618\":1,\"1719\":1}}],[\"primer书中有提到说\",{\"1\":{\"518\":1}}],[\"privileges\",{\"1\":{\"1407\":1,\"1408\":1,\"1447\":1,\"1799\":2,\"1821\":1}}],[\"private访问关键字限制的\",{\"1\":{\"724\":1}}],[\"private进行修饰的成员是不可以在类之外进行访问的\",{\"1\":{\"449\":1}}],[\"private\",{\"1\":{\"101\":2,\"182\":1,\"185\":1,\"224\":1,\"355\":1,\"372\":1,\"385\":1,\"388\":1,\"389\":2,\"397\":1,\"405\":1,\"406\":1,\"421\":1,\"422\":1,\"423\":1,\"426\":1,\"432\":1,\"433\":1,\"434\":2,\"435\":1,\"439\":2,\"448\":1,\"449\":4,\"459\":1,\"464\":1,\"517\":1,\"518\":1,\"521\":1,\"530\":1,\"548\":1,\"606\":1,\"646\":2,\"653\":2,\"657\":1,\"662\":3,\"667\":2,\"670\":1,\"672\":1,\"678\":2,\"683\":1,\"684\":2,\"699\":2,\"704\":2,\"714\":1,\"722\":1,\"731\":1,\"736\":1,\"751\":1,\"791\":1,\"792\":2,\"802\":1,\"817\":1,\"819\":1,\"821\":1,\"826\":4,\"830\":2,\"831\":3,\"832\":1,\"848\":2,\"849\":1,\"850\":1,\"851\":2,\"852\":1,\"854\":2,\"855\":3,\"856\":2,\"857\":2,\"871\":1,\"889\":4,\"891\":4,\"894\":2,\"898\":3,\"900\":1,\"907\":2,\"919\":1,\"933\":2,\"934\":2,\"943\":1,\"948\":2,\"949\":2,\"953\":1,\"954\":1,\"989\":1,\"1002\":2,\"1032\":2,\"1041\":2,\"1055\":2,\"1110\":1,\"1114\":1,\"1115\":1,\"1120\":1,\"1123\":1,\"1127\":1,\"1148\":1,\"1151\":2,\"1158\":3,\"1173\":1,\"1219\":2,\"1839\":2,\"1846\":1,\"1848\":2,\"1856\":1,\"1859\":3,\"1875\":2,\"1878\":3}}],[\"price\",{\"1\":{\"397\":8,\"426\":5,\"435\":6,\"439\":8,\"440\":6,\"449\":7,\"450\":8,\"464\":8}}],[\"prioritylevel\",{\"1\":{\"1025\":1}}],[\"priority\",{\"0\":{\"1023\":1},\"1\":{\"239\":2,\"784\":8,\"984\":2,\"992\":1,\"1020\":2,\"1025\":1,\"1031\":4,\"1032\":3,\"1183\":3}}],[\"print$2\",{\"1\":{\"1405\":1}}],[\"printtotalprice\",{\"1\":{\"439\":9,\"440\":1}}],[\"printlineimpl\",{\"1\":{\"826\":2}}],[\"printline\",{\"1\":{\"434\":2,\"826\":2}}],[\"printf\",{\"1\":{\"277\":4,\"310\":1,\"323\":2,\"338\":1,\"440\":2,\"468\":3,\"483\":1,\"484\":3,\"494\":3,\"515\":2,\"535\":2,\"547\":7,\"570\":1,\"575\":1,\"576\":1,\"594\":2,\"618\":5,\"633\":4,\"890\":4,\"894\":13,\"1299\":1,\"1383\":3,\"1384\":5,\"1385\":11}}],[\"printvec\",{\"1\":{\"214\":3}}],[\"print\",{\"1\":{\"60\":2,\"104\":2,\"107\":10,\"110\":6,\"188\":3,\"191\":5,\"378\":5,\"392\":1,\"421\":2,\"433\":1,\"434\":3,\"435\":1,\"439\":5,\"440\":6,\"454\":1,\"455\":1,\"459\":3,\"548\":6,\"594\":16,\"652\":10,\"653\":3,\"722\":1,\"826\":3,\"848\":2,\"849\":1,\"850\":2,\"851\":2,\"852\":1,\"900\":1,\"913\":2,\"1238\":8,\"1340\":2}}],[\"proto\",{\"1\":{\"1915\":1}}],[\"proto3\",{\"1\":{\"1915\":1}}],[\"proto配置文件定义好消息类型\",{\"1\":{\"1915\":1}}],[\"proto文件\",{\"1\":{\"1915\":1}}],[\"protocol\",{\"1\":{\"1913\":1}}],[\"protobuf简单使用实例\",{\"0\":{\"1915\":1}}],[\"protobuf简介\",{\"0\":{\"1913\":1}}],[\"protobuf简介及使用\",{\"0\":{\"1912\":1},\"2\":{\"1917\":1}}],[\"protobuf语法\",{\"0\":{\"1914\":1}}],[\"protobuf\",{\"1\":{\"1901\":1,\"1913\":1,\"1914\":1}}],[\"protected进行修饰的成员\",{\"1\":{\"449\":1}}],[\"protected\",{\"1\":{\"448\":1,\"449\":2,\"646\":2,\"657\":1,\"667\":1,\"683\":1,\"684\":2,\"688\":8,\"724\":1,\"862\":1,\"867\":1,\"886\":1,\"900\":3,\"905\":1,\"919\":1,\"933\":2,\"943\":2,\"948\":2,\"953\":1,\"954\":1,\"1079\":1,\"1086\":2}}],[\"profiles命令可有查看sql详细的运行时间\",{\"1\":{\"1776\":1}}],[\"profiles\",{\"1\":{\"1582\":1}}],[\"profiles查看sql具体的运行时间\",{\"0\":{\"1582\":1}}],[\"profiling=on\",{\"1\":{\"1776\":1}}],[\"profiling变量只影响当前session\",{\"1\":{\"1582\":1}}],[\"profiling\",{\"1\":{\"1577\":1,\"1582\":1,\"1776\":1}}],[\"procedure\",{\"1\":{\"1523\":1}}],[\"processlist查看master和salve相关线程的运行状态\",{\"1\":{\"1826\":1}}],[\"processlist\",{\"1\":{\"1786\":1}}],[\"process\",{\"1\":{\"1102\":1,\"1820\":1}}],[\"processes\",{\"1\":{\"239\":1}}],[\"properties\",{\"1\":{\"1316\":4}}],[\"property>\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"property\",{\"1\":{\"1026\":2}}],[\"propertyconfigurator\",{\"1\":{\"1026\":2}}],[\"project\",{\"1\":{\"1310\":4,\"1312\":4,\"1314\":1,\"1315\":1,\"1316\":5,\"1317\":2,\"1318\":2,\"1322\":1}}],[\"produce\",{\"1\":{\"1849\":2,\"1859\":2,\"1875\":1}}],[\"produceconnectiontask\",{\"1\":{\"1848\":1,\"1849\":2,\"1859\":3,\"1875\":3}}],[\"producer\",{\"1\":{\"1219\":4}}],[\"product\",{\"1\":{\"1428\":2}}],[\"producta和productb就是一个产品簇\",{\"1\":{\"867\":1}}],[\"pro\",{\"1\":{\"49\":2}}],[\"program\",{\"1\":{\"263\":1,\"289\":1,\"1335\":4,\"1365\":1}}],[\"programs\",{\"1\":{\"27\":1,\"1237\":1}}],[\"programdata\",{\"1\":{\"27\":1}}],[\"policy=low\",{\"1\":{\"1407\":1}}],[\"policy\",{\"0\":{\"1407\":1},\"1\":{\"1407\":3}}],[\"polymorphism\",{\"1\":{\"494\":1,\"881\":1}}],[\"port端口号\",{\"1\":{\"1865\":1}}],[\"port=3306\",{\"1\":{\"1818\":1,\"1825\":1,\"1829\":1,\"1844\":1,\"1878\":1}}],[\"port配置原因\",{\"1\":{\"1806\":1}}],[\"port\",{\"1\":{\"1238\":1,\"1374\":2,\"1409\":1,\"1818\":1,\"1833\":1,\"1839\":4,\"1846\":1,\"1847\":2,\"1848\":1,\"1849\":4,\"1856\":3,\"1859\":3,\"1875\":5,\"1878\":1}}],[\"pobser\",{\"1\":{\"871\":2}}],[\"pool的脏数据页是不是刷新到磁盘上\",{\"1\":{\"1763\":1}}],[\"pool中\",{\"1\":{\"1762\":2}}],[\"pool中的dirty\",{\"1\":{\"1758\":1}}],[\"pool中的脏数据刷新到磁盘上\",{\"1\":{\"1758\":1}}],[\"pool中的数据改变记录到redo\",{\"1\":{\"1758\":1}}],[\"pool中的数据\",{\"1\":{\"1758\":1}}],[\"pool里的数据写入磁盘\",{\"1\":{\"1762\":1}}],[\"pool里面的脏数据\",{\"0\":{\"1760\":1}}],[\"pool缓存的数据\",{\"1\":{\"1760\":1}}],[\"pool缓存池\",{\"1\":{\"1758\":1}}],[\"pool默认大小为128m\",{\"1\":{\"1758\":1}}],[\"pool大致结构如图所示\",{\"1\":{\"1758\":1}}],[\"pool\",{\"1\":{\"751\":3,\"1151\":7,\"1748\":1,\"1752\":3,\"1758\":1,\"1762\":1,\"1763\":1,\"1839\":2,\"1849\":2,\"1851\":4,\"1875\":2,\"1878\":4}}],[\"point1\",{\"1\":{\"1640\":2}}],[\"point\",{\"1\":{\"251\":1,\"255\":1,\"372\":2,\"392\":2,\"395\":2,\"396\":3,\"421\":6,\"422\":3,\"426\":1,\"432\":3,\"433\":8,\"434\":6,\"454\":1,\"455\":7,\"458\":12,\"459\":19,\"463\":9,\"722\":10,\"723\":1,\"826\":4}}],[\"pointer\",{\"1\":{\"59\":1,\"488\":2,\"497\":3,\"1080\":4,\"1086\":4}}],[\"pos=1262\",{\"1\":{\"1825\":1,\"1829\":1}}],[\"possible\",{\"1\":{\"1521\":1}}],[\"pos4\",{\"1\":{\"163\":1}}],[\"pos4=upper\",{\"1\":{\"163\":1}}],[\"pos3\",{\"1\":{\"163\":1}}],[\"pos3=lower\",{\"1\":{\"163\":1}}],[\"pos2\",{\"1\":{\"163\":1}}],[\"pos2=upper\",{\"1\":{\"163\":1}}],[\"pos1\",{\"1\":{\"163\":1}}],[\"pos1=lower\",{\"1\":{\"163\":1}}],[\"pos下标\",{\"1\":{\"101\":1}}],[\"pos\",{\"1\":{\"101\":13,\"121\":7,\"199\":1,\"536\":2,\"538\":1,\"539\":4,\"542\":1,\"546\":8,\"1031\":11,\"1825\":1}}],[\"position表示左闭右开区间\",{\"1\":{\"1774\":1}}],[\"position和stop\",{\"1\":{\"1774\":1}}],[\"position=1410\",{\"1\":{\"1774\":1}}],[\"position=775\",{\"1\":{\"1774\":1}}],[\"position\",{\"1\":{\"51\":1,\"543\":2,\"1333\":1,\"1774\":2}}],[\"posix\",{\"1\":{\"239\":1}}],[\"posix标准不仅包含了iso\",{\"1\":{\"16\":1}}],[\"posix是portable\",{\"1\":{\"16\":1}}],[\"pop将底层pop\",{\"1\":{\"989\":1}}],[\"pop\",{\"1\":{\"101\":4,\"182\":8,\"185\":2,\"224\":6,\"232\":1,\"233\":1,\"238\":1,\"355\":2,\"385\":2,\"388\":2,\"406\":2,\"704\":1,\"747\":4,\"751\":2,\"784\":1,\"817\":6,\"984\":1,\"989\":2,\"990\":2,\"991\":2,\"992\":2,\"1020\":1,\"1086\":1,\"1087\":1,\"1127\":1,\"1219\":2,\"1849\":3,\"1859\":2,\"1869\":1,\"1872\":1}}],[\"popups\",{\"1\":{\"59\":1}}],[\"payment\",{\"1\":{\"1428\":2}}],[\"page写入磁盘\",{\"1\":{\"1758\":1}}],[\"page\",{\"1\":{\"1014\":1}}],[\"pair\",{\"1\":{\"1000\":16,\"1001\":1,\"1002\":3,\"1168\":2}}],[\"pair<int\",{\"1\":{\"125\":1}}],[\"patsubst\",{\"1\":{\"1361\":2,\"1367\":1}}],[\"patternlayout\",{\"1\":{\"1021\":6,\"1031\":9,\"1032\":6}}],[\"pattern\",{\"1\":{\"871\":1,\"1361\":1}}],[\"path环境变量或\",{\"1\":{\"1331\":1}}],[\"path和project\",{\"1\":{\"1316\":1}}],[\"path=mdima\",{\"1\":{\"60\":1}}],[\"path\",{\"1\":{\"60\":15,\"1133\":1,\"1291\":1,\"1310\":2,\"1316\":3,\"1317\":1,\"1318\":1,\"1328\":2,\"1335\":3}}],[\"package\",{\"0\":{\"1295\":1},\"1\":{\"1915\":1}}],[\"packet\",{\"1\":{\"1260\":5}}],[\"pack指定的数值中最小的一个的整数倍的地址开始存储\",{\"1\":{\"557\":1}}],[\"pack\",{\"0\":{\"1086\":2,\"1087\":2},\"1\":{\"555\":1,\"556\":1,\"557\":2,\"1143\":1,\"1905\":3}}],[\"pa接收它\",{\"0\":{\"520\":1}}],[\"pa\",{\"1\":{\"518\":3,\"615\":3,\"890\":6,\"1056\":9}}],[\"passward\",{\"1\":{\"1846\":1,\"1847\":2,\"1856\":3}}],[\"password=147258\",{\"1\":{\"1844\":1,\"1878\":1}}],[\"password=123456\",{\"1\":{\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":1}}],[\"password=1000000中password是整型\",{\"1\":{\"1617\":1}}],[\"password=\",{\"1\":{\"1581\":1,\"1825\":1,\"1829\":1,\"1888\":2,\"1891\":2}}],[\"password=password\",{\"1\":{\"1254\":1}}],[\"passwordidx\",{\"1\":{\"1581\":1}}],[\"password是\",{\"1\":{\"1581\":1}}],[\"password添加索引\",{\"1\":{\"1581\":1}}],[\"password\",{\"0\":{\"1407\":1},\"1\":{\"1407\":20,\"1447\":2,\"1539\":1,\"1581\":1,\"1839\":4,\"1848\":1,\"1849\":4,\"1859\":3,\"1875\":5,\"1878\":1,\"1888\":1,\"1891\":1}}],[\"passwd\",{\"1\":{\"1374\":2,\"1556\":1}}],[\"pass\",{\"1\":{\"484\":1}}],[\"parsefromstring\",{\"1\":{\"1915\":1}}],[\"parsefloat\",{\"1\":{\"59\":1}}],[\"parse\",{\"0\":{\"1906\":1},\"1\":{\"1906\":1,\"1907\":1,\"1908\":1,\"1909\":1}}],[\"parts\",{\"1\":{\"1569\":1}}],[\"partitions\",{\"1\":{\"1521\":1}}],[\"partition\",{\"1\":{\"795\":1}}],[\"partial\",{\"1\":{\"389\":1}}],[\"part\",{\"1\":{\"682\":1}}],[\"parray\",{\"1\":{\"493\":2,\"497\":2,\"515\":7}}],[\"parr\",{\"1\":{\"459\":5}}],[\"param\",{\"1\":{\"182\":3,\"791\":1,\"792\":1}}],[\"parentelement\",{\"1\":{\"59\":5}}],[\"parent\",{\"1\":{\"59\":2,\"121\":4,\"194\":7}}],[\"parentnode\",{\"1\":{\"54\":2,\"59\":2}}],[\"padding\",{\"1\":{\"48\":1,\"49\":2,\"51\":2}}],[\"purge\",{\"1\":{\"1405\":2}}],[\"purple\",{\"1\":{\"29\":1}}],[\"publish\",{\"1\":{\"871\":1}}],[\"public\",{\"0\":{\"1845\":1},\"1\":{\"60\":1,\"67\":1,\"73\":1,\"77\":1,\"78\":1,\"81\":1,\"87\":1,\"96\":1,\"101\":2,\"114\":1,\"115\":1,\"125\":1,\"129\":1,\"133\":1,\"137\":1,\"141\":1,\"142\":1,\"143\":1,\"148\":1,\"149\":1,\"153\":1,\"154\":1,\"155\":1,\"158\":1,\"162\":1,\"166\":1,\"170\":1,\"171\":1,\"174\":1,\"178\":1,\"179\":1,\"182\":1,\"185\":1,\"224\":2,\"355\":2,\"372\":1,\"382\":1,\"385\":2,\"388\":1,\"389\":2,\"397\":1,\"405\":1,\"406\":1,\"410\":1,\"413\":1,\"421\":1,\"422\":7,\"423\":2,\"426\":2,\"432\":1,\"433\":1,\"434\":2,\"435\":1,\"439\":2,\"440\":1,\"448\":1,\"449\":4,\"459\":1,\"464\":1,\"470\":1,\"516\":1,\"517\":1,\"518\":1,\"521\":1,\"530\":1,\"548\":1,\"606\":2,\"631\":7,\"646\":2,\"647\":4,\"649\":4,\"650\":4,\"652\":6,\"653\":10,\"657\":1,\"662\":8,\"667\":5,\"669\":2,\"670\":2,\"672\":2,\"678\":3,\"683\":1,\"684\":3,\"688\":16,\"693\":3,\"695\":9,\"699\":2,\"704\":2,\"714\":1,\"722\":2,\"731\":1,\"736\":1,\"751\":1,\"755\":1,\"756\":1,\"759\":1,\"762\":1,\"768\":1,\"771\":2,\"774\":2,\"777\":2,\"782\":1,\"783\":1,\"784\":2,\"787\":1,\"791\":1,\"792\":1,\"795\":1,\"798\":2,\"802\":1,\"817\":1,\"819\":1,\"821\":1,\"826\":3,\"830\":7,\"831\":13,\"832\":9,\"848\":1,\"849\":1,\"850\":1,\"851\":1,\"852\":1,\"854\":2,\"855\":2,\"856\":1,\"857\":1,\"862\":5,\"864\":5,\"866\":5,\"867\":14,\"871\":8,\"886\":7,\"889\":7,\"890\":5,\"891\":8,\"894\":3,\"898\":11,\"900\":9,\"905\":7,\"906\":3,\"907\":4,\"908\":3,\"913\":3,\"919\":3,\"933\":2,\"934\":3,\"939\":8,\"943\":5,\"948\":6,\"949\":3,\"953\":3,\"954\":3,\"982\":2,\"989\":1,\"1002\":2,\"1011\":3,\"1032\":1,\"1041\":3,\"1055\":2,\"1056\":4,\"1057\":4,\"1060\":2,\"1096\":1,\"1110\":1,\"1114\":1,\"1115\":1,\"1120\":1,\"1123\":1,\"1127\":1,\"1148\":1,\"1151\":2,\"1154\":1,\"1158\":3,\"1167\":1,\"1173\":3,\"1183\":1,\"1188\":5,\"1189\":1,\"1219\":2,\"1839\":3,\"1845\":3,\"1846\":1,\"1847\":1,\"1848\":2,\"1849\":1,\"1856\":7,\"1859\":3,\"1875\":3,\"1878\":5,\"1881\":2}}],[\"pulbic\",{\"1\":{\"669\":1,\"670\":1,\"672\":1}}],[\"push将底层容器的push\",{\"1\":{\"989\":1}}],[\"push\",{\"0\":{\"1086\":1},\"1\":{\"59\":2,\"101\":5,\"110\":1,\"133\":1,\"137\":1,\"182\":8,\"185\":3,\"188\":1,\"191\":4,\"224\":5,\"232\":1,\"233\":1,\"234\":4,\"235\":1,\"236\":2,\"355\":2,\"385\":4,\"388\":3,\"406\":2,\"638\":6,\"704\":2,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":6,\"751\":2,\"755\":1,\"784\":2,\"817\":9,\"871\":3,\"906\":1,\"908\":1,\"966\":5,\"984\":1,\"989\":2,\"990\":2,\"991\":2,\"992\":2,\"1011\":2,\"1045\":3,\"1086\":1,\"1087\":1,\"1124\":2,\"1127\":5,\"1147\":1,\"1148\":1,\"1151\":2,\"1177\":1,\"1183\":3,\"1208\":1,\"1219\":2,\"1233\":1,\"1839\":1,\"1849\":3,\"1859\":3,\"1870\":1,\"1872\":1,\"1875\":2,\"1905\":3}}],[\"put\",{\"1\":{\"51\":1,\"1219\":2}}],[\"pgsql\",{\"1\":{\"0\":1}}],[\"phantom\",{\"1\":{\"1639\":1}}],[\"phony增加makefile的可读性\",{\"1\":{\"1365\":1}}],[\"phony目标\",{\"1\":{\"1365\":1}}],[\"phony\",{\"1\":{\"1355\":1,\"1365\":1,\"1366\":2,\"1367\":1}}],[\"phonegap\",{\"1\":{\"0\":1}}],[\"phdmi\",{\"1\":{\"832\":3}}],[\"phead\",{\"1\":{\"792\":9}}],[\"phead还是\",{\"1\":{\"792\":1}}],[\"phing\",{\"1\":{\"0\":1}}],[\"phpunit\",{\"1\":{\"0\":1}}],[\"phpdoc\",{\"1\":{\"0\":1}}],[\"php\",{\"1\":{\"0\":1,\"1251\":3}}],[\"l集群\",{\"0\":{\"1955\":1}}],[\"l日志\",{\"0\":{\"1954\":1}}],[\"l优化\",{\"0\":{\"1953\":1}}],[\"l的锁机制\",{\"0\":{\"1952\":1}}],[\"l事务\",{\"0\":{\"1951\":1}}],[\"l索引\",{\"0\":{\"1950\":1}}],[\"l存储引擎\",{\"0\":{\"1949\":1}}],[\"l核心\",{\"0\":{\"1948\":1}}],[\"l基础\",{\"0\":{\"1947\":1}}],[\"l二级空间配置器内存池源码\",{\"0\":{\"1939\":1}}],[\"l|grep\",{\"1\":{\"1405\":1}}],[\"lmysqlclient\",{\"1\":{\"1372\":1,\"1856\":1}}],[\"lmylib\",{\"1\":{\"1328\":1,\"1331\":2,\"1335\":1}}],[\"lh\",{\"1\":{\"1283\":1}}],[\"lhs\",{\"1\":{\"535\":2,\"541\":5,\"545\":6,\"699\":4,\"722\":8,\"731\":4,\"736\":4,\"1122\":6,\"1123\":9}}],[\"lhs小于rhs\",{\"1\":{\"535\":1}}],[\"lhs大于rhs\",{\"1\":{\"535\":1}}],[\"lhs等于rhs\",{\"1\":{\"535\":1}}],[\"lrwxrwxrwx\",{\"1\":{\"1271\":2}}],[\"ln\",{\"1\":{\"1270\":1,\"1271\":1,\"1305\":1,\"1332\":1}}],[\"ln命令\",{\"0\":{\"1269\":1}}],[\"l文件类型为l\",{\"1\":{\"1268\":1}}],[\"l显示文件的硬链接数\",{\"1\":{\"1267\":1}}],[\"ls\",{\"1\":{\"1267\":1,\"1268\":1,\"1283\":1}}],[\"lsb\",{\"1\":{\"572\":1}}],[\"lt\",{\"1\":{\"1238\":1}}],[\"l或\",{\"1\":{\"1237\":1}}],[\"lck\",{\"1\":{\"1219\":6,\"1227\":3}}],[\"lcr\",{\"1\":{\"812\":1}}],[\"lpthread\",{\"1\":{\"1030\":1}}],[\"l2\",{\"1\":{\"782\":10,\"783\":10,\"784\":2,\"867\":2}}],[\"l1\",{\"1\":{\"782\":10,\"783\":10,\"784\":2,\"867\":2}}],[\"lu\",{\"1\":{\"515\":2,\"547\":2}}],[\"ldconfig\",{\"1\":{\"1030\":1,\"1332\":3}}],[\"ld\",{\"1\":{\"255\":2,\"1030\":1,\"1299\":4,\"1331\":1,\"1332\":2,\"1335\":1}}],[\"ll=\",{\"1\":{\"1283\":1}}],[\"llog4cpp\",{\"1\":{\"1030\":1}}],[\"ll\",{\"1\":{\"163\":1}}],[\"l\",{\"0\":{\"1934\":1,\"1948\":1},\"1\":{\"96\":1,\"194\":5,\"239\":1,\"249\":1,\"262\":1,\"535\":2,\"547\":2,\"1021\":2,\"1026\":2,\"1245\":1,\"1271\":1,\"1328\":3,\"1331\":2,\"1335\":4,\"1390\":1}}],[\"limit实际应用的优化\",{\"0\":{\"1524\":1}}],[\"limit对于查询的作用\",{\"0\":{\"1522\":1}}],[\"limit只是对select显示条数进行限制了\",{\"0\":{\"1517\":1}}],[\"limit\",{\"0\":{\"1516\":1},\"1\":{\"1516\":4,\"1538\":1,\"1539\":5,\"1740\":4,\"1820\":1}}],[\"limits\",{\"1\":{\"239\":1}}],[\"li4\",{\"1\":{\"1299\":3}}],[\"li3\",{\"1\":{\"1299\":3}}],[\"li2\",{\"1\":{\"1299\":3}}],[\"li1\",{\"1\":{\"1299\":3}}],[\"like等运算符的查询中\",{\"1\":{\"1618\":1}}],[\"like\",{\"1\":{\"1255\":1,\"1334\":1,\"1407\":2,\"1409\":1,\"1471\":1,\"1511\":3,\"1569\":2,\"1574\":1,\"1577\":1,\"1578\":1,\"1603\":1,\"1768\":1,\"1771\":1}}],[\"liuxiang\",{\"1\":{\"1537\":1,\"1563\":1,\"1564\":3}}],[\"liu\",{\"1\":{\"1155\":1,\"1415\":2}}],[\"liufeng\",{\"1\":{\"1041\":1}}],[\"little\",{\"1\":{\"1082\":1}}],[\"lib库的名字\",{\"1\":{\"1855\":1}}],[\"lib的路径\",{\"1\":{\"1855\":1}}],[\"libmecab2\",{\"1\":{\"1397\":1}}],[\"libmysqld\",{\"1\":{\"1397\":1}}],[\"libmysqlclient20\",{\"1\":{\"1397\":1}}],[\"libmysqlclient\",{\"1\":{\"1371\":1,\"1397\":1,\"1399\":1}}],[\"libmylib\",{\"1\":{\"1331\":2,\"1332\":7,\"1335\":1}}],[\"libtinfo5\",{\"1\":{\"1397\":1}}],[\"libtinfo5依赖\",{\"1\":{\"1397\":1}}],[\"libaio1\",{\"1\":{\"1397\":1}}],[\"libaray\",{\"1\":{\"963\":1}}],[\"libname\",{\"1\":{\"1334\":2}}],[\"libraries\",{\"1\":{\"1315\":1,\"1316\":1,\"1322\":1}}],[\"library第\",{\"1\":{\"1315\":1}}],[\"library\",{\"1\":{\"1015\":1,\"1310\":1,\"1315\":2,\"1316\":3,\"1331\":1,\"1335\":2}}],[\"libs\",{\"1\":{\"1310\":1,\"1328\":1,\"1335\":1}}],[\"lib\",{\"0\":{\"1296\":1,\"1315\":1},\"1\":{\"1015\":1,\"1029\":1,\"1030\":1,\"1315\":4,\"1316\":10,\"1332\":3,\"1556\":1,\"1574\":1,\"1580\":1,\"1758\":1,\"1820\":1}}],[\"lib表示程序执行时需要连接的库\",{\"1\":{\"244\":1}}],[\"lisi\",{\"1\":{\"1428\":1,\"1518\":1,\"1902\":1,\"1903\":1,\"1904\":2,\"1907\":1,\"1908\":2}}],[\"lis\",{\"1\":{\"871\":3}}],[\"list|grep\",{\"1\":{\"1405\":3}}],[\"listen\",{\"1\":{\"1238\":1,\"1240\":1,\"1398\":1,\"1820\":2}}],[\"listening\",{\"1\":{\"1237\":1,\"1240\":1}}],[\"listener\",{\"1\":{\"871\":1}}],[\"list<std\",{\"1\":{\"1208\":1,\"1233\":1}}],[\"list<observer\",{\"1\":{\"871\":2}}],[\"list从\",{\"1\":{\"1105\":1}}],[\"list别的地方拿到未分配的内存块后\",{\"1\":{\"1102\":1}}],[\"list挂载的位置\",{\"1\":{\"1102\":1}}],[\"list后\",{\"1\":{\"1102\":1}}],[\"list还没有申请过内存池\",{\"1\":{\"1102\":1}}],[\"list向os申请8字节时备用的内存池进行申请\",{\"1\":{\"1102\":1}}],[\"list数组\",{\"1\":{\"1099\":1}}],[\"list中已经分配内存池的位置\",{\"1\":{\"1102\":1}}],[\"list中从前往后找挂载的空闲内存块\",{\"1\":{\"1102\":1}}],[\"list中不存在比\",{\"1\":{\"1102\":1}}],[\"list中查找一个比\",{\"1\":{\"1102\":1}}],[\"list中对应位置的元素指向一个\",{\"1\":{\"1099\":1}}],[\"list中哪个小的内存池分配的\",{\"1\":{\"1093\":1}}],[\"list下面挂着的下一块空闲的内存块\",{\"1\":{\"1096\":1}}],[\"list下没有挂着空闲的chunk块\",{\"1\":{\"1096\":1}}],[\"list的对应位置\",{\"1\":{\"1105\":1}}],[\"list的对应位置的地址\",{\"1\":{\"1102\":1}}],[\"list的每个元素都是一个指针\",{\"1\":{\"1102\":1}}],[\"list的哪个元素中分配\",{\"1\":{\"1099\":1}}],[\"list的元素直接指向后面的节点\",{\"1\":{\"1096\":1}}],[\"list的元素\",{\"1\":{\"1093\":1}}],[\"list的16个元素初始化为0\",{\"1\":{\"1082\":1}}],[\"list对应的元素\",{\"1\":{\"1093\":1}}],[\"list对比分析\",{\"0\":{\"971\":1}}],[\"list每个元素下面挂的8\",{\"1\":{\"1082\":1}}],[\"list插入不同\",{\"1\":{\"999\":3}}],[\"list特点\",{\"1\":{\"974\":1}}],[\"list容器\",{\"0\":{\"970\":1}}],[\"lists\",{\"0\":{\"1296\":1},\"1\":{\"782\":3,\"783\":7,\"784\":3}}],[\"list2\",{\"1\":{\"762\":2,\"783\":2}}],[\"list1\",{\"1\":{\"762\":2,\"783\":2}}],[\"listnode\",{\"1\":{\"755\":8,\"756\":20,\"759\":12,\"762\":22,\"765\":3,\"768\":7,\"771\":13,\"774\":21,\"777\":11,\"782\":15,\"783\":18,\"784\":13,\"787\":15,\"791\":17,\"795\":16,\"798\":16,\"802\":18,\"806\":4}}],[\"list\",{\"0\":{\"962\":1},\"1\":{\"182\":1,\"755\":1,\"756\":1,\"759\":1,\"762\":1,\"768\":1,\"771\":1,\"774\":4,\"782\":1,\"783\":1,\"784\":1,\"787\":1,\"795\":1,\"798\":1,\"802\":1,\"806\":3,\"817\":16,\"970\":1,\"1082\":3,\"1090\":2,\"1093\":6,\"1096\":8,\"1099\":11,\"1102\":14,\"1284\":3,\"1322\":2,\"1340\":3,\"1362\":2,\"1818\":1,\"1905\":1,\"1909\":2}}],[\"listdir\",{\"1\":{\"60\":1}}],[\"light\",{\"1\":{\"867\":8}}],[\"li\",{\"1\":{\"59\":1,\"1475\":1}}],[\"lielement\",{\"1\":{\"59\":9}}],[\"linfeng\",{\"1\":{\"1537\":1,\"1569\":1}}],[\"linkedlist\",{\"1\":{\"817\":21}}],[\"linked\",{\"1\":{\"755\":1,\"756\":1,\"759\":1,\"762\":1,\"768\":1,\"771\":1,\"774\":1,\"782\":1,\"783\":1,\"784\":1,\"787\":1,\"795\":1,\"798\":1,\"802\":1}}],[\"link修改程序的入口地址\",{\"1\":{\"244\":1}}],[\"link\",{\"1\":{\"51\":1,\"1082\":1,\"1093\":1,\"1096\":1,\"1099\":3,\"1102\":2,\"1271\":6,\"1315\":1,\"1316\":2,\"1322\":1}}],[\"lines\",{\"1\":{\"1729\":1}}],[\"linenum\",{\"1\":{\"1340\":2}}],[\"lineimple\",{\"1\":{\"826\":1}}],[\"lineimpl\",{\"1\":{\"826\":7}}],[\"line\",{\"1\":{\"49\":1,\"50\":5,\"51\":1,\"434\":6,\"476\":1,\"722\":2,\"723\":1,\"826\":12,\"1032\":16,\"1839\":4,\"1845\":1,\"1849\":4,\"1856\":1,\"1875\":4,\"1878\":4}}],[\"linux主机\",{\"1\":{\"1892\":1}}],[\"linux上的文件上传到windows\",{\"1\":{\"1800\":1}}],[\"linux上cmake使用\",{\"0\":{\"1308\":1}}],[\"linux是my\",{\"1\":{\"1750\":1}}],[\"linux平台为\",{\"1\":{\"1372\":1}}],[\"linux环境安装cmake\",{\"0\":{\"1305\":1}}],[\"linux环境下\",{\"0\":{\"1030\":1}}],[\"linux或者手机等设备的ip冲突\",{\"1\":{\"1278\":1}}],[\"linux的文件系统\",{\"1\":{\"1267\":1}}],[\"linux工具和基本命令\",{\"2\":{\"1242\":1,\"1247\":1,\"1258\":1,\"1265\":1,\"1274\":1}}],[\"linux底层使用的也是自己的pthread\",{\"1\":{\"1217\":1}}],[\"linux\",{\"0\":{\"1245\":1},\"1\":{\"303\":1,\"1071\":1,\"1198\":2,\"1201\":1,\"1202\":1,\"1305\":4,\"1332\":1,\"1338\":2,\"1395\":1,\"1849\":1,\"1859\":1,\"1875\":1},\"2\":{\"1144\":1,\"1246\":1,\"1257\":1,\"1264\":1,\"1273\":1,\"1323\":1,\"1336\":1,\"1349\":1,\"1369\":1}}],[\"linux不需要\",{\"1\":{\"293\":1}}],[\"linux下后缀名是\",{\"1\":{\"1855\":1}}],[\"linux下重启mysqld服务的命令\",{\"1\":{\"1769\":1}}],[\"linux下是so\",{\"1\":{\"267\":1}}],[\"linux下rb模式和r模式读取文本文件时\",{\"1\":{\"17\":1}}],[\"linux系统会为当前进程分配一个2^32大小的空间\",{\"1\":{\"267\":1}}],[\"linuxulimit\",{\"1\":{\"239\":1}}],[\"linux文件类型\",{\"1\":{\"17\":1}}],[\"linux操作系统\",{\"0\":{\"15\":1}}],[\"low\",{\"1\":{\"1407\":1}}],[\"lower\",{\"0\":{\"163\":1},\"1\":{\"162\":1,\"163\":3}}],[\"love\",{\"1\":{\"605\":1}}],[\"long类型\",{\"1\":{\"1299\":1}}],[\"long\",{\"1\":{\"162\":6,\"163\":2,\"296\":1,\"330\":3,\"497\":1,\"653\":4,\"669\":3,\"670\":3,\"672\":8,\"678\":8,\"894\":31,\"900\":7,\"1299\":2,\"1374\":1,\"1574\":1,\"1577\":1,\"1578\":2,\"1776\":1,\"1891\":3}}],[\"long>\",{\"1\":{\"162\":1}}],[\"longestlen\",{\"1\":{\"129\":4}}],[\"longestconsecutive\",{\"1\":{\"129\":1}}],[\"loop\",{\"1\":{\"81\":2,\"277\":2}}],[\"locate\",{\"0\":{\"1295\":1}}],[\"location\",{\"1\":{\"286\":25}}],[\"local下\",{\"1\":{\"1800\":1}}],[\"localhost\",{\"1\":{\"1374\":1,\"1383\":1,\"1384\":1,\"1385\":1,\"1407\":1,\"1447\":7,\"1799\":1}}],[\"local\",{\"1\":{\"249\":1,\"312\":1,\"1015\":2,\"1030\":1,\"1332\":1,\"1729\":1,\"1905\":1,\"1909\":2}}],[\"localstorage\",{\"1\":{\"59\":4}}],[\"lock<mutex>\",{\"1\":{\"1849\":4,\"1859\":3,\"1869\":1,\"1870\":1,\"1872\":2,\"1875\":1}}],[\"lock<std\",{\"1\":{\"848\":2,\"849\":1,\"1219\":2,\"1226\":1,\"1227\":1}}],[\"lock对比\",{\"0\":{\"1228\":1}}],[\"lock做的事情是一样的\",{\"1\":{\"1220\":1,\"1228\":1}}],[\"lock可以看成unique\",{\"1\":{\"1220\":1,\"1228\":1}}],[\"lock源码\",{\"0\":{\"1212\":1},\"1\":{\"1220\":1}}],[\"locks\",{\"1\":{\"239\":1,\"1719\":1,\"1720\":1}}],[\"locked\",{\"1\":{\"239\":1}}],[\"lock\",{\"0\":{\"1210\":1,\"1211\":1,\"1220\":2,\"1224\":1,\"1226\":1,\"1227\":1,\"1228\":1,\"1296\":2},\"1\":{\"59\":1,\"848\":2,\"849\":1,\"1050\":1,\"1057\":1,\"1093\":2,\"1096\":8,\"1202\":2,\"1209\":3,\"1210\":4,\"1212\":1,\"1219\":4,\"1220\":3,\"1225\":1,\"1226\":1,\"1227\":2,\"1228\":2,\"1232\":2,\"1656\":1,\"1665\":1,\"1671\":2,\"1686\":6,\"1693\":1,\"1698\":1,\"1717\":3,\"1719\":6,\"1848\":1,\"1849\":6,\"1859\":6,\"1863\":1,\"1869\":2,\"1870\":1,\"1871\":1,\"1872\":3,\"1875\":3}}],[\"login登录请求对象\",{\"1\":{\"1915\":1}}],[\"loginresponse\",{\"1\":{\"1915\":1}}],[\"loginrequest\",{\"1\":{\"1915\":4}}],[\"logic\",{\"1\":{\"604\":1}}],[\"log里把drop\",{\"1\":{\"1830\":1}}],[\"log里面\",{\"1\":{\"1761\":2}}],[\"log里面记录的数据\",{\"1\":{\"1760\":1}}],[\"log复制到其中继日志\",{\"1\":{\"1784\":1}}],[\"log完成\",{\"1\":{\"1775\":2}}],[\"log完整的写到磁盘上\",{\"1\":{\"1763\":1}}],[\"log完整记录到磁盘上\",{\"1\":{\"1763\":1}}],[\"logs\",{\"1\":{\"1772\":2,\"1800\":1,\"1805\":1,\"1806\":1}}],[\"log开关\",{\"1\":{\"1771\":1}}],[\"log重做日志来恢复事务成功commit的数据状态\",{\"1\":{\"1763\":1}}],[\"log重新回滚\",{\"1\":{\"1761\":1}}],[\"log重新执行这一事务的sql\",{\"1\":{\"1757\":1}}],[\"log失败\",{\"1\":{\"1763\":1}}],[\"log后才算是事务提交成功\",{\"1\":{\"1763\":1}}],[\"log可以用来恢复数据到事务提交时的状态\",{\"1\":{\"1762\":1}}],[\"log文件中\",{\"1\":{\"1762\":1}}],[\"log首先被写入log\",{\"1\":{\"1762\":1}}],[\"log保存完整\",{\"1\":{\"1762\":1}}],[\"log保证的\",{\"1\":{\"1650\":1}}],[\"log从log\",{\"1\":{\"1762\":1}}],[\"log要记录在redo\",{\"1\":{\"1761\":1}}],[\"log要写成功\",{\"1\":{\"1760\":1}}],[\"log支持事务回滚\",{\"1\":{\"1761\":1}}],[\"log本身也是记录在redo\",{\"0\":{\"1761\":1}}],[\"log写成功\",{\"1\":{\"1759\":1}}],[\"log在写入磁盘的过程中也有可能发生异常\",{\"1\":{\"1759\":1}}],[\"log会记录状态为commit\",{\"1\":{\"1759\":1}}],[\"logfile1\",{\"1\":{\"1758\":1}}],[\"logfile0\",{\"1\":{\"1758\":1}}],[\"log缓存\",{\"1\":{\"1758\":1}}],[\"log缓冲区的大小\",{\"1\":{\"1758\":1}}],[\"log恢复到掉电前的时刻\",{\"1\":{\"1758\":1}}],[\"log还没写\",{\"1\":{\"1758\":1}}],[\"log是在事务begin时就开始记录\",{\"1\":{\"1758\":1}}],[\"log是一个global的变量\",{\"1\":{\"1577\":1}}],[\"log默认放在\",{\"1\":{\"1758\":1}}],[\"log将数据重新写入磁盘\",{\"1\":{\"1758\":1}}],[\"log概念\",{\"0\":{\"1758\":1}}],[\"log把数据恢复到事务执行前的状态\",{\"1\":{\"1757\":1}}],[\"log举例\",{\"0\":{\"1682\":1}}],[\"log中读取事件\",{\"1\":{\"1784\":1}}],[\"log中对应为null\",{\"1\":{\"1682\":1}}],[\"log中\",{\"0\":{\"1761\":1},\"1\":{\"1681\":1,\"1682\":1,\"1758\":1,\"1762\":1}}],[\"log实现\",{\"1\":{\"1680\":1,\"1757\":1}}],[\"log的存在\",{\"1\":{\"1762\":1}}],[\"log的写入\",{\"1\":{\"1762\":1}}],[\"log的时候没有写完\",{\"1\":{\"1759\":1}}],[\"log的效率就高了\",{\"1\":{\"1748\":1}}],[\"log的指针\",{\"1\":{\"1682\":1}}],[\"log的数据结构如下\",{\"1\":{\"1681\":2}}],[\"log的数据结构\",{\"0\":{\"1681\":1}}],[\"log的作用\",{\"0\":{\"1680\":1},\"1\":{\"1783\":1}}],[\"log的概念\",{\"0\":{\"1679\":1}}],[\"log统称事务日志\",{\"1\":{\"1679\":1}}],[\"log和redo\",{\"1\":{\"1679\":1,\"1757\":1}}],[\"log和undo\",{\"1\":{\"1645\":1,\"1650\":1}}],[\"log回滚日志当中\",{\"1\":{\"1681\":1}}],[\"log回滚日志的主要作用\",{\"1\":{\"1680\":1}}],[\"log回滚日志的链表指向的旧数据\",{\"1\":{\"1658\":1}}],[\"log回滚日志\",{\"1\":{\"1677\":1}}],[\"log机制保证\",{\"1\":{\"1645\":1}}],[\"log500大约需要3次io就可以\",{\"1\":{\"1622\":1}}],[\"log2\",{\"1\":{\"1622\":1}}],[\"log102=logn\",{\"1\":{\"1622\":1}}],[\"log=on\",{\"1\":{\"1577\":1}}],[\"log`\",{\"1\":{\"1253\":1}}],[\"loggercmake\",{\"1\":{\"1322\":1}}],[\"logger\",{\"1\":{\"1032\":32,\"1322\":3}}],[\"log4test\",{\"1\":{\"1030\":1}}],[\"log4cpp主要提供如下几个类来简化代码设置\",{\"1\":{\"1026\":1}}],[\"log4cpp记录日志的原理\",{\"0\":{\"1024\":1}}],[\"log4cpptest\",{\"1\":{\"1019\":2}}],[\"log4cpp从大的结构上分为\",{\"1\":{\"1017\":1}}],[\"log4cpp基本结构\",{\"0\":{\"1017\":1}}],[\"log4cpp\",{\"1\":{\"1015\":2,\"1018\":4,\"1019\":8,\"1020\":6,\"1021\":2,\"1025\":1,\"1026\":13,\"1031\":1,\"1032\":5,\"1322\":1}}],[\"log4cpp的主页为\",{\"1\":{\"1015\":1}}],[\"log4cpp开发文档\",{\"1\":{\"1014\":1}}],[\"log4cpp库的使用\",{\"0\":{\"1014\":1}}],[\"logtest\",{\"1\":{\"1026\":1}}],[\"logn\",{\"1\":{\"100\":1,\"195\":1,\"202\":1,\"1601\":1,\"1622\":1,\"1623\":2}}],[\"log\",{\"0\":{\"1576\":1,\"1577\":1,\"1676\":1,\"1677\":1,\"1678\":1,\"1748\":1,\"1757\":1,\"1811\":1},\"1\":{\"59\":9,\"126\":2,\"1015\":1,\"1019\":1,\"1026\":4,\"1031\":17,\"1032\":9,\"1253\":1,\"1411\":3,\"1573\":1,\"1622\":2,\"1645\":2,\"1656\":1,\"1677\":4,\"1679\":2,\"1681\":4,\"1682\":4,\"1729\":1,\"1757\":2,\"1758\":11,\"1759\":1,\"1763\":1,\"1768\":1,\"1769\":1,\"1776\":1,\"1783\":2,\"1784\":1,\"1800\":2,\"1805\":1,\"1806\":1,\"1810\":1,\"1811\":1,\"1812\":2,\"1813\":2,\"1814\":2,\"1825\":4,\"1829\":2,\"1830\":1,\"1839\":1,\"1845\":1,\"1847\":2,\"1849\":2,\"1856\":4,\"1859\":1,\"1869\":1,\"1871\":1,\"1872\":1,\"1875\":1,\"1878\":2,\"1881\":2}}],[\"loadconfigfile\",{\"1\":{\"1839\":3,\"1848\":1,\"1849\":2,\"1859\":1,\"1875\":3,\"1878\":2}}],[\"loaded\",{\"1\":{\"1820\":2}}],[\"load\",{\"1\":{\"54\":1,\"59\":3,\"1729\":1,\"1848\":2,\"1875\":2}}],[\"leak\",{\"1\":{\"531\":1,\"1035\":1}}],[\"leave\",{\"1\":{\"234\":2}}],[\"len过长\",{\"1\":{\"1615\":1}}],[\"lenght指定前多少个字符建立索引\",{\"1\":{\"1614\":1}}],[\"length=4\",{\"1\":{\"1407\":1}}],[\"length\",{\"1\":{\"59\":7,\"60\":1,\"140\":1,\"161\":2,\"170\":2,\"536\":1,\"540\":1,\"547\":1,\"604\":1,\"699\":2,\"736\":2,\"787\":1,\"898\":5,\"1240\":1,\"1407\":2,\"1614\":1,\"1736\":2}}],[\"lenb\",{\"1\":{\"771\":3}}],[\"lena\",{\"1\":{\"771\":3}}],[\"len3\",{\"1\":{\"547\":4}}],[\"len2\",{\"1\":{\"535\":1,\"547\":9}}],[\"len1\",{\"1\":{\"535\":1,\"547\":7}}],[\"len\",{\"1\":{\"70\":2,\"91\":1,\"188\":3,\"194\":5,\"217\":3,\"355\":4,\"385\":4,\"547\":3,\"704\":4,\"782\":3,\"783\":3,\"787\":2,\"1001\":6,\"1127\":9,\"1521\":1}}],[\"leetcode707\",{\"1\":{\"822\":1}}],[\"leetcode23\",{\"1\":{\"783\":1}}],[\"leetcode206\",{\"1\":{\"756\":1}}],[\"leetcode876\",{\"1\":{\"756\":1}}],[\"leetcode344\",{\"1\":{\"67\":1}}],[\"leetcode\",{\"0\":{\"67\":1,\"70\":1,\"73\":1,\"76\":1,\"81\":1,\"84\":1,\"87\":1,\"124\":1,\"129\":1,\"132\":1,\"140\":1,\"146\":1,\"152\":1,\"158\":1,\"161\":1,\"166\":1,\"169\":1,\"174\":1,\"177\":1,\"182\":1,\"754\":1,\"759\":1,\"762\":1,\"765\":1,\"768\":1,\"771\":1,\"774\":1,\"777\":1,\"780\":1,\"787\":1,\"790\":1,\"795\":1,\"798\":1,\"801\":1},\"1\":{\"70\":1,\"73\":1,\"76\":1,\"81\":2,\"84\":1,\"87\":1,\"110\":1,\"146\":1,\"152\":1,\"158\":1,\"161\":1,\"177\":1,\"182\":1,\"202\":2,\"754\":1,\"759\":1,\"765\":1,\"768\":1,\"771\":1,\"774\":1,\"777\":1,\"780\":1,\"787\":1,\"790\":1,\"795\":1,\"798\":1,\"801\":1}}],[\"let\",{\"1\":{\"59\":2}}],[\"letter++\",{\"1\":{\"11\":1}}],[\"letter\",{\"1\":{\"11\":2}}],[\"leftover\",{\"1\":{\"1102\":1}}],[\"left大小的空间在自由链表的位置\",{\"1\":{\"1102\":1}}],[\"leftnode\",{\"1\":{\"802\":3}}],[\"leftbound\",{\"1\":{\"162\":2}}],[\"left<=right\",{\"1\":{\"96\":1}}],[\"left<right\",{\"1\":{\"96\":1,\"97\":1}}],[\"left遇到用于新数组的值\",{\"1\":{\"78\":1}}],[\"left表示新数组下标\",{\"1\":{\"78\":1}}],[\"left++\",{\"1\":{\"67\":1,\"70\":2,\"78\":1,\"87\":1,\"126\":1,\"133\":3,\"136\":3}}],[\"left\",{\"1\":{\"51\":13,\"67\":2,\"70\":7,\"73\":1,\"78\":9,\"84\":5,\"87\":5,\"96\":17,\"97\":9,\"126\":4,\"133\":8,\"135\":1,\"136\":17,\"142\":7,\"143\":10,\"202\":11,\"220\":13,\"783\":7,\"801\":3,\"802\":8,\"900\":1,\"1102\":7,\"1148\":1,\"1500\":1,\"1543\":1,\"1544\":1}}],[\"less<int>\",{\"1\":{\"1008\":1,\"1148\":1}}],[\"less<\",{\"1\":{\"985\":1}}],[\"less<typename\",{\"1\":{\"984\":1}}],[\"less\",{\"1\":{\"0\":1,\"1008\":1,\"1148\":2}}],[\"latch阻塞\",{\"1\":{\"1569\":1}}],[\"latin1特点为\",{\"1\":{\"1552\":1}}],[\"late\",{\"1\":{\"883\":1}}],[\"lamda表达式对象的类型如何确定\",{\"1\":{\"1060\":1}}],[\"lambda应用\",{\"0\":{\"1176\":1}}],[\"lambda表达式的应用实践\",{\"0\":{\"1180\":1}}],[\"lambda表达式对应函数对象小括号重载函数的\",{\"1\":{\"1173\":1}}],[\"lambda表达式语法\",{\"0\":{\"1172\":1}}],[\"lambda表达式原理\",{\"1\":{\"1171\":1}}],[\"lambda表达式实际上都是函数对象\",{\"1\":{\"1161\":1}}],[\"lambda表达式也就是一个临时的函数对象\",{\"1\":{\"1060\":1}}],[\"lambda表达式方法\",{\"1\":{\"1060\":1}}],[\"lambda表达式\",{\"0\":{\"1171\":1},\"1\":{\"1007\":1,\"1008\":1,\"1161\":1,\"1171\":1,\"1180\":1,\"1195\":1,\"1863\":1}}],[\"lambda\",{\"1\":{\"784\":1,\"1060\":2},\"2\":{\"1062\":1,\"1185\":1}}],[\"lambda的结合使用\",{\"1\":{\"784\":1}}],[\"last移动到第二行开始部分\",{\"1\":{\"968\":1}}],[\"last指针\",{\"1\":{\"385\":1,\"704\":1,\"747\":1,\"1087\":1}}],[\"last指针指向的内存构造一个值为val的对象\",{\"1\":{\"385\":1,\"704\":1,\"1087\":1}}],[\"last++\",{\"1\":{\"355\":1,\"385\":2,\"704\":2,\"747\":1,\"1087\":2,\"1127\":5}}],[\"last\",{\"1\":{\"286\":6,\"355\":13,\"385\":19,\"537\":2,\"541\":1,\"543\":1,\"704\":20,\"747\":13,\"1087\":4,\"1127\":15,\"1148\":3,\"1240\":1,\"1828\":1}}],[\"layout=patternlayout\",{\"1\":{\"1026\":2}}],[\"layout是加载到appender中去的\",{\"1\":{\"1021\":1}}],[\"layout\",{\"0\":{\"1021\":1},\"1\":{\"261\":1,\"1021\":1,\"1026\":2}}],[\"languages\",{\"1\":{\"1548\":1}}],[\"language\",{\"0\":{\"1548\":1},\"1\":{\"61\":1,\"1548\":2}}],[\"label\",{\"1\":{\"51\":5}}],[\"lazyphp\",{\"1\":{\"0\":1}}],[\"lavarel\",{\"1\":{\"0\":1}}],[\"g查看是否需要关闭ahi\",{\"1\":{\"1569\":1}}],[\"g编译代码\",{\"1\":{\"1338\":1}}],[\"group\",{\"0\":{\"1527\":1},\"1\":{\"1497\":1,\"1526\":3,\"1531\":1,\"1538\":6,\"1737\":1,\"1758\":1}}],[\"groups\",{\"1\":{\"1237\":1}}],[\"grant\",{\"1\":{\"1408\":2,\"1447\":4,\"1485\":1,\"1548\":1,\"1799\":2,\"1821\":1,\"1828\":1}}],[\"grep\",{\"1\":{\"1238\":4,\"1296\":1,\"1390\":1,\"1398\":1,\"1820\":1}}],[\"greater是一个二元函数对象\",{\"1\":{\"1147\":1}}],[\"greater\",{\"1\":{\"1008\":1,\"1147\":1,\"1148\":4}}],[\"greater<int>>\",{\"1\":{\"984\":1,\"985\":1}}],[\"greater<int>\",{\"1\":{\"163\":2,\"1007\":1,\"1008\":1,\"1147\":1,\"1148\":3}}],[\"greater<type>\",{\"1\":{\"163\":2}}],[\"green\",{\"1\":{\"29\":1}}],[\"g或\",{\"1\":{\"1237\":1}}],[\"gaoyang\",{\"1\":{\"1537\":1,\"1569\":1}}],[\"gard互斥锁解决的\",{\"1\":{\"1232\":1}}],[\"gard源码\",{\"1\":{\"1220\":1}}],[\"gard和unique\",{\"0\":{\"1220\":1,\"1228\":1},\"1\":{\"1220\":2,\"1228\":2}}],[\"gard将拷贝构造和赋值重载都delete了\",{\"1\":{\"1219\":1,\"1227\":1}}],[\"gard\",{\"0\":{\"1208\":1}}],[\"gap\",{\"1\":{\"199\":12,\"1686\":4,\"1719\":2}}],[\"guan\",{\"1\":{\"1851\":2,\"1856\":1,\"1878\":1}}],[\"guard和unique\",{\"0\":{\"1224\":1}}],[\"guard<std\",{\"1\":{\"1210\":1,\"1219\":3,\"1232\":2}}],[\"guard析构函数直接解锁\",{\"1\":{\"1210\":1}}],[\"guard构造函数直接加锁\",{\"1\":{\"1210\":1}}],[\"guard\",{\"0\":{\"1210\":1,\"1226\":1},\"1\":{\"1202\":1,\"1219\":4,\"1226\":2,\"1232\":2}}],[\"gulp\",{\"1\":{\"0\":1}}],[\"gc\",{\"1\":{\"1142\":1}}],[\"gcc\",{\"0\":{\"1325\":1,\"1333\":1},\"1\":{\"500\":1,\"501\":1,\"568\":1,\"570\":1,\"1016\":4,\"1280\":1,\"1326\":1,\"1327\":1,\"1328\":1,\"1329\":1,\"1330\":1,\"1331\":2,\"1332\":1,\"1335\":3,\"1356\":1,\"1365\":1,\"1366\":1}}],[\"gcc编译环境下\",{\"1\":{\"312\":2}}],[\"gt\",{\"1\":{\"1137\":2}}],[\"gb2312\",{\"1\":{\"1133\":1,\"1291\":1}}],[\"gbk\",{\"1\":{\"1133\":1,\"1291\":1}}],[\"gb18030\",{\"1\":{\"1133\":1,\"1291\":1}}],[\"gnu\",{\"1\":{\"1341\":1}}],[\"gnuc\",{\"1\":{\"1082\":1}}],[\"gnumber\",{\"1\":{\"616\":1}}],[\"gz解压\",{\"1\":{\"1285\":1}}],[\"gz的文件进行解压\",{\"1\":{\"1261\":1}}],[\"gz的压缩文件\",{\"1\":{\"1261\":1}}],[\"gzip\",{\"1\":{\"1261\":3,\"1263\":1}}],[\"gzip用来将文件压缩成后缀为\",{\"1\":{\"1261\":1}}],[\"gzip和bzip的介绍\",{\"0\":{\"1261\":1}}],[\"gz拖入用户主目录\",{\"1\":{\"1015\":1}}],[\"gz\",{\"1\":{\"1015\":1,\"1260\":3,\"1261\":2,\"1263\":2,\"1305\":2}}],[\"g1\",{\"1\":{\"889\":2}}],[\"gg=g\",{\"1\":{\"1142\":1}}],[\"gg\",{\"1\":{\"557\":3}}],[\"glob\",{\"1\":{\"1312\":1}}],[\"global\",{\"1\":{\"249\":1,\"572\":2,\"1407\":2,\"1409\":1,\"1577\":1,\"1771\":1,\"1830\":1}}],[\"glibc里面定义\",{\"1\":{\"283\":1}}],[\"go\",{\"1\":{\"1913\":1}}],[\"google\",{\"1\":{\"1913\":1}}],[\"good\",{\"1\":{\"1902\":1,\"1903\":1,\"1904\":4,\"1907\":1,\"1908\":2}}],[\"goods\",{\"1\":{\"449\":1}}],[\"goodman\",{\"1\":{\"0\":1}}],[\"goto\",{\"1\":{\"277\":1,\"296\":1}}],[\"g在\",{\"1\":{\"267\":1}}],[\"gdata\",{\"1\":{\"246\":5}}],[\"gdb都会显示\",{\"1\":{\"1346\":1}}],[\"gdb都会计算并显示\",{\"1\":{\"1345\":1}}],[\"gdb都会自动显示\",{\"1\":{\"1342\":1}}],[\"gdb会为每个显示的表达式分配一个编号\",{\"1\":{\"1341\":1}}],[\"gdb调试出错的程序\",{\"0\":{\"1338\":1}}],[\"gdb查看汇编\",{\"0\":{\"261\":1}}],[\"gdb\",{\"0\":{\"1339\":1,\"1340\":1},\"1\":{\"234\":7,\"261\":2,\"1338\":1,\"1342\":1,\"1343\":1,\"1344\":1,\"1345\":1,\"1346\":1,\"1348\":5}}],[\"g++下定义的空结构体大小为1\",{\"1\":{\"1072\":1}}],[\"g++只做前3步\",{\"1\":{\"908\":1}}],[\"g++只负责开辟栈帧不进行初始化\",{\"1\":{\"500\":1}}],[\"g++不会报错\",{\"1\":{\"578\":1}}],[\"g++\",{\"0\":{\"1325\":1},\"1\":{\"234\":3,\"244\":1,\"247\":2,\"253\":1,\"260\":1,\"516\":1,\"567\":1,\"568\":3,\"569\":1,\"1016\":4,\"1030\":1,\"1280\":1,\"1326\":1,\"1327\":1,\"1356\":1}}],[\"gpu\",{\"1\":{\"63\":1}}],[\"g\",{\"0\":{\"1939\":1},\"1\":{\"59\":1,\"60\":2,\"214\":2,\"234\":4,\"249\":1,\"253\":1,\"260\":2,\"502\":1,\"516\":1,\"614\":1,\"621\":1,\"851\":6,\"889\":6,\"894\":4,\"1035\":1,\"1082\":1,\"1141\":1,\"1317\":1,\"1327\":3,\"1347\":1,\"1551\":1,\"1569\":1,\"1600\":1,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1719\":1,\"1720\":1,\"1747\":1,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1}}],[\"genera\",{\"1\":{\"1771\":1}}],[\"generator\",{\"1\":{\"1310\":1}}],[\"generatematrix\",{\"1\":{\"81\":1}}],[\"gender\",{\"1\":{\"1428\":2}}],[\"gecko\",{\"1\":{\"1255\":1}}],[\"getconnection\",{\"1\":{\"1848\":1,\"1849\":1,\"1859\":2,\"1869\":1,\"1872\":1,\"1875\":2}}],[\"getconnectionpool\",{\"1\":{\"1839\":2,\"1848\":1,\"1849\":1,\"1851\":2,\"1859\":1,\"1875\":2,\"1878\":5}}],[\"getchar\",{\"1\":{\"8\":1,\"11\":1}}],[\"getobject作用域\",{\"1\":{\"1115\":1}}],[\"getobject函数完成调用时\",{\"1\":{\"1115\":1}}],[\"getobject\",{\"1\":{\"1115\":2,\"1116\":3}}],[\"getdata\",{\"1\":{\"1115\":2,\"1116\":1}}],[\"get字节\",{\"1\":{\"1102\":1}}],[\"get字节内存失败\",{\"1\":{\"1102\":1}}],[\"get个字节\",{\"1\":{\"1102\":1}}],[\"getroot\",{\"1\":{\"1018\":1,\"1020\":1,\"1031\":3,\"1032\":1}}],[\"getrear\",{\"1\":{\"185\":2}}],[\"getmilespergallon\",{\"1\":{\"900\":4}}],[\"getleftmiles\",{\"1\":{\"900\":2}}],[\"getstring\",{\"1\":{\"1120\":2,\"1123\":1}}],[\"getsmartptr<int>\",{\"1\":{\"1047\":1}}],[\"getsmartptr\",{\"1\":{\"1047\":1}}],[\"getsingleton\",{\"1\":{\"849\":2,\"852\":2}}],[\"getsum\",{\"1\":{\"148\":5,\"149\":2}}],[\"getheapdata\",{\"1\":{\"618\":3}}],[\"getname\",{\"1\":{\"449\":2,\"900\":2}}],[\"getprice\",{\"1\":{\"426\":2}}],[\"getparentdirectory\",{\"1\":{\"60\":3}}],[\"get\",{\"0\":{\"1296\":2},\"1\":{\"234\":3,\"422\":1,\"790\":1,\"791\":1,\"792\":1,\"1016\":2,\"1020\":1,\"1102\":6,\"1207\":1,\"1219\":2,\"1296\":1,\"1395\":1,\"1397\":6,\"1405\":3}}],[\"gettestdate2\",{\"1\":{\"191\":1}}],[\"gettestdate\",{\"1\":{\"188\":2,\"191\":2}}],[\"getfront\",{\"1\":{\"185\":2}}],[\"getfilename\",{\"1\":{\"60\":3}}],[\"getinstance的方法都加锁\",{\"1\":{\"848\":1}}],[\"getinstance\",{\"1\":{\"848\":2,\"850\":2,\"851\":2,\"854\":1,\"855\":1,\"856\":2,\"857\":2,\"1018\":1,\"1031\":1,\"1032\":4}}],[\"getindex\",{\"1\":{\"618\":6}}],[\"getintersectionnode\",{\"1\":{\"771\":2}}],[\"getintersection2\",{\"1\":{\"107\":3,\"110\":2}}],[\"getintersection\",{\"1\":{\"107\":1,\"110\":2}}],[\"getintersection3\",{\"1\":{\"104\":3,\"107\":2,\"110\":2}}],[\"getitem\",{\"1\":{\"59\":2}}],[\"getalivetime\",{\"1\":{\"1846\":1,\"1859\":1}}],[\"getallfiles\",{\"1\":{\"60\":2}}],[\"getallpicfiles\",{\"1\":{\"60\":2}}],[\"getabsolutepath\",{\"1\":{\"60\":2}}],[\"getattribute\",{\"1\":{\"59\":2}}],[\"getusedpicnames\",{\"1\":{\"60\":2}}],[\"getelementbyid\",{\"1\":{\"59\":1}}],[\"getelementsbyname\",{\"1\":{\"59\":1}}],[\"getelementsbyclassname\",{\"1\":{\"54\":2,\"59\":3}}],[\"getelementsbytagname\",{\"1\":{\"54\":1,\"59\":3}}],[\"georgia\",{\"1\":{\"49\":1}}],[\"gmail\",{\"1\":{\"0\":1}}],[\"gitee\",{\"1\":{\"110\":2,\"496\":2,\"673\":1,\"678\":2,\"692\":2,\"707\":2,\"965\":2,\"1063\":2,\"1121\":2,\"1287\":1,\"1610\":2,\"1747\":2}}],[\"git\",{\"1\":{\"0\":1,\"1132\":2,\"1280\":1,\"1287\":3,\"1290\":2}}],[\"githubfast\",{\"1\":{\"5\":1}}],[\"github\",{\"1\":{\"0\":2,\"5\":1,\"750\":2,\"1087\":2,\"1132\":1,\"1143\":1,\"1290\":1}}],[\"egbfv\",{\"1\":{\"1821\":3}}],[\"e9dcd78f6d444a1d869a00b6bac9028f\",{\"1\":{\"1758\":1}}],[\"eq\",{\"1\":{\"1521\":1}}],[\"epoll比select性能好\",{\"0\":{\"1455\":1}}],[\"echo\",{\"1\":{\"1357\":2,\"1362\":2}}],[\"ecx\",{\"1\":{\"638\":4,\"906\":2,\"954\":2}}],[\"eth0\",{\"1\":{\"1238\":1}}],[\"etc\",{\"1\":{\"239\":1,\"1030\":1,\"1284\":3,\"1331\":1,\"1332\":2,\"1408\":1,\"1410\":1,\"1555\":1,\"1769\":1,\"1772\":1,\"1776\":1,\"1820\":2}}],[\"e或\",{\"1\":{\"1237\":1}}],[\"e打开配置文件my\",{\"1\":{\"1135\":1}}],[\"either\",{\"1\":{\"1102\":1}}],[\"eventually\",{\"1\":{\"1102\":1}}],[\"everylength\",{\"1\":{\"59\":2}}],[\"ee\",{\"1\":{\"557\":1}}],[\"effective\",{\"1\":{\"503\":1}}],[\"e3\",{\"1\":{\"468\":4}}],[\"e2\",{\"1\":{\"468\":4}}],[\"e1\",{\"1\":{\"468\":4}}],[\"e后面只能写整数\",{\"1\":{\"338\":1}}],[\"e在\",{\"1\":{\"267\":1}}],[\"e=0\",{\"1\":{\"267\":1}}],[\"established\",{\"1\":{\"1240\":2}}],[\"esc\",{\"1\":{\"1136\":1}}],[\"esi\",{\"1\":{\"235\":1}}],[\"esi和edi\",{\"1\":{\"235\":1}}],[\"esp<\",{\"1\":{\"908\":2}}],[\"esp=ebp\",{\"1\":{\"234\":1}}],[\"esp从main函数栈顶\",{\"1\":{\"234\":1}}],[\"esp是可变的\",{\"1\":{\"233\":1}}],[\"esp\",{\"1\":{\"233\":3,\"234\":6,\"235\":3,\"236\":1,\"238\":1,\"267\":1,\"908\":3}}],[\"esp和ebp\",{\"0\":{\"233\":1}}],[\"eb0bab49501445e3aaf1c8251a48515e\",{\"1\":{\"1776\":1}}],[\"ebx\",{\"1\":{\"235\":2}}],[\"ebp指向当前函数栈底\",{\"1\":{\"908\":1}}],[\"ebp+8字节找到a的值\",{\"1\":{\"238\":1}}],[\"ebp+0xc\",{\"1\":{\"234\":1}}],[\"ebp+0x8\",{\"1\":{\"234\":1}}],[\"ebp\",{\"1\":{\"233\":3,\"234\":15,\"235\":2,\"236\":5,\"238\":2,\"638\":3,\"908\":3}}],[\"edu\",{\"1\":{\"1284\":6}}],[\"edata+30k只是完成虚拟地址的分配\",{\"1\":{\"283\":1}}],[\"edata+30k就完成内存分配了\",{\"1\":{\"283\":1}}],[\"edata指针了\",{\"1\":{\"284\":1}}],[\"edata指针\",{\"1\":{\"283\":1}}],[\"edata\",{\"1\":{\"281\":1}}],[\"edi\",{\"1\":{\"235\":1}}],[\"editor\",{\"1\":{\"44\":1}}],[\"edx\",{\"1\":{\"234\":2}}],[\"each可以遍历容器的所有元素\",{\"1\":{\"1007\":1}}],[\"each\",{\"0\":{\"1179\":1},\"1\":{\"965\":1,\"1007\":3,\"1179\":1,\"1194\":1}}],[\"early\",{\"1\":{\"883\":1}}],[\"ealign\",{\"1\":{\"271\":1}}],[\"eax\",{\"1\":{\"234\":8,\"236\":1,\"238\":1,\"638\":2,\"906\":2,\"954\":2}}],[\"easychen\",{\"1\":{\"0\":1}}],[\"errcode\",{\"1\":{\"1915\":1}}],[\"errcpde\",{\"1\":{\"1915\":1}}],[\"errmsg\",{\"1\":{\"1915\":2}}],[\"erro\",{\"1\":{\"1411\":1}}],[\"error的路径\",{\"1\":{\"1769\":1}}],[\"error的路径就是开启了log\",{\"1\":{\"1769\":1}}],[\"error是一个标准的异常处理\",{\"1\":{\"600\":1}}],[\"error类类型的异常类型\",{\"1\":{\"600\":1}}],[\"error\",{\"1\":{\"182\":1,\"217\":1,\"234\":1,\"370\":1,\"426\":1,\"432\":2,\"433\":1,\"439\":1,\"440\":1,\"459\":1,\"476\":1,\"480\":2,\"483\":1,\"485\":1,\"488\":2,\"490\":1,\"491\":4,\"492\":4,\"497\":5,\"516\":1,\"535\":2,\"547\":2,\"563\":1,\"588\":2,\"600\":2,\"604\":7,\"605\":2,\"606\":4,\"621\":2,\"625\":2,\"629\":1,\"630\":1,\"633\":1,\"639\":2,\"640\":1,\"652\":1,\"653\":1,\"670\":1,\"678\":3,\"717\":1,\"718\":1,\"736\":1,\"900\":1,\"1018\":7,\"1020\":2,\"1025\":2,\"1031\":9,\"1032\":12,\"1260\":1,\"1299\":1,\"1318\":2,\"1382\":1,\"1383\":1,\"1384\":3,\"1385\":4,\"1407\":1,\"1411\":1,\"1769\":1,\"1770\":1}}],[\"errno\",{\"1\":{\"1382\":1,\"1828\":2}}],[\"err\",{\"1\":{\"605\":2,\"1383\":1,\"1384\":3,\"1385\":4,\"1770\":1}}],[\"erase时加上break时候\",{\"1\":{\"742\":1}}],[\"erase\",{\"1\":{\"101\":10,\"162\":2,\"543\":3,\"741\":1,\"742\":2,\"745\":2,\"747\":5,\"966\":2,\"999\":5,\"1000\":1,\"1002\":2}}],[\"engine\",{\"1\":{\"1569\":2,\"1747\":1}}],[\"engines\",{\"1\":{\"1555\":1,\"1651\":1}}],[\"engine=innodb\",{\"1\":{\"1551\":1}}],[\"enabled\",{\"1\":{\"1820\":2}}],[\"enable\",{\"1\":{\"1318\":1,\"1818\":1}}],[\"environment\",{\"1\":{\"1306\":1}}],[\"en\",{\"1\":{\"1255\":1}}],[\"enum枚举只能取其中一个数据类型\",{\"1\":{\"1428\":1}}],[\"enum和set\",{\"0\":{\"1428\":1}}],[\"enums\",{\"1\":{\"503\":1}}],[\"enum\",{\"1\":{\"296\":1,\"736\":1,\"864\":1,\"1025\":1,\"1082\":3,\"1096\":1,\"1428\":1,\"1437\":1,\"1537\":1,\"1551\":1,\"1614\":4}}],[\"entry\",{\"1\":{\"255\":1,\"260\":1}}],[\"enter\",{\"1\":{\"251\":1}}],[\"encoding=\",{\"1\":{\"60\":1}}],[\"endidx\",{\"1\":{\"1839\":2,\"1849\":2,\"1875\":2,\"1878\":2}}],[\"endif\",{\"1\":{\"188\":1,\"194\":1,\"199\":1,\"205\":1,\"217\":1,\"220\":1,\"244\":1,\"439\":1,\"504\":1,\"506\":1,\"526\":1,\"547\":1,\"548\":1,\"557\":1,\"570\":2,\"571\":2,\"577\":3,\"578\":1,\"594\":2,\"618\":2,\"642\":2,\"817\":1,\"1079\":2,\"1082\":1,\"1093\":1,\"1096\":1,\"1102\":1,\"1158\":1,\"1318\":1,\"1320\":1,\"1321\":1,\"1839\":1,\"1845\":1,\"1846\":1,\"1848\":2,\"1849\":1,\"1856\":2,\"1859\":2,\"1875\":3,\"1878\":1}}],[\"end$\",{\"1\":{\"1523\":1}}],[\"endstr\",{\"1\":{\"1299\":1}}],[\"endswith\",{\"1\":{\"60\":4}}],[\"endptr\",{\"1\":{\"1299\":1}}],[\"end之间元素默认小到大排序\",{\"1\":{\"1007\":2}}],[\"endkl\",{\"1\":{\"864\":1}}],[\"endoffirsthalf\",{\"1\":{\"756\":2}}],[\"endtime\",{\"1\":{\"751\":3}}],[\"end++\",{\"1\":{\"179\":1}}],[\"end=mid\",{\"1\":{\"93\":1,\"94\":1}}],[\"end=nums\",{\"1\":{\"93\":1,\"94\":1}}],[\"end\",{\"1\":{\"60\":2,\"93\":2,\"94\":2,\"104\":1,\"107\":1,\"110\":4,\"114\":1,\"125\":1,\"126\":1,\"133\":1,\"137\":1,\"153\":1,\"154\":1,\"158\":1,\"163\":4,\"170\":1,\"171\":3,\"178\":1,\"179\":6,\"214\":2,\"220\":5,\"234\":2,\"355\":10,\"385\":10,\"476\":1,\"539\":2,\"571\":1,\"577\":1,\"584\":1,\"585\":1,\"589\":1,\"590\":1,\"591\":1,\"592\":2,\"594\":7,\"698\":2,\"699\":2,\"704\":12,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":9,\"871\":2,\"966\":7,\"999\":3,\"1000\":1,\"1001\":2,\"1002\":2,\"1007\":7,\"1008\":1,\"1011\":1,\"1082\":3,\"1086\":2,\"1099\":1,\"1102\":12,\"1127\":10,\"1147\":3,\"1148\":6,\"1168\":1,\"1177\":1,\"1178\":2,\"1179\":1,\"1238\":1,\"1523\":1,\"1851\":6}}],[\"endl都是std空间中的实体\",{\"1\":{\"589\":1}}],[\"endlf不为0\",{\"1\":{\"267\":1}}],[\"endl\",{\"1\":{\"8\":3,\"11\":5,\"60\":1,\"70\":2,\"101\":2,\"104\":2,\"107\":3,\"110\":2,\"118\":4,\"185\":16,\"188\":2,\"191\":2,\"194\":1,\"214\":2,\"224\":6,\"355\":1,\"362\":1,\"364\":2,\"365\":1,\"366\":1,\"368\":2,\"371\":3,\"372\":3,\"378\":5,\"382\":2,\"385\":6,\"388\":2,\"389\":1,\"392\":1,\"397\":1,\"406\":1,\"410\":2,\"411\":1,\"412\":1,\"413\":3,\"421\":3,\"422\":8,\"426\":2,\"433\":5,\"434\":6,\"435\":3,\"439\":7,\"440\":7,\"459\":8,\"464\":1,\"468\":2,\"476\":4,\"492\":2,\"497\":5,\"500\":4,\"506\":2,\"510\":1,\"515\":3,\"516\":4,\"517\":3,\"536\":7,\"547\":18,\"548\":7,\"557\":9,\"563\":5,\"567\":1,\"568\":1,\"569\":2,\"571\":1,\"588\":1,\"589\":2,\"590\":3,\"592\":5,\"594\":18,\"601\":3,\"602\":4,\"605\":2,\"606\":2,\"618\":14,\"621\":3,\"631\":4,\"633\":6,\"637\":2,\"642\":5,\"649\":2,\"650\":2,\"652\":3,\"662\":40,\"667\":6,\"669\":2,\"670\":1,\"672\":2,\"678\":5,\"688\":16,\"695\":8,\"698\":1,\"699\":1,\"701\":1,\"704\":3,\"714\":2,\"731\":3,\"745\":2,\"746\":2,\"747\":6,\"751\":1,\"756\":1,\"810\":2,\"817\":5,\"819\":3,\"821\":2,\"826\":1,\"830\":7,\"831\":3,\"832\":2,\"848\":3,\"849\":3,\"850\":3,\"851\":3,\"852\":3,\"854\":4,\"855\":4,\"856\":2,\"857\":2,\"862\":2,\"864\":2,\"867\":4,\"871\":8,\"886\":3,\"889\":16,\"890\":13,\"891\":19,\"894\":19,\"898\":1,\"900\":4,\"905\":3,\"906\":2,\"907\":4,\"908\":4,\"913\":3,\"919\":2,\"943\":9,\"948\":10,\"949\":4,\"953\":7,\"954\":3,\"966\":15,\"980\":2,\"981\":2,\"982\":2,\"984\":1,\"985\":1,\"990\":1,\"991\":1,\"992\":1,\"999\":6,\"1000\":7,\"1001\":2,\"1002\":7,\"1007\":5,\"1008\":1,\"1011\":4,\"1031\":1,\"1032\":3,\"1041\":2,\"1045\":4,\"1050\":1,\"1055\":4,\"1056\":14,\"1057\":15,\"1060\":4,\"1110\":5,\"1111\":2,\"1112\":2,\"1113\":3,\"1114\":4,\"1115\":4,\"1120\":5,\"1121\":2,\"1123\":9,\"1124\":2,\"1127\":2,\"1147\":1,\"1148\":1,\"1151\":1,\"1154\":3,\"1155\":1,\"1158\":2,\"1164\":1,\"1165\":2,\"1166\":1,\"1167\":1,\"1168\":13,\"1173\":4,\"1177\":1,\"1178\":1,\"1179\":1,\"1186\":1,\"1187\":1,\"1188\":7,\"1189\":5,\"1207\":3,\"1208\":3,\"1209\":6,\"1210\":2,\"1219\":4,\"1233\":1,\"1299\":2,\"1321\":2,\"1839\":2,\"1845\":1,\"1847\":1,\"1849\":2,\"1851\":3,\"1856\":3,\"1859\":1,\"1875\":2,\"1878\":3,\"1902\":1,\"1903\":1,\"1904\":1,\"1905\":1,\"1907\":4,\"1908\":3,\"1909\":3,\"1915\":3}}],[\"elasticsearch\",{\"1\":{\"1610\":1}}],[\"elide\",{\"1\":{\"398\":1}}],[\"elf|grep\",{\"1\":{\"1280\":1}}],[\"elf头\",{\"1\":{\"251\":1}}],[\"elf文件头\",{\"1\":{\"251\":1}}],[\"elf\",{\"1\":{\"228\":1,\"263\":1,\"572\":2,\"1316\":2,\"1317\":1}}],[\"element\",{\"1\":{\"59\":16,\"214\":4}}],[\"elements\",{\"1\":{\"59\":7}}],[\"else\",{\"1\":{\"8\":1,\"11\":2,\"29\":1,\"53\":1,\"59\":2,\"60\":4,\"84\":2,\"87\":1,\"93\":1,\"94\":1,\"96\":2,\"97\":2,\"110\":2,\"115\":2,\"118\":1,\"121\":1,\"126\":2,\"133\":2,\"136\":2,\"142\":2,\"153\":1,\"158\":1,\"185\":2,\"194\":1,\"202\":1,\"273\":2,\"274\":1,\"296\":1,\"388\":2,\"405\":1,\"526\":1,\"601\":1,\"602\":1,\"631\":1,\"699\":1,\"736\":2,\"745\":1,\"747\":3,\"759\":1,\"762\":1,\"771\":3,\"782\":1,\"783\":1,\"792\":1,\"795\":1,\"810\":1,\"817\":3,\"819\":1,\"871\":1,\"966\":2,\"999\":1,\"1001\":1,\"1050\":1,\"1079\":1,\"1082\":1,\"1086\":1,\"1093\":1,\"1096\":2,\"1099\":1,\"1102\":2,\"1120\":1,\"1123\":1,\"1168\":1,\"1318\":2,\"1321\":1,\"1383\":1,\"1384\":1,\"1385\":1,\"1839\":8,\"1849\":9,\"1859\":1,\"1875\":8}}],[\"exame会产生一张中间表存储结果供外面的sql查询\",{\"1\":{\"1544\":1}}],[\"exame\",{\"1\":{\"1537\":5,\"1538\":9,\"1540\":1,\"1541\":2,\"1544\":2}}],[\"exists\",{\"1\":{\"1507\":2}}],[\"exit\",{\"1\":{\"1384\":3,\"1385\":5,\"1408\":1,\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":1}}],[\"exclusive\",{\"1\":{\"1697\":1}}],[\"exchanged\",{\"1\":{\"1240\":1}}],[\"exception类位于<exception>头文件中\",{\"1\":{\"599\":1}}],[\"exceptiontype\",{\"1\":{\"599\":2}}],[\"exception\",{\"0\":{\"1016\":1},\"1\":{\"597\":1,\"599\":2,\"601\":6,\"604\":2,\"606\":1,\"607\":2,\"1102\":2,\"1770\":1}}],[\"expire\",{\"1\":{\"1769\":1}}],[\"explain可查看\",{\"1\":{\"1881\":1}}],[\"explain可以将执行语句的执行过程和一些关键信息罗列出来\",{\"1\":{\"1520\":1}}],[\"explain分析的时候可能出现以下问题\",{\"1\":{\"1744\":1}}],[\"explain结果字段分析\",{\"0\":{\"1618\":1}}],[\"explain各个字段代表的意思\",{\"0\":{\"1521\":1}}],[\"explain\",{\"0\":{\"1520\":1},\"1\":{\"1540\":1,\"1738\":2}}],[\"explicit\",{\"1\":{\"898\":1}}],[\"export\",{\"1\":{\"1282\":1}}],[\"expression\",{\"1\":{\"628\":1,\"1341\":1}}],[\"expand\",{\"1\":{\"54\":1,\"59\":1,\"101\":3,\"224\":2,\"355\":2,\"385\":2,\"704\":2,\"1087\":1,\"1127\":4}}],[\"expandallbutton\",{\"1\":{\"54\":1,\"59\":1}}],[\"expandbutton\",{\"1\":{\"54\":6,\"59\":6}}],[\"extra\",{\"1\":{\"1521\":1,\"1618\":1}}],[\"extractimagenames\",{\"1\":{\"60\":2}}],[\"ext4\",{\"1\":{\"1267\":1}}],[\"extend\",{\"1\":{\"1237\":1}}],[\"extended\",{\"0\":{\"1135\":1},\"1\":{\"1143\":1}}],[\"extern关键字\",{\"0\":{\"574\":1}}],[\"extern\",{\"0\":{\"573\":1,\"575\":1,\"576\":1,\"577\":1},\"1\":{\"246\":1,\"296\":1,\"567\":2,\"568\":1,\"570\":2,\"571\":2,\"574\":3,\"575\":1,\"576\":6,\"577\":1,\"578\":7}}],[\"exe存储在磁盘上\",{\"1\":{\"267\":1}}],[\"execstartpre=\",{\"1\":{\"1820\":1}}],[\"executable\",{\"1\":{\"1310\":1,\"1312\":4,\"1314\":1,\"1315\":1,\"1316\":4,\"1317\":2,\"1318\":3,\"1322\":1}}],[\"executed\",{\"1\":{\"601\":5}}],[\"exec\",{\"1\":{\"59\":1}}],[\"exe\",{\"1\":{\"4\":1,\"28\":1,\"29\":2,\"44\":3,\"310\":1,\"1367\":4}}],[\"e\",{\"0\":{\"1295\":1},\"1\":{\"53\":1,\"54\":2,\"59\":10,\"214\":2,\"239\":1,\"255\":3,\"470\":1,\"535\":1,\"547\":1,\"557\":4,\"599\":2,\"601\":4,\"602\":1,\"605\":4,\"621\":2,\"662\":1,\"1282\":4,\"1296\":1,\"1330\":2,\"1356\":1,\"1836\":2}}],[\"employeeid=1\",{\"1\":{\"1471\":1}}],[\"employeeaddress\",{\"1\":{\"1471\":1}}],[\"empty类的大小虽然为1\",{\"1\":{\"470\":1}}],[\"empty<\",{\"1\":{\"355\":1}}],[\"empty\",{\"1\":{\"60\":1,\"97\":1,\"182\":9,\"185\":6,\"191\":1,\"214\":1,\"224\":4,\"355\":3,\"385\":2,\"388\":4,\"406\":3,\"468\":7,\"470\":4,\"540\":1,\"704\":2,\"747\":1,\"751\":2,\"784\":2,\"966\":5,\"984\":1,\"990\":2,\"991\":2,\"992\":2,\"1020\":1,\"1087\":1,\"1127\":4,\"1219\":2,\"1849\":5,\"1859\":4,\"1869\":3,\"1871\":3,\"1872\":3,\"1875\":1}}],[\"emergency\",{\"1\":{\"1025\":1}}],[\"emerg\",{\"1\":{\"1025\":1}}],[\"email\",{\"1\":{\"0\":1,\"1539\":2,\"1552\":3}}],[\"emberjs\",{\"1\":{\"0\":1}}],[\"y=s\",{\"1\":{\"1878\":1}}],[\"yu\",{\"1\":{\"1856\":1,\"1878\":1}}],[\"yu1\",{\"1\":{\"1851\":2}}],[\"year获取年份\",{\"0\":{\"1497\":1}}],[\"yellow\",{\"1\":{\"29\":1}}],[\"yy\",{\"1\":{\"1321\":1}}],[\"yyyy\",{\"1\":{\"46\":1}}],[\"yx\",{\"1\":{\"1312\":1}}],[\"yield\",{\"1\":{\"1207\":1,\"1233\":2}}],[\"yii\",{\"1\":{\"0\":1}}],[\"y定义成默认值0\",{\"1\":{\"637\":1}}],[\"y要看成表达式加\",{\"1\":{\"500\":1}}],[\"y2\",{\"1\":{\"434\":2,\"826\":5}}],[\"y1\",{\"1\":{\"434\":2,\"826\":5}}],[\"y\",{\"0\":{\"1950\":1},\"1\":{\"362\":2,\"371\":2,\"395\":1,\"463\":2,\"473\":1,\"497\":2,\"500\":9,\"501\":3,\"504\":4,\"506\":3,\"557\":1,\"571\":10,\"572\":1,\"578\":1,\"594\":3,\"601\":5,\"602\":7,\"615\":3,\"618\":8,\"637\":5,\"641\":4,\"642\":8,\"826\":4,\"980\":1,\"1021\":2,\"1026\":2,\"1131\":1,\"1289\":1,\"1443\":1}}],[\"ya\",{\"1\":{\"1305\":1}}],[\"yahei\",{\"1\":{\"49\":2}}],[\"yaf\",{\"1\":{\"0\":1}}],[\"youcompleteme\",{\"1\":{\"1287\":3}}],[\"your\",{\"0\":{\"1407\":1},\"1\":{\"182\":1,\"791\":1,\"792\":1,\"1335\":4,\"1407\":1}}],[\"you\",{\"1\":{\"8\":1}}],[\"h发现\",{\"1\":{\"1915\":1}}],[\"h文件\",{\"1\":{\"1915\":1}}],[\"h文件中声明了一个函数\",{\"1\":{\"528\":1}}],[\"h头文件的路径\",{\"1\":{\"1855\":1}}],[\"hy000\",{\"0\":{\"1407\":1},\"1\":{\"1407\":1}}],[\"hypot\",{\"1\":{\"722\":2}}],[\"h或\",{\"1\":{\"1237\":1}}],[\"hlsearch\",{\"1\":{\"1133\":1,\"1291\":1}}],[\"hpp\",{\"1\":{\"1896\":1,\"1901\":1}}],[\"hp\",{\"1\":{\"1082\":1}}],[\"hh>\",{\"1\":{\"1020\":5,\"1031\":8,\"1032\":5}}],[\"hdmi接口\",{\"1\":{\"832\":1}}],[\"hdmi\",{\"1\":{\"832\":6}}],[\"hide\",{\"0\":{\"695\":1}}],[\"highmen\",{\"1\":{\"267\":1}}],[\"highlight\",{\"1\":{\"62\":2}}],[\"hurt\",{\"1\":{\"1102\":1}}],[\"hubei\",{\"1\":{\"662\":1}}],[\"huawei\",{\"1\":{\"397\":1,\"439\":2,\"440\":1,\"449\":1,\"464\":1}}],[\"h找不到\",{\"1\":{\"614\":2}}],[\"hbase\",{\"1\":{\"1452\":1}}],[\"hb\",{\"1\":{\"594\":3}}],[\"hfcppprojectprint\",{\"1\":{\"594\":1}}],[\"hwprint\",{\"1\":{\"594\":1}}],[\"h的头文件\",{\"1\":{\"576\":1}}],[\"h的声明如下\",{\"1\":{\"528\":1}}],[\"host=\",{\"1\":{\"1825\":1,\"1829\":1,\"1888\":2,\"1891\":2}}],[\"host是主机名\",{\"1\":{\"1374\":1}}],[\"host\",{\"1\":{\"1374\":1,\"1407\":1,\"1447\":1,\"1770\":2,\"1825\":1}}],[\"home\",{\"1\":{\"1271\":3,\"1758\":1}}],[\"holdsanint\",{\"1\":{\"470\":2}}],[\"how\",{\"1\":{\"8\":1}}],[\"h这个文件\",{\"1\":{\"312\":1}}],[\"h>的封装\",{\"1\":{\"536\":1}}],[\"h>或中\",{\"1\":{\"535\":1}}],[\"h>\",{\"1\":{\"101\":3,\"163\":1,\"234\":1,\"267\":1,\"277\":4,\"293\":1,\"323\":1,\"338\":1,\"476\":1,\"493\":1,\"494\":1,\"515\":1,\"547\":1,\"548\":1,\"570\":1,\"571\":2,\"575\":1,\"576\":1,\"594\":1,\"614\":1,\"662\":2,\"817\":2,\"1299\":2,\"1372\":2,\"1383\":2,\"1384\":4,\"1385\":4,\"1399\":1,\"1846\":1,\"1856\":1,\"1859\":1}}],[\"h\",{\"0\":{\"1845\":1,\"1846\":1,\"1848\":1},\"1\":{\"59\":4,\"188\":6,\"194\":5,\"199\":4,\"202\":2,\"205\":5,\"217\":5,\"220\":5,\"234\":1,\"251\":1,\"312\":2,\"439\":2,\"476\":1,\"504\":3,\"506\":5,\"528\":1,\"529\":2,\"535\":2,\"547\":3,\"557\":1,\"576\":2,\"577\":1,\"578\":4,\"614\":1,\"817\":6,\"826\":2,\"889\":6,\"894\":4,\"1021\":2,\"1026\":2,\"1032\":2,\"1080\":1,\"1081\":1,\"1086\":4,\"1305\":1,\"1312\":1,\"1313\":2,\"1316\":2,\"1347\":1,\"1367\":2,\"1839\":6,\"1845\":3,\"1846\":3,\"1847\":2,\"1848\":4,\"1849\":2,\"1856\":12,\"1859\":9,\"1866\":2,\"1875\":6,\"1878\":9,\"1915\":1}}],[\"hs\",{\"1\":{\"59\":2}}],[\"h6>\",{\"1\":{\"51\":1}}],[\"h6toc\",{\"1\":{\"51\":3}}],[\"h6\",{\"1\":{\"51\":12,\"59\":1}}],[\"h5>\",{\"1\":{\"51\":1}}],[\"h5toc\",{\"1\":{\"51\":4}}],[\"h5\",{\"1\":{\"51\":16,\"59\":1}}],[\"h4>\",{\"1\":{\"51\":1}}],[\"h4toc\",{\"1\":{\"51\":5}}],[\"h4\",{\"1\":{\"51\":18,\"59\":1}}],[\"h3>\",{\"1\":{\"51\":1}}],[\"h3toc\",{\"1\":{\"51\":6}}],[\"h3\",{\"1\":{\"51\":20,\"59\":1}}],[\"h2>\",{\"1\":{\"51\":1}}],[\"h2toc\",{\"1\":{\"51\":7}}],[\"h2\",{\"1\":{\"51\":20,\"59\":1}}],[\"h1\",{\"1\":{\"51\":3,\"59\":1}}],[\"having用在分组后过滤\",{\"1\":{\"1538\":1}}],[\"having\",{\"1\":{\"1240\":2,\"1526\":1,\"1538\":1}}],[\"have\",{\"1\":{\"606\":2,\"1102\":1}}],[\"hao\",{\"1\":{\"1155\":1}}],[\"happy\",{\"1\":{\"1082\":1}}],[\"hahaha\",{\"1\":{\"536\":1}}],[\"hascycle\",{\"1\":{\"765\":1}}],[\"hash取模等\",{\"1\":{\"1890\":1}}],[\"hash\",{\"1\":{\"155\":2,\"158\":6,\"166\":4,\"170\":3,\"174\":4,\"1569\":2,\"1600\":1,\"1747\":1}}],[\"hashmap\",{\"1\":{\"125\":7,\"141\":4,\"178\":6}}],[\"hashtable\",{\"1\":{\"104\":3,\"107\":3,\"110\":3}}],[\"hasaddiframe\",{\"1\":{\"59\":3}}],[\"handler\",{\"1\":{\"1102\":6,\"1151\":3}}],[\"handler01\",{\"1\":{\"1050\":4}}],[\"handle\",{\"1\":{\"572\":1,\"871\":4}}],[\"han\",{\"1\":{\"49\":1}}],[\"hack\",{\"1\":{\"0\":1}}],[\"help显示mycat支持的命令\",{\"1\":{\"1808\":1}}],[\"help\",{\"1\":{\"1237\":1}}],[\"hell\",{\"1\":{\"588\":1}}],[\"hello2\",{\"1\":{\"1165\":2}}],[\"hello1\",{\"1\":{\"1164\":2}}],[\"helloworld\",{\"1\":{\"536\":1,\"594\":2}}],[\"hello\",{\"1\":{\"8\":1,\"267\":2,\"277\":2,\"378\":6,\"405\":1,\"476\":4,\"515\":1,\"535\":2,\"536\":1,\"547\":3,\"548\":1,\"662\":2,\"698\":2,\"699\":1,\"849\":1,\"852\":1,\"949\":1,\"1020\":2,\"1123\":1,\"1154\":4,\"1155\":4,\"1158\":7,\"1164\":2,\"1165\":2,\"1167\":3,\"1173\":2,\"1206\":1,\"1207\":2,\"1271\":3,\"1357\":3,\"1361\":2,\"1902\":1,\"1903\":1}}],[\"heng\",{\"1\":{\"886\":2,\"905\":2}}],[\"here\",{\"1\":{\"277\":2}}],[\"heartbeat>\",{\"1\":{\"1888\":2,\"1891\":2}}],[\"heartbeat\",{\"1\":{\"1803\":1}}],[\"headb\",{\"1\":{\"771\":7}}],[\"heada\",{\"1\":{\"771\":8}}],[\"head\",{\"1\":{\"747\":5,\"754\":1,\"755\":2,\"756\":9,\"759\":4,\"762\":2,\"765\":3,\"768\":5,\"774\":6,\"777\":7,\"782\":2,\"783\":2,\"784\":3,\"787\":14,\"795\":5,\"798\":6,\"801\":1,\"802\":6,\"810\":4,\"817\":19,\"819\":21,\"821\":15}}],[\"header\",{\"1\":{\"263\":1}}],[\"headers\",{\"1\":{\"262\":1,\"263\":1,\"1328\":1}}],[\"headers段\",{\"0\":{\"262\":1},\"1\":{\"262\":1}}],[\"heading\",{\"1\":{\"51\":4}}],[\"headings\",{\"1\":{\"51\":3}}],[\"heapify复杂度o\",{\"1\":{\"195\":1}}],[\"heapify\",{\"1\":{\"194\":4}}],[\"heap\",{\"1\":{\"194\":3,\"267\":1,\"1041\":1,\"1082\":2,\"1102\":5}}],[\"heapsort\",{\"1\":{\"194\":5}}],[\"height\",{\"1\":{\"49\":1,\"50\":1,\"51\":1,\"53\":3,\"54\":2,\"59\":6,\"271\":1}}],[\"hkey\",{\"1\":{\"44\":3}}],[\"hr会打印你的简历\",{\"1\":{\"0\":1}}],[\"html\",{\"1\":{\"110\":1,\"496\":1,\"673\":1,\"678\":1,\"692\":1,\"707\":1,\"750\":1,\"965\":1,\"1063\":1,\"1087\":1,\"1121\":1,\"1610\":1,\"1747\":1}}],[\"html5\",{\"1\":{\"0\":1}}],[\"https\",{\"1\":{\"5\":2,\"110\":1,\"496\":1,\"673\":1,\"678\":1,\"692\":1,\"707\":1,\"750\":1,\"965\":1,\"1063\":1,\"1087\":1,\"1121\":1,\"1132\":1,\"1284\":6,\"1287\":1,\"1290\":1,\"1395\":1,\"1610\":1,\"1747\":1,\"1878\":1}}],[\"http\",{\"1\":{\"0\":2,\"597\":1,\"599\":1,\"1249\":1,\"1251\":2,\"1252\":2,\"1253\":1,\"1284\":2,\"1888\":1,\"1891\":1}}],[\"1qaz\",{\"1\":{\"1825\":1,\"1828\":1,\"1829\":1}}],[\"1地址登录\",{\"1\":{\"1821\":1}}],[\"1地址\",{\"1\":{\"1821\":1}}],[\"1的请求\",{\"1\":{\"1821\":1}}],[\"1的mslave用户权限不够\",{\"1\":{\"1821\":1}}],[\"1的数据\",{\"1\":{\"1821\":1}}],[\"1的秒数\",{\"1\":{\"1427\":1}}],[\"1再转发到物理机\",{\"1\":{\"1821\":1}}],[\"1s\",{\"1\":{\"1579\":1}}],[\"1外连接查询\",{\"0\":{\"1500\":1}}],[\"1nf\",{\"0\":{\"1460\":1}}],[\"1ubuntu18\",{\"1\":{\"1395\":1,\"1396\":1,\"1397\":10}}],[\"1m\",{\"1\":{\"1282\":3}}],[\"1就是表示你本机ip地址的意思了\",{\"1\":{\"1239\":1}}],[\"1等待状态\",{\"1\":{\"1219\":1}}],[\"1时\",{\"1\":{\"1209\":1}}],[\"1得到的是下标\",{\"1\":{\"1090\":1}}],[\"1~8\",{\"1\":{\"1090\":3}}],[\"1单重集合与多重集合\",{\"0\":{\"999\":1}}],[\"1底层实现\",{\"0\":{\"968\":1}}],[\"1使用方式\",{\"0\":{\"965\":1}}],[\"1输出结果\",{\"1\":{\"908\":1}}],[\"1步\",{\"1\":{\"774\":1}}],[\"1eh\",{\"1\":{\"638\":1}}],[\"1e9\",{\"1\":{\"163\":1}}],[\"1c3da4cd2450\",{\"1\":{\"473\":1}}],[\"1+2\",{\"1\":{\"339\":1}}],[\"1表示可用\",{\"1\":{\"286\":1}}],[\"192\",{\"1\":{\"1796\":2,\"1818\":2,\"1821\":3,\"1825\":1,\"1829\":1,\"1888\":4,\"1891\":4}}],[\"1973\",{\"1\":{\"301\":1}}],[\"1972\",{\"1\":{\"301\":1}}],[\"1971\",{\"1\":{\"301\":1}}],[\"1970\",{\"1\":{\"301\":1}}],[\"1969\",{\"1\":{\"301\":2}}],[\"1965年为了解决大型机连接终端数量不够用的问题\",{\"1\":{\"301\":1}}],[\"19\",{\"0\":{\"774\":1,\"1939\":1},\"1\":{\"234\":1,\"236\":1,\"239\":1,\"774\":1,\"900\":1,\"1271\":6,\"1415\":2,\"1537\":1,\"1769\":1}}],[\"199\",{\"1\":{\"191\":1}}],[\"1998\",{\"1\":{\"0\":1}}],[\"1个位置\",{\"1\":{\"217\":1}}],[\"16k\",{\"1\":{\"1603\":1}}],[\"168\",{\"1\":{\"1239\":1,\"1796\":2,\"1818\":4,\"1821\":13,\"1825\":1,\"1829\":1,\"1888\":4,\"1891\":4}}],[\"1681217280598\",{\"1\":{\"601\":1}}],[\"1681303112683\",{\"1\":{\"509\":1}}],[\"1681304023862\",{\"1\":{\"636\":1}}],[\"1681304077461\",{\"1\":{\"473\":1}}],[\"1681304184845\",{\"1\":{\"597\":1}}],[\"1681304109194\",{\"1\":{\"500\":1}}],[\"1681302938745\",{\"1\":{\"479\":1}}],[\"160\",{\"0\":{\"771\":1},\"1\":{\"771\":1}}],[\"16进制及进制转换\",{\"0\":{\"349\":1}}],[\"16位操作系统\",{\"1\":{\"308\":1}}],[\"16384将把默认栈大小设置为16384\",{\"1\":{\"239\":1}}],[\"16\",{\"0\":{\"1937\":1},\"1\":{\"214\":1,\"234\":1,\"433\":1,\"553\":1,\"1082\":5,\"1090\":1,\"1255\":2,\"1299\":1,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":3,\"1772\":1,\"1773\":5,\"1774\":8,\"1776\":1,\"1820\":6}}],[\"167\",{\"0\":{\"140\":1},\"1\":{\"140\":1}}],[\"1轮循环\",{\"1\":{\"188\":1}}],[\"1位置二分查找num的数字\",{\"1\":{\"163\":2}}],[\"1位置二分查找第一个num的数字\",{\"1\":{\"163\":2}}],[\"1=2147483647\",{\"1\":{\"147\":1}}],[\"1819\",{\"0\":{\"1407\":1},\"1\":{\"1407\":1}}],[\"1840\",{\"1\":{\"1253\":1}}],[\"187\",{\"1\":{\"812\":1}}],[\"18\",{\"0\":{\"1943\":1},\"1\":{\"107\":1,\"234\":1,\"236\":1,\"599\":1,\"819\":2,\"900\":1,\"1271\":1,\"1395\":1,\"1437\":1,\"1475\":1,\"1480\":1,\"1537\":1,\"1773\":1,\"1818\":1}}],[\"17成功了\",{\"1\":{\"1693\":1}}],[\"171363566787064\",{\"1\":{\"1776\":1}}],[\"171363548398851\",{\"1\":{\"1774\":1}}],[\"171363533193338\",{\"1\":{\"1774\":1}}],[\"171363531440435\",{\"1\":{\"1774\":1}}],[\"171363528522132\",{\"1\":{\"1773\":1}}],[\"171363526798929\",{\"1\":{\"1773\":1}}],[\"171363514679822\",{\"1\":{\"1773\":1}}],[\"171363507402613\",{\"1\":{\"1772\":1}}],[\"17136210429909\",{\"1\":{\"1759\":1}}],[\"171360312686323\",{\"1\":{\"1665\":1}}],[\"171360298211316\",{\"1\":{\"1665\":1}}],[\"17136021990519\",{\"1\":{\"1663\":1}}],[\"171359635630221\",{\"1\":{\"1682\":1}}],[\"171359623530518\",{\"1\":{\"1682\":1}}],[\"171359616071615\",{\"1\":{\"1682\":1}}],[\"171359600478510\",{\"1\":{\"1681\":1}}],[\"17135959581577\",{\"1\":{\"1681\":1}}],[\"17~24\",{\"1\":{\"1090\":1}}],[\"17\",{\"0\":{\"1942\":1},\"1\":{\"107\":1,\"224\":2,\"234\":1,\"236\":1,\"599\":1,\"1271\":2}}],[\"17px\",{\"1\":{\"49\":1}}],[\"147258\",{\"1\":{\"1851\":3,\"1856\":1,\"1878\":1}}],[\"14ds\",{\"1\":{\"1821\":3}}],[\"14ba37259316444580233aac35698e7b\",{\"1\":{\"1776\":1}}],[\"142\",{\"0\":{\"768\":1},\"1\":{\"768\":1}}],[\"14159\",{\"1\":{\"898\":1}}],[\"141\",{\"0\":{\"765\":1},\"1\":{\"765\":1}}],[\"14h\",{\"1\":{\"234\":1,\"638\":1}}],[\"14\",{\"0\":{\"1938\":1},\"1\":{\"107\":3,\"110\":1,\"338\":1,\"1114\":2,\"1310\":1,\"1774\":1}}],[\"129\",{\"1\":{\"1796\":1,\"1818\":1,\"1821\":1,\"1825\":1,\"1829\":1,\"1888\":2,\"1891\":2}}],[\"12s\",{\"1\":{\"1740\":1}}],[\"127\",{\"1\":{\"1374\":1,\"1408\":1,\"1820\":1,\"1851\":3,\"1856\":1,\"1878\":1}}],[\"12感兴趣\",{\"1\":{\"871\":1}}],[\"120\",{\"1\":{\"371\":1,\"515\":1,\"1252\":1}}],[\"123\",{\"1\":{\"338\":1}}],[\"123456\",{\"1\":{\"1447\":3,\"1799\":1,\"1888\":2,\"1891\":2,\"1915\":1}}],[\"1234\",{\"1\":{\"191\":1}}],[\"128字节所有的chunk块\",{\"1\":{\"1105\":1}}],[\"128\",{\"0\":{\"129\":1},\"1\":{\"129\":1,\"1082\":1,\"1096\":1,\"1102\":1,\"1384\":1,\"1385\":1}}],[\"12\",{\"0\":{\"1383\":1,\"1935\":1,\"1957\":1},\"1\":{\"107\":2,\"110\":2,\"118\":1,\"185\":1,\"224\":2,\"234\":1,\"345\":1,\"459\":1,\"633\":2,\"1007\":2,\"1008\":1,\"1114\":1,\"1239\":1,\"1310\":1,\"1537\":4,\"1665\":1,\"1688\":2,\"1774\":1}}],[\"136\",{\"1\":{\"1818\":1}}],[\"131\",{\"1\":{\"1796\":1,\"1818\":1,\"1821\":13,\"1825\":1,\"1829\":1,\"1888\":2,\"1891\":2}}],[\"131331\",{\"1\":{\"1415\":2}}],[\"13711112222\",{\"1\":{\"1593\":1}}],[\"13感兴趣\",{\"1\":{\"871\":1}}],[\"13\",{\"1\":{\"107\":3,\"110\":3,\"118\":1,\"234\":1,\"239\":1,\"547\":1,\"819\":4,\"1114\":1,\"1310\":1}}],[\"135\",{\"1\":{\"0\":1,\"1239\":1,\"1818\":1}}],[\"11知识汇总\",{\"0\":{\"1943\":1}}],[\"11月\",{\"1\":{\"1820\":2}}],[\"110955333\",{\"1\":{\"1878\":1}}],[\"1100\",{\"1\":{\"1415\":3}}],[\"1101110100110100100000\",{\"1\":{\"1299\":2}}],[\"11中使用nullptr来表示空指针\",{\"1\":{\"529\":1}}],[\"11的nullptr的时候\",{\"0\":{\"530\":1}}],[\"11的nullptr就很好的解决了这个问题\",{\"1\":{\"529\":1}}],[\"11的nullptr\",{\"0\":{\"529\":1}}],[\"1111\",{\"1\":{\"1271\":5}}],[\"11111000与\",{\"1\":{\"1090\":1}}],[\"11111000\",{\"1\":{\"1090\":2}}],[\"11111111\",{\"1\":{\"1090\":8}}],[\"111\",{\"1\":{\"459\":1,\"547\":1}}],[\"11\",{\"0\":{\"1382\":1,\"1936\":1,\"1958\":1},\"1\":{\"101\":4,\"107\":1,\"110\":1,\"234\":1,\"459\":1,\"678\":1,\"1032\":8,\"1114\":1,\"1115\":1,\"1310\":1,\"1537\":3,\"1665\":1,\"1688\":1,\"1773\":2,\"1774\":1,\"1820\":1,\"1896\":1}}],[\"1开始\",{\"1\":{\"93\":1}}],[\"1要快\",{\"1\":{\"70\":1}}],[\"103\",{\"1\":{\"1278\":1}}],[\"1030\",{\"1\":{\"1000\":3,\"1002\":2}}],[\"1020\",{\"1\":{\"1000\":5,\"1002\":5}}],[\"1024\",{\"1\":{\"239\":1,\"240\":4,\"480\":1,\"736\":2,\"1026\":1,\"1031\":1,\"1032\":1,\"1839\":1,\"1849\":1,\"1851\":2,\"1856\":1,\"1875\":1,\"1878\":2}}],[\"1010\",{\"1\":{\"1000\":4,\"1002\":2}}],[\"101\",{\"1\":{\"717\":2,\"718\":2,\"1686\":4}}],[\"10>\",{\"1\":{\"371\":1,\"388\":1}}],[\"10进制\",{\"0\":{\"349\":1}}],[\"1048576个\",{\"1\":{\"308\":1}}],[\"10~9\",{\"1\":{\"191\":1}}],[\"109\",{\"1\":{\"161\":3}}],[\"105\",{\"1\":{\"161\":1}}],[\"10\",{\"0\":{\"1381\":1,\"1932\":1,\"1955\":1},\"1\":{\"70\":3,\"101\":3,\"104\":2,\"107\":2,\"110\":1,\"118\":1,\"147\":1,\"148\":2,\"149\":2,\"185\":2,\"188\":1,\"191\":10,\"234\":4,\"236\":1,\"338\":1,\"345\":1,\"355\":1,\"359\":1,\"365\":2,\"368\":3,\"378\":3,\"385\":1,\"422\":4,\"440\":3,\"459\":2,\"476\":1,\"480\":1,\"485\":1,\"487\":1,\"488\":1,\"489\":1,\"490\":3,\"492\":8,\"497\":3,\"512\":2,\"515\":6,\"517\":1,\"518\":2,\"520\":2,\"523\":1,\"524\":3,\"547\":3,\"563\":4,\"567\":1,\"568\":1,\"569\":1,\"570\":1,\"574\":1,\"589\":1,\"590\":1,\"591\":1,\"592\":2,\"594\":6,\"614\":1,\"618\":5,\"620\":3,\"621\":2,\"624\":1,\"625\":2,\"630\":2,\"633\":2,\"638\":2,\"639\":2,\"653\":1,\"678\":2,\"688\":2,\"704\":1,\"713\":1,\"714\":1,\"729\":1,\"817\":1,\"819\":1,\"821\":2,\"884\":2,\"885\":2,\"889\":1,\"891\":1,\"894\":1,\"906\":1,\"943\":1,\"948\":1,\"953\":3,\"954\":2,\"980\":1,\"981\":2,\"982\":2,\"1040\":1,\"1043\":1,\"1045\":1,\"1110\":1,\"1114\":6,\"1115\":2,\"1124\":1,\"1127\":1,\"1151\":1,\"1154\":1,\"1158\":1,\"1174\":1,\"1175\":1,\"1183\":4,\"1186\":1,\"1188\":2,\"1189\":1,\"1219\":4,\"1233\":1,\"1255\":1,\"1285\":1,\"1299\":1,\"1310\":1,\"1312\":1,\"1426\":2,\"1480\":1,\"1537\":5,\"1539\":5,\"1719\":1,\"1740\":4,\"1774\":1,\"1888\":2,\"1891\":2,\"1901\":1}}],[\"1001\",{\"1\":{\"170\":1}}],[\"100\",{\"1\":{\"59\":4,\"70\":1,\"101\":8,\"129\":1,\"191\":1,\"224\":2,\"355\":1,\"406\":1,\"473\":2,\"488\":2,\"592\":2,\"597\":6,\"599\":2,\"605\":1,\"616\":1,\"618\":1,\"629\":1,\"630\":1,\"633\":3,\"704\":1,\"742\":1,\"743\":1,\"745\":1,\"746\":1,\"747\":6,\"817\":12,\"819\":1,\"821\":2,\"889\":1,\"891\":1,\"894\":1,\"966\":5,\"984\":1,\"985\":1,\"990\":1,\"991\":1,\"992\":1,\"1011\":2,\"1025\":1,\"1031\":1,\"1060\":2,\"1114\":4,\"1147\":1,\"1148\":1,\"1166\":1,\"1177\":1,\"1208\":2,\"1209\":4,\"1210\":1,\"1219\":4,\"1233\":1,\"1238\":1,\"1252\":1,\"1428\":1,\"1537\":1,\"1552\":2,\"1686\":3,\"1878\":1,\"1888\":2,\"1891\":1,\"1896\":1}}],[\"10000\",{\"1\":{\"889\":1,\"891\":1}}],[\"1000000\",{\"1\":{\"751\":1}}],[\"100000\",{\"1\":{\"751\":1}}],[\"1000以内的\",{\"1\":{\"170\":1}}],[\"1000\",{\"1\":{\"53\":1,\"54\":1,\"59\":5,\"170\":2,\"616\":1,\"751\":1,\"889\":1,\"891\":1,\"1000\":9,\"1001\":2,\"1002\":1,\"1238\":1,\"1415\":3,\"1888\":2,\"1891\":2}}],[\"1rem\",{\"1\":{\"51\":1}}],[\"1px\",{\"1\":{\"49\":2}}],[\"15902021\",{\"1\":{\"1285\":1}}],[\"1500000\",{\"1\":{\"1539\":4,\"1581\":1}}],[\"150\",{\"1\":{\"1278\":1}}],[\"15出现了一次\",{\"1\":{\"999\":1}}],[\"15个教徒和15\",{\"1\":{\"811\":1}}],[\"15\",{\"0\":{\"132\":1,\"1940\":1},\"1\":{\"46\":1,\"132\":1,\"163\":1,\"277\":2,\"819\":2,\"999\":2,\"1183\":2,\"1239\":1,\"1310\":1,\"1423\":1,\"1758\":1}}],[\"15k~20k\",{\"1\":{\"0\":1}}],[\"1\",{\"0\":{\"124\":1,\"692\":1,\"756\":1,\"830\":1,\"862\":2,\"863\":1,\"866\":1,\"965\":1,\"966\":1,\"999\":1,\"1000\":1,\"1001\":1,\"1039\":1,\"1043\":1,\"1109\":1,\"1120\":1,\"1172\":1,\"1181\":1,\"1194\":1,\"1202\":1,\"1204\":1,\"1216\":1,\"1217\":2,\"1218\":1,\"1225\":1,\"1372\":1,\"1485\":1,\"1490\":1,\"1494\":1,\"1576\":1,\"1577\":1,\"1658\":1,\"1662\":1,\"1679\":1,\"1692\":1,\"1729\":1,\"1733\":1,\"1773\":1,\"1797\":1,\"1802\":1,\"1805\":1,\"1808\":1,\"1811\":1,\"1820\":1,\"1824\":1,\"1828\":1,\"1888\":1,\"1891\":1,\"1898\":1,\"1902\":1,\"1907\":1},\"1\":{\"8\":1,\"22\":1,\"29\":5,\"49\":1,\"50\":3,\"51\":3,\"59\":1,\"60\":4,\"67\":3,\"70\":2,\"73\":3,\"78\":2,\"81\":3,\"84\":3,\"87\":2,\"93\":2,\"95\":1,\"96\":6,\"97\":8,\"100\":2,\"101\":7,\"104\":10,\"107\":6,\"110\":3,\"115\":3,\"118\":1,\"121\":1,\"124\":1,\"126\":2,\"129\":7,\"133\":5,\"135\":14,\"136\":5,\"137\":4,\"140\":2,\"141\":2,\"142\":12,\"143\":8,\"146\":3,\"147\":7,\"148\":1,\"149\":3,\"155\":1,\"161\":1,\"162\":2,\"163\":1,\"169\":3,\"170\":3,\"177\":3,\"178\":3,\"179\":3,\"182\":3,\"185\":3,\"188\":4,\"191\":2,\"194\":9,\"199\":1,\"202\":4,\"205\":5,\"214\":5,\"217\":3,\"220\":2,\"224\":1,\"244\":1,\"286\":1,\"287\":1,\"301\":1,\"306\":1,\"323\":1,\"338\":1,\"339\":2,\"340\":4,\"355\":1,\"372\":2,\"378\":10,\"385\":1,\"388\":4,\"395\":2,\"397\":2,\"405\":4,\"406\":6,\"422\":5,\"426\":1,\"433\":1,\"434\":1,\"435\":1,\"439\":1,\"454\":1,\"455\":1,\"458\":6,\"459\":9,\"463\":3,\"464\":3,\"468\":1,\"473\":2,\"510\":1,\"512\":1,\"513\":1,\"515\":4,\"518\":1,\"521\":1,\"535\":3,\"547\":2,\"548\":6,\"553\":2,\"557\":1,\"572\":1,\"588\":2,\"592\":2,\"594\":3,\"599\":1,\"600\":1,\"601\":2,\"602\":1,\"612\":1,\"616\":2,\"618\":2,\"629\":2,\"639\":1,\"640\":1,\"642\":3,\"658\":1,\"662\":11,\"669\":1,\"672\":1,\"678\":1,\"695\":5,\"699\":5,\"704\":2,\"721\":1,\"730\":1,\"731\":3,\"736\":9,\"742\":1,\"743\":2,\"745\":1,\"746\":2,\"747\":17,\"751\":2,\"755\":1,\"756\":2,\"762\":1,\"771\":1,\"774\":2,\"777\":1,\"783\":1,\"787\":1,\"790\":1,\"791\":2,\"792\":3,\"795\":3,\"798\":1,\"802\":5,\"810\":9,\"812\":1,\"815\":1,\"817\":1,\"819\":1,\"830\":1,\"854\":3,\"856\":1,\"857\":1,\"871\":7,\"875\":1,\"889\":1,\"891\":2,\"894\":2,\"900\":2,\"908\":1,\"949\":2,\"965\":4,\"966\":6,\"969\":5,\"970\":7,\"973\":4,\"974\":3,\"990\":2,\"991\":2,\"992\":2,\"993\":1,\"999\":3,\"1001\":4,\"1002\":1,\"1015\":6,\"1041\":1,\"1055\":1,\"1056\":4,\"1057\":4,\"1082\":2,\"1090\":19,\"1099\":4,\"1102\":1,\"1114\":2,\"1115\":1,\"1120\":4,\"1122\":2,\"1123\":8,\"1127\":2,\"1147\":1,\"1148\":1,\"1151\":1,\"1155\":4,\"1168\":3,\"1177\":1,\"1188\":1,\"1208\":1,\"1209\":2,\"1219\":5,\"1227\":1,\"1238\":2,\"1239\":1,\"1240\":1,\"1249\":1,\"1252\":1,\"1253\":1,\"1255\":1,\"1271\":2,\"1299\":3,\"1310\":1,\"1315\":1,\"1332\":3,\"1341\":1,\"1367\":1,\"1374\":1,\"1407\":6,\"1408\":1,\"1427\":1,\"1469\":1,\"1475\":1,\"1507\":1,\"1531\":1,\"1537\":4,\"1538\":2,\"1552\":1,\"1569\":1,\"1578\":1,\"1656\":1,\"1686\":1,\"1719\":2,\"1733\":2,\"1734\":1,\"1735\":2,\"1736\":7,\"1773\":1,\"1799\":1,\"1803\":3,\"1820\":3,\"1821\":6,\"1839\":3,\"1844\":1,\"1849\":5,\"1851\":4,\"1856\":1,\"1859\":2,\"1875\":4,\"1878\":5,\"1888\":1,\"1891\":1,\"1902\":1,\"1904\":1,\"1905\":2,\"1908\":1,\"1909\":2,\"1914\":2,\"1915\":3}}],[\"期望城市\",{\"1\":{\"0\":1}}],[\"期望薪资\",{\"1\":{\"0\":1}}],[\"期望职位\",{\"1\":{\"0\":1}}],[\"c3p0以及apache\",{\"1\":{\"1864\":1}}],[\"cgroup\",{\"1\":{\"1820\":1}}],[\"c上做\",{\"1\":{\"1790\":1}}],[\"c库\",{\"1\":{\"1622\":1}}],[\"c=\",{\"1\":{\"1360\":1,\"1365\":1,\"1366\":2}}],[\"c重新组合成main\",{\"1\":{\"1360\":1}}],[\"c重新启动下载中断的文件\",{\"1\":{\"1252\":1}}],[\"cflags\",{\"1\":{\"1356\":1}}],[\"cfvz\",{\"1\":{\"1260\":1}}],[\"cfv\",{\"1\":{\"1260\":1}}],[\"c预编译器选项\",{\"1\":{\"1356\":1}}],[\"c预编译器\",{\"1\":{\"1356\":1}}],[\"c编译器选项\",{\"1\":{\"1356\":1}}],[\"c编译器\",{\"1\":{\"1356\":1}}],[\"c编写的代码\",{\"1\":{\"577\":1}}],[\"cxxflags\",{\"1\":{\"1356\":1,\"1367\":1}}],[\"cxx\",{\"1\":{\"1310\":3,\"1317\":4,\"1356\":1,\"1360\":5,\"1367\":4}}],[\"cxa\",{\"1\":{\"572\":1}}],[\"c参数\",{\"1\":{\"1252\":1}}],[\"cec5ca395e184437abf68a77ec43db2b\",{\"1\":{\"1656\":1}}],[\"centos7\",{\"1\":{\"1818\":1}}],[\"centos\",{\"1\":{\"1251\":2,\"1914\":1}}],[\"cerr\",{\"1\":{\"605\":2,\"606\":2,\"864\":1}}],[\"cnblogs\",{\"1\":{\"1914\":1}}],[\"cnt\",{\"1\":{\"1538\":4}}],[\"cname\",{\"1\":{\"1537\":3,\"1538\":8}}],[\"cnf中指定\",{\"1\":{\"1821\":1}}],[\"cnf中进行配置\",{\"1\":{\"1820\":1}}],[\"cnf中设置的id\",{\"1\":{\"1773\":1}}],[\"cnf配置的data\",{\"1\":{\"1772\":1,\"1776\":1}}],[\"cnf配置参数如下\",{\"1\":{\"1748\":1}}],[\"cnf或my\",{\"1\":{\"1754\":1}}],[\"cnf\",{\"0\":{\"1844\":1},\"1\":{\"1408\":1,\"1410\":1,\"1555\":1,\"1746\":1,\"1750\":1,\"1769\":2,\"1820\":1,\"1839\":2,\"1849\":2,\"1875\":2,\"1878\":2}}],[\"cn\",{\"1\":{\"1249\":2,\"1252\":2,\"1253\":2,\"1284\":6}}],[\"cut\",{\"1\":{\"1238\":1}}],[\"curtime\",{\"1\":{\"1443\":1}}],[\"curdate\",{\"1\":{\"1443\":1}}],[\"cursorline\",{\"1\":{\"1133\":1,\"1291\":1}}],[\"cur是指向某一个结构体的指针\",{\"1\":{\"747\":1}}],[\"currently\",{\"1\":{\"1318\":1}}],[\"currentlen++\",{\"1\":{\"129\":1}}],[\"currentlen\",{\"1\":{\"129\":2}}],[\"current\",{\"0\":{\"1407\":1},\"1\":{\"286\":16,\"1099\":5,\"1310\":2,\"1407\":1,\"1443\":2}}],[\"cur++\",{\"1\":{\"129\":1}}],[\"cur\",{\"1\":{\"129\":2,\"747\":5,\"751\":4,\"756\":6,\"759\":9,\"774\":4,\"782\":7,\"783\":7,\"784\":4,\"817\":33}}],[\"curassetabsolutepath\",{\"1\":{\"60\":3}}],[\"curassetname\",{\"1\":{\"60\":2}}],[\"curassetfile\",{\"1\":{\"60\":2}}],[\"curfilnamewithoutmd\",{\"1\":{\"60\":2}}],[\"curfile\",{\"1\":{\"60\":13}}],[\"curfilename\",{\"1\":{\"60\":6}}],[\"curpicfile\",{\"1\":{\"60\":4}}],[\"c|sort\",{\"1\":{\"1238\":2}}],[\"cv\",{\"1\":{\"1219\":5,\"1227\":2,\"1229\":1,\"1849\":1,\"1859\":1,\"1871\":1,\"1872\":1}}],[\"c＋+11新标准\",{\"1\":{\"1042\":1}}],[\"c时输出category的类别\",{\"1\":{\"1018\":1}}],[\"cd\",{\"1\":{\"891\":5,\"1015\":1,\"1282\":1,\"1285\":1,\"1287\":1,\"1305\":1,\"1308\":1,\"1317\":1,\"1318\":2,\"1410\":1,\"1556\":2}}],[\"cii\",{\"1\":{\"1896\":1}}],[\"cid=3\",{\"1\":{\"1541\":2}}],[\"cid=b\",{\"1\":{\"1537\":1,\"1538\":7}}],[\"cid=2这门课程的考试平均成绩\",{\"1\":{\"1538\":1}}],[\"cid=2这门课程考试成绩的最高分的学生信息和课程信息\",{\"1\":{\"1538\":1}}],[\"cid=2\",{\"1\":{\"1537\":3,\"1538\":4}}],[\"cid\",{\"1\":{\"1537\":6,\"1538\":24,\"1544\":1}}],[\"circle\",{\"1\":{\"898\":3}}],[\"circlelist\",{\"1\":{\"819\":3}}],[\"cindent\",{\"1\":{\"1133\":1,\"1291\":1}}],[\"cint\",{\"1\":{\"492\":1}}],[\"cin\",{\"1\":{\"104\":1,\"107\":1,\"110\":1,\"422\":1,\"476\":2,\"601\":1,\"602\":2,\"731\":1,\"871\":1,\"1168\":1}}],[\"cmakelists中会写如下三行\",{\"1\":{\"1320\":1}}],[\"cmakelists\",{\"0\":{\"1315\":1},\"1\":{\"1314\":1,\"1315\":4,\"1316\":3,\"1318\":5}}],[\"cmakelist\",{\"1\":{\"1310\":1}}],[\"cmake常用预定义变量\",{\"0\":{\"1310\":1}}],[\"cmake\",{\"0\":{\"1319\":1,\"1320\":1},\"1\":{\"1303\":1,\"1305\":10,\"1306\":4,\"1310\":11,\"1312\":5,\"1314\":1,\"1315\":3,\"1316\":2,\"1317\":4,\"1318\":7,\"1319\":2,\"1320\":3,\"1322\":1}}],[\"cmake介绍\",{\"0\":{\"1303\":1}}],[\"cmake的使用\",{\"0\":{\"1302\":1}}],[\"cmystring\",{\"1\":{\"1120\":21,\"1121\":13,\"1122\":7,\"1123\":38,\"1124\":8,\"1127\":8}}],[\"cmystirng代码的问题分析\",{\"0\":{\"1120\":1}}],[\"cmpfunc\",{\"1\":{\"784\":3}}],[\"cmp\",{\"1\":{\"784\":8}}],[\"cmd找到源文件所在目录\",{\"1\":{\"958\":1}}],[\"cmd\",{\"1\":{\"163\":2,\"1818\":3}}],[\"c6\",{\"1\":{\"731\":3}}],[\"c5\",{\"1\":{\"731\":8}}],[\"c4++\",{\"1\":{\"731\":1}}],[\"c4\",{\"1\":{\"731\":8}}],[\"c2\",{\"1\":{\"731\":2}}],[\"c2f9d32f\",{\"1\":{\"473\":1}}],[\"c与md\",{\"1\":{\"688\":1}}],[\"c有自己的mc\",{\"1\":{\"688\":1}}],[\"c有一个基类b而且同时还从a继承而来\",{\"1\":{\"688\":1}}],[\"c从b与a继承而来\",{\"1\":{\"688\":1}}],[\"c从a继承来并且有自己的mc\",{\"1\":{\"688\":1}}],[\"c从a也是单继承而来\",{\"1\":{\"688\":1}}],[\"c为多继承\",{\"1\":{\"688\":1}}],[\"c为0\",{\"1\":{\"267\":1}}],[\"c虚拟继承自a\",{\"1\":{\"653\":1}}],[\"c风格\",{\"1\":{\"629\":1}}],[\"c风格的转换不容易查找\",{\"1\":{\"628\":1}}],[\"c风格的转换的格式很简单\",{\"1\":{\"628\":1}}],[\"c风格字符串可以转换为c++风格字符串\",{\"1\":{\"547\":1}}],[\"c风格字符串默认以\",{\"1\":{\"547\":1}}],[\"c风格字符串两种定义方式\",{\"1\":{\"547\":1}}],[\"c风格字符串转换为string字符串相对来说比较简单\",{\"1\":{\"538\":1}}],[\"c风格字符串转换为c++风格字符串\",{\"1\":{\"536\":1}}],[\"c风格字符串是以\",{\"1\":{\"535\":1}}],[\"c风格字符串\",{\"0\":{\"535\":1}}],[\"c本身有内存有名字\",{\"1\":{\"621\":1}}],[\"c要大写\",{\"1\":{\"577\":1}}],[\"c和c++的混合编程\",{\"1\":{\"571\":1}}],[\"c和c++中const修饰变量有什么不同\",{\"0\":{\"483\":1}}],[\"c调用c++的函数代码\",{\"0\":{\"570\":1}}],[\"c会按照c++方式编译成test\",{\"1\":{\"568\":1}}],[\"c文件的变量\",{\"1\":{\"576\":1}}],[\"c文件的i的值了\",{\"1\":{\"575\":1}}],[\"c文件就可以访问到test\",{\"1\":{\"575\":1}}],[\"c文件中定义一个全局变量\",{\"1\":{\"575\":1}}],[\"c文件\",{\"1\":{\"575\":2}}],[\"c文件链接用gcc\",{\"1\":{\"565\":1}}],[\"c文件使用了strcpy\",{\"1\":{\"293\":1}}],[\"c代码在产生函数符号时\",{\"1\":{\"562\":1}}],[\"c代码产生函数符号的时候\",{\"1\":{\"562\":1}}],[\"c1+c2\",{\"1\":{\"731\":1}}],[\"c1\",{\"1\":{\"557\":4,\"731\":2}}],[\"c100c3cc\",{\"1\":{\"479\":1}}],[\"cb2\",{\"1\":{\"891\":7}}],[\"cb1\",{\"1\":{\"891\":5}}],[\"cb\",{\"1\":{\"547\":2,\"891\":7}}],[\"c的构造及ma的初始化\",{\"1\":{\"688\":1}}],[\"c的基类\",{\"1\":{\"688\":1}}],[\"c的虚基指针\",{\"1\":{\"653\":1}}],[\"c的成员方法的\",{\"1\":{\"647\":1}}],[\"c的头文件\",{\"1\":{\"547\":1}}],[\"c的null\",{\"0\":{\"526\":1}}],[\"c的部分内容\",{\"1\":{\"16\":1}}],[\"c中出现了两个ma属性\",{\"1\":{\"688\":1}}],[\"c中类型转换\",{\"1\":{\"630\":2}}],[\"c中\",{\"1\":{\"484\":1}}],[\"c中const修饰的量可以不初始化\",{\"1\":{\"483\":1}}],[\"c+±>预编译器\",{\"1\":{\"311\":1}}],[\"c++string类中substr\",{\"1\":{\"1878\":1}}],[\"c++string中的find用法\",{\"1\":{\"1878\":1}}],[\"c++多线程pthread和thread\",{\"1\":{\"1875\":1}}],[\"c++多线程介绍\",{\"0\":{\"1202\":1}}],[\"c++项目中\",{\"1\":{\"1864\":1}}],[\"c++项目开发\",{\"1\":{\"1537\":1}}],[\"c++库\",{\"1\":{\"1622\":1}}],[\"c++库里面\",{\"1\":{\"1042\":1}}],[\"c++分配内存\",{\"1\":{\"1622\":1}}],[\"c++开源的搜索引擎\",{\"1\":{\"1610\":1}}],[\"c++算法课程\",{\"1\":{\"1537\":1}}],[\"c++高级课程\",{\"1\":{\"1537\":1}}],[\"c++操作mysql数据库之前需要安装mysql库\",{\"0\":{\"1399\":1}}],[\"c++连接数据库\",{\"2\":{\"1387\":1}}],[\"c++的库\",{\"1\":{\"1371\":1}}],[\"c++的右值引用的应用\",{\"0\":{\"1119\":1}}],[\"c++的0\",{\"0\":{\"527\":1}}],[\"c++对象的优化\",{\"0\":{\"1108\":1}}],[\"c++对于左值和右值没有标准定义\",{\"1\":{\"621\":1}}],[\"c++里不叫变量\",{\"1\":{\"1073\":1}}],[\"c++补充\",{\"2\":{\"1065\":1,\"1069\":1,\"1075\":1}}],[\"c++支持\",{\"1\":{\"1063\":1}}],[\"c++支持函数重载\",{\"1\":{\"571\":1}}],[\"c++17\",{\"0\":{\"1016\":1}}],[\"c++11线程\",{\"2\":{\"1223\":1}}],[\"c++11线程间的同步通信\",{\"0\":{\"1215\":1}}],[\"c++11线程安全\",{\"0\":{\"850\":1,\"852\":1}}],[\"c++11多线程编程\",{\"0\":{\"1201\":1},\"1\":{\"1863\":1}}],[\"c++11内容总结\",{\"0\":{\"1193\":1}}],[\"c++11的atomic原子类型\",{\"0\":{\"1233\":1}}],[\"c++11的mutex底层实现\",{\"1\":{\"1217\":1}}],[\"c++11的bind和function比较\",{\"1\":{\"1154\":1}}],[\"c++11的新特性了\",{\"1\":{\"530\":1}}],[\"c++11绑定器介绍\",{\"0\":{\"1154\":1}}],[\"c++11提供的语法糖\",{\"1\":{\"965\":1}}],[\"c++11提供了右值引用\",{\"1\":{\"621\":1}}],[\"c++11标准中的foreach方式来遍历容器内部元素的值\",{\"1\":{\"701\":1}}],[\"c++11标例子准中已经被废弃\",{\"0\":{\"607\":1}}],[\"c++11之后与c\",{\"1\":{\"538\":1}}],[\"c++11\",{\"0\":{\"852\":1},\"1\":{\"530\":1,\"621\":1,\"701\":1,\"784\":1,\"1154\":2,\"1171\":1},\"2\":{\"1200\":1,\"1231\":1,\"1235\":1}}],[\"c++函数对象实现\",{\"1\":{\"982\":1}}],[\"c++有一个专门的函数对象来解决这个问题\",{\"1\":{\"981\":1}}],[\"c++采用\",{\"1\":{\"925\":1}}],[\"c++采用基于模版的方式处理容器\",{\"1\":{\"353\":1}}],[\"c++通过来实现动态绑定\",{\"1\":{\"883\":1}}],[\"c++实现\",{\"1\":{\"811\":1}}],[\"c++规定\",{\"1\":{\"730\":1}}],[\"c++用户\",{\"1\":{\"728\":1}}],[\"c++用类来描述对象\",{\"1\":{\"449\":1}}],[\"c++可以给函数定义默认参数值\",{\"1\":{\"637\":1}}],[\"c++为什么区分单个元素和数组的内存分配和释放呢\",{\"0\":{\"712\":1}}],[\"c++为什么支持函数重载\",{\"0\":{\"562\":1}}],[\"c++为了克服这些缺点\",{\"1\":{\"628\":1}}],[\"c++定义的标准异常类\",{\"0\":{\"604\":1}}],[\"c++编译器选项\",{\"1\":{\"1356\":1}}],[\"c++编译器\",{\"1\":{\"1356\":1}}],[\"c++编译器对于对象构造的优化\",{\"1\":{\"1110\":2,\"1111\":1}}],[\"c++编译器根据传递给函数的参数和函数名决定具体要使用哪一个函数\",{\"1\":{\"883\":1}}],[\"c++编译器在处理纯c头文件时\",{\"1\":{\"578\":1}}],[\"c++编译器都内置了\",{\"1\":{\"570\":1}}],[\"c++调用c函数\",{\"0\":{\"566\":1}}],[\"c++文件用g++\",{\"1\":{\"565\":1}}],[\"c++和c语言代码之间如何相互调用\",{\"0\":{\"565\":1}}],[\"c++下我们可以编译通过它\",{\"1\":{\"562\":1}}],[\"c++代码调用c语言代码\",{\"1\":{\"577\":1}}],[\"c++代码用c语言编译器编译会出现链接错误\",{\"1\":{\"562\":1}}],[\"c++代码在产生函数符号的时候\",{\"1\":{\"562\":1}}],[\"c++代码编译链接之后产生一个可执行文件\",{\"1\":{\"267\":1}}],[\"c++进行叫名字改编\",{\"1\":{\"560\":1}}],[\"c++进行编写\",{\"1\":{\"304\":1}}],[\"c++头文件\",{\"1\":{\"547\":1}}],[\"c++头文件没有加\",{\"1\":{\"476\":1}}],[\"c++提供了std\",{\"1\":{\"536\":1}}],[\"c++风格字符串的拼接\",{\"1\":{\"547\":1}}],[\"c++风格字符串的长度\",{\"1\":{\"547\":1}}],[\"c++风格字符串\",{\"0\":{\"536\":1}}],[\"c++字符串使用的是双引号\",{\"1\":{\"535\":1}}],[\"c++如何区分单个元素和数组内存分配和释放\",{\"0\":{\"517\":1}}],[\"c++语言层面\",{\"1\":{\"1202\":1}}],[\"c++语言级别的多线程编程=\",{\"1\":{\"1201\":1}}],[\"c++语言级别支持的多线程编程\",{\"0\":{\"1198\":1}}],[\"c++语言\",{\"1\":{\"505\":1}}],[\"c++是将a在\",{\"1\":{\"484\":1}}],[\"c++初探\",{\"0\":{\"476\":1}}],[\"c++基础课程\",{\"1\":{\"1537\":1}}],[\"c++基础\",{\"2\":{\"475\":1,\"478\":1,\"499\":1,\"508\":1,\"533\":1,\"550\":1,\"559\":1,\"580\":1,\"596\":1,\"610\":1,\"627\":1,\"635\":1,\"644\":1}}],[\"c++标准指出\",{\"1\":{\"470\":1}}],[\"c++中如何设计一个程序\",{\"0\":{\"716\":1}}],[\"c++中类型转换const\",{\"1\":{\"630\":2}}],[\"c++中类的定义\",{\"0\":{\"449\":1}}],[\"c++中的引用本质上是一种被限制的指针\",{\"1\":{\"614\":1}}],[\"c++中的const初始化值为\",{\"1\":{\"484\":1}}],[\"c++中编译时不会检查函数的异常抛出列表\",{\"1\":{\"608\":1}}],[\"c++中使用异常时应注意的问题\",{\"0\":{\"608\":1}}],[\"c++中定义命名空间的基本格式如下\",{\"1\":{\"584\":1}}],[\"c++中引入了命名空间\",{\"1\":{\"582\":1}}],[\"c++中称之为\",{\"1\":{\"518\":1}}],[\"c++中const初始化值为立即数叫常量\",{\"1\":{\"484\":1}}],[\"c++中const修饰的变量必须初始化\",{\"1\":{\"484\":1}}],[\"c++中const特性\",{\"0\":{\"484\":1}}],[\"c++中经常会使用一个变量初始化另一个变量\",{\"1\":{\"395\":1}}],[\"c++类中还有两种特殊的成员函数\",{\"1\":{\"438\":1}}],[\"c++允许使用static\",{\"1\":{\"435\":1}}],[\"c++模板的特化\",{\"1\":{\"389\":1}}],[\"c++这种本地编译型语言的编译过程\",{\"1\":{\"243\":1}}],[\"c++config\",{\"1\":{\"234\":2}}],[\"c++\",{\"0\":{\"14\":1,\"529\":1,\"1087\":1},\"1\":{\"234\":1,\"293\":1,\"359\":1,\"447\":1,\"455\":1,\"503\":3,\"504\":1,\"526\":1,\"530\":1,\"547\":1,\"560\":1,\"572\":2,\"591\":1,\"597\":1,\"599\":2,\"604\":3,\"784\":1,\"826\":1,\"943\":1,\"957\":1,\"1015\":1,\"1080\":1,\"1154\":1,\"1208\":1,\"1219\":1,\"1310\":1,\"1317\":1,\"1855\":1,\"1859\":2,\"1869\":1,\"1878\":2,\"1896\":3,\"1906\":1,\"1913\":1},\"2\":{\"229\":1,\"241\":1,\"265\":1,\"268\":1,\"278\":1,\"291\":1,\"294\":1,\"297\":1,\"313\":1,\"318\":1,\"321\":1,\"324\":1,\"327\":1,\"335\":1,\"341\":1,\"347\":1,\"350\":1,\"356\":1,\"373\":1,\"379\":1,\"390\":1,\"393\":1,\"402\":1,\"407\":1,\"416\":1,\"429\":1,\"436\":1,\"442\":1,\"451\":1,\"460\":1,\"471\":1,\"474\":1,\"477\":1,\"498\":1,\"507\":1,\"532\":1,\"549\":1,\"558\":1,\"579\":1,\"595\":1,\"609\":1,\"626\":1,\"634\":1,\"643\":1,\"654\":1,\"660\":1,\"663\":1,\"676\":1,\"679\":1,\"686\":1,\"689\":1,\"696\":1,\"702\":1,\"705\":1,\"725\":1,\"732\":1,\"737\":1,\"748\":1,\"752\":1,\"827\":1,\"833\":1,\"858\":1,\"869\":1,\"872\":1,\"878\":1,\"887\":1,\"892\":1,\"895\":1,\"909\":1,\"917\":1,\"928\":1,\"941\":1,\"944\":1,\"950\":1,\"960\":1,\"975\":1,\"986\":1,\"995\":1,\"1004\":1,\"1009\":1,\"1012\":1,\"1033\":1,\"1036\":1,\"1048\":1,\"1051\":1,\"1058\":1,\"1061\":1,\"1064\":1,\"1068\":1,\"1074\":1,\"1077\":1,\"1083\":1,\"1088\":1,\"1091\":1,\"1094\":1,\"1097\":1,\"1100\":1,\"1103\":1,\"1106\":1,\"1117\":1,\"1125\":1,\"1128\":1,\"1149\":1,\"1152\":1,\"1159\":1,\"1169\":1,\"1184\":1,\"1191\":1,\"1199\":1,\"1213\":1,\"1222\":1,\"1230\":1,\"1234\":1}}],[\"c++后端开发工程师\",{\"1\":{\"0\":1}}],[\"c或\",{\"1\":{\"304\":1,\"1237\":2}}],[\"c基础\",{\"2\":{\"295\":1,\"298\":1,\"314\":1,\"319\":1,\"322\":1,\"325\":1,\"328\":1,\"336\":1,\"342\":1,\"348\":1,\"351\":1}}],[\"crud效率都很低\",{\"1\":{\"1886\":1}}],[\"crud操作\",{\"0\":{\"1474\":1}}],[\"credit\",{\"1\":{\"1428\":2,\"1537\":3,\"1538\":2}}],[\"creator\",{\"1\":{\"1656\":1}}],[\"creata\",{\"1\":{\"1428\":1}}],[\"createthread\",{\"1\":{\"1198\":1,\"1202\":1}}],[\"createcarlight\",{\"1\":{\"867\":3}}],[\"createcar\",{\"1\":{\"864\":1,\"866\":3,\"867\":3}}],[\"create\",{\"0\":{\"1600\":1},\"1\":{\"493\":1,\"1151\":2,\"1198\":1,\"1202\":1,\"1428\":1,\"1437\":1,\"1447\":2,\"1485\":1,\"1486\":1,\"1506\":1,\"1507\":3,\"1523\":1,\"1537\":3,\"1548\":1,\"1551\":2,\"1552\":2,\"1581\":1,\"1600\":3,\"1603\":1,\"1614\":7,\"1821\":2,\"1849\":1,\"1859\":1,\"1875\":1}}],[\"createelement\",{\"1\":{\"53\":1,\"54\":2,\"59\":6}}],[\"crsv\",{\"0\":{\"1334\":1},\"1\":{\"1331\":1,\"1334\":1}}],[\"critical\",{\"1\":{\"1025\":1}}],[\"crit\",{\"1\":{\"1025\":1,\"1031\":6}}],[\"crash\",{\"1\":{\"597\":1}}],[\"crt\",{\"1\":{\"293\":3}}],[\"c语言连接mysql\",{\"0\":{\"1371\":1}}],[\"c语言空结构定义变量里面什么都没有\",{\"1\":{\"1073\":1}}],[\"c语言中的函数指针刚好可以很好解决这个问题\",{\"1\":{\"980\":1}}],[\"c语言不支持函数重载\",{\"0\":{\"562\":1},\"1\":{\"571\":1}}],[\"c语言的const可以不初始化叫常变量\",{\"1\":{\"484\":1}}],[\"c语言的优势\",{\"0\":{\"304\":1}}],[\"c语言\",{\"0\":{\"598\":1},\"1\":{\"300\":1,\"447\":1,\"503\":2}}],[\"c语言基础\",{\"0\":{\"1925\":1},\"1\":{\"1878\":1},\"2\":{\"292\":1}}],[\"c语法及语义\",{\"1\":{\"16\":1}}],[\"csdn\",{\"1\":{\"1878\":1}}],[\"csdn博客\",{\"1\":{\"389\":1,\"811\":1,\"957\":1,\"1141\":1,\"1525\":1,\"1828\":2,\"1859\":1,\"1875\":1,\"1878\":4,\"1914\":1}}],[\"cst\",{\"1\":{\"1820\":1}}],[\"csmartptr<t>\",{\"1\":{\"1055\":3}}],[\"csmartptr<test>q\",{\"1\":{\"1041\":1}}],[\"csmartptr<int>q\",{\"1\":{\"1055\":1}}],[\"csmartptr<int>p\",{\"1\":{\"1041\":1,\"1055\":1}}],[\"csmartptr<int>\",{\"1\":{\"1041\":2}}],[\"csmartptr\",{\"1\":{\"1041\":6,\"1055\":3}}],[\"csapp\",{\"1\":{\"264\":1}}],[\"css\",{\"1\":{\"48\":1,\"49\":1,\"51\":2}}],[\"cp\",{\"1\":{\"1284\":1,\"1332\":1}}],[\"cplusplus宏名\",{\"1\":{\"570\":1}}],[\"cplusplus\",{\"1\":{\"526\":1,\"570\":2,\"571\":2,\"577\":2}}],[\"cpl\",{\"1\":{\"301\":1}}],[\"cpp和connection\",{\"1\":{\"1866\":1}}],[\"cpp和connectionpool\",{\"1\":{\"1866\":1}}],[\"cpp和b\",{\"1\":{\"528\":1}}],[\"cppflags\",{\"1\":{\"1356\":1}}],[\"cpp查看此时的内存布局\",{\"1\":{\"936\":1}}],[\"cpp中的调用代码也很快可能忽略过去了\",{\"1\":{\"528\":1}}],[\"cpp中的调用代码这个时候就不能按照期望的运行了\",{\"1\":{\"528\":1}}],[\"cpp中的0是整数\",{\"1\":{\"528\":1}}],[\"cpp中调用了\",{\"1\":{\"528\":1}}],[\"cpp文件中\",{\"1\":{\"504\":1}}],[\"cpp里定义得全局变量及函数\",{\"1\":{\"246\":1}}],[\"cpp\",{\"1\":{\"246\":2,\"247\":2,\"253\":1,\"501\":1,\"526\":1,\"528\":5,\"529\":4,\"567\":1,\"568\":3,\"570\":2,\"578\":1,\"1030\":1,\"1312\":5,\"1313\":3,\"1314\":1,\"1316\":3,\"1318\":3,\"1321\":1,\"1326\":1,\"1356\":1,\"1915\":1}}],[\"cpu进行计算再把数据写回内存块的这样一个过程\",{\"1\":{\"1232\":1}}],[\"cpu和内存通信是通过系统总线进行的\",{\"1\":{\"1232\":1}}],[\"cpu\",{\"1\":{\"239\":1,\"307\":1,\"310\":1,\"344\":2}}],[\"cache\",{\"1\":{\"1237\":1,\"1332\":1,\"1750\":1,\"1753\":2,\"1864\":1}}],[\"card\",{\"1\":{\"1428\":3}}],[\"cardid\",{\"1\":{\"1415\":2}}],[\"cartype\",{\"1\":{\"864\":2}}],[\"car\",{\"1\":{\"831\":16,\"862\":8,\"864\":9,\"866\":3,\"867\":8,\"900\":12}}],[\"catch的匹配过程中\",{\"1\":{\"608\":1}}],[\"catch的匹配是逐层向外匹配\",{\"1\":{\"608\":1}}],[\"catch通过\",{\"1\":{\"608\":1}}],[\"catch\",{\"1\":{\"599\":17,\"601\":8,\"602\":4,\"605\":2,\"606\":4}}],[\"catch语句块的catch可以有多个\",{\"1\":{\"599\":2}}],[\"catspeak\",{\"1\":{\"494\":2}}],[\"cat\",{\"1\":{\"494\":8,\"886\":11,\"905\":3,\"1250\":1,\"1733\":2,\"1734\":1,\"1735\":2}}],[\"category的priority为debug\",{\"1\":{\"1026\":1}}],[\"category\",{\"0\":{\"1018\":1,\"1022\":1},\"1\":{\"45\":1,\"1018\":5,\"1020\":4,\"1026\":1,\"1031\":10,\"1032\":5}}],[\"cash\",{\"1\":{\"1428\":2}}],[\"cas也叫做无锁操作\",{\"1\":{\"1232\":1}}],[\"cast方式\",{\"1\":{\"632\":1}}],[\"cast很容易导致程序的不安全\",{\"1\":{\"632\":1}}],[\"cast的效果很强大\",{\"1\":{\"632\":1}}],[\"cast的用法主要有以下几种\",{\"1\":{\"629\":1}}],[\"cast将整型常量地址转换为另一个指针类型不匹配的指针\",{\"1\":{\"630\":1}}],[\"cast\",{\"0\":{\"629\":1,\"630\":1,\"631\":1,\"632\":1},\"1\":{\"604\":2,\"628\":4,\"630\":2,\"631\":3,\"678\":1}}],[\"cast<\",{\"1\":{\"1080\":1}}],[\"cast<derived\",{\"1\":{\"678\":2}}],[\"cast<derive2\",{\"1\":{\"631\":1}}],[\"cast<double\",{\"1\":{\"632\":1}}],[\"cast<里面必须是指针或引用类型>\",{\"1\":{\"630\":1}}],[\"cast<float\",{\"1\":{\"629\":1}}],[\"cast<float>\",{\"1\":{\"629\":1}}],[\"cast<int>\",{\"1\":{\"630\":1,\"633\":1}}],[\"cast<int\",{\"1\":{\"571\":1,\"629\":1,\"630\":1,\"633\":2}}],[\"cast<char\",{\"1\":{\"547\":1,\"630\":1}}],[\"cast<sometype2\",{\"1\":{\"528\":1}}],[\"cast时\",{\"1\":{\"489\":1}}],[\"case\",{\"1\":{\"296\":1,\"599\":1,\"864\":2,\"871\":5,\"1102\":1,\"1168\":5,\"1407\":2}}],[\"can\",{\"1\":{\"1102\":1}}],[\"cannot\",{\"1\":{\"388\":1}}],[\"canconstruct\",{\"1\":{\"174\":1}}],[\"cancelbubble\",{\"1\":{\"59\":2}}],[\"cancelbutton\",{\"1\":{\"59\":6}}],[\"cancel\",{\"1\":{\"59\":1}}],[\"call一个具体函数地址\",{\"1\":{\"959\":1}}],[\"call指令先把call指令的下一行指令的地址入栈\",{\"1\":{\"500\":1}}],[\"call函数首先会将下一行执行的地址入栈\",{\"1\":{\"238\":1}}],[\"caller\",{\"1\":{\"235\":2}}],[\"called\",{\"1\":{\"182\":1,\"791\":1,\"792\":1}}],[\"call的1所存入的值\",{\"1\":{\"234\":1}}],[\"call\",{\"0\":{\"238\":1,\"852\":1},\"1\":{\"234\":4,\"236\":1,\"410\":1,\"413\":1,\"563\":1,\"631\":4,\"638\":3,\"852\":1,\"884\":2,\"906\":3,\"907\":4,\"908\":4,\"923\":2,\"948\":2,\"953\":2,\"954\":2,\"1060\":2,\"1151\":1,\"1167\":1,\"1188\":5,\"1523\":1}}],[\"cap\",{\"1\":{\"224\":8}}],[\"capacity\",{\"1\":{\"101\":7,\"540\":1}}],[\"chenwei\",{\"1\":{\"1537\":1}}],[\"checksqlschema=\",{\"1\":{\"1888\":2,\"1891\":1}}],[\"checks=1\",{\"1\":{\"1730\":1}}],[\"checks=0\",{\"1\":{\"1730\":1}}],[\"check=full\",{\"1\":{\"1035\":1}}],[\"check\",{\"1\":{\"1015\":1,\"1407\":2}}],[\"chat\",{\"1\":{\"1851\":3}}],[\"chatdb\",{\"1\":{\"1506\":3}}],[\"change\",{\"1\":{\"1552\":4,\"1825\":1,\"1829\":1}}],[\"character\",{\"1\":{\"1828\":1}}],[\"charset=utf8\",{\"1\":{\"1551\":1}}],[\"char的存储方式是\",{\"1\":{\"1426\":1}}],[\"char的存取数度还是要比varchar要得多\",{\"1\":{\"1426\":1}}],[\"char的长度是不可变的\",{\"1\":{\"1426\":1}}],[\"chart\",{\"1\":{\"541\":4,\"546\":4}}],[\"char这样的内置类型编译器不会多开这4字节\",{\"1\":{\"520\":1}}],[\"char\",{\"1\":{\"8\":1,\"11\":1,\"60\":1,\"174\":2,\"185\":1,\"240\":2,\"267\":1,\"277\":4,\"296\":1,\"330\":1,\"366\":7,\"368\":5,\"397\":5,\"405\":8,\"426\":4,\"433\":1,\"434\":1,\"435\":3,\"439\":6,\"449\":7,\"450\":4,\"459\":1,\"464\":5,\"468\":1,\"476\":1,\"494\":2,\"497\":2,\"500\":1,\"506\":1,\"515\":1,\"535\":32,\"537\":3,\"538\":3,\"541\":4,\"546\":2,\"547\":8,\"548\":8,\"557\":18,\"563\":7,\"571\":1,\"584\":1,\"585\":1,\"588\":1,\"594\":6,\"597\":2,\"599\":2,\"600\":1,\"601\":5,\"602\":1,\"605\":4,\"606\":3,\"618\":1,\"630\":3,\"633\":1,\"642\":1,\"662\":25,\"692\":1,\"695\":1,\"699\":14,\"701\":1,\"736\":15,\"751\":1,\"891\":18,\"894\":1,\"949\":10,\"1020\":1,\"1031\":1,\"1032\":34,\"1063\":1,\"1082\":5,\"1099\":2,\"1102\":7,\"1112\":2,\"1120\":12,\"1121\":3,\"1122\":4,\"1123\":15,\"1124\":2,\"1186\":1,\"1187\":4,\"1189\":1,\"1299\":5,\"1374\":5,\"1376\":1,\"1382\":1,\"1384\":1,\"1385\":1,\"1407\":2,\"1839\":2,\"1849\":2,\"1851\":2,\"1856\":1,\"1875\":2,\"1878\":5,\"1915\":1}}],[\"chxuan\",{\"1\":{\"1287\":1}}],[\"chrome\",{\"1\":{\"1255\":1}}],[\"chrono\",{\"1\":{\"1050\":3,\"1207\":3,\"1208\":1,\"1209\":3,\"1210\":1,\"1219\":4,\"1233\":1,\"1849\":2,\"1859\":2,\"1869\":1,\"1871\":1,\"1872\":1}}],[\"choice\",{\"1\":{\"1168\":4}}],[\"chunk块分配出去\",{\"1\":{\"1099\":1}}],[\"chunk块\",{\"1\":{\"1082\":1,\"1093\":2,\"1099\":2,\"1102\":1}}],[\"chunk块的next被赋值成当前还未分配出去\",{\"1\":{\"1093\":1}}],[\"chunk块的next域为0地址\",{\"1\":{\"1099\":1}}],[\"chunk块的next域\",{\"1\":{\"1093\":1,\"1099\":2}}],[\"chunk块的首地址\",{\"1\":{\"1093\":3}}],[\"chunk块的的大小为128b\",{\"1\":{\"1082\":1}}],[\"chunk块的其实地址\",{\"1\":{\"1076\":1}}],[\"chunk\",{\"0\":{\"1102\":1},\"1\":{\"1082\":2,\"1099\":11,\"1102\":6}}],[\"chuck块进行扩容或缩容\",{\"1\":{\"1076\":1}}],[\"china\",{\"1\":{\"605\":1,\"1155\":1}}],[\"childnodes\",{\"1\":{\"61\":1}}],[\"child\",{\"1\":{\"59\":2}}],[\"children\",{\"1\":{\"59\":2}}],[\"childelementcount\",{\"1\":{\"59\":1}}],[\"ch2\",{\"1\":{\"597\":1,\"599\":1}}],[\"ch1为垃圾值\",{\"1\":{\"597\":1}}],[\"ch1\",{\"1\":{\"597\":2,\"599\":1}}],[\"ch\",{\"1\":{\"535\":1,\"537\":1,\"541\":2,\"546\":2,\"585\":1,\"701\":2}}],[\"chdata\",{\"1\":{\"240\":3}}],[\"ctags\",{\"1\":{\"1131\":1,\"1289\":1}}],[\"ct\",{\"1\":{\"864\":3}}],[\"ctl\",{\"1\":{\"45\":1,\"1277\":1}}],[\"ctrlp插件\",{\"0\":{\"1136\":1}}],[\"ctrl+shift+h\",{\"1\":{\"62\":2}}],[\"ctrl+alt+b\",{\"1\":{\"29\":2}}],[\"ctrl+alt+r\",{\"1\":{\"29\":2}}],[\"ctrl+alt+o\",{\"1\":{\"29\":2}}],[\"ctrlkey==true\",{\"1\":{\"59\":1}}],[\"ctrl键\",{\"1\":{\"30\":1}}],[\"ctrl\",{\"1\":{\"29\":4,\"56\":1,\"1136\":1,\"1139\":1,\"1142\":2}}],[\"closing\",{\"1\":{\"1240\":1}}],[\"close\",{\"1\":{\"1240\":4,\"1375\":1,\"1383\":1,\"1384\":1,\"1385\":1,\"1847\":1,\"1856\":1}}],[\"closed\",{\"1\":{\"1240\":5}}],[\"clone\",{\"1\":{\"1132\":1,\"1198\":1,\"1287\":1,\"1290\":1}}],[\"clocks\",{\"1\":{\"751\":1}}],[\"clock\",{\"1\":{\"751\":3,\"1846\":4,\"1851\":10,\"1859\":4}}],[\"cl\",{\"1\":{\"936\":1,\"958\":1}}],[\"clean\",{\"1\":{\"1355\":1,\"1359\":1,\"1365\":3,\"1366\":4,\"1367\":3}}],[\"cleanunnecessarypic\",{\"1\":{\"60\":2}}],[\"cleanunusedpic\",{\"1\":{\"60\":2}}],[\"clear\",{\"1\":{\"191\":2,\"544\":1,\"908\":2,\"1508\":1}}],[\"clearinterval\",{\"1\":{\"59\":1}}],[\"client拿到结果\",{\"1\":{\"1881\":1}}],[\"client和\",{\"1\":{\"1881\":1}}],[\"client都是操作的mycat上的逻辑库\",{\"1\":{\"1803\":1}}],[\"client访问的是mycat\",{\"1\":{\"1802\":1}}],[\"client直接访问的是mycat\",{\"1\":{\"1802\":1}}],[\"client连接的是8066端口\",{\"1\":{\"1792\":1}}],[\"client通过mysql\",{\"1\":{\"1790\":1}}],[\"client发起一个连接请求\",{\"1\":{\"1767\":1}}],[\"clientflag\",{\"1\":{\"1374\":2}}],[\"client\",{\"1\":{\"1082\":2,\"1393\":1,\"1397\":2,\"1864\":1}}],[\"clist\",{\"1\":{\"819\":7}}],[\"click\",{\"1\":{\"59\":1}}],[\"clipboard\",{\"1\":{\"29\":2}}],[\"class定义派生类\",{\"1\":{\"659\":1}}],[\"class不写出来就是私有继承\",{\"0\":{\"647\":1}}],[\"class的默认访问权限是private\",{\"1\":{\"450\":1}}],[\"class能做的事儿\",{\"1\":{\"450\":1}}],[\"class与struct的区别\",{\"0\":{\"450\":1}}],[\"class与typename在此\",{\"1\":{\"360\":1}}],[\"class内部可以拥有的是数据成员\",{\"1\":{\"449\":1}}],[\"class也可以替换typename\",{\"1\":{\"365\":1,\"366\":1,\"368\":1}}],[\"class出现的时间比较早\",{\"1\":{\"360\":1}}],[\"class\",{\"1\":{\"60\":1,\"67\":1,\"73\":1,\"77\":1,\"78\":1,\"81\":1,\"87\":1,\"96\":1,\"101\":1,\"114\":1,\"115\":1,\"125\":1,\"129\":1,\"133\":1,\"137\":1,\"141\":1,\"142\":1,\"143\":1,\"148\":1,\"149\":1,\"153\":1,\"154\":1,\"155\":1,\"158\":1,\"162\":1,\"166\":1,\"170\":1,\"171\":1,\"174\":1,\"178\":1,\"179\":1,\"182\":1,\"185\":1,\"224\":1,\"355\":3,\"371\":1,\"372\":1,\"376\":1,\"382\":1,\"385\":2,\"388\":1,\"389\":2,\"397\":1,\"405\":1,\"406\":1,\"410\":1,\"413\":1,\"421\":1,\"422\":4,\"423\":2,\"426\":2,\"432\":1,\"433\":1,\"434\":2,\"435\":1,\"439\":2,\"440\":1,\"449\":3,\"450\":1,\"459\":1,\"464\":1,\"468\":1,\"470\":3,\"516\":1,\"517\":1,\"518\":1,\"521\":1,\"530\":2,\"548\":1,\"606\":1,\"631\":4,\"646\":1,\"647\":2,\"649\":1,\"650\":1,\"652\":4,\"653\":8,\"659\":1,\"662\":5,\"667\":3,\"669\":2,\"670\":2,\"672\":2,\"678\":2,\"683\":1,\"684\":2,\"688\":8,\"692\":1,\"693\":2,\"695\":6,\"699\":2,\"704\":2,\"714\":1,\"721\":2,\"722\":2,\"723\":2,\"731\":1,\"736\":1,\"751\":1,\"755\":1,\"756\":1,\"759\":1,\"762\":1,\"768\":1,\"771\":2,\"774\":2,\"777\":2,\"782\":1,\"783\":1,\"784\":2,\"787\":1,\"791\":1,\"792\":1,\"795\":1,\"798\":2,\"802\":1,\"817\":1,\"819\":1,\"821\":1,\"826\":4,\"830\":4,\"831\":7,\"832\":6,\"848\":1,\"849\":1,\"850\":1,\"851\":1,\"852\":1,\"854\":3,\"855\":2,\"856\":1,\"857\":1,\"862\":3,\"864\":3,\"866\":3,\"867\":9,\"871\":5,\"886\":4,\"889\":4,\"890\":3,\"891\":4,\"894\":2,\"898\":7,\"900\":6,\"905\":4,\"906\":2,\"907\":4,\"908\":2,\"912\":1,\"913\":2,\"919\":2,\"933\":2,\"934\":2,\"939\":4,\"943\":3,\"948\":4,\"949\":2,\"953\":4,\"954\":2,\"956\":3,\"982\":2,\"984\":2,\"985\":2,\"989\":1,\"1002\":2,\"1011\":4,\"1032\":1,\"1041\":3,\"1055\":2,\"1056\":6,\"1057\":6,\"1060\":2,\"1079\":4,\"1080\":2,\"1081\":1,\"1082\":1,\"1086\":6,\"1087\":1,\"1090\":1,\"1096\":4,\"1110\":1,\"1114\":1,\"1115\":1,\"1120\":1,\"1123\":1,\"1127\":1,\"1148\":1,\"1151\":2,\"1154\":1,\"1158\":4,\"1167\":1,\"1173\":3,\"1183\":1,\"1188\":5,\"1189\":2,\"1219\":2,\"1839\":1,\"1846\":1,\"1848\":1,\"1856\":1,\"1859\":2,\"1875\":1,\"1878\":2,\"1881\":3}}],[\"classname\",{\"1\":{\"53\":1,\"54\":2,\"59\":5,\"936\":1}}],[\"classes\",{\"1\":{\"44\":3}}],[\"cc代码\",{\"1\":{\"1915\":1}}],[\"cc中测试一下\",{\"1\":{\"1915\":1}}],[\"cc与\",{\"1\":{\"1915\":2}}],[\"ccomplex\",{\"1\":{\"731\":27}}],[\"ccpp\",{\"1\":{\"496\":1,\"673\":1,\"678\":1,\"692\":1,\"707\":1,\"750\":1,\"965\":1,\"1063\":1,\"1087\":1,\"1121\":1}}],[\"ccccc\",{\"1\":{\"1415\":2}}],[\"ccc\",{\"1\":{\"368\":1}}],[\"ccimage\",{\"1\":{\"271\":2}}],[\"cc\",{\"0\":{\"36\":1,\"1847\":1,\"1849\":1},\"1\":{\"188\":2,\"194\":1,\"202\":1,\"217\":1,\"220\":1,\"234\":4,\"260\":1,\"271\":3,\"504\":1,\"506\":1,\"516\":1,\"567\":1,\"569\":2,\"572\":3,\"614\":1,\"621\":1,\"817\":2,\"826\":1,\"1032\":4,\"1082\":1,\"1322\":2,\"1327\":1,\"1356\":2,\"1365\":3,\"1366\":2,\"1367\":9,\"1856\":4}}],[\"cyan\",{\"1\":{\"29\":1}}],[\"c标准时\",{\"1\":{\"16\":1}}],[\"c主要定义了c语言的语法规则\",{\"1\":{\"16\":1}}],[\"c是国际标准化组织\",{\"1\":{\"16\":1}}],[\"column\",{\"1\":{\"1385\":3}}],[\"colors\",{\"1\":{\"1143\":1}}],[\"colorschemes\",{\"1\":{\"1143\":1}}],[\"colorscheme\",{\"1\":{\"1133\":1,\"1143\":2,\"1291\":1}}],[\"color=\",{\"1\":{\"29\":1,\"688\":1}}],[\"color\",{\"1\":{\"29\":2,\"48\":2,\"50\":5,\"51\":6,\"1082\":1,\"1660\":1,\"1663\":1,\"1665\":4,\"1673\":1,\"1681\":3,\"1682\":4,\"1758\":2,\"1759\":1,\"1767\":1,\"1769\":2,\"1772\":1,\"1773\":5,\"1774\":7,\"1776\":1}}],[\"copy\",{\"1\":{\"538\":1,\"1076\":4}}],[\"cocos2d\",{\"0\":{\"271\":1},\"1\":{\"530\":1}}],[\"cocos2djs\",{\"1\":{\"0\":1}}],[\"coredump\",{\"1\":{\"1770\":1}}],[\"core\",{\"1\":{\"239\":1,\"1338\":7}}],[\"cornflowerblue\",{\"1\":{\"29\":2}}],[\"course\",{\"1\":{\"1537\":3,\"1538\":8}}],[\"could\",{\"0\":{\"1296\":1}}],[\"count统计数据个数\",{\"0\":{\"1497\":1}}],[\"count=100\",{\"1\":{\"1232\":1}}],[\"count定义成\",{\"1\":{\"1055\":1}}],[\"countvec\",{\"1\":{\"214\":6}}],[\"countsort\",{\"1\":{\"214\":2}}],[\"count++\",{\"1\":{\"81\":4,\"191\":2,\"1232\":1}}],[\"count\",{\"1\":{\"59\":3,\"81\":2,\"115\":4,\"125\":1,\"129\":2,\"137\":1,\"141\":1,\"149\":1,\"178\":1,\"191\":2,\"518\":2,\"521\":2,\"535\":3,\"537\":2,\"538\":1,\"541\":1,\"542\":1,\"546\":2,\"802\":3,\"999\":3,\"1055\":2,\"1056\":6,\"1057\":5,\"1232\":1,\"1340\":1,\"1342\":2,\"1380\":1,\"1385\":1,\"1407\":6,\"1444\":1,\"1526\":6,\"1531\":1,\"1538\":6}}],[\"counter=1\",{\"1\":{\"1830\":1}}],[\"counter\",{\"1\":{\"51\":77}}],[\"cout<<val<<\",{\"1\":{\"1194\":1}}],[\"cout<<mystrq\",{\"1\":{\"1020\":1}}],[\"cout<<e<<endl\",{\"1\":{\"601\":3}}],[\"cout<<ch2<<endl\",{\"1\":{\"597\":1,\"599\":1}}],[\"cout<<ch1<<endl\",{\"1\":{\"597\":1,\"599\":1}}],[\"cout<<c<<\",{\"1\":{\"267\":1}}],[\"cout<<\",{\"1\":{\"389\":1,\"518\":2,\"521\":2,\"599\":2,\"601\":5,\"1020\":2,\"1321\":2}}],[\"cout<<pos4<<\",{\"1\":{\"163\":1}}],[\"cout<<pos3<<\",{\"1\":{\"163\":1}}],[\"cout<<pos2<<\",{\"1\":{\"163\":1}}],[\"cout<<pos1<<\",{\"1\":{\"163\":1}}],[\"cout\",{\"1\":{\"8\":3,\"11\":5,\"60\":1,\"70\":4,\"101\":6,\"104\":3,\"107\":4,\"110\":3,\"118\":5,\"185\":15,\"188\":3,\"191\":3,\"194\":1,\"214\":3,\"224\":6,\"267\":1,\"355\":2,\"362\":1,\"364\":2,\"365\":1,\"366\":3,\"368\":3,\"371\":3,\"372\":3,\"378\":6,\"382\":2,\"385\":6,\"388\":2,\"389\":1,\"392\":1,\"397\":1,\"406\":2,\"410\":2,\"411\":1,\"412\":1,\"413\":3,\"421\":3,\"422\":8,\"426\":2,\"433\":5,\"434\":6,\"435\":1,\"439\":9,\"440\":7,\"459\":8,\"464\":1,\"468\":2,\"476\":4,\"492\":2,\"497\":5,\"500\":4,\"506\":2,\"510\":1,\"515\":3,\"516\":4,\"517\":3,\"536\":8,\"547\":17,\"548\":7,\"557\":9,\"563\":5,\"567\":1,\"568\":1,\"569\":2,\"571\":1,\"588\":3,\"589\":3,\"590\":3,\"592\":5,\"594\":22,\"599\":1,\"601\":5,\"602\":4,\"605\":2,\"618\":14,\"621\":3,\"631\":4,\"633\":6,\"637\":2,\"642\":5,\"649\":2,\"650\":2,\"652\":3,\"662\":38,\"667\":6,\"669\":2,\"670\":1,\"672\":2,\"678\":4,\"688\":16,\"695\":8,\"698\":2,\"699\":2,\"701\":2,\"704\":6,\"710\":2,\"711\":2,\"714\":2,\"722\":1,\"731\":4,\"745\":4,\"746\":4,\"747\":10,\"751\":1,\"756\":1,\"810\":3,\"817\":6,\"819\":4,\"821\":4,\"826\":2,\"830\":7,\"831\":9,\"832\":2,\"848\":3,\"849\":3,\"850\":3,\"851\":3,\"852\":3,\"854\":4,\"855\":4,\"856\":2,\"857\":2,\"862\":2,\"864\":2,\"867\":4,\"871\":9,\"886\":3,\"889\":16,\"890\":13,\"891\":19,\"894\":18,\"898\":4,\"900\":4,\"905\":3,\"906\":2,\"907\":4,\"908\":4,\"913\":3,\"919\":2,\"943\":7,\"948\":10,\"949\":4,\"953\":7,\"954\":3,\"966\":22,\"980\":2,\"981\":2,\"982\":2,\"984\":2,\"985\":2,\"990\":2,\"991\":2,\"992\":2,\"999\":8,\"1000\":7,\"1001\":3,\"1002\":6,\"1007\":13,\"1008\":2,\"1011\":6,\"1031\":5,\"1032\":4,\"1041\":2,\"1045\":2,\"1050\":1,\"1055\":4,\"1056\":14,\"1057\":15,\"1060\":4,\"1110\":5,\"1111\":2,\"1112\":2,\"1113\":3,\"1114\":4,\"1115\":4,\"1120\":5,\"1121\":2,\"1123\":10,\"1124\":2,\"1127\":2,\"1147\":2,\"1148\":2,\"1151\":1,\"1154\":3,\"1155\":1,\"1158\":2,\"1164\":1,\"1165\":2,\"1166\":1,\"1167\":1,\"1168\":14,\"1173\":4,\"1177\":2,\"1178\":2,\"1179\":2,\"1186\":1,\"1187\":1,\"1188\":7,\"1189\":9,\"1207\":3,\"1208\":3,\"1209\":6,\"1210\":2,\"1219\":4,\"1233\":1,\"1299\":2,\"1839\":2,\"1845\":1,\"1847\":1,\"1849\":2,\"1851\":3,\"1856\":3,\"1859\":1,\"1875\":2,\"1878\":3,\"1902\":1,\"1903\":1,\"1904\":1,\"1905\":1,\"1907\":4,\"1908\":3,\"1909\":4,\"1915\":3}}],[\"code=exited\",{\"1\":{\"1820\":1}}],[\"codemirror\",{\"1\":{\"59\":1}}],[\"codedivs\",{\"1\":{\"53\":1,\"59\":2}}],[\"code\",{\"1\":{\"49\":1,\"53\":1,\"54\":2,\"59\":3,\"234\":2,\"1333\":1}}],[\"cond\",{\"1\":{\"1848\":1,\"1849\":4,\"1859\":5,\"1869\":2,\"1871\":1,\"1872\":2,\"1875\":3}}],[\"condition\",{\"1\":{\"1202\":1,\"1219\":1,\"1227\":2,\"1848\":2,\"1859\":2,\"1875\":2}}],[\"conn\",{\"1\":{\"1384\":8,\"1385\":11,\"1839\":3,\"1846\":1,\"1847\":7,\"1849\":8,\"1851\":12,\"1856\":11,\"1859\":9,\"1875\":6,\"1878\":3}}],[\"connect\",{\"1\":{\"1374\":1,\"1383\":6,\"1384\":1,\"1385\":1,\"1754\":1,\"1847\":1,\"1856\":1}}],[\"connection就被close掉了\",{\"1\":{\"1849\":1,\"1859\":1,\"1872\":1}}],[\"connectioncnt++\",{\"1\":{\"1839\":1,\"1849\":2,\"1859\":2,\"1875\":2}}],[\"connectioncnt\",{\"1\":{\"1839\":1,\"1848\":1,\"1849\":3,\"1859\":4,\"1875\":2}}],[\"connectionque\",{\"1\":{\"1839\":2,\"1848\":1,\"1849\":14,\"1859\":12,\"1869\":5,\"1870\":2,\"1871\":3,\"1872\":6,\"1875\":4,\"1878\":1}}],[\"connectiontimeout=100\",{\"1\":{\"1844\":1,\"1878\":1}}],[\"connectiontimeout\",{\"1\":{\"1839\":3,\"1848\":1,\"1849\":3,\"1859\":2,\"1865\":1,\"1869\":1,\"1871\":1,\"1872\":1,\"1875\":3,\"1878\":1}}],[\"connectionpool\",{\"0\":{\"1848\":1,\"1849\":1},\"1\":{\"1839\":14,\"1848\":6,\"1849\":13,\"1851\":4,\"1859\":14,\"1866\":1,\"1869\":1,\"1872\":1,\"1875\":17,\"1878\":22}}],[\"connections=1000\",{\"1\":{\"1754\":1}}],[\"connection\",{\"0\":{\"1846\":1,\"1847\":1},\"1\":{\"1240\":7,\"1839\":3,\"1846\":6,\"1847\":8,\"1848\":1,\"1849\":6,\"1851\":6,\"1856\":20,\"1859\":11,\"1866\":1,\"1870\":1,\"1872\":1,\"1875\":5,\"1878\":4}}],[\"con\",{\"1\":{\"989\":4,\"1147\":3,\"1148\":3}}],[\"concurrency\",{\"1\":{\"1656\":1}}],[\"concat\",{\"1\":{\"1523\":1}}],[\"concatenates\",{\"1\":{\"535\":1}}],[\"concretedecorator03\",{\"1\":{\"831\":4}}],[\"concretedecorator02\",{\"1\":{\"831\":4}}],[\"concretedecorator01\",{\"1\":{\"831\":3}}],[\"conversionpattern=\",{\"1\":{\"1026\":2}}],[\"conversion\",{\"1\":{\"485\":1}}],[\"conf下\",{\"1\":{\"1801\":1}}],[\"conf文件来实现\",{\"1\":{\"1331\":1}}],[\"confirming\",{\"1\":{\"1240\":1}}],[\"config\",{\"1\":{\"1405\":1,\"1848\":2,\"1875\":2}}],[\"configs\",{\"1\":{\"1133\":2,\"1135\":1,\"1291\":2}}],[\"configure\",{\"1\":{\"1015\":1,\"1026\":1,\"1312\":1}}],[\"conf\",{\"1\":{\"239\":1,\"1030\":1,\"1332\":1,\"1408\":1,\"1410\":1,\"1555\":1,\"1769\":1,\"1800\":1,\"1804\":1,\"1808\":1,\"1809\":1,\"1814\":1,\"1820\":2,\"1886\":1}}],[\"conquer\",{\"1\":{\"202\":1}}],[\"consistent\",{\"1\":{\"1656\":1}}],[\"consistency\",{\"1\":{\"1644\":1}}],[\"consumer\",{\"1\":{\"1219\":4}}],[\"console\",{\"1\":{\"59\":9}}],[\"consolas\",{\"1\":{\"49\":1}}],[\"consts\",{\"1\":{\"503\":1}}],[\"const与一级指针结合\",{\"1\":{\"491\":1}}],[\"const与二级\",{\"0\":{\"490\":1}}],[\"const和指针的类型转换\",{\"0\":{\"491\":1}}],[\"const和普通变量的区别\",{\"0\":{\"482\":1}}],[\"const修饰q\",{\"1\":{\"490\":1}}],[\"const修饰\",{\"1\":{\"490\":2}}],[\"const修饰的是q2\",{\"1\":{\"492\":1}}],[\"const修饰的量常见错误\",{\"0\":{\"485\":1}}],[\"const修饰的变量称为常量\",{\"1\":{\"497\":1}}],[\"const修饰的变量必须初始化\",{\"1\":{\"484\":1}}],[\"const修饰的变量不能再作为左值\",{\"1\":{\"482\":1}}],[\"const就是当作一个变量编译生成指令的\",{\"1\":{\"484\":1}}],[\"const的编译方式不同\",{\"1\":{\"484\":1}}],[\"const常量则会被视为一个编译时的常数\",{\"1\":{\"484\":1}}],[\"const常量有具体的类型\",{\"1\":{\"481\":1}}],[\"const常量与宏定义的区别是什么\",{\"0\":{\"481\":1}}],[\"const关键字修饰对象\",{\"0\":{\"496\":1}}],[\"const关键字修饰成员函数\",{\"0\":{\"495\":1}}],[\"const关键字修饰指针\",{\"0\":{\"486\":1}}],[\"const关键字修饰的变量称为常量\",{\"1\":{\"480\":1}}],[\"const关键字修饰变量\",{\"0\":{\"480\":1}}],[\"const可以去掉吗\",{\"0\":{\"466\":1}}],[\"const对象等都是左值\",{\"1\":{\"621\":1}}],[\"const对象\",{\"0\":{\"454\":1}}],[\"const对象只能访问const版本的成员函数\",{\"1\":{\"440\":1}}],[\"const对象调用const版本的成员函数\",{\"1\":{\"440\":1}}],[\"const版本的成员函数\",{\"1\":{\"440\":1}}],[\"const版本的成员函数可以与非const版本的成员函数进行重载\",{\"1\":{\"440\":1}}],[\"const版本的成员函数具有只读特性\",{\"1\":{\"440\":1}}],[\"const版本的成员函数与非const版本的成员函数可以重载\",{\"1\":{\"440\":1}}],[\"const在类成员函数中还有种特殊的用法\",{\"1\":{\"440\":1}}],[\"const成员函数\",{\"0\":{\"440\":1},\"1\":{\"495\":1}}],[\"const成员不能修改\",{\"1\":{\"432\":1}}],[\"constructed\",{\"1\":{\"422\":4}}],[\"constructors\",{\"1\":{\"398\":1}}],[\"construct\",{\"1\":{\"385\":5,\"572\":1,\"704\":5,\"747\":3,\"964\":1,\"1080\":2,\"1086\":6,\"1087\":2,\"1127\":9}}],[\"const\",{\"0\":{\"400\":1,\"479\":1,\"630\":1},\"1\":{\"59\":2,\"60\":20,\"104\":4,\"107\":4,\"110\":8,\"129\":2,\"163\":2,\"178\":1,\"185\":5,\"188\":2,\"191\":1,\"214\":2,\"296\":1,\"355\":7,\"366\":4,\"368\":2,\"385\":10,\"388\":8,\"392\":2,\"395\":1,\"396\":1,\"397\":4,\"405\":3,\"406\":4,\"423\":1,\"426\":2,\"432\":2,\"435\":1,\"438\":1,\"439\":5,\"440\":8,\"441\":3,\"449\":3,\"450\":2,\"454\":1,\"463\":1,\"464\":4,\"480\":3,\"483\":2,\"484\":2,\"485\":3,\"488\":9,\"489\":7,\"490\":12,\"491\":7,\"492\":21,\"493\":1,\"494\":2,\"497\":10,\"511\":2,\"530\":3,\"535\":14,\"537\":3,\"538\":5,\"539\":12,\"540\":5,\"541\":12,\"542\":1,\"543\":1,\"545\":12,\"546\":14,\"547\":4,\"548\":7,\"563\":9,\"601\":3,\"605\":1,\"606\":3,\"612\":1,\"614\":1,\"618\":1,\"620\":3,\"621\":2,\"624\":1,\"625\":6,\"628\":1,\"630\":7,\"633\":2,\"662\":35,\"698\":2,\"699\":21,\"704\":12,\"722\":9,\"731\":9,\"736\":19,\"747\":5,\"751\":4,\"784\":18,\"819\":1,\"826\":5,\"848\":3,\"850\":3,\"851\":3,\"898\":8,\"900\":2,\"943\":1,\"949\":6,\"989\":2,\"1001\":2,\"1002\":6,\"1011\":9,\"1032\":36,\"1055\":2,\"1060\":2,\"1063\":1,\"1080\":3,\"1086\":3,\"1087\":2,\"1110\":3,\"1111\":1,\"1113\":1,\"1114\":5,\"1115\":6,\"1120\":14,\"1121\":3,\"1122\":4,\"1123\":17,\"1124\":3,\"1127\":7,\"1148\":5,\"1173\":2,\"1186\":1,\"1187\":2,\"1189\":1,\"1299\":1,\"1374\":5,\"1376\":1,\"1382\":1,\"1521\":1,\"1618\":1,\"1851\":1}}],[\"continuing\",{\"1\":{\"1253\":1}}],[\"continuous\",{\"1\":{\"1237\":1}}],[\"continue\",{\"1\":{\"60\":1,\"133\":1,\"135\":2,\"137\":1,\"296\":1,\"1340\":1,\"1839\":1,\"1849\":1,\"1875\":1,\"1878\":1}}],[\"control\",{\"1\":{\"286\":6,\"287\":2,\"1548\":1,\"1656\":1}}],[\"contractbutton\",{\"1\":{\"54\":6,\"59\":6}}],[\"contract\",{\"1\":{\"53\":1,\"54\":3,\"59\":4}}],[\"container>\",{\"1\":{\"1147\":1,\"1148\":1}}],[\"container=deque<t>>\",{\"1\":{\"989\":1}}],[\"container\",{\"1\":{\"984\":2,\"989\":1,\"1147\":2,\"1148\":2,\"1194\":1}}],[\"containsnearbyalmostduplicate\",{\"1\":{\"162\":1}}],[\"containsnearbyduplicate\",{\"1\":{\"158\":1}}],[\"containsduplicate\",{\"1\":{\"153\":1,\"154\":1,\"155\":1}}],[\"contarctallbutton\",{\"1\":{\"54\":1,\"59\":1}}],[\"content\",{\"1\":{\"8\":8,\"11\":10,\"51\":15,\"53\":1,\"54\":1,\"59\":13}}],[\"commit\",{\"1\":{\"1640\":1,\"1649\":1,\"1671\":1,\"1734\":1,\"1762\":1}}],[\"committed隔离级别\",{\"0\":{\"1634\":1}}],[\"committed\",{\"1\":{\"1631\":1,\"1677\":1}}],[\"comment\",{\"1\":{\"1437\":2,\"1537\":2}}],[\"common\",{\"1\":{\"1397\":2,\"1405\":1}}],[\"community\",{\"1\":{\"1395\":1,\"1397\":3,\"1820\":3}}],[\"command\",{\"1\":{\"1310\":1,\"1353\":1}}],[\"com2\",{\"1\":{\"439\":4,\"440\":3}}],[\"com1\",{\"1\":{\"439\":5,\"440\":3}}],[\"compile\",{\"1\":{\"1317\":3,\"1828\":1}}],[\"compiler\",{\"1\":{\"1082\":1}}],[\"compilation\",{\"1\":{\"234\":1}}],[\"comp\",{\"1\":{\"731\":2,\"981\":2,\"982\":2,\"1148\":10}}],[\"computer2\",{\"1\":{\"450\":1}}],[\"computer\",{\"1\":{\"397\":9,\"426\":4,\"435\":3,\"439\":20,\"440\":7,\"449\":4,\"450\":1,\"464\":10,\"832\":5}}],[\"compare>\",{\"1\":{\"981\":1,\"982\":1,\"1148\":1}}],[\"compare是c++的库函数模板\",{\"1\":{\"981\":1,\"982\":1}}],[\"compare<const\",{\"1\":{\"366\":2,\"368\":2,\"1187\":2}}],[\"compare<double>\",{\"1\":{\"365\":2,\"368\":1}}],[\"compare<int>\",{\"1\":{\"365\":2,\"368\":2}}],[\"compare\",{\"1\":{\"60\":1,\"365\":3,\"366\":5,\"368\":5,\"563\":14,\"884\":6,\"885\":3,\"980\":3,\"981\":4,\"982\":4,\"1148\":6,\"1186\":4}}],[\"composer\",{\"1\":{\"0\":1}}],[\"com\",{\"1\":{\"0\":3,\"5\":2,\"731\":3,\"1132\":1,\"1143\":1,\"1277\":1,\"1284\":2,\"1287\":1,\"1290\":1,\"1395\":1,\"1523\":1,\"1828\":1,\"1869\":1,\"1914\":1}}],[\"c\",{\"0\":{\"14\":1,\"494\":1,\"573\":1,\"577\":1,\"578\":1,\"1252\":1,\"1928\":1,\"1943\":1},\"1\":{\"0\":1,\"27\":1,\"29\":1,\"135\":1,\"137\":3,\"147\":1,\"174\":4,\"227\":2,\"234\":1,\"239\":1,\"243\":1,\"247\":2,\"253\":1,\"260\":1,\"267\":3,\"289\":1,\"300\":3,\"301\":2,\"302\":3,\"303\":3,\"304\":1,\"310\":2,\"359\":1,\"422\":6,\"426\":3,\"494\":1,\"500\":5,\"501\":1,\"504\":1,\"505\":1,\"516\":2,\"530\":4,\"535\":1,\"538\":1,\"547\":3,\"557\":5,\"567\":4,\"568\":9,\"569\":3,\"570\":6,\"571\":2,\"572\":1,\"575\":2,\"577\":3,\"578\":7,\"597\":1,\"599\":1,\"605\":1,\"606\":7,\"613\":1,\"616\":1,\"620\":1,\"621\":6,\"622\":1,\"640\":2,\"642\":3,\"647\":2,\"649\":1,\"650\":2,\"652\":6,\"653\":5,\"678\":1,\"688\":11,\"692\":1,\"699\":1,\"707\":1,\"736\":1,\"747\":2,\"750\":1,\"890\":19,\"898\":6,\"939\":2,\"943\":6,\"1021\":1,\"1031\":4,\"1120\":3,\"1121\":1,\"1123\":2,\"1238\":3,\"1252\":2,\"1261\":7,\"1287\":1,\"1310\":2,\"1317\":3,\"1326\":1,\"1327\":1,\"1328\":1,\"1329\":3,\"1330\":2,\"1331\":6,\"1332\":1,\"1333\":1,\"1334\":1,\"1338\":3,\"1345\":3,\"1347\":1,\"1360\":11,\"1361\":5,\"1365\":5,\"1366\":4,\"1537\":14,\"1538\":33,\"1622\":1,\"1757\":1,\"1790\":1,\"1839\":5,\"1847\":6,\"1849\":5,\"1855\":1,\"1856\":6,\"1875\":5,\"1903\":1,\"1913\":1,\"1915\":1},\"2\":{\"229\":1,\"241\":1,\"265\":1,\"268\":1,\"278\":1,\"291\":1,\"294\":1,\"297\":1,\"313\":1,\"318\":1,\"321\":1,\"324\":1,\"327\":1,\"335\":1,\"341\":1,\"347\":1,\"350\":1,\"356\":1,\"373\":1,\"379\":1,\"390\":1,\"393\":1,\"402\":1,\"407\":1,\"416\":1,\"429\":1,\"436\":1,\"442\":1,\"451\":1,\"460\":1,\"471\":1,\"474\":1,\"477\":1,\"498\":1,\"507\":1,\"532\":1,\"549\":1,\"558\":1,\"579\":1,\"595\":1,\"609\":1,\"626\":1,\"634\":1,\"643\":1,\"654\":1,\"660\":1,\"663\":1,\"676\":1,\"679\":1,\"686\":1,\"689\":1,\"696\":1,\"702\":1,\"705\":1,\"725\":1,\"732\":1,\"737\":1,\"748\":1,\"752\":1,\"827\":1,\"833\":1,\"858\":1,\"869\":1,\"872\":1,\"878\":1,\"887\":1,\"892\":1,\"895\":1,\"909\":1,\"917\":1,\"928\":1,\"941\":1,\"944\":1,\"950\":1,\"960\":1,\"975\":1,\"986\":1,\"995\":1,\"1004\":1,\"1009\":1,\"1012\":1,\"1033\":1,\"1036\":1,\"1048\":1,\"1051\":1,\"1058\":1,\"1061\":1,\"1064\":1,\"1068\":1,\"1074\":1,\"1077\":1,\"1083\":1,\"1088\":1,\"1091\":1,\"1094\":1,\"1097\":1,\"1100\":1,\"1103\":1,\"1106\":1,\"1117\":1,\"1125\":1,\"1128\":1,\"1149\":1,\"1152\":1,\"1159\":1,\"1169\":1,\"1184\":1,\"1191\":1,\"1199\":1,\"1213\":1,\"1222\":1,\"1230\":1,\"1234\":1,\"1387\":1}}],[\"硕士\",{\"1\":{\"0\":1}}],[\"男\",{\"1\":{\"0\":1}}]],\"serializationVersion\":2}}")).map(([e,t])=>[e,zt(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n}})=>{e==="suggest"?self.postMessage(st(t,v[s],n)):e==="search"?self.postMessage(et(t,v[s],n)):self.postMessage({suggestions:st(t,v[s],n),results:et(t,v[s],n)})};
//# sourceMappingURL=index.js.map
